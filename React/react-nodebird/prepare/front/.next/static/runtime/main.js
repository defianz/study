(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["static/runtime/main.js"],{

/***/ "./node_modules/@babel/runtime/helpers/arrayLikeToArray.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/arrayLikeToArray.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

module.exports = _arrayLikeToArray;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/arrayWithHoles.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/arrayWithHoles.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

module.exports = _arrayWithHoles;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/arrayWithoutHoles.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/arrayWithoutHoles.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeToArray = __webpack_require__(/*! ./arrayLikeToArray */ "./node_modules/@babel/runtime/helpers/arrayLikeToArray.js");

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return arrayLikeToArray(arr);
}

module.exports = _arrayWithoutHoles;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/assertThisInitialized.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/assertThisInitialized.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

module.exports = _assertThisInitialized;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/asyncToGenerator.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

module.exports = _asyncToGenerator;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/classCallCheck.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/classCallCheck.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

module.exports = _classCallCheck;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/construct.js":
/*!**********************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/construct.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var setPrototypeOf = __webpack_require__(/*! ./setPrototypeOf */ "./node_modules/@babel/runtime/helpers/setPrototypeOf.js");

var isNativeReflectConstruct = __webpack_require__(/*! ./isNativeReflectConstruct */ "./node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js");

function _construct(Parent, args, Class) {
  if (isNativeReflectConstruct()) {
    module.exports = _construct = Reflect.construct;
  } else {
    module.exports = _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

module.exports = _construct;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/createClass.js":
/*!************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/createClass.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

module.exports = _createClass;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/extends.js":
/*!********************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/extends.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _extends() {
  module.exports = _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

module.exports = _extends;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/getPrototypeOf.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _getPrototypeOf(o) {
  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

module.exports = _getPrototypeOf;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/inherits.js":
/*!*********************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/inherits.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var setPrototypeOf = __webpack_require__(/*! ./setPrototypeOf */ "./node_modules/@babel/runtime/helpers/setPrototypeOf.js");

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) setPrototypeOf(subClass, superClass);
}

module.exports = _inherits;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/interopRequireDefault.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

module.exports = _interopRequireDefault;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/interopRequireWildcard.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/interopRequireWildcard.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = __webpack_require__(/*! ../helpers/typeof */ "./node_modules/@babel/runtime/helpers/typeof.js");

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

module.exports = _interopRequireWildcard;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

module.exports = _isNativeReflectConstruct;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/iterableToArray.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/iterableToArray.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}

module.exports = _iterableToArray;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

module.exports = _iterableToArrayLimit;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/nonIterableRest.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/nonIterableRest.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

module.exports = _nonIterableRest;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/nonIterableSpread.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/nonIterableSpread.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

module.exports = _nonIterableSpread;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = __webpack_require__(/*! ../helpers/typeof */ "./node_modules/@babel/runtime/helpers/typeof.js");

var assertThisInitialized = __webpack_require__(/*! ./assertThisInitialized */ "./node_modules/@babel/runtime/helpers/assertThisInitialized.js");

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return assertThisInitialized(self);
}

module.exports = _possibleConstructorReturn;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/setPrototypeOf.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/setPrototypeOf.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _setPrototypeOf(o, p) {
  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

module.exports = _setPrototypeOf;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/slicedToArray.js":
/*!**************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/slicedToArray.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayWithHoles = __webpack_require__(/*! ./arrayWithHoles */ "./node_modules/@babel/runtime/helpers/arrayWithHoles.js");

var iterableToArrayLimit = __webpack_require__(/*! ./iterableToArrayLimit */ "./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js");

var unsupportedIterableToArray = __webpack_require__(/*! ./unsupportedIterableToArray */ "./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js");

var nonIterableRest = __webpack_require__(/*! ./nonIterableRest */ "./node_modules/@babel/runtime/helpers/nonIterableRest.js");

function _slicedToArray(arr, i) {
  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();
}

module.exports = _slicedToArray;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/toConsumableArray.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/toConsumableArray.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayWithoutHoles = __webpack_require__(/*! ./arrayWithoutHoles */ "./node_modules/@babel/runtime/helpers/arrayWithoutHoles.js");

var iterableToArray = __webpack_require__(/*! ./iterableToArray */ "./node_modules/@babel/runtime/helpers/iterableToArray.js");

var unsupportedIterableToArray = __webpack_require__(/*! ./unsupportedIterableToArray */ "./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js");

var nonIterableSpread = __webpack_require__(/*! ./nonIterableSpread */ "./node_modules/@babel/runtime/helpers/nonIterableSpread.js");

function _toConsumableArray(arr) {
  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();
}

module.exports = _toConsumableArray;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/typeof.js":
/*!*******************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/typeof.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    module.exports = _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    module.exports = _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

module.exports = _typeof;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeToArray = __webpack_require__(/*! ./arrayLikeToArray */ "./node_modules/@babel/runtime/helpers/arrayLikeToArray.js");

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);
}

module.exports = _unsupportedIterableToArray;

/***/ }),

/***/ "./node_modules/@babel/runtime/regenerator/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@babel/runtime/regenerator/index.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! regenerator-runtime */ "./node_modules/regenerator-runtime/runtime.js");


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/client.js":
/*!************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/client.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
exports.__esModule = true;
var Bus = __importStar(__webpack_require__(/*! ./internal/bus */ "./node_modules/@next/react-dev-overlay/lib/internal/bus.js"));
var parseStack_1 = __webpack_require__(/*! ./internal/helpers/parseStack */ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/parseStack.js");
var isRegistered = false;
var stackTraceLimit = undefined;
function onUnhandledError(ev) {
    var error = ev === null || ev === void 0 ? void 0 : ev.error;
    if (!error || !(error instanceof Error) || typeof error.stack !== 'string') {
        // A non-error was thrown, we don't have anything to show. :-(
        return;
    }
    var e = error;
    Bus.emit({
        type: Bus.TYPE_UNHANDLED_ERROR,
        reason: error,
        frames: parseStack_1.parseStack(e.stack)
    });
}
function onUnhandledRejection(ev) {
    var reason = ev === null || ev === void 0 ? void 0 : ev.reason;
    if (!reason ||
        !(reason instanceof Error) ||
        typeof reason.stack !== 'string') {
        // A non-error was thrown, we don't have anything to show. :-(
        return;
    }
    var e = reason;
    Bus.emit({
        type: Bus.TYPE_UNHANDLED_REJECTION,
        reason: reason,
        frames: parseStack_1.parseStack(e.stack)
    });
}
function register() {
    if (isRegistered) {
        return;
    }
    isRegistered = true;
    try {
        var limit = Error.stackTraceLimit;
        Error.stackTraceLimit = 50;
        stackTraceLimit = limit;
    }
    catch (_a) { }
    window.addEventListener('error', onUnhandledError);
    window.addEventListener('unhandledrejection', onUnhandledRejection);
}
exports.register = register;
function unregister() {
    if (!isRegistered) {
        return;
    }
    isRegistered = false;
    if (stackTraceLimit !== undefined) {
        try {
            Error.stackTraceLimit = stackTraceLimit;
        }
        catch (_a) { }
        stackTraceLimit = undefined;
    }
    window.removeEventListener('error', onUnhandledError);
    window.removeEventListener('unhandledrejection', onUnhandledRejection);
}
exports.unregister = unregister;
function onBuildOk() {
    Bus.emit({ type: Bus.TYPE_BUILD_OK });
}
exports.onBuildOk = onBuildOk;
function onBuildError(message) {
    Bus.emit({ type: Bus.TYPE_BUILD_ERROR, message: message });
}
exports.onBuildError = onBuildError;
function onRefresh() {
    Bus.emit({ type: Bus.TYPE_REFFRESH });
}
exports.onRefresh = onRefresh;
var nodeStackFrames_1 = __webpack_require__(/*! ./internal/helpers/nodeStackFrames */ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/nodeStackFrames.js");
exports.getNodeError = nodeStackFrames_1.getNodeError;
var ReactDevOverlay_1 = __webpack_require__(/*! ./internal/ReactDevOverlay */ "./node_modules/@next/react-dev-overlay/lib/internal/ReactDevOverlay.js");
exports.ReactDevOverlay = ReactDevOverlay_1["default"];


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/ErrorBoundary.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/ErrorBoundary.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
exports.__esModule = true;
var react_1 = __importDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var ErrorBoundary = /** @class */ (function (_super) {
    __extends(ErrorBoundary, _super);
    function ErrorBoundary() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.state = { error: null };
        return _this;
    }
    ErrorBoundary.prototype.componentDidCatch = function (error, 
    // Loosely typed because it depends on the React version and was
    // accidentally excluded in some versions.
    errorInfo) {
        this.props.onError(error, (errorInfo === null || errorInfo === void 0 ? void 0 : errorInfo.componentStack) || null);
        this.setState({ error: error });
    };
    ErrorBoundary.prototype.render = function () {
        return this.state.error
            ? // The component has to be unmounted or else it would continue to error
                null
            : this.props.children;
    };
    return ErrorBoundary;
}(react_1["default"].PureComponent));
exports.ErrorBoundary = ErrorBoundary;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/ReactDevOverlay.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/ReactDevOverlay.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
exports.__esModule = true;
var React = __importStar(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var Bus = __importStar(__webpack_require__(/*! ./bus */ "./node_modules/@next/react-dev-overlay/lib/internal/bus.js"));
var ShadowPortal_1 = __webpack_require__(/*! ./components/ShadowPortal */ "./node_modules/@next/react-dev-overlay/lib/internal/components/ShadowPortal.js");
var Errors_1 = __webpack_require__(/*! ./container/Errors */ "./node_modules/@next/react-dev-overlay/lib/internal/container/Errors.js");
var BuildError_1 = __webpack_require__(/*! ./container/BuildError */ "./node_modules/@next/react-dev-overlay/lib/internal/container/BuildError.js");
var ErrorBoundary_1 = __webpack_require__(/*! ./ErrorBoundary */ "./node_modules/@next/react-dev-overlay/lib/internal/ErrorBoundary.js");
var Base_1 = __webpack_require__(/*! ./styles/Base */ "./node_modules/@next/react-dev-overlay/lib/internal/styles/Base.js");
var ComponentStyles_1 = __webpack_require__(/*! ./styles/ComponentStyles */ "./node_modules/@next/react-dev-overlay/lib/internal/styles/ComponentStyles.js");
var CssReset_1 = __webpack_require__(/*! ./styles/CssReset */ "./node_modules/@next/react-dev-overlay/lib/internal/styles/CssReset.js");
function reducer(state, ev) {
    switch (ev.type) {
        case Bus.TYPE_BUILD_OK: {
            return __assign(__assign({}, state), { buildError: null });
        }
        case Bus.TYPE_BUILD_ERROR: {
            return __assign(__assign({}, state), { buildError: ev.message });
        }
        case Bus.TYPE_REFFRESH: {
            return __assign(__assign({}, state), { buildError: null, errors: [] });
        }
        case Bus.TYPE_UNHANDLED_ERROR:
        case Bus.TYPE_UNHANDLED_REJECTION: {
            return __assign(__assign({}, state), { nextId: state.nextId + 1, errors: __spread(state.errors, [{ id: state.nextId, event: ev }]) });
        }
        default: {
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            var _1 = ev;
            return state;
        }
    }
}
function ReactDevOverlay(_a) {
    var children = _a.children;
    var _b = __read(React.useReducer(reducer, { nextId: 1, buildError: null, errors: [] }), 2), state = _b[0], dispatch = _b[1];
    React.useEffect(function () {
        Bus.on(dispatch);
        return function () {
            Bus.off(dispatch);
        };
    }, [dispatch]);
    var onComponentError = React.useCallback(function (error, componentStack) {
        // TODO: special handling
    }, []);
    var hasBuildError = state.buildError != null;
    var hasRuntimeErrors = Boolean(state.errors.length);
    var isMounted = hasBuildError || hasRuntimeErrors;
    return (React.createElement(React.Fragment, null,
        React.createElement(ErrorBoundary_1.ErrorBoundary, { onError: onComponentError }, children !== null && children !== void 0 ? children : null),
        isMounted ? (React.createElement(ShadowPortal_1.ShadowPortal, null,
            React.createElement(CssReset_1.CssReset, null),
            React.createElement(Base_1.Base, null),
            React.createElement(ComponentStyles_1.ComponentStyles, null),
            hasBuildError ? (React.createElement(BuildError_1.BuildError, { message: state.buildError })) : hasRuntimeErrors ? (React.createElement(Errors_1.Errors, { errors: state.errors })) : undefined)) : undefined));
}
exports["default"] = ReactDevOverlay;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/bus.js":
/*!******************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/bus.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
exports.__esModule = true;
exports.TYPE_BUILD_OK = 'build-ok';
exports.TYPE_BUILD_ERROR = 'build-error';
exports.TYPE_REFFRESH = 'fast-refresh';
exports.TYPE_UNHANDLED_ERROR = 'unhandled-error';
exports.TYPE_UNHANDLED_REJECTION = 'unhandled-rejection';
var handlers = new Set();
var queue = [];
function drain() {
    // Draining should never happen synchronously in case multiple handlers are
    // registered.
    setTimeout(function () {
        var _loop_1 = function () {
            var ev = queue.shift();
            handlers.forEach(function (handler) { return handler(ev); });
        };
        while (
        // Until we are out of events:
        Boolean(queue.length) &&
            // Or, if all handlers removed themselves as a result of handling the
            // event(s)
            Boolean(handlers.size)) {
            _loop_1();
        }
    }, 1);
}
function emit(ev) {
    queue.push(Object.freeze(__assign({}, ev)));
    drain();
}
exports.emit = emit;
function on(fn) {
    if (handlers.has(fn)) {
        return false;
    }
    handlers.add(fn);
    drain();
    return true;
}
exports.on = on;
function off(fn) {
    if (handlers.has(fn)) {
        handlers["delete"](fn);
        return true;
    }
    return false;
}
exports.off = off;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/CodeFrame/CodeFrame.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/CodeFrame/CodeFrame.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
exports.__esModule = true;
var anser_1 = __importDefault(__webpack_require__(/*! anser */ "./node_modules/anser/lib/index.js"));
var React = __importStar(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var strip_ansi_1 = __importDefault(__webpack_require__(/*! strip-ansi */ "./node_modules/strip-ansi/index.js"));
var stack_frame_1 = __webpack_require__(/*! ../../helpers/stack-frame */ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/stack-frame.js");
exports.CodeFrame = function CodeFrame(_a) {
    var stackFrame = _a.stackFrame, codeFrame = _a.codeFrame;
    // Strip leading spaces out of the code frame:
    var formattedFrame = React.useMemo(function () {
        var lines = codeFrame.split(/\r?\n/g);
        var prefixLength = lines
            .map(function (line) { return /^>? +\d+ +\| ( *)/.exec(strip_ansi_1["default"](line)); })
            .filter(Boolean)
            .map(function (v) { return v.pop(); })
            .reduce(function (c, n) { return (isNaN(c) ? n.length : Math.min(c, n.length)); }, NaN);
        if (prefixLength > 1) {
            var p_1 = ' '.repeat(prefixLength);
            return lines
                .map(function (line, a) {
                return ~(a = line.indexOf('|'))
                    ? line.substring(0, a) + line.substring(a).replace(p_1, '')
                    : line;
            })
                .join('\n');
        }
        return lines.join('\n');
    }, [codeFrame]);
    var decoded = React.useMemo(function () {
        return anser_1["default"].ansiToJson(formattedFrame, {
            json: true,
            use_classes: true,
            remove_empty: true
        });
    }, [formattedFrame]);
    var open = React.useCallback(function () {
        var _a;
        var params = new URLSearchParams();
        for (var key in stackFrame) {
            params.append(key, ((_a = stackFrame[key]) !== null && _a !== void 0 ? _a : '').toString());
        }
        self.fetch("/__nextjs_launch-editor?" + params.toString()).then(function () { }, function () {
            // TODO: report error
        });
    }, [stackFrame]);
    // TODO: make the caret absolute
    return (React.createElement("div", { "data-nextjs-codeframe": true },
        React.createElement("p", { role: "link", onClick: open, tabIndex: 1, title: "Click to open in your editor" },
            React.createElement("span", null,
                stack_frame_1.getFrameSource(stackFrame),
                " @ ",
                stackFrame.methodName),
            React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" },
                React.createElement("path", { d: "M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6" }),
                React.createElement("polyline", { points: "15 3 21 3 21 9" }),
                React.createElement("line", { x1: "10", y1: "14", x2: "21", y2: "3" }))),
        React.createElement("hr", null),
        React.createElement("pre", null, decoded.map(function (entry, index) { return (React.createElement("span", { key: "frame-" + index, style: __assign({ color: entry.fg ? "var(--color-" + entry.fg + ")" : undefined }, (entry.decoration === 'bold'
                ? { fontWeight: 800 }
                : entry.decoration === 'italic'
                    ? { fontStyle: 'italic' }
                    : undefined)) }, entry.content)); }))));
};


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/CodeFrame/index.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/CodeFrame/index.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.__esModule = true;
var CodeFrame_1 = __webpack_require__(/*! ./CodeFrame */ "./node_modules/@next/react-dev-overlay/lib/internal/components/CodeFrame/CodeFrame.js");
exports.CodeFrame = CodeFrame_1.CodeFrame;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/CodeFrame/styles.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/CodeFrame/styles.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
exports.__esModule = true;
var noop_template_1 = __webpack_require__(/*! ../../helpers/noop-template */ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/noop-template.js");
var styles = noop_template_1.noop(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n  [data-nextjs-codeframe] {\n    border-radius: var(--size-gap-half);\n    background-color: var(--color-ansi-bg);\n    color: var(--color-ansi-fg);\n  }\n  [data-nextjs-codeframe]::selection,\n  [data-nextjs-codeframe] *::selection {\n    background-color: var(--color-ansi-selection);\n  }\n  [data-nextjs-codeframe] * {\n    color: inherit;\n    background-color: transparent;\n    font-family: var(--font-stack-monospace);\n  }\n\n  [data-nextjs-codeframe] > * {\n    margin: 0;\n    padding: calc(var(--size-gap) + var(--size-gap-half))\n      calc(var(--size-gap-double) + var(--size-gap-half));\n  }\n  [data-nextjs-codeframe] > hr {\n    margin: 0;\n    padding: 0;\n\n    border: none;\n    border-style: solid;\n    border-width: 0;\n    border-bottom-width: 1px;\n    border-color: var(--color-ansi-bright-black);\n  }\n\n  [data-nextjs-codeframe] > p {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    cursor: pointer;\n  }\n  [data-nextjs-codeframe] > p:hover {\n    text-decoration: underline dotted;\n  }\n  [data-nextjs-codeframe] > p > svg {\n    width: auto;\n    height: 1em;\n    margin-left: 0.5rem;\n  }\n"], ["\n  [data-nextjs-codeframe] {\n    border-radius: var(--size-gap-half);\n    background-color: var(--color-ansi-bg);\n    color: var(--color-ansi-fg);\n  }\n  [data-nextjs-codeframe]::selection,\n  [data-nextjs-codeframe] *::selection {\n    background-color: var(--color-ansi-selection);\n  }\n  [data-nextjs-codeframe] * {\n    color: inherit;\n    background-color: transparent;\n    font-family: var(--font-stack-monospace);\n  }\n\n  [data-nextjs-codeframe] > * {\n    margin: 0;\n    padding: calc(var(--size-gap) + var(--size-gap-half))\n      calc(var(--size-gap-double) + var(--size-gap-half));\n  }\n  [data-nextjs-codeframe] > hr {\n    margin: 0;\n    padding: 0;\n\n    border: none;\n    border-style: solid;\n    border-width: 0;\n    border-bottom-width: 1px;\n    border-color: var(--color-ansi-bright-black);\n  }\n\n  [data-nextjs-codeframe] > p {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    cursor: pointer;\n  }\n  [data-nextjs-codeframe] > p:hover {\n    text-decoration: underline dotted;\n  }\n  [data-nextjs-codeframe] > p > svg {\n    width: auto;\n    height: 1em;\n    margin-left: 0.5rem;\n  }\n"])));
exports.styles = styles;
var templateObject_1;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/Dialog.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/Dialog.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
exports.__esModule = true;
var React = __importStar(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var use_on_click_outside_1 = __webpack_require__(/*! ../../hooks/use-on-click-outside */ "./node_modules/@next/react-dev-overlay/lib/internal/hooks/use-on-click-outside.js");
var Dialog = function Dialog(_a) {
    var children = _a.children, type = _a.type, onClose = _a.onClose, props = __rest(_a, ["children", "type", "onClose"]);
    var _b = __read(React.useState(null), 2), dialog = _b[0], setDialog = _b[1];
    var onDialog = React.useCallback(function (node) {
        setDialog(node);
    }, []);
    use_on_click_outside_1.useOnClickOutside(dialog, onClose);
    // Make HTMLElements with `role=link` accessible to be triggered by the
    // keyboard, i.e. [Enter].
    React.useEffect(function () {
        if (dialog == null) {
            return;
        }
        var root = dialog.getRootNode();
        // Always true, but we do this for TypeScript:
        if (!(root instanceof ShadowRoot)) {
            return;
        }
        var shadowRoot = root;
        function handler(e) {
            var el = shadowRoot.activeElement;
            if (e.key === 'Enter' &&
                el instanceof HTMLElement &&
                el.getAttribute('role') === 'link') {
                e.preventDefault();
                e.stopPropagation();
                el.click();
            }
        }
        shadowRoot.addEventListener('keydown', handler);
        return function () { return shadowRoot.removeEventListener('keydown', handler); };
    }, [dialog]);
    return (React.createElement("div", { ref: onDialog, "data-nextjs-dialog": true, tabIndex: -1, role: "dialog", "aria-labelledby": props['aria-labelledby'], "aria-describedby": props['aria-describedby'], "aria-modal": "true" },
        React.createElement("div", { "data-nextjs-dialog-banner": true, className: "banner-" + type }),
        children));
};
exports.Dialog = Dialog;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/DialogBody.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/DialogBody.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
exports.__esModule = true;
var React = __importStar(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var DialogBody = function DialogBody(_a) {
    var children = _a.children, className = _a.className;
    return (React.createElement("div", { "data-nextjs-dialog-body": true, className: className }, children));
};
exports.DialogBody = DialogBody;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/DialogContent.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/DialogContent.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
exports.__esModule = true;
var React = __importStar(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var DialogContent = function DialogContent(_a) {
    var children = _a.children, className = _a.className;
    return (React.createElement("div", { "data-nextjs-dialog-content": true, className: className }, children));
};
exports.DialogContent = DialogContent;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/DialogHeader.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/DialogHeader.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
exports.__esModule = true;
var React = __importStar(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var DialogHeader = function DialogHeader(_a) {
    var children = _a.children, className = _a.className;
    return (React.createElement("div", { "data-nextjs-dialog-header": true, className: className }, children));
};
exports.DialogHeader = DialogHeader;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/index.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/index.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.__esModule = true;
var Dialog_1 = __webpack_require__(/*! ./Dialog */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/Dialog.js");
exports.Dialog = Dialog_1.Dialog;
var DialogBody_1 = __webpack_require__(/*! ./DialogBody */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/DialogBody.js");
exports.DialogBody = DialogBody_1.DialogBody;
var DialogContent_1 = __webpack_require__(/*! ./DialogContent */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/DialogContent.js");
exports.DialogContent = DialogContent_1.DialogContent;
var DialogHeader_1 = __webpack_require__(/*! ./DialogHeader */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/DialogHeader.js");
exports.DialogHeader = DialogHeader_1.DialogHeader;
var styles_1 = __webpack_require__(/*! ./styles */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/styles.js");
exports.styles = styles_1.styles;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/styles.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/styles.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
exports.__esModule = true;
var noop_template_1 = __webpack_require__(/*! ../../helpers/noop-template */ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/noop-template.js");
var styles = noop_template_1.noop(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n  [data-nextjs-dialog] {\n    display: flex;\n    flex-direction: column;\n    width: 100%;\n    margin-right: auto;\n    margin-left: auto;\n    outline: none;\n    background: white;\n    border-radius: var(--size-gap);\n    box-shadow: 0 var(--size-gap-half) var(--size-gap-double)\n      rgba(0, 0, 0, 0.25);\n    max-height: calc(100% - 3.5rem);\n    overflow-y: hidden;\n  }\n\n  @media (min-width: 576px) {\n    [data-nextjs-dialog] {\n      max-width: 540px;\n      box-shadow: 0 var(--size-gap) var(--size-gap-quad) rgba(0, 0, 0, 0.25);\n    }\n  }\n\n  @media (min-width: 768px) {\n    [data-nextjs-dialog] {\n      max-width: 720px;\n    }\n  }\n\n  @media (min-width: 992px) {\n    [data-nextjs-dialog] {\n      max-width: 960px;\n    }\n  }\n\n  [data-nextjs-dialog-banner] {\n    position: relative;\n  }\n  [data-nextjs-dialog-banner].banner-warning {\n    border-color: var(--color-ansi-yellow);\n  }\n  [data-nextjs-dialog-banner].banner-error {\n    border-color: var(--color-ansi-red);\n  }\n\n  [data-nextjs-dialog-banner]::after {\n    z-index: 2;\n    content: '';\n    position: absolute;\n    top: 0;\n    right: 0;\n    width: 100%;\n    /* banner width: */\n    border-top-width: var(--size-gap-half);\n    border-bottom-width: 0;\n    border-top-style: solid;\n    border-bottom-style: solid;\n    border-top-color: inherit;\n    border-bottom-color: transparent;\n  }\n\n  [data-nextjs-dialog-content] {\n    overflow-y: auto;\n    border: none;\n    margin: 0;\n    /* calc(padding + banner width offset) */\n    padding: calc(var(--size-gap-double) + var(--size-gap-half))\n      var(--size-gap-double);\n    height: 100%;\n    display: flex;\n    flex-direction: column;\n  }\n  [data-nextjs-dialog-content] > [data-nextjs-dialog-header] {\n    flex-shrink: 0;\n    margin-bottom: var(--size-gap-double);\n  }\n  [data-nextjs-dialog-content] > [data-nextjs-dialog-body] {\n    position: relative;\n    flex: 1 1 auto;\n  }\n"], ["\n  [data-nextjs-dialog] {\n    display: flex;\n    flex-direction: column;\n    width: 100%;\n    margin-right: auto;\n    margin-left: auto;\n    outline: none;\n    background: white;\n    border-radius: var(--size-gap);\n    box-shadow: 0 var(--size-gap-half) var(--size-gap-double)\n      rgba(0, 0, 0, 0.25);\n    max-height: calc(100% - 3.5rem);\n    overflow-y: hidden;\n  }\n\n  @media (min-width: 576px) {\n    [data-nextjs-dialog] {\n      max-width: 540px;\n      box-shadow: 0 var(--size-gap) var(--size-gap-quad) rgba(0, 0, 0, 0.25);\n    }\n  }\n\n  @media (min-width: 768px) {\n    [data-nextjs-dialog] {\n      max-width: 720px;\n    }\n  }\n\n  @media (min-width: 992px) {\n    [data-nextjs-dialog] {\n      max-width: 960px;\n    }\n  }\n\n  [data-nextjs-dialog-banner] {\n    position: relative;\n  }\n  [data-nextjs-dialog-banner].banner-warning {\n    border-color: var(--color-ansi-yellow);\n  }\n  [data-nextjs-dialog-banner].banner-error {\n    border-color: var(--color-ansi-red);\n  }\n\n  [data-nextjs-dialog-banner]::after {\n    z-index: 2;\n    content: '';\n    position: absolute;\n    top: 0;\n    right: 0;\n    width: 100%;\n    /* banner width: */\n    border-top-width: var(--size-gap-half);\n    border-bottom-width: 0;\n    border-top-style: solid;\n    border-bottom-style: solid;\n    border-top-color: inherit;\n    border-bottom-color: transparent;\n  }\n\n  [data-nextjs-dialog-content] {\n    overflow-y: auto;\n    border: none;\n    margin: 0;\n    /* calc(padding + banner width offset) */\n    padding: calc(var(--size-gap-double) + var(--size-gap-half))\n      var(--size-gap-double);\n    height: 100%;\n    display: flex;\n    flex-direction: column;\n  }\n  [data-nextjs-dialog-content] > [data-nextjs-dialog-header] {\n    flex-shrink: 0;\n    margin-bottom: var(--size-gap-double);\n  }\n  [data-nextjs-dialog-content] > [data-nextjs-dialog-body] {\n    position: relative;\n    flex: 1 1 auto;\n  }\n"])));
exports.styles = styles;
var templateObject_1;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/LeftRightDialogHeader/LeftRightDialogHeader.js":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/LeftRightDialogHeader/LeftRightDialogHeader.js ***!
  \*********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
exports.__esModule = true;
var React = __importStar(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var LeftRightDialogHeader = function LeftRightDialogHeader(_a) {
    var children = _a.children, className = _a.className, previous = _a.previous, next = _a.next, close = _a.close;
    var buttonLeft = React.useRef();
    var buttonRight = React.useRef();
    var buttonClose = React.useRef();
    var _b = __read(React.useState(null), 2), nav = _b[0], setNav = _b[1];
    var onNav = React.useCallback(function (el) {
        setNav(el);
    }, []);
    React.useEffect(function () {
        if (nav == null) {
            return;
        }
        var root = nav.getRootNode();
        var d = self.document;
        function handler(e) {
            if (e.key === 'ArrowLeft') {
                e.stopPropagation();
                if (buttonLeft.current) {
                    buttonLeft.current.focus();
                }
                previous && previous();
            }
            else if (e.key === 'ArrowRight') {
                e.stopPropagation();
                if (buttonRight.current) {
                    buttonRight.current.focus();
                }
                next && next();
            }
            else if (e.key === 'Escape') {
                e.stopPropagation();
                if (root instanceof ShadowRoot) {
                    var a = root.activeElement;
                    if (a && a !== buttonClose.current && a instanceof HTMLElement) {
                        a.blur();
                        return;
                    }
                }
                close();
            }
        }
        root.addEventListener('keydown', handler);
        if (root !== d) {
            d.addEventListener('keydown', handler);
        }
        return function () {
            root.removeEventListener('keydown', handler);
            if (root !== d) {
                d.removeEventListener('keydown', handler);
            }
        };
    }, [close, nav, next, previous]);
    // Unlock focus for browsers like Firefox, that break all user focus if the
    // currently focused item becomes disabled.
    React.useEffect(function () {
        if (nav == null) {
            return;
        }
        var root = nav.getRootNode();
        // Always true, but we do this for TypeScript:
        if (root instanceof ShadowRoot) {
            var a = root.activeElement;
            if (previous == null) {
                if (a === buttonLeft.current) {
                    buttonLeft.current.blur();
                }
            }
            else if (next == null) {
                if (a === buttonRight.current) {
                    buttonRight.current.blur();
                }
            }
        }
    }, [nav, next, previous]);
    return (React.createElement("div", { "data-nextjs-dialog-left-right": true, className: className },
        React.createElement("nav", { ref: onNav },
            React.createElement("button", { ref: buttonLeft, type: "button", disabled: previous == null ? true : undefined, "aria-disabled": previous == null ? true : undefined, onClick: previous !== null && previous !== void 0 ? previous : undefined },
                React.createElement("svg", { viewBox: "0 0 14 14", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
                    React.createElement("path", { d: "M6.99996 1.16666L1.16663 6.99999L6.99996 12.8333M12.8333 6.99999H1.99996H12.8333Z", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }))),
            React.createElement("button", { ref: buttonRight, type: "button", disabled: next == null ? true : undefined, "aria-disabled": next == null ? true : undefined, onClick: next !== null && next !== void 0 ? next : undefined },
                React.createElement("svg", { viewBox: "0 0 14 14", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
                    React.createElement("path", { d: "M6.99996 1.16666L12.8333 6.99999L6.99996 12.8333M1.16663 6.99999H12H1.16663Z", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }))),
            "\u00A0",
            children),
        React.createElement("button", { ref: buttonClose, type: "button", onClick: close, "aria-label": "Close" },
            React.createElement("span", { "aria-hidden": "true" },
                React.createElement("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
                    React.createElement("path", { d: "M18 6L6 18", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }),
                    React.createElement("path", { d: "M6 6L18 18", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }))))));
};
exports.LeftRightDialogHeader = LeftRightDialogHeader;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/LeftRightDialogHeader/index.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/LeftRightDialogHeader/index.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.__esModule = true;
var LeftRightDialogHeader_1 = __webpack_require__(/*! ./LeftRightDialogHeader */ "./node_modules/@next/react-dev-overlay/lib/internal/components/LeftRightDialogHeader/LeftRightDialogHeader.js");
exports.LeftRightDialogHeader = LeftRightDialogHeader_1.LeftRightDialogHeader;
var styles_1 = __webpack_require__(/*! ./styles */ "./node_modules/@next/react-dev-overlay/lib/internal/components/LeftRightDialogHeader/styles.js");
exports.styles = styles_1.styles;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/LeftRightDialogHeader/styles.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/LeftRightDialogHeader/styles.js ***!
  \******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
exports.__esModule = true;
var noop_template_1 = __webpack_require__(/*! ../../helpers/noop-template */ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/noop-template.js");
var styles = noop_template_1.noop(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n  [data-nextjs-dialog-left-right] {\n    display: flex;\n    flex-direction: row;\n    align-content: center;\n    align-items: center;\n    justify-content: space-between;\n  }\n  [data-nextjs-dialog-left-right] > nav > button {\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n\n    width: calc(var(--size-gap-double) + var(--size-gap));\n    height: calc(var(--size-gap-double) + var(--size-gap));\n    font-size: 0;\n    border: none;\n    background-color: rgba(255, 85, 85, 0.1);\n    color: var(--color-ansi-red);\n    cursor: pointer;\n    transition: background-color 0.25s ease;\n  }\n  [data-nextjs-dialog-left-right] > nav > button > svg {\n    width: auto;\n    height: calc(var(--size-gap) + var(--size-gap-half));\n  }\n  [data-nextjs-dialog-left-right] > nav > button:hover {\n    background-color: rgba(255, 85, 85, 0.2);\n  }\n  [data-nextjs-dialog-left-right] > nav > button:disabled {\n    background-color: rgba(255, 85, 85, 0.1);\n    color: rgba(255, 85, 85, 0.4);\n    cursor: not-allowed;\n  }\n\n  [data-nextjs-dialog-left-right] > nav > button:first-of-type {\n    border-radius: var(--size-gap-half) 0 0 var(--size-gap-half);\n    margin-right: 1px;\n  }\n  [data-nextjs-dialog-left-right] > nav > button:last-of-type {\n    border-radius: 0 var(--size-gap-half) var(--size-gap-half) 0;\n  }\n\n  [data-nextjs-dialog-left-right] > button:last-of-type {\n    border: 0;\n    padding: 0;\n\n    background-color: transparent;\n    appearance: none;\n\n    opacity: 0.4;\n    transition: opacity 0.25s ease;\n  }\n  [data-nextjs-dialog-left-right] > button:last-of-type:hover {\n    opacity: 0.7;\n  }\n"], ["\n  [data-nextjs-dialog-left-right] {\n    display: flex;\n    flex-direction: row;\n    align-content: center;\n    align-items: center;\n    justify-content: space-between;\n  }\n  [data-nextjs-dialog-left-right] > nav > button {\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n\n    width: calc(var(--size-gap-double) + var(--size-gap));\n    height: calc(var(--size-gap-double) + var(--size-gap));\n    font-size: 0;\n    border: none;\n    background-color: rgba(255, 85, 85, 0.1);\n    color: var(--color-ansi-red);\n    cursor: pointer;\n    transition: background-color 0.25s ease;\n  }\n  [data-nextjs-dialog-left-right] > nav > button > svg {\n    width: auto;\n    height: calc(var(--size-gap) + var(--size-gap-half));\n  }\n  [data-nextjs-dialog-left-right] > nav > button:hover {\n    background-color: rgba(255, 85, 85, 0.2);\n  }\n  [data-nextjs-dialog-left-right] > nav > button:disabled {\n    background-color: rgba(255, 85, 85, 0.1);\n    color: rgba(255, 85, 85, 0.4);\n    cursor: not-allowed;\n  }\n\n  [data-nextjs-dialog-left-right] > nav > button:first-of-type {\n    border-radius: var(--size-gap-half) 0 0 var(--size-gap-half);\n    margin-right: 1px;\n  }\n  [data-nextjs-dialog-left-right] > nav > button:last-of-type {\n    border-radius: 0 var(--size-gap-half) var(--size-gap-half) 0;\n  }\n\n  [data-nextjs-dialog-left-right] > button:last-of-type {\n    border: 0;\n    padding: 0;\n\n    background-color: transparent;\n    appearance: none;\n\n    opacity: 0.4;\n    transition: opacity 0.25s ease;\n  }\n  [data-nextjs-dialog-left-right] > button:last-of-type:hover {\n    opacity: 0.7;\n  }\n"])));
exports.styles = styles;
var templateObject_1;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/Overlay/Overlay.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/Overlay/Overlay.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
exports.__esModule = true;
var disabled_1 = __importDefault(__webpack_require__(/*! ally.js/maintain/disabled */ "./node_modules/ally.js/maintain/disabled.js"));
var tab_focus_1 = __importDefault(__webpack_require__(/*! ally.js/maintain/tab-focus */ "./node_modules/ally.js/maintain/tab-focus.js"));
var React = __importStar(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var body_locker_1 = __webpack_require__(/*! ./body-locker */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Overlay/body-locker.js");
var Overlay = function Overlay(_a) {
    var className = _a.className, children = _a.children, fixed = _a.fixed;
    React.useEffect(function () {
        body_locker_1.lock();
        return function () {
            body_locker_1.unlock();
        };
    }, []);
    var _b = __read(React.useState(null), 2), overlay = _b[0], setOverlay = _b[1];
    var onOverlay = React.useCallback(function (el) {
        setOverlay(el);
    }, []);
    React.useEffect(function () {
        if (overlay == null) {
            return;
        }
        var handle1 = disabled_1["default"]({ filter: overlay });
        var handle2 = tab_focus_1["default"]({ context: overlay });
        return function () {
            handle1.disengage();
            handle2.disengage();
        };
    }, [overlay]);
    return (React.createElement("div", { "data-nextjs-dialog-overlay": true, className: className, ref: onOverlay },
        React.createElement("div", { "data-nextjs-dialog-backdrop": true, "data-nextjs-dialog-backdrop-fixed": fixed ? true : undefined }),
        children));
};
exports.Overlay = Overlay;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/Overlay/body-locker.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/Overlay/body-locker.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.__esModule = true;
var previousBodyPaddingRight;
var previousBodyOverflowSetting;
var activeLocks = 0;
function lock() {
    setTimeout(function () {
        if (activeLocks++ > 0) {
            return;
        }
        var scrollBarGap = window.innerWidth - document.documentElement.clientWidth;
        if (scrollBarGap > 0) {
            previousBodyPaddingRight = document.body.style.paddingRight;
            document.body.style.paddingRight = scrollBarGap + "px";
        }
        previousBodyOverflowSetting = document.body.style.overflow;
        document.body.style.overflow = 'hidden';
    });
}
exports.lock = lock;
function unlock() {
    setTimeout(function () {
        if (activeLocks === 0 || --activeLocks !== 0) {
            return;
        }
        if (previousBodyPaddingRight !== undefined) {
            document.body.style.paddingRight = previousBodyPaddingRight;
            previousBodyPaddingRight = undefined;
        }
        if (previousBodyOverflowSetting !== undefined) {
            document.body.style.overflow = previousBodyOverflowSetting;
            previousBodyOverflowSetting = undefined;
        }
    });
}
exports.unlock = unlock;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/Overlay/index.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/Overlay/index.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.__esModule = true;
var Overlay_1 = __webpack_require__(/*! ./Overlay */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Overlay/Overlay.js");
exports.Overlay = Overlay_1.Overlay;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/Overlay/styles.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/Overlay/styles.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
exports.__esModule = true;
var noop_template_1 = __webpack_require__(/*! ../../helpers/noop-template */ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/noop-template.js");
var styles = noop_template_1.noop(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n  [data-nextjs-dialog-overlay] {\n    position: fixed;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n    overflow: auto;\n    z-index: 9000;\n\n    display: flex;\n    align-content: center;\n    align-items: center;\n    flex-direction: column;\n    padding: 10vh 15px 0;\n  }\n\n  [data-nextjs-dialog-backdrop] {\n    position: fixed;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n    background-color: rgba(17, 17, 17, 0.2);\n    pointer-events: all;\n    z-index: -1;\n  }\n\n  [data-nextjs-dialog-backdrop-fixed] {\n    cursor: not-allowed;\n    -webkit-backdrop-filter: blur(8px);\n    backdrop-filter: blur(8px);\n  }\n"], ["\n  [data-nextjs-dialog-overlay] {\n    position: fixed;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n    overflow: auto;\n    z-index: 9000;\n\n    display: flex;\n    align-content: center;\n    align-items: center;\n    flex-direction: column;\n    padding: 10vh 15px 0;\n  }\n\n  [data-nextjs-dialog-backdrop] {\n    position: fixed;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n    background-color: rgba(17, 17, 17, 0.2);\n    pointer-events: all;\n    z-index: -1;\n  }\n\n  [data-nextjs-dialog-backdrop-fixed] {\n    cursor: not-allowed;\n    -webkit-backdrop-filter: blur(8px);\n    backdrop-filter: blur(8px);\n  }\n"])));
exports.styles = styles;
var templateObject_1;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/ShadowPortal.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/ShadowPortal.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
exports.__esModule = true;
var React = __importStar(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var react_dom_1 = __webpack_require__(/*! react-dom */ "./node_modules/react-dom/index.js");
exports.ShadowPortal = function Portal(_a) {
    var children = _a.children;
    var mountNode = React.useRef(null);
    var portalNode = React.useRef(null);
    var shadowNode = React.useRef(null);
    var _b = __read(React.useState(), 2), forceUpdate = _b[1];
    React.useLayoutEffect(function () {
        var ownerDocument = mountNode.current.ownerDocument;
        portalNode.current = ownerDocument.createElement('nextjs-portal');
        shadowNode.current = portalNode.current.attachShadow({ mode: 'open' });
        ownerDocument.body.appendChild(portalNode.current);
        forceUpdate({});
        return function () {
            if (portalNode.current && portalNode.current.ownerDocument) {
                portalNode.current.ownerDocument.body.removeChild(portalNode.current);
            }
        };
    }, []);
    return shadowNode.current ? (react_dom_1.createPortal(children, shadowNode.current)) : (React.createElement("span", { ref: mountNode }));
};


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/Terminal/Terminal.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/Terminal/Terminal.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
exports.__esModule = true;
var anser_1 = __importDefault(__webpack_require__(/*! anser */ "./node_modules/anser/lib/index.js"));
var React = __importStar(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
exports.Terminal = function Terminal(_a) {
    var content = _a.content;
    var decoded = React.useMemo(function () {
        return anser_1["default"].ansiToJson(content, {
            json: true,
            use_classes: true,
            remove_empty: true
        });
    }, [content]);
    return (React.createElement("div", { "data-nextjs-terminal": true },
        React.createElement("pre", null, decoded.map(function (entry, index) { return (React.createElement("span", { key: "terminal-entry-" + index, style: __assign({ color: entry.fg ? "var(--color-" + entry.fg + ")" : undefined }, (entry.decoration === 'bold'
                ? { fontWeight: 800 }
                : entry.decoration === 'italic'
                    ? { fontStyle: 'italic' }
                    : undefined)) }, entry.content)); }))));
};


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/Terminal/index.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/Terminal/index.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.__esModule = true;
var Terminal_1 = __webpack_require__(/*! ./Terminal */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Terminal/Terminal.js");
exports.Terminal = Terminal_1.Terminal;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/Terminal/styles.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/Terminal/styles.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
exports.__esModule = true;
var noop_template_1 = __webpack_require__(/*! ../../helpers/noop-template */ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/noop-template.js");
var styles = noop_template_1.noop(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n  [data-nextjs-terminal] {\n    border-radius: var(--size-gap-half);\n    background-color: var(--color-ansi-bg);\n    color: var(--color-ansi-fg);\n  }\n  [data-nextjs-terminal]::selection,\n  [data-nextjs-terminal] *::selection {\n    background-color: var(--color-ansi-selection);\n  }\n  [data-nextjs-terminal] * {\n    color: inherit;\n    background-color: transparent;\n    font-family: var(--font-stack-monospace);\n  }\n  [data-nextjs-terminal] > * {\n    margin: 0;\n    padding: calc(var(--size-gap) + var(--size-gap-half))\n      calc(var(--size-gap-double) + var(--size-gap-half));\n  }\n\n  [data-nextjs-terminal] pre {\n    white-space: pre-wrap;\n    word-break: break-word;\n  }\n"], ["\n  [data-nextjs-terminal] {\n    border-radius: var(--size-gap-half);\n    background-color: var(--color-ansi-bg);\n    color: var(--color-ansi-fg);\n  }\n  [data-nextjs-terminal]::selection,\n  [data-nextjs-terminal] *::selection {\n    background-color: var(--color-ansi-selection);\n  }\n  [data-nextjs-terminal] * {\n    color: inherit;\n    background-color: transparent;\n    font-family: var(--font-stack-monospace);\n  }\n  [data-nextjs-terminal] > * {\n    margin: 0;\n    padding: calc(var(--size-gap) + var(--size-gap-half))\n      calc(var(--size-gap-double) + var(--size-gap-half));\n  }\n\n  [data-nextjs-terminal] pre {\n    white-space: pre-wrap;\n    word-break: break-word;\n  }\n"])));
exports.styles = styles;
var templateObject_1;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/Toast/Toast.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/Toast/Toast.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
exports.__esModule = true;
var React = __importStar(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
exports.Toast = function Toast(_a) {
    var onClick = _a.onClick, children = _a.children, className = _a.className;
    return (React.createElement("div", { "data-nextjs-toast": true, onClick: onClick, className: className },
        React.createElement("div", { "data-nextjs-toast-wrapper": true }, children)));
};


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/Toast/index.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/Toast/index.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.__esModule = true;
var styles_1 = __webpack_require__(/*! ./styles */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Toast/styles.js");
exports.styles = styles_1.styles;
var Toast_1 = __webpack_require__(/*! ./Toast */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Toast/Toast.js");
exports.Toast = Toast_1.Toast;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/Toast/styles.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/Toast/styles.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
exports.__esModule = true;
var noop_template_1 = __webpack_require__(/*! ../../helpers/noop-template */ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/noop-template.js");
var styles = noop_template_1.noop(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n  [data-nextjs-toast] {\n    position: fixed;\n    bottom: var(--size-gap-double);\n    left: var(--size-gap-double);\n    max-width: 420px;\n    z-index: 9000;\n  }\n\n  @media (max-width: 440px) {\n    [data-nextjs-toast] {\n      max-width: 90vw;\n      left: 5vw;\n    }\n  }\n\n  [data-nextjs-toast-wrapper] {\n    padding: 1rem;\n    border-radius: var(--size-gap-half);\n    font-weight: 500;\n    color: var(--color-ansi-bright-white);\n    background-color: var(--color-ansi-red);\n    box-shadow: 0px var(--size-gap-double) var(--size-gap-quad)\n      rgba(0, 0, 0, 0.25);\n  }\n"], ["\n  [data-nextjs-toast] {\n    position: fixed;\n    bottom: var(--size-gap-double);\n    left: var(--size-gap-double);\n    max-width: 420px;\n    z-index: 9000;\n  }\n\n  @media (max-width: 440px) {\n    [data-nextjs-toast] {\n      max-width: 90vw;\n      left: 5vw;\n    }\n  }\n\n  [data-nextjs-toast-wrapper] {\n    padding: 1rem;\n    border-radius: var(--size-gap-half);\n    font-weight: 500;\n    color: var(--color-ansi-bright-white);\n    background-color: var(--color-ansi-red);\n    box-shadow: 0px var(--size-gap-double) var(--size-gap-quad)\n      rgba(0, 0, 0, 0.25);\n  }\n"])));
exports.styles = styles;
var templateObject_1;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/container/BuildError.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/container/BuildError.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
exports.__esModule = true;
var React = __importStar(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var Dialog_1 = __webpack_require__(/*! ../components/Dialog */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/index.js");
var Overlay_1 = __webpack_require__(/*! ../components/Overlay */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Overlay/index.js");
var Terminal_1 = __webpack_require__(/*! ../components/Terminal */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Terminal/index.js");
var noop_template_1 = __webpack_require__(/*! ../helpers/noop-template */ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/noop-template.js");
exports.BuildError = function BuildError(_a) {
    var message = _a.message;
    var noop = React.useCallback(function () { }, []);
    return (React.createElement(Overlay_1.Overlay, { fixed: true },
        React.createElement(Dialog_1.Dialog, { type: "error", "aria-labelledby": "nextjs__container_build_error_label", "aria-describedby": "nextjs__container_build_error_desc", onClose: noop },
            React.createElement(Dialog_1.DialogContent, null,
                React.createElement(Dialog_1.DialogHeader, { className: "nextjs-container-build-error-header" },
                    React.createElement("h4", { id: "nextjs__container_build_error_label" }, "Failed to compile")),
                React.createElement(Dialog_1.DialogBody, { className: "nextjs-container-build-error-body" },
                    React.createElement(Terminal_1.Terminal, { content: message }),
                    React.createElement("footer", null,
                        React.createElement("p", { id: "nextjs__container_build_error_desc" },
                            React.createElement("small", null, "This error occured during the build process and can only be dismissed by fixing the error."))))))));
};
exports.styles = noop_template_1.noop(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n  .nextjs-container-build-error-header > h4 {\n    line-height: 1.5;\n    margin: 0;\n    padding: 0;\n  }\n\n  .nextjs-container-build-error-body footer {\n    margin-top: var(--size-gap);\n  }\n  .nextjs-container-build-error-body footer p {\n    margin: 0;\n  }\n\n  .nextjs-container-build-error-body small {\n    color: #757575;\n  }\n"], ["\n  .nextjs-container-build-error-header > h4 {\n    line-height: 1.5;\n    margin: 0;\n    padding: 0;\n  }\n\n  .nextjs-container-build-error-body footer {\n    margin-top: var(--size-gap);\n  }\n  .nextjs-container-build-error-body footer p {\n    margin: 0;\n  }\n\n  .nextjs-container-build-error-body small {\n    color: #757575;\n  }\n"])));
var templateObject_1;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/container/Errors.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/container/Errors.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
exports.__esModule = true;
var React = __importStar(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var bus_1 = __webpack_require__(/*! ../bus */ "./node_modules/@next/react-dev-overlay/lib/internal/bus.js");
var Dialog_1 = __webpack_require__(/*! ../components/Dialog */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/index.js");
var LeftRightDialogHeader_1 = __webpack_require__(/*! ../components/LeftRightDialogHeader */ "./node_modules/@next/react-dev-overlay/lib/internal/components/LeftRightDialogHeader/index.js");
var Overlay_1 = __webpack_require__(/*! ../components/Overlay */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Overlay/index.js");
var Toast_1 = __webpack_require__(/*! ../components/Toast */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Toast/index.js");
var nodeStackFrames_1 = __webpack_require__(/*! ../helpers/nodeStackFrames */ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/nodeStackFrames.js");
var noop_template_1 = __webpack_require__(/*! ../helpers/noop-template */ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/noop-template.js");
var stack_frame_1 = __webpack_require__(/*! ../helpers/stack-frame */ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/stack-frame.js");
var RuntimeError_1 = __webpack_require__(/*! ./RuntimeError */ "./node_modules/@next/react-dev-overlay/lib/internal/container/RuntimeError.js");
function getErrorSignature(ev) {
    var event = ev.event;
    switch (event.type) {
        case bus_1.TYPE_UNHANDLED_ERROR:
        case bus_1.TYPE_UNHANDLED_REJECTION: {
            return event.reason.name + "::" + event.reason.message + "::" + event.reason.stack;
        }
        default: {
        }
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    var _ = event;
    return '';
}
function getErrorByType(ev) {
    return __awaiter(this, void 0, void 0, function () {
        var id, event, _a, _b, _;
        return __generator(this, function (_c) {
            switch (_c.label) {
                case 0:
                    id = ev.id, event = ev.event;
                    _a = event.type;
                    switch (_a) {
                        case bus_1.TYPE_UNHANDLED_ERROR: return [3 /*break*/, 1];
                        case bus_1.TYPE_UNHANDLED_REJECTION: return [3 /*break*/, 1];
                    }
                    return [3 /*break*/, 3];
                case 1:
                    _b = {
                        id: id,
                        runtime: true,
                        error: event.reason
                    };
                    return [4 /*yield*/, stack_frame_1.getOriginalStackFrames(nodeStackFrames_1.isNodeError(event.reason), event.frames)];
                case 2: return [2 /*return*/, (_b.frames = _c.sent(),
                        _b)];
                case 3:
                    {
                        return [3 /*break*/, 4];
                    }
                    _c.label = 4;
                case 4:
                    _ = event;
                    throw new Error('type system invariant violation');
            }
        });
    });
}
exports.Errors = function Errors(_a) {
    var errors = _a.errors;
    var _b = __read(React.useState({}), 2), lookups = _b[0], setLookups = _b[1];
    var _c = __read(React.useMemo(function () {
        var ready = [];
        var next = null;
        // Ensure errors are displayed in the order they occurred in:
        for (var idx = 0; idx < errors.length; ++idx) {
            var e = errors[idx];
            var id = e.id;
            if (id in lookups) {
                ready.push(lookups[id]);
                continue;
            }
            // Check for duplicate errors
            if (idx > 0) {
                var prev = errors[idx - 1];
                if (getErrorSignature(prev) === getErrorSignature(e)) {
                    continue;
                }
            }
            next = e;
            break;
        }
        return [ready, next];
    }, [errors, lookups]), 2), readyErrors = _c[0], nextError = _c[1];
    var isLoading = React.useMemo(function () {
        return readyErrors.length < 1 && Boolean(errors.length);
    }, [errors.length, readyErrors.length]);
    React.useEffect(function () {
        if (nextError == null) {
            return;
        }
        getErrorByType(nextError).then(function (resolved) {
            // We don't care if the desired error changed while we were resolving,
            // thus we're not tracking it using a ref. Once the work has been done,
            // we'll store it.
            setLookups(function (m) {
                var _a;
                return (__assign(__assign({}, m), (_a = {}, _a[resolved.id] = resolved, _a)));
            });
        }, function () {
            // TODO: handle this, though an edge case
        });
    }, [nextError]);
    var _d = __read(React.useState(false), 2), isMinimized = _d[0], setMinimized = _d[1];
    var _e = __read(React.useState(0), 2), activeIdx = _e[0], setActiveIndex = _e[1];
    var previous = React.useCallback(function (e) {
        e === null || e === void 0 ? void 0 : e.preventDefault();
        setActiveIndex(function (v) { return Math.max(0, v - 1); });
    }, []);
    var next = React.useCallback(function (e) {
        e === null || e === void 0 ? void 0 : e.preventDefault();
        setActiveIndex(function (v) {
            return Math.max(0, Math.min(readyErrors.length - 1, v + 1));
        });
    }, [readyErrors.length]);
    var activeError = React.useMemo(function () { var _a; return (_a = readyErrors[activeIdx]) !== null && _a !== void 0 ? _a : null; }, [activeIdx, readyErrors]);
    // Reset component state when there are no errors to be displayed.
    // This should never happen, but lets handle it.
    React.useEffect(function () {
        if (errors.length < 1) {
            setLookups({});
            setMinimized(false);
            setActiveIndex(0);
        }
    }, [errors.length]);
    var minimize = React.useCallback(function (e) {
        e === null || e === void 0 ? void 0 : e.preventDefault();
        setMinimized(true);
    }, []);
    var reopen = React.useCallback(function (e) {
        e === null || e === void 0 ? void 0 : e.preventDefault();
        setMinimized(false);
    }, []);
    // This component shouldn't be rendered with no errors, but if it is, let's
    // handle it gracefully by rendering nothing.
    if (errors.length < 1) {
        return null;
    }
    if (isLoading) {
        // TODO: better loading state
        return React.createElement(Overlay_1.Overlay, null);
    }
    if (isMinimized) {
        return (React.createElement(Toast_1.Toast, { className: "nextjs-toast-errors-parent", onClick: reopen },
            React.createElement("div", { className: "nextjs-toast-errors" },
                React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" },
                    React.createElement("circle", { cx: "12", cy: "12", r: "10" }),
                    React.createElement("line", { x1: "12", y1: "8", x2: "12", y2: "12" }),
                    React.createElement("line", { x1: "12", y1: "16", x2: "12.01", y2: "16" })),
                React.createElement("span", null,
                    readyErrors.length,
                    " error",
                    readyErrors.length > 1 ? 's' : ''))));
    }
    var isServerError = nodeStackFrames_1.isNodeError(activeError.error);
    return (React.createElement(Overlay_1.Overlay, null,
        React.createElement(Dialog_1.Dialog, { type: "error", "aria-labelledby": "nextjs__container_errors_label", "aria-describedby": "nextjs__container_errors_desc", onClose: minimize },
            React.createElement(Dialog_1.DialogContent, null,
                React.createElement(Dialog_1.DialogHeader, { className: "nextjs-container-errors-header" },
                    React.createElement(LeftRightDialogHeader_1.LeftRightDialogHeader, { previous: activeIdx > 0 ? previous : null, next: activeIdx < readyErrors.length - 1 ? next : null, close: minimize },
                        React.createElement("small", null,
                            React.createElement("span", null, activeIdx + 1),
                            " of",
                            ' ',
                            React.createElement("span", null, readyErrors.length),
                            " unhandled error",
                            readyErrors.length < 2 ? '' : 's')),
                    React.createElement("h1", { id: "nextjs__container_errors_label" }, isServerError ? 'Server Error' : 'Unhandled Runtime Error'),
                    React.createElement("p", { id: "nextjs__container_errors_desc" },
                        activeError.error.name,
                        ": ",
                        activeError.error.message),
                    isServerError ? (React.createElement("div", null,
                        React.createElement("small", null, "This error happened while generating the page. Any console logs will be displayed in the terminal window."))) : undefined),
                React.createElement(Dialog_1.DialogBody, { className: "nextjs-container-errors-body" },
                    React.createElement(RuntimeError_1.RuntimeError, { key: activeError.id.toString(), error: activeError }))))));
};
exports.styles = noop_template_1.noop(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n  .nextjs-container-errors-header > h1 {\n    font-size: var(--size-font-big);\n    line-height: var(--size-font-bigger);\n    font-weight: bold;\n    margin: 0;\n    margin-top: calc(var(--size-gap-double) + var(--size-gap-half));\n  }\n  .nextjs-container-errors-header small {\n    font-size: var(--size-font-small);\n    color: var(--color-accents-1);\n    margin-left: var(--size-gap-double);\n  }\n  .nextjs-container-errors-header small > span {\n    font-family: var(--font-stack-monospace);\n  }\n  .nextjs-container-errors-header > p {\n    font-family: var(--font-stack-monospace);\n    font-size: var(--size-font-small);\n    line-height: var(--size-font-big);\n    font-weight: bold;\n    margin: 0;\n    margin-top: var(--size-gap-half);\n    color: var(--color-ansi-red);\n    white-space: pre-wrap;\n  }\n  .nextjs-container-errors-header > div > small {\n    margin: 0;\n    margin-top: var(--size-gap-half);\n  }\n\n  .nextjs-container-errors-body > h5:not(:first-child) {\n    margin-top: calc(var(--size-gap-double) + var(--size-gap));\n  }\n  .nextjs-container-errors-body > h5 {\n    margin-bottom: var(--size-gap);\n  }\n\n  .nextjs-toast-errors-parent {\n    cursor: pointer;\n    transition: transform 0.2s ease;\n  }\n  .nextjs-toast-errors-parent:hover {\n    transform: scale(1.1);\n  }\n  .nextjs-toast-errors {\n    display: flex;\n    align-items: center;\n    justify-content: flex-start;\n  }\n  .nextjs-toast-errors > svg {\n    margin-right: var(--size-gap);\n  }\n"], ["\n  .nextjs-container-errors-header > h1 {\n    font-size: var(--size-font-big);\n    line-height: var(--size-font-bigger);\n    font-weight: bold;\n    margin: 0;\n    margin-top: calc(var(--size-gap-double) + var(--size-gap-half));\n  }\n  .nextjs-container-errors-header small {\n    font-size: var(--size-font-small);\n    color: var(--color-accents-1);\n    margin-left: var(--size-gap-double);\n  }\n  .nextjs-container-errors-header small > span {\n    font-family: var(--font-stack-monospace);\n  }\n  .nextjs-container-errors-header > p {\n    font-family: var(--font-stack-monospace);\n    font-size: var(--size-font-small);\n    line-height: var(--size-font-big);\n    font-weight: bold;\n    margin: 0;\n    margin-top: var(--size-gap-half);\n    color: var(--color-ansi-red);\n    white-space: pre-wrap;\n  }\n  .nextjs-container-errors-header > div > small {\n    margin: 0;\n    margin-top: var(--size-gap-half);\n  }\n\n  .nextjs-container-errors-body > h5:not(:first-child) {\n    margin-top: calc(var(--size-gap-double) + var(--size-gap));\n  }\n  .nextjs-container-errors-body > h5 {\n    margin-bottom: var(--size-gap);\n  }\n\n  .nextjs-toast-errors-parent {\n    cursor: pointer;\n    transition: transform 0.2s ease;\n  }\n  .nextjs-toast-errors-parent:hover {\n    transform: scale(1.1);\n  }\n  .nextjs-toast-errors {\n    display: flex;\n    align-items: center;\n    justify-content: flex-start;\n  }\n  .nextjs-toast-errors > svg {\n    margin-right: var(--size-gap);\n  }\n"])));
var templateObject_1;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/container/RuntimeError.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/container/RuntimeError.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
exports.__esModule = true;
var React = __importStar(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var CodeFrame_1 = __webpack_require__(/*! ../components/CodeFrame */ "./node_modules/@next/react-dev-overlay/lib/internal/components/CodeFrame/index.js");
var noop_template_1 = __webpack_require__(/*! ../helpers/noop-template */ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/noop-template.js");
var stack_frame_1 = __webpack_require__(/*! ../helpers/stack-frame */ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/stack-frame.js");
var CallStackFrame = function CallStackFrame(_a) {
    // TODO: ability to expand resolved frames
    // TODO: render error or external indicator
    var frame = _a.frame;
    var _b;
    var f = (_b = frame.originalStackFrame) !== null && _b !== void 0 ? _b : frame.sourceStackFrame;
    var hasSource = Boolean(frame.originalCodeFrame);
    var open = React.useCallback(function () {
        var _a;
        if (!hasSource)
            return;
        var params = new URLSearchParams();
        for (var key in f) {
            params.append(key, ((_a = f[key]) !== null && _a !== void 0 ? _a : '').toString());
        }
        self.fetch("/__nextjs_launch-editor?" + params.toString()).then(function () { }, function () {
            // TODO: report error
        });
    }, [hasSource, f]);
    return (React.createElement("div", { "data-nextjs-call-stack-frame": true },
        React.createElement("h6", { "data-nextjs-frame-expanded": Boolean(frame.expanded) }, f.methodName),
        React.createElement("div", { "data-has-source": hasSource ? 'true' : undefined, tabIndex: hasSource ? 10 : undefined, role: hasSource ? 'link' : undefined, onClick: open, title: hasSource ? 'Click to open in your editor' : undefined },
            React.createElement("span", null, stack_frame_1.getFrameSource(f)),
            React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" },
                React.createElement("path", { d: "M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6" }),
                React.createElement("polyline", { points: "15 3 21 3 21 9" }),
                React.createElement("line", { x1: "10", y1: "14", x2: "21", y2: "3" })))));
};
var RuntimeError = function RuntimeError(_a) {
    var error = _a.error;
    var firstFirstPartyFrameIndex = React.useMemo(function () {
        return error.frames.findIndex(function (entry) {
            return entry.expanded &&
                Boolean(entry.originalCodeFrame) &&
                Boolean(entry.originalStackFrame);
        });
    }, [error.frames]);
    var firstFrame = React.useMemo(function () {
        var _a;
        return (_a = error.frames[firstFirstPartyFrameIndex]) !== null && _a !== void 0 ? _a : null;
    }, [error.frames, firstFirstPartyFrameIndex]);
    var allLeadingFrames = React.useMemo(function () {
        return firstFirstPartyFrameIndex < 0
            ? []
            : error.frames.slice(0, firstFirstPartyFrameIndex);
    }, [error.frames, firstFirstPartyFrameIndex]);
    var _b = __read(React.useState(firstFrame == null), 2), all = _b[0], setAll = _b[1];
    var toggleAll = React.useCallback(function () {
        setAll(function (v) { return !v; });
    }, []);
    var leadingFrames = React.useMemo(function () { return allLeadingFrames.filter(function (f) { return f.expanded || all; }); }, [all, allLeadingFrames]);
    var allCallStackFrames = React.useMemo(function () { return error.frames.slice(firstFirstPartyFrameIndex + 1); }, [error.frames, firstFirstPartyFrameIndex]);
    var visibleCallStackFrames = React.useMemo(function () { return allCallStackFrames.filter(function (f) { return f.expanded || all; }); }, [all, allCallStackFrames]);
    var canShowMore = React.useMemo(function () {
        return (allCallStackFrames.length !== visibleCallStackFrames.length ||
            (all && firstFrame != null));
    }, [
        all,
        allCallStackFrames.length,
        firstFrame,
        visibleCallStackFrames.length,
    ]);
    return (React.createElement(React.Fragment, null,
        firstFrame ? (React.createElement(React.Fragment, null,
            React.createElement("h5", null, "Source"),
            leadingFrames.map(function (frame, index) { return (React.createElement(CallStackFrame, { key: "leading-frame-" + index + "-" + all, frame: frame })); }),
            React.createElement(CodeFrame_1.CodeFrame, { stackFrame: firstFrame.originalStackFrame, codeFrame: firstFrame.originalCodeFrame }))) : undefined,
        visibleCallStackFrames.length ? (React.createElement(React.Fragment, null,
            React.createElement("h5", null, "Call Stack"),
            visibleCallStackFrames.map(function (frame, index) { return (React.createElement(CallStackFrame, { key: "call-stack-" + index + "-" + all, frame: frame })); }))) : undefined,
        canShowMore ? (React.createElement(React.Fragment, null,
            React.createElement("button", { tabIndex: 10, "data-nextjs-data-runtime-error-collapsed-action": true, type: "button", onClick: toggleAll },
                all ? 'Hide' : 'Show',
                " collapsed frames"))) : undefined));
};
exports.RuntimeError = RuntimeError;
exports.styles = noop_template_1.noop(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n  button[data-nextjs-data-runtime-error-collapsed-action] {\n    background: none;\n    border: none;\n    padding: 0;\n    font-size: var(--size-font-small);\n    line-height: var(--size-font-bigger);\n    color: var(--color-accents-3);\n  }\n\n  [data-nextjs-call-stack-frame]:not(:last-child) {\n    margin-bottom: var(--size-gap-double);\n  }\n\n  [data-nextjs-call-stack-frame] > h6 {\n    margin-top: 0;\n    margin-bottom: var(--size-gap);\n    font-family: var(--font-stack-monospace);\n    color: #222;\n  }\n  [data-nextjs-call-stack-frame] > h6[data-nextjs-frame-expanded='false'] {\n    color: #666;\n  }\n  [data-nextjs-call-stack-frame] > div {\n    display: flex;\n    align-items: center;\n    padding-left: calc(var(--size-gap) + var(--size-gap-half));\n    font-size: var(--size-font-small);\n    color: #999;\n  }\n  [data-nextjs-call-stack-frame] > div > svg {\n    width: auto;\n    height: var(--size-font-small);\n    margin-left: var(--size-gap);\n\n    display: none;\n  }\n\n  [data-nextjs-call-stack-frame] > div[data-has-source] {\n    cursor: pointer;\n  }\n  [data-nextjs-call-stack-frame] > div[data-has-source]:hover {\n    text-decoration: underline dotted;\n  }\n  [data-nextjs-call-stack-frame] > div[data-has-source] > svg {\n    display: unset;\n  }\n"], ["\n  button[data-nextjs-data-runtime-error-collapsed-action] {\n    background: none;\n    border: none;\n    padding: 0;\n    font-size: var(--size-font-small);\n    line-height: var(--size-font-bigger);\n    color: var(--color-accents-3);\n  }\n\n  [data-nextjs-call-stack-frame]:not(:last-child) {\n    margin-bottom: var(--size-gap-double);\n  }\n\n  [data-nextjs-call-stack-frame] > h6 {\n    margin-top: 0;\n    margin-bottom: var(--size-gap);\n    font-family: var(--font-stack-monospace);\n    color: #222;\n  }\n  [data-nextjs-call-stack-frame] > h6[data-nextjs-frame-expanded='false'] {\n    color: #666;\n  }\n  [data-nextjs-call-stack-frame] > div {\n    display: flex;\n    align-items: center;\n    padding-left: calc(var(--size-gap) + var(--size-gap-half));\n    font-size: var(--size-font-small);\n    color: #999;\n  }\n  [data-nextjs-call-stack-frame] > div > svg {\n    width: auto;\n    height: var(--size-font-small);\n    margin-left: var(--size-gap);\n\n    display: none;\n  }\n\n  [data-nextjs-call-stack-frame] > div[data-has-source] {\n    cursor: pointer;\n  }\n  [data-nextjs-call-stack-frame] > div[data-has-source]:hover {\n    text-decoration: underline dotted;\n  }\n  [data-nextjs-call-stack-frame] > div[data-has-source] > svg {\n    display: unset;\n  }\n"])));
var templateObject_1;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/nodeStackFrames.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/helpers/nodeStackFrames.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
exports.__esModule = true;
var stacktrace_parser_1 = __webpack_require__(/*! stacktrace-parser */ "./node_modules/stacktrace-parser/dist/stack-trace-parser.esm.js");
function getFilesystemFrame(frame) {
    var f = __assign({}, frame);
    if (typeof f.file === 'string') {
        if (
        // Posix:
        f.file.startsWith('/') ||
            // Win32:
            /^[a-z]:\\/i.test(f.file) ||
            // Win32 UNC:
            f.file.startsWith('\\\\')) {
            f.file = "file://" + f.file;
        }
    }
    return f;
}
exports.getFilesystemFrame = getFilesystemFrame;
var symbolNodeError = Symbol('NextjsNodeError');
function isNodeError(error) {
    return symbolNodeError in error;
}
exports.isNodeError = isNodeError;
function getNodeError(error) {
    var n;
    try {
        throw new Error(error.message);
    }
    catch (e) {
        n = e;
    }
    n.name = error.name;
    try {
        n.stack = stacktrace_parser_1.parse(error.stack)
            .map(getFilesystemFrame)
            .map(function (f) {
            var str = "    at " + f.methodName;
            if (f.file) {
                var loc = f.file;
                if (f.lineNumber) {
                    loc += ":" + f.lineNumber;
                    if (f.column) {
                        loc += ":" + f.column;
                    }
                }
                str += " (" + loc + ")";
            }
            return str;
        })
            .join('\n');
    }
    catch (_a) {
        n.stack = error.stack;
    }
    Object.defineProperty(n, symbolNodeError, {
        writable: false,
        enumerable: false,
        configurable: false
    });
    return n;
}
exports.getNodeError = getNodeError;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/noop-template.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/helpers/noop-template.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.__esModule = true;
function noop(strings) {
    var keys = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        keys[_i - 1] = arguments[_i];
    }
    var lastIndex = strings.length - 1;
    return (strings.slice(0, lastIndex).reduce(function (p, s, i) { return p + s + keys[i]; }, '') +
        strings[lastIndex]);
}
exports.noop = noop;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/parseStack.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/helpers/parseStack.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.__esModule = true;
var stacktrace_parser_1 = __webpack_require__(/*! stacktrace-parser */ "./node_modules/stacktrace-parser/dist/stack-trace-parser.esm.js");
var regexNextStatic = /\/_next(\/static\/.+)/g;
function parseStack(stack) {
    var frames = stacktrace_parser_1.parse(stack);
    return frames.map(function (frame) {
        var _a, _b;
        try {
            var url = new URL(frame.file);
            var res = regexNextStatic.exec(url.pathname);
            if (res) {
                var distDir = (_b = (_a = "C:\\Git_defian\\study\\React\\react-nodebird\\prepare\\front\\.next") === null || _a === void 0 ? void 0 : _a.replace(/\\/g, '/')) === null || _b === void 0 ? void 0 : _b.replace(/\/$/, '');
                if (distDir) {
                    frame.file = 'file://' + distDir.concat(res.pop());
                }
            }
        }
        catch (_c) { }
        return frame;
    });
}
exports.parseStack = parseStack;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/stack-frame.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/helpers/stack-frame.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
exports.__esModule = true;
function getOriginalStackFrames(isServerSide, frames) {
    return Promise.all(frames.map(function (frame) { return getOriginalStackFrame(isServerSide, frame); }));
}
exports.getOriginalStackFrames = getOriginalStackFrames;
function getOriginalStackFrame(isServerSide, source) {
    var _a, _b;
    function _getOriginalStackFrame() {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function () {
            var params, key, controller, tm, res, _c, _d, _e, body;
            return __generator(this, function (_f) {
                switch (_f.label) {
                    case 0:
                        params = new URLSearchParams();
                        params.append('isServerSide', String(isServerSide));
                        for (key in source) {
                            params.append(key, ((_a = source[key]) !== null && _a !== void 0 ? _a : '').toString());
                        }
                        controller = new AbortController();
                        tm = setTimeout(function () { return controller.abort(); }, 3000);
                        return [4 /*yield*/, self
                                .fetch("/__nextjs_original-stack-frame?" + params.toString(), {
                                signal: controller.signal
                            })["finally"](function () {
                                clearTimeout(tm);
                            })];
                    case 1:
                        res = _f.sent();
                        if (!(!res.ok || res.status === 204)) return [3 /*break*/, 3];
                        _d = (_c = Promise).reject;
                        _e = Error.bind;
                        return [4 /*yield*/, res.text()];
                    case 2: return [2 /*return*/, _d.apply(_c, [new (_e.apply(Error, [void 0, _f.sent()]))()])];
                    case 3: return [4 /*yield*/, res.json()];
                    case 4:
                        body = _f.sent();
                        return [2 /*return*/, {
                                error: false,
                                reason: null,
                                external: false,
                                expanded: ((_b = body.originalStackFrame) === null || _b === void 0 ? void 0 : _b.file) &&
                                    !body.originalStackFrame.file.includes('node_modules'),
                                sourceStackFrame: source,
                                originalStackFrame: body.originalStackFrame,
                                originalCodeFrame: body.originalCodeFrame || null
                            }];
                }
            });
        });
    }
    if (!(((_a = source.file) === null || _a === void 0 ? void 0 : _a.startsWith('webpack-internal:')) || ((_b = source.file) === null || _b === void 0 ? void 0 : _b.startsWith('file:')))) {
        return Promise.resolve({
            error: false,
            reason: null,
            external: true,
            expanded: false,
            sourceStackFrame: source,
            originalStackFrame: null,
            originalCodeFrame: null
        });
    }
    return _getOriginalStackFrame()["catch"](function (err) {
        var _a, _b;
        return ({
            error: true,
            reason: (_b = (_a = err === null || err === void 0 ? void 0 : err.message) !== null && _a !== void 0 ? _a : err === null || err === void 0 ? void 0 : err.toString()) !== null && _b !== void 0 ? _b : 'Unknown Error',
            external: false,
            expanded: false,
            sourceStackFrame: source,
            originalStackFrame: null,
            originalCodeFrame: null
        });
    });
}
exports.getOriginalStackFrame = getOriginalStackFrame;
function getFrameSource(frame) {
    var _a;
    var str = '';
    try {
        var u = new URL(frame.file);
        // Strip the origin for same-origin scripts.
        if (typeof globalThis !== 'undefined' &&
            ((_a = globalThis.location) === null || _a === void 0 ? void 0 : _a.origin) !== u.origin) {
            // URLs can be valid without an `origin`, so long as they have a
            // `protocol`. However, `origin` is preferred.
            if (u.origin === 'null') {
                str += u.protocol;
            }
            else {
                str += u.origin;
            }
        }
        // Strip query string information as it's typically too verbose to be
        // meaningful.
        str += u.pathname;
        str += ' ';
    }
    catch (_b) {
        str += (frame.file || '(unknown)') + ' ';
    }
    if (frame.lineNumber != null) {
        if (frame.column != null) {
            str += "(" + frame.lineNumber + ":" + frame.column + ") ";
        }
        else {
            str += "(" + frame.lineNumber + ") ";
        }
    }
    return str.slice(0, -1);
}
exports.getFrameSource = getFrameSource;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/hooks/use-on-click-outside.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/hooks/use-on-click-outside.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
exports.__esModule = true;
var React = __importStar(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
function useOnClickOutside(el, handler) {
    React.useEffect(function () {
        if (el == null) {
            return;
        }
        var listener = function (e) {
            // Do nothing if clicking ref's element or descendent elements
            if (!el || el.contains(e.target)) {
                return;
            }
            handler(e);
        };
        var root = el.getRootNode();
        root.addEventListener('mousedown', listener);
        root.addEventListener('touchstart', listener);
        return function () {
            root.removeEventListener('mousedown', listener);
            root.removeEventListener('touchstart', listener);
        };
    }, [handler, el]);
}
exports.useOnClickOutside = useOnClickOutside;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/styles/Base.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/styles/Base.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
exports.__esModule = true;
var React = __importStar(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var noop_template_1 = __webpack_require__(/*! ../helpers/noop-template */ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/noop-template.js");
function Base() {
    return (React.createElement("style", { dangerouslySetInnerHTML: {
            __html: noop_template_1.noop(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n          :host {\n            --size-gap-half: 0.25rem; /* 4px */\n            --size-gap: 0.5rem; /* 8px */\n            --size-gap-double: 1rem; /* 16px */\n            --size-gap-quad: 2rem; /* 32px */\n\n            --size-font-small: 0.875rem; /* 14px */\n            --size-font: 1rem; /* 16px */\n            --size-font-big: 1.25rem; /* 20px */\n            --size-font-bigger: 1.5rem; /* 24px */\n\n            --color-accents-1: #808080;\n            --color-accents-2: #222222;\n            --color-accents-3: #404040;\n\n            --font-stack-monospace: 'SFMono-Regular', Consolas,\n              'Liberation Mono', Menlo, Courier, monospace;\n\n            --color-ansi-selection: rgba(95, 126, 151, 0.48);\n            --color-ansi-bg: #111111;\n            --color-ansi-fg: #cccccc;\n\n            --color-ansi-white: #777777;\n            --color-ansi-black: #141414;\n            --color-ansi-blue: #00aaff;\n            --color-ansi-cyan: #88ddff;\n            --color-ansi-green: #98ec65;\n            --color-ansi-magenta: #aa88ff;\n            --color-ansi-red: #ff5555;\n            --color-ansi-yellow: #ffcc33;\n            --color-ansi-bright-white: #ffffff;\n            --color-ansi-bright-black: #777777;\n            --color-ansi-bright-blue: #33bbff;\n            --color-ansi-bright-cyan: #bbecff;\n            --color-ansi-bright-green: #b6f292;\n            --color-ansi-bright-magenta: #cebbff;\n            --color-ansi-bright-red: #ff8888;\n            --color-ansi-bright-yellow: #ffd966;\n          }\n\n          .mono {\n            font-family: var(--font-stack-monospace);\n          }\n\n          h1,\n          h2,\n          h3,\n          h4,\n          h5,\n          h6 {\n            margin-bottom: var(--size-gap);\n            font-weight: 500;\n            line-height: 1.5;\n          }\n\n          h1 {\n            font-size: 2.5rem;\n          }\n          h2 {\n            font-size: 2rem;\n          }\n          h3 {\n            font-size: 1.75rem;\n          }\n          h4 {\n            font-size: 1.5rem;\n          }\n          h5 {\n            font-size: 1.25rem;\n          }\n          h6 {\n            font-size: 1rem;\n          }\n        "], ["\n          :host {\n            --size-gap-half: 0.25rem; /* 4px */\n            --size-gap: 0.5rem; /* 8px */\n            --size-gap-double: 1rem; /* 16px */\n            --size-gap-quad: 2rem; /* 32px */\n\n            --size-font-small: 0.875rem; /* 14px */\n            --size-font: 1rem; /* 16px */\n            --size-font-big: 1.25rem; /* 20px */\n            --size-font-bigger: 1.5rem; /* 24px */\n\n            --color-accents-1: #808080;\n            --color-accents-2: #222222;\n            --color-accents-3: #404040;\n\n            --font-stack-monospace: 'SFMono-Regular', Consolas,\n              'Liberation Mono', Menlo, Courier, monospace;\n\n            --color-ansi-selection: rgba(95, 126, 151, 0.48);\n            --color-ansi-bg: #111111;\n            --color-ansi-fg: #cccccc;\n\n            --color-ansi-white: #777777;\n            --color-ansi-black: #141414;\n            --color-ansi-blue: #00aaff;\n            --color-ansi-cyan: #88ddff;\n            --color-ansi-green: #98ec65;\n            --color-ansi-magenta: #aa88ff;\n            --color-ansi-red: #ff5555;\n            --color-ansi-yellow: #ffcc33;\n            --color-ansi-bright-white: #ffffff;\n            --color-ansi-bright-black: #777777;\n            --color-ansi-bright-blue: #33bbff;\n            --color-ansi-bright-cyan: #bbecff;\n            --color-ansi-bright-green: #b6f292;\n            --color-ansi-bright-magenta: #cebbff;\n            --color-ansi-bright-red: #ff8888;\n            --color-ansi-bright-yellow: #ffd966;\n          }\n\n          .mono {\n            font-family: var(--font-stack-monospace);\n          }\n\n          h1,\n          h2,\n          h3,\n          h4,\n          h5,\n          h6 {\n            margin-bottom: var(--size-gap);\n            font-weight: 500;\n            line-height: 1.5;\n          }\n\n          h1 {\n            font-size: 2.5rem;\n          }\n          h2 {\n            font-size: 2rem;\n          }\n          h3 {\n            font-size: 1.75rem;\n          }\n          h4 {\n            font-size: 1.5rem;\n          }\n          h5 {\n            font-size: 1.25rem;\n          }\n          h6 {\n            font-size: 1rem;\n          }\n        "])))
        } }));
}
exports.Base = Base;
var templateObject_1;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/styles/ComponentStyles.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/styles/ComponentStyles.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
exports.__esModule = true;
var React = __importStar(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var styles_1 = __webpack_require__(/*! ../components/CodeFrame/styles */ "./node_modules/@next/react-dev-overlay/lib/internal/components/CodeFrame/styles.js");
var Dialog_1 = __webpack_require__(/*! ../components/Dialog */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/index.js");
var styles_2 = __webpack_require__(/*! ../components/LeftRightDialogHeader/styles */ "./node_modules/@next/react-dev-overlay/lib/internal/components/LeftRightDialogHeader/styles.js");
var styles_3 = __webpack_require__(/*! ../components/Overlay/styles */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Overlay/styles.js");
var styles_4 = __webpack_require__(/*! ../components/Terminal/styles */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Terminal/styles.js");
var Toast_1 = __webpack_require__(/*! ../components/Toast */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Toast/index.js");
var BuildError_1 = __webpack_require__(/*! ../container/BuildError */ "./node_modules/@next/react-dev-overlay/lib/internal/container/BuildError.js");
var Errors_1 = __webpack_require__(/*! ../container/Errors */ "./node_modules/@next/react-dev-overlay/lib/internal/container/Errors.js");
var RuntimeError_1 = __webpack_require__(/*! ../container/RuntimeError */ "./node_modules/@next/react-dev-overlay/lib/internal/container/RuntimeError.js");
var noop_template_1 = __webpack_require__(/*! ../helpers/noop-template */ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/noop-template.js");
function ComponentStyles() {
    return (React.createElement("style", { dangerouslySetInnerHTML: {
            __html: noop_template_1.noop(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n          ", "\n          ", "\n          ", "\n          ", "\n          ", "\n          ", "\n\n          ", "\n          ", "\n          ", "\n        "], ["\n          ", "\n          ", "\n          ", "\n          ", "\n          ", "\n          ", "\n\n          ", "\n          ", "\n          ", "\n        "])), styles_3.styles, Toast_1.styles, Dialog_1.styles, styles_2.styles, styles_1.styles, styles_4.styles, BuildError_1.styles, Errors_1.styles, RuntimeError_1.styles)
        } }));
}
exports.ComponentStyles = ComponentStyles;
var templateObject_1;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/styles/CssReset.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/styles/CssReset.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
exports.__esModule = true;
var React = __importStar(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var noop_template_1 = __webpack_require__(/*! ../helpers/noop-template */ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/noop-template.js");
function CssReset() {
    return (React.createElement("style", { dangerouslySetInnerHTML: {
            __html: noop_template_1.noop(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n          :host {\n            all: initial;\n\n            /* the direction property is not reset by 'all' */\n            direction: ltr;\n          }\n\n          /*!\n           * Bootstrap Reboot v4.4.1 (https://getbootstrap.com/)\n           * Copyright 2011-2019 The Bootstrap Authors\n           * Copyright 2011-2019 Twitter, Inc.\n           * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n           * Forked from Normalize.css, licensed MIT (https://github.com/necolas/normalize.css/blob/master/LICENSE.md)\n           */\n          *,\n          *::before,\n          *::after {\n            box-sizing: border-box;\n          }\n\n          :host {\n            font-family: sans-serif;\n            line-height: 1.15;\n            -webkit-text-size-adjust: 100%;\n            -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n          }\n\n          article,\n          aside,\n          figcaption,\n          figure,\n          footer,\n          header,\n          hgroup,\n          main,\n          nav,\n          section {\n            display: block;\n          }\n\n          :host {\n            margin: 0;\n            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto,\n              'Helvetica Neue', Arial, 'Noto Sans', sans-serif,\n              'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol',\n              'Noto Color Emoji';\n            font-size: 1rem;\n            font-weight: 400;\n            line-height: 1.5;\n            color: #212529;\n            text-align: left;\n            background-color: #fff;\n          }\n\n          [tabindex='-1']:focus:not(:focus-visible) {\n            outline: 0 !important;\n          }\n\n          hr {\n            box-sizing: content-box;\n            height: 0;\n            overflow: visible;\n          }\n\n          h1,\n          h2,\n          h3,\n          h4,\n          h5,\n          h6 {\n            margin-top: 0;\n            margin-bottom: 0.5rem;\n          }\n\n          p {\n            margin-top: 0;\n            margin-bottom: 1rem;\n          }\n\n          abbr[title],\n          abbr[data-original-title] {\n            text-decoration: underline;\n            -webkit-text-decoration: underline dotted;\n            text-decoration: underline dotted;\n            cursor: help;\n            border-bottom: 0;\n            -webkit-text-decoration-skip-ink: none;\n            text-decoration-skip-ink: none;\n          }\n\n          address {\n            margin-bottom: 1rem;\n            font-style: normal;\n            line-height: inherit;\n          }\n\n          ol,\n          ul,\n          dl {\n            margin-top: 0;\n            margin-bottom: 1rem;\n          }\n\n          ol ol,\n          ul ul,\n          ol ul,\n          ul ol {\n            margin-bottom: 0;\n          }\n\n          dt {\n            font-weight: 700;\n          }\n\n          dd {\n            margin-bottom: 0.5rem;\n            margin-left: 0;\n          }\n\n          blockquote {\n            margin: 0 0 1rem;\n          }\n\n          b,\n          strong {\n            font-weight: bolder;\n          }\n\n          small {\n            font-size: 80%;\n          }\n\n          sub,\n          sup {\n            position: relative;\n            font-size: 75%;\n            line-height: 0;\n            vertical-align: baseline;\n          }\n\n          sub {\n            bottom: -0.25em;\n          }\n\n          sup {\n            top: -0.5em;\n          }\n\n          a {\n            color: #007bff;\n            text-decoration: none;\n            background-color: transparent;\n          }\n\n          a:hover {\n            color: #0056b3;\n            text-decoration: underline;\n          }\n\n          a:not([href]) {\n            color: inherit;\n            text-decoration: none;\n          }\n\n          a:not([href]):hover {\n            color: inherit;\n            text-decoration: none;\n          }\n\n          pre,\n          code,\n          kbd,\n          samp {\n            font-family: SFMono-Regular, Menlo, Monaco, Consolas,\n              'Liberation Mono', 'Courier New', monospace;\n            font-size: 1em;\n          }\n\n          pre {\n            margin-top: 0;\n            margin-bottom: 1rem;\n            overflow: auto;\n          }\n\n          figure {\n            margin: 0 0 1rem;\n          }\n\n          img {\n            vertical-align: middle;\n            border-style: none;\n          }\n\n          svg {\n            overflow: hidden;\n            vertical-align: middle;\n          }\n\n          table {\n            border-collapse: collapse;\n          }\n\n          caption {\n            padding-top: 0.75rem;\n            padding-bottom: 0.75rem;\n            color: #6c757d;\n            text-align: left;\n            caption-side: bottom;\n          }\n\n          th {\n            text-align: inherit;\n          }\n\n          label {\n            display: inline-block;\n            margin-bottom: 0.5rem;\n          }\n\n          button {\n            border-radius: 0;\n          }\n\n          button:focus {\n            outline: 1px dotted;\n            outline: 5px auto -webkit-focus-ring-color;\n          }\n\n          input,\n          button,\n          select,\n          optgroup,\n          textarea {\n            margin: 0;\n            font-family: inherit;\n            font-size: inherit;\n            line-height: inherit;\n          }\n\n          button,\n          input {\n            overflow: visible;\n          }\n\n          button,\n          select {\n            text-transform: none;\n          }\n\n          select {\n            word-wrap: normal;\n          }\n\n          button,\n          [type='button'],\n          [type='reset'],\n          [type='submit'] {\n            -webkit-appearance: button;\n          }\n\n          button:not(:disabled),\n          [type='button']:not(:disabled),\n          [type='reset']:not(:disabled),\n          [type='submit']:not(:disabled) {\n            cursor: pointer;\n          }\n\n          button::-moz-focus-inner,\n          [type='button']::-moz-focus-inner,\n          [type='reset']::-moz-focus-inner,\n          [type='submit']::-moz-focus-inner {\n            padding: 0;\n            border-style: none;\n          }\n\n          input[type='radio'],\n          input[type='checkbox'] {\n            box-sizing: border-box;\n            padding: 0;\n          }\n\n          input[type='date'],\n          input[type='time'],\n          input[type='datetime-local'],\n          input[type='month'] {\n            -webkit-appearance: listbox;\n          }\n\n          textarea {\n            overflow: auto;\n            resize: vertical;\n          }\n\n          fieldset {\n            min-width: 0;\n            padding: 0;\n            margin: 0;\n            border: 0;\n          }\n\n          legend {\n            display: block;\n            width: 100%;\n            max-width: 100%;\n            padding: 0;\n            margin-bottom: 0.5rem;\n            font-size: 1.5rem;\n            line-height: inherit;\n            color: inherit;\n            white-space: normal;\n          }\n\n          progress {\n            vertical-align: baseline;\n          }\n\n          [type='number']::-webkit-inner-spin-button,\n          [type='number']::-webkit-outer-spin-button {\n            height: auto;\n          }\n\n          [type='search'] {\n            outline-offset: -2px;\n            -webkit-appearance: none;\n          }\n\n          [type='search']::-webkit-search-decoration {\n            -webkit-appearance: none;\n          }\n\n          ::-webkit-file-upload-button {\n            font: inherit;\n            -webkit-appearance: button;\n          }\n\n          output {\n            display: inline-block;\n          }\n\n          summary {\n            display: list-item;\n            cursor: pointer;\n          }\n\n          template {\n            display: none;\n          }\n\n          [hidden] {\n            display: none !important;\n          }\n        "], ["\n          :host {\n            all: initial;\n\n            /* the direction property is not reset by 'all' */\n            direction: ltr;\n          }\n\n          /*!\n           * Bootstrap Reboot v4.4.1 (https://getbootstrap.com/)\n           * Copyright 2011-2019 The Bootstrap Authors\n           * Copyright 2011-2019 Twitter, Inc.\n           * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n           * Forked from Normalize.css, licensed MIT (https://github.com/necolas/normalize.css/blob/master/LICENSE.md)\n           */\n          *,\n          *::before,\n          *::after {\n            box-sizing: border-box;\n          }\n\n          :host {\n            font-family: sans-serif;\n            line-height: 1.15;\n            -webkit-text-size-adjust: 100%;\n            -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n          }\n\n          article,\n          aside,\n          figcaption,\n          figure,\n          footer,\n          header,\n          hgroup,\n          main,\n          nav,\n          section {\n            display: block;\n          }\n\n          :host {\n            margin: 0;\n            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto,\n              'Helvetica Neue', Arial, 'Noto Sans', sans-serif,\n              'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol',\n              'Noto Color Emoji';\n            font-size: 1rem;\n            font-weight: 400;\n            line-height: 1.5;\n            color: #212529;\n            text-align: left;\n            background-color: #fff;\n          }\n\n          [tabindex='-1']:focus:not(:focus-visible) {\n            outline: 0 !important;\n          }\n\n          hr {\n            box-sizing: content-box;\n            height: 0;\n            overflow: visible;\n          }\n\n          h1,\n          h2,\n          h3,\n          h4,\n          h5,\n          h6 {\n            margin-top: 0;\n            margin-bottom: 0.5rem;\n          }\n\n          p {\n            margin-top: 0;\n            margin-bottom: 1rem;\n          }\n\n          abbr[title],\n          abbr[data-original-title] {\n            text-decoration: underline;\n            -webkit-text-decoration: underline dotted;\n            text-decoration: underline dotted;\n            cursor: help;\n            border-bottom: 0;\n            -webkit-text-decoration-skip-ink: none;\n            text-decoration-skip-ink: none;\n          }\n\n          address {\n            margin-bottom: 1rem;\n            font-style: normal;\n            line-height: inherit;\n          }\n\n          ol,\n          ul,\n          dl {\n            margin-top: 0;\n            margin-bottom: 1rem;\n          }\n\n          ol ol,\n          ul ul,\n          ol ul,\n          ul ol {\n            margin-bottom: 0;\n          }\n\n          dt {\n            font-weight: 700;\n          }\n\n          dd {\n            margin-bottom: 0.5rem;\n            margin-left: 0;\n          }\n\n          blockquote {\n            margin: 0 0 1rem;\n          }\n\n          b,\n          strong {\n            font-weight: bolder;\n          }\n\n          small {\n            font-size: 80%;\n          }\n\n          sub,\n          sup {\n            position: relative;\n            font-size: 75%;\n            line-height: 0;\n            vertical-align: baseline;\n          }\n\n          sub {\n            bottom: -0.25em;\n          }\n\n          sup {\n            top: -0.5em;\n          }\n\n          a {\n            color: #007bff;\n            text-decoration: none;\n            background-color: transparent;\n          }\n\n          a:hover {\n            color: #0056b3;\n            text-decoration: underline;\n          }\n\n          a:not([href]) {\n            color: inherit;\n            text-decoration: none;\n          }\n\n          a:not([href]):hover {\n            color: inherit;\n            text-decoration: none;\n          }\n\n          pre,\n          code,\n          kbd,\n          samp {\n            font-family: SFMono-Regular, Menlo, Monaco, Consolas,\n              'Liberation Mono', 'Courier New', monospace;\n            font-size: 1em;\n          }\n\n          pre {\n            margin-top: 0;\n            margin-bottom: 1rem;\n            overflow: auto;\n          }\n\n          figure {\n            margin: 0 0 1rem;\n          }\n\n          img {\n            vertical-align: middle;\n            border-style: none;\n          }\n\n          svg {\n            overflow: hidden;\n            vertical-align: middle;\n          }\n\n          table {\n            border-collapse: collapse;\n          }\n\n          caption {\n            padding-top: 0.75rem;\n            padding-bottom: 0.75rem;\n            color: #6c757d;\n            text-align: left;\n            caption-side: bottom;\n          }\n\n          th {\n            text-align: inherit;\n          }\n\n          label {\n            display: inline-block;\n            margin-bottom: 0.5rem;\n          }\n\n          button {\n            border-radius: 0;\n          }\n\n          button:focus {\n            outline: 1px dotted;\n            outline: 5px auto -webkit-focus-ring-color;\n          }\n\n          input,\n          button,\n          select,\n          optgroup,\n          textarea {\n            margin: 0;\n            font-family: inherit;\n            font-size: inherit;\n            line-height: inherit;\n          }\n\n          button,\n          input {\n            overflow: visible;\n          }\n\n          button,\n          select {\n            text-transform: none;\n          }\n\n          select {\n            word-wrap: normal;\n          }\n\n          button,\n          [type='button'],\n          [type='reset'],\n          [type='submit'] {\n            -webkit-appearance: button;\n          }\n\n          button:not(:disabled),\n          [type='button']:not(:disabled),\n          [type='reset']:not(:disabled),\n          [type='submit']:not(:disabled) {\n            cursor: pointer;\n          }\n\n          button::-moz-focus-inner,\n          [type='button']::-moz-focus-inner,\n          [type='reset']::-moz-focus-inner,\n          [type='submit']::-moz-focus-inner {\n            padding: 0;\n            border-style: none;\n          }\n\n          input[type='radio'],\n          input[type='checkbox'] {\n            box-sizing: border-box;\n            padding: 0;\n          }\n\n          input[type='date'],\n          input[type='time'],\n          input[type='datetime-local'],\n          input[type='month'] {\n            -webkit-appearance: listbox;\n          }\n\n          textarea {\n            overflow: auto;\n            resize: vertical;\n          }\n\n          fieldset {\n            min-width: 0;\n            padding: 0;\n            margin: 0;\n            border: 0;\n          }\n\n          legend {\n            display: block;\n            width: 100%;\n            max-width: 100%;\n            padding: 0;\n            margin-bottom: 0.5rem;\n            font-size: 1.5rem;\n            line-height: inherit;\n            color: inherit;\n            white-space: normal;\n          }\n\n          progress {\n            vertical-align: baseline;\n          }\n\n          [type='number']::-webkit-inner-spin-button,\n          [type='number']::-webkit-outer-spin-button {\n            height: auto;\n          }\n\n          [type='search'] {\n            outline-offset: -2px;\n            -webkit-appearance: none;\n          }\n\n          [type='search']::-webkit-search-decoration {\n            -webkit-appearance: none;\n          }\n\n          ::-webkit-file-upload-button {\n            font: inherit;\n            -webkit-appearance: button;\n          }\n\n          output {\n            display: inline-block;\n          }\n\n          summary {\n            display: list-item;\n            cursor: pointer;\n          }\n\n          template {\n            display: none;\n          }\n\n          [hidden] {\n            display: none !important;\n          }\n        "])))
        } }));
}
exports.CssReset = CssReset;
var templateObject_1;


/***/ }),

/***/ "./node_modules/ally.js/element/disabled.js":
/*!**************************************************!*\
  !*** ./node_modules/ally.js/element/disabled.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (context, disabledState) {
  if (!supports) {
    supports = (0, _supports3.default)();
  }

  var element = (0, _contextToElement2.default)({
    label: 'element/disabled',
    context: context
  });

  // accept truthy/falsy values
  disabledState = Boolean(disabledState);
  var currentState = element.hasAttribute('data-ally-disabled');
  // if there's no value to set, we're running as a getter
  var runningAsGetter = arguments.length === 1;

  if ((0, _nativeDisabledSupported2.default)(element)) {
    if (runningAsGetter) {
      return element.disabled;
    }

    // form elements know the disabled attribute, which we shall use instead of our poor man's copy of it
    element.disabled = disabledState;
    return element;
  }

  if (runningAsGetter) {
    return currentState;
  }

  if (currentState === disabledState) {
    // no update necessary
    return element;
  }

  setElementDisabled(element, disabledState);
  return element;
};

var _contextToElement = __webpack_require__(/*! ../util/context-to-element */ "./node_modules/ally.js/util/context-to-element.js");

var _contextToElement2 = _interopRequireDefault(_contextToElement);

var _tabindexValue = __webpack_require__(/*! ../util/tabindex-value */ "./node_modules/ally.js/util/tabindex-value.js");

var _tabindexValue2 = _interopRequireDefault(_tabindexValue);

var _nativeDisabledSupported = __webpack_require__(/*! ../is/native-disabled-supported */ "./node_modules/ally.js/is/native-disabled-supported.js");

var _nativeDisabledSupported2 = _interopRequireDefault(_nativeDisabledSupported);

var _toggleAttribute = __webpack_require__(/*! ../util/toggle-attribute */ "./node_modules/ally.js/util/toggle-attribute.js");

var _toggleAttribute2 = _interopRequireDefault(_toggleAttribute);

var _toggleAttributeValue = __webpack_require__(/*! ../util/toggle-attribute-value */ "./node_modules/ally.js/util/toggle-attribute-value.js");

var _toggleAttributeValue2 = _interopRequireDefault(_toggleAttributeValue);

var _logger = __webpack_require__(/*! ../util/logger */ "./node_modules/ally.js/util/logger.js");

var _logger2 = _interopRequireDefault(_logger);

var _supports2 = __webpack_require__(/*! ../supports/supports */ "./node_modules/ally.js/supports/supports.js");

var _supports3 = _interopRequireDefault(_supports2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var supports = void 0;
/*
  Utility to make any element inert (disabled). Inert means the elements cannot be interacted
  with and they cannot be focused via script, pointer or keyboard - and thus not receive focus.

  Elements made inert (disabled) by this utility are given the attribute [data-ally-disabled="true"].

  ---------------

  inert attribute was [removed](https://html5.org/r/8536) [tweet by steve](https://twitter.com/stevefaulkner/status/443075900201259008)
  but definition of [inert subtrees](https://www.w3.org/html/wg/drafts/html/master/editing.html#inert-subtrees) remains.

  [implementation idea by Vasilis](https://codepen.io/vasilisvg/pen/scowI)
  [inert attribute polyfill by GoogleChrome](https://github.com/GoogleChrome/inert-polyfill)

  [Gecko Bug: Inert Attribute](https://bugzilla.mozilla.org/show_bug.cgi?id=921504)
  [Chromium Bug: Inert Attribute](https://code.google.com/p/chromium/issues/detail?id=269846)
  [Chromium Bug: Inert Subtree](https://code.google.com/p/chromium/issues/detail?id=241699)
  [WebKit Bug: Inert Subtree](https://bugs.webkit.org/show_bug.cgi?id=110952)
*/

function disabledFocus() {
  _logger2.default.warn('trying to focus inert element', this);
}

function disableTabindex(element, disabledState) {
  if (disabledState) {
    var tabIndex = (0, _tabindexValue2.default)(element);
    (0, _toggleAttributeValue2.default)({
      element: element,
      attribute: 'tabindex',
      temporaryValue: '-1',
      saveValue: tabIndex !== null ? tabIndex : ''
    });
  } else {
    (0, _toggleAttributeValue2.default)({
      element: element,
      attribute: 'tabindex'
    });
  }
}

function disableVideoControls(element, disabledState) {
  (0, _toggleAttribute2.default)({
    element: element,
    attribute: 'controls',
    remove: disabledState
  });
}

function disableSvgFocusable(element, disabledState) {
  (0, _toggleAttributeValue2.default)({
    element: element,
    attribute: 'focusable',
    temporaryValue: disabledState ? 'false' : undefined
  });
}

function disableSvgLink(element, disabledState) {
  (0, _toggleAttribute2.default)({
    element: element,
    attribute: 'xlink:href',
    remove: disabledState
  });
}

function setAriaDisabled(element, disabledState) {
  (0, _toggleAttributeValue2.default)({
    element: element,
    attribute: 'aria-disabled',
    temporaryValue: disabledState ? 'true' : undefined
  });
}

function disableScriptFocus(element, disabledState) {
  if (disabledState) {
    // make sure no script can focus the element
    element.focus = disabledFocus;
  } else {
    // restore original focus function from prototype
    delete element.focus;
  }
}

function disablePointerEvents(element, disabledState) {
  if (disabledState) {
    // remember previous pointer events status so we can restore it
    var pointerEvents = element.style.pointerEvents || '';
    element.setAttribute('data-inert-pointer-events', pointerEvents);
    // make sure no pointer interaction can access the element
    element.style.pointerEvents = 'none';
  } else {
    // restore to previous pointer interaction status
    var _pointerEvents = element.getAttribute('data-inert-pointer-events');
    element.removeAttribute('data-inert-pointer-events');
    element.style.pointerEvents = _pointerEvents;
  }
}

function setElementDisabled(element, disabledState) {
  setAriaDisabled(element, disabledState);
  disableTabindex(element, disabledState);
  disableScriptFocus(element, disabledState);
  disablePointerEvents(element, disabledState);

  var nodeName = element.nodeName.toLowerCase();
  if (nodeName === 'video' || nodeName === 'audio') {
    // Blink and Gecko leave <video controls tabindex="-1"> in document focus navigation sequence
    // Blink leaves <audio controls tabindex="-1"> in document focus navigation sequence
    disableVideoControls(element, disabledState);
  }

  if (nodeName === 'svg' || element.ownerSVGElement) {
    if (supports.focusSvgFocusableAttribute) {
      // Internet Explorer knows focusable="false" instead of tabindex="-1"
      disableSvgFocusable(element, disabledState);
    } else if (!supports.focusSvgTabindexAttribute && nodeName === 'a') {
      // Firefox neither knows focusable="false" nor tabindex="-1"
      disableSvgLink(element, disabledState);
    }
  }

  if (disabledState) {
    element.setAttribute('data-ally-disabled', 'true');
  } else {
    element.removeAttribute('data-ally-disabled');
  }
}

module.exports = exports['default'];
//# sourceMappingURL=disabled.js.map

/***/ }),

/***/ "./node_modules/ally.js/element/focus.svg-foreign-object-hack.js":
/*!***********************************************************************!*\
  !*** ./node_modules/ally.js/element/focus.svg-foreign-object-hack.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (element) {
  // Edge13, Edge14: foreignObject focus hack
  // https://jsbin.com/kunehinugi/edit?html,js,output
  // https://jsbin.com/fajagi/3/edit?html,js,output
  var isSvgElement = element.ownerSVGElement || element.nodeName.toLowerCase() === 'svg';
  if (!isSvgElement) {
    return false;
  }

  // inject and focus an <input> element into the SVG element to receive focus
  var foreignObject = makeFocusableForeignObject();
  element.appendChild(foreignObject);
  var input = foreignObject.querySelector('input');
  input.focus();

  // upon disabling the activeElement, IE and Edge
  // will not shift focus to <body> like all the other
  // browsers, but instead find the first focusable
  // ancestor and shift focus to that
  input.disabled = true;

  // clean up
  element.removeChild(foreignObject);
  return true;
};

function makeFocusableForeignObject() {
  var fragment = document.createElement('div');
  fragment.innerHTML = '<svg><foreignObject width="30" height="30">\n      <input type="text"/>\n  </foreignObject></svg>';

  return fragment.firstChild.firstChild;
}

module.exports = exports['default'];
//# sourceMappingURL=focus.svg-foreign-object-hack.js.map

/***/ }),

/***/ "./node_modules/ally.js/get/parents.js":
/*!*********************************************!*\
  !*** ./node_modules/ally.js/get/parents.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function () {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      context = _ref.context;

  var list = [];
  var element = (0, _contextToElement2.default)({
    label: 'get/parents',
    context: context
  });

  while (element) {
    list.push(element);
    // IE does know support parentElement on SVGElement
    element = element.parentNode;
    if (element && element.nodeType !== Node.ELEMENT_NODE) {
      element = null;
    }
  }

  return list;
};

var _contextToElement = __webpack_require__(/*! ../util/context-to-element */ "./node_modules/ally.js/util/context-to-element.js");

var _contextToElement2 = _interopRequireDefault(_contextToElement);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

module.exports = exports['default'];

// [elem, elem.parent, elem.parent.parent, , html]
// will not contain the shadowRoot (DOCUMENT_FRAGMENT_NODE) and shadowHost
//# sourceMappingURL=parents.js.map

/***/ }),

/***/ "./node_modules/ally.js/get/shadow-host.js":
/*!*************************************************!*\
  !*** ./node_modules/ally.js/get/shadow-host.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function () {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      context = _ref.context;

  var element = (0, _contextToElement2.default)({
    label: 'get/shadow-host',
    context: context
  });

  // walk up to the root
  var container = null;

  while (element) {
    container = element;
    element = element.parentNode;
  }

  // https://developer.mozilla.org/en-US/docs/Web/API/Node.nodeType
  // NOTE: Firefox 34 does not expose ShadowRoot.host (but 37 does)
  if (container.nodeType === container.DOCUMENT_FRAGMENT_NODE && container.host) {
    // the root is attached to a fragment node that has a host
    return container.host;
  }

  return null;
};

var _contextToElement = __webpack_require__(/*! ../util/context-to-element */ "./node_modules/ally.js/util/context-to-element.js");

var _contextToElement2 = _interopRequireDefault(_contextToElement);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

module.exports = exports['default'];
//# sourceMappingURL=shadow-host.js.map

/***/ }),

/***/ "./node_modules/ally.js/is/active-element.js":
/*!***************************************************!*\
  !*** ./node_modules/ally.js/is/active-element.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (context) {
  var element = (0, _contextToElement2.default)({
    label: 'is/active-element',
    resolveDocument: true,
    context: context
  });

  var _document = (0, _getDocument2.default)(element);
  if (_document.activeElement === element) {
    return true;
  }

  var shadowHost = (0, _shadowHost2.default)({ context: element });
  if (shadowHost && shadowHost.shadowRoot.activeElement === element) {
    return true;
  }

  return false;
};

var _contextToElement = __webpack_require__(/*! ../util/context-to-element */ "./node_modules/ally.js/util/context-to-element.js");

var _contextToElement2 = _interopRequireDefault(_contextToElement);

var _shadowHost = __webpack_require__(/*! ../get/shadow-host */ "./node_modules/ally.js/get/shadow-host.js");

var _shadowHost2 = _interopRequireDefault(_shadowHost);

var _getDocument = __webpack_require__(/*! ../util/get-document */ "./node_modules/ally.js/util/get-document.js");

var _getDocument2 = _interopRequireDefault(_getDocument);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Determines if an element is the activeElement within its context, i.e. its document iFrame or ShadowHost

module.exports = exports['default'];
//# sourceMappingURL=active-element.js.map

/***/ }),

/***/ "./node_modules/ally.js/is/disabled.js":
/*!*********************************************!*\
  !*** ./node_modules/ally.js/is/disabled.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (context) {
  if (!supports) {
    supports = (0, _supports3.default)();
  }

  var element = (0, _contextToElement2.default)({
    label: 'is/disabled',
    context: context
  });

  if (element.hasAttribute('data-ally-disabled')) {
    // treat ally's element/disabled like the DOM native element.disabled
    return true;
  }

  if (!(0, _nativeDisabledSupported2.default)(element)) {
    // non-form elements do not support the disabled attribute
    return false;
  }

  if (element.disabled) {
    // the element itself is disabled
    return true;
  }

  var parents = (0, _parents2.default)({ context: element });
  if (parents.some(isDisabledFieldset)) {
    // a parental <fieldset> is disabld and inherits the state onto this element
    return true;
  }

  if (!supports.focusFormDisabled && parents.some(isDisabledForm)) {
    // a parental <form> is disabld and inherits the state onto this element
    return true;
  }

  return false;
};

var _contextToElement = __webpack_require__(/*! ../util/context-to-element */ "./node_modules/ally.js/util/context-to-element.js");

var _contextToElement2 = _interopRequireDefault(_contextToElement);

var _parents = __webpack_require__(/*! ../get/parents */ "./node_modules/ally.js/get/parents.js");

var _parents2 = _interopRequireDefault(_parents);

var _nativeDisabledSupported = __webpack_require__(/*! ./native-disabled-supported */ "./node_modules/ally.js/is/native-disabled-supported.js");

var _nativeDisabledSupported2 = _interopRequireDefault(_nativeDisabledSupported);

var _supports2 = __webpack_require__(/*! ../supports/supports */ "./node_modules/ally.js/supports/supports.js");

var _supports3 = _interopRequireDefault(_supports2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Determine if an element is disabled (i.e. not editable)

var supports = void 0;

function isDisabledFieldset(element) {
  var nodeName = element.nodeName.toLowerCase();
  return nodeName === 'fieldset' && element.disabled;
}

function isDisabledForm(element) {
  var nodeName = element.nodeName.toLowerCase();
  return nodeName === 'form' && element.disabled;
}

module.exports = exports['default'];
//# sourceMappingURL=disabled.js.map

/***/ }),

/***/ "./node_modules/ally.js/is/focus-relevant.js":
/*!***************************************************!*\
  !*** ./node_modules/ally.js/is/focus-relevant.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _parents = __webpack_require__(/*! ../get/parents */ "./node_modules/ally.js/get/parents.js");

var _parents2 = _interopRequireDefault(_parents);

var _contextToElement = __webpack_require__(/*! ../util/context-to-element */ "./node_modules/ally.js/util/context-to-element.js");

var _contextToElement2 = _interopRequireDefault(_contextToElement);

var _elementMatches = __webpack_require__(/*! ../util/element-matches */ "./node_modules/ally.js/util/element-matches.js");

var _elementMatches2 = _interopRequireDefault(_elementMatches);

var _tabindexValue = __webpack_require__(/*! ../util/tabindex-value */ "./node_modules/ally.js/util/tabindex-value.js");

var _tabindexValue2 = _interopRequireDefault(_tabindexValue);

var _validTabindex = __webpack_require__(/*! ./valid-tabindex */ "./node_modules/ally.js/is/valid-tabindex.js");

var _validTabindex2 = _interopRequireDefault(_validTabindex);

var _is = __webpack_require__(/*! ./is.util */ "./node_modules/ally.js/is/is.util.js");

var _supports2 = __webpack_require__(/*! ../supports/supports */ "./node_modules/ally.js/supports/supports.js");

var _supports3 = _interopRequireDefault(_supports2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var supports = void 0;
// determine if an element supports.can be focused by script regardless
// of the element actually being focusable at the time of execution
// i.e. <input disabled> is conisdered focus-relevant, but not focusable

function isFocusRelevantRules() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      context = _ref.context,
      _ref$except = _ref.except,
      except = _ref$except === undefined ? {
    flexbox: false,
    scrollable: false,
    shadow: false
  } : _ref$except;

  if (!supports) {
    supports = (0, _supports3.default)();
  }

  var element = (0, _contextToElement2.default)({
    label: 'is/focus-relevant',
    resolveDocument: true,
    context: context
  });

  if (!except.shadow && element.shadowRoot) {
    // a ShadowDOM host receives focus when the focus moves to its content
    return true;
  }

  var nodeName = element.nodeName.toLowerCase();

  if (nodeName === 'input' && element.type === 'hidden') {
    // input[type="hidden"] supports.cannot be focused
    return false;
  }

  if (nodeName === 'input' || nodeName === 'select' || nodeName === 'button' || nodeName === 'textarea') {
    return true;
  }

  if (nodeName === 'legend' && supports.focusRedirectLegend) {
    // specifics filtered in is/focusable
    return true;
  }

  if (nodeName === 'label') {
    // specifics filtered in is/focusable
    return true;
  }

  if (nodeName === 'area') {
    // specifics filtered in is/focusable
    return true;
  }

  if (nodeName === 'a' && element.hasAttribute('href')) {
    return true;
  }

  if (nodeName === 'object' && element.hasAttribute('usemap')) {
    // object[usemap] is not focusable in any browser
    return false;
  }

  if (nodeName === 'object') {
    var svgType = element.getAttribute('type');
    if (!supports.focusObjectSvg && svgType === 'image/svg+xml') {
      // object[type="image/svg+xml"] is not focusable in Internet Explorer
      return false;
    } else if (!supports.focusObjectSwf && svgType === 'application/x-shockwave-flash') {
      // object[type="application/x-shockwave-flash"] is not focusable in Internet Explorer 9
      return false;
    }
  }

  if (nodeName === 'iframe' || nodeName === 'object') {
    // browsing context containers
    return true;
  }

  if (nodeName === 'embed' || nodeName === 'keygen') {
    // embed is considered focus-relevant but not focusable
    // see https://github.com/medialize/ally.js/issues/82
    return true;
  }

  if (element.hasAttribute('contenteditable')) {
    // also see CSS property user-modify below
    return true;
  }

  if (nodeName === 'audio' && (supports.focusAudioWithoutControls || element.hasAttribute('controls'))) {
    return true;
  }

  if (nodeName === 'video' && (supports.focusVideoWithoutControls || element.hasAttribute('controls'))) {
    return true;
  }

  if (supports.focusSummary && nodeName === 'summary') {
    return true;
  }

  var validTabindex = (0, _validTabindex2.default)(element);

  if (nodeName === 'img' && element.hasAttribute('usemap')) {
    // Gecko, Trident and Edge do not allow an image with an image map and tabindex to be focused,
    // it appears the tabindex is overruled so focus is still forwarded to the <map>
    return validTabindex && supports.focusImgUsemapTabindex || supports.focusRedirectImgUsemap;
  }

  if (supports.focusTable && (nodeName === 'table' || nodeName === 'td')) {
    // IE10-11 supports.can focus <table> and <td>
    return true;
  }

  if (supports.focusFieldset && nodeName === 'fieldset') {
    // IE10-11 supports.can focus <fieldset>
    return true;
  }

  var isSvgElement = nodeName === 'svg';
  var isSvgContent = element.ownerSVGElement;
  var focusableAttribute = element.getAttribute('focusable');
  var tabindex = (0, _tabindexValue2.default)(element);

  if (nodeName === 'use' && tabindex !== null && !supports.focusSvgUseTabindex) {
    // <use> cannot be made focusable by adding a tabindex attribute anywhere but Blink and WebKit
    return false;
  }

  if (nodeName === 'foreignobject') {
    // <use> can only be made focusable in Blink and WebKit
    return tabindex !== null && supports.focusSvgForeignobjectTabindex;
  }

  if ((0, _elementMatches2.default)(element, 'svg a') && element.hasAttribute('xlink:href')) {
    return true;
  }

  if ((isSvgElement || isSvgContent) && element.focus && !supports.focusSvgNegativeTabindexAttribute && tabindex < 0) {
    // Firefox 51 and 52 treat any natively tabbable SVG element with
    // tabindex="-1" as tabbable and everything else as inert
    // see https://bugzilla.mozilla.org/show_bug.cgi?id=1302340
    return false;
  }

  if (isSvgElement) {
    return validTabindex || supports.focusSvg || supports.focusSvgInIframe
    // Internet Explorer understands the focusable attribute introduced in SVG Tiny 1.2
    || Boolean(supports.focusSvgFocusableAttribute && focusableAttribute && focusableAttribute === 'true');
  }

  if (isSvgContent) {
    if (supports.focusSvgTabindexAttribute && validTabindex) {
      return true;
    }

    if (supports.focusSvgFocusableAttribute) {
      // Internet Explorer understands the focusable attribute introduced in SVG Tiny 1.2
      return focusableAttribute === 'true';
    }
  }

  // https://www.w3.org/TR/html5/editing.html#sequential-focus-navigation-and-the-tabindex-attribute
  if (validTabindex) {
    return true;
  }

  var style = window.getComputedStyle(element, null);
  if ((0, _is.isUserModifyWritable)(style)) {
    return true;
  }

  if (supports.focusImgIsmap && nodeName === 'img' && element.hasAttribute('ismap')) {
    // IE10-11 considers the <img> in <a href><img ismap> focusable
    // https://github.com/medialize/ally.js/issues/20
    var hasLinkParent = (0, _parents2.default)({ context: element }).some(function (parent) {
      return parent.nodeName.toLowerCase() === 'a' && parent.hasAttribute('href');
    });

    if (hasLinkParent) {
      return true;
    }
  }

  // https://github.com/medialize/ally.js/issues/21
  if (!except.scrollable && supports.focusScrollContainer) {
    if (supports.focusScrollContainerWithoutOverflow) {
      // Internet Explorer does will consider the scrollable area focusable
      // if the element is a <div> or a <span> and it is in fact scrollable,
      // regardless of the CSS overflow property
      if ((0, _is.isScrollableContainer)(element, nodeName)) {
        return true;
      }
    } else if ((0, _is.hasCssOverflowScroll)(style)) {
      // Firefox requires proper overflow setting, IE does not necessarily
      // https://developer.mozilla.org/en-US/docs/Web/CSS/overflow
      return true;
    }
  }

  if (!except.flexbox && supports.focusFlexboxContainer && (0, _is.hasCssDisplayFlex)(style)) {
    // elements with display:flex are focusable in IE10-11
    return true;
  }

  var parent = element.parentElement;
  if (!except.scrollable && parent) {
    var parentNodeName = parent.nodeName.toLowerCase();
    var parentStyle = window.getComputedStyle(parent, null);
    if (supports.focusScrollBody && (0, _is.isScrollableContainer)(parent, nodeName, parentNodeName, parentStyle)) {
      // scrollable bodies are focusable Internet Explorer
      // https://github.com/medialize/ally.js/issues/21
      return true;
    }

    // Children of focusable elements with display:flex are focusable in IE10-11
    if (supports.focusChildrenOfFocusableFlexbox) {
      if ((0, _is.hasCssDisplayFlex)(parentStyle)) {
        return true;
      }
    }
  }

  // NOTE: elements marked as inert are not focusable,
  // but that property is not exposed to the DOM
  // https://www.w3.org/TR/html5/editing.html#inert

  return false;
}

// bind exceptions to an iterator callback
isFocusRelevantRules.except = function () {
  var except = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var isFocusRelevant = function isFocusRelevant(context) {
    return isFocusRelevantRules({
      context: context,
      except: except
    });
  };

  isFocusRelevant.rules = isFocusRelevantRules;
  return isFocusRelevant;
};

// provide isFocusRelevant(context) as default iterator callback
var isFocusRelevant = isFocusRelevantRules.except({});
exports.default = isFocusRelevant;
module.exports = exports['default'];
//# sourceMappingURL=focus-relevant.js.map

/***/ }),

/***/ "./node_modules/ally.js/is/focusable.js":
/*!**********************************************!*\
  !*** ./node_modules/ally.js/is/focusable.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _focusRelevant = __webpack_require__(/*! ./focus-relevant */ "./node_modules/ally.js/is/focus-relevant.js");

var _focusRelevant2 = _interopRequireDefault(_focusRelevant);

var _validArea = __webpack_require__(/*! ./valid-area */ "./node_modules/ally.js/is/valid-area.js");

var _validArea2 = _interopRequireDefault(_validArea);

var _visible = __webpack_require__(/*! ./visible */ "./node_modules/ally.js/is/visible.js");

var _visible2 = _interopRequireDefault(_visible);

var _disabled = __webpack_require__(/*! ./disabled */ "./node_modules/ally.js/is/disabled.js");

var _disabled2 = _interopRequireDefault(_disabled);

var _onlyTabbable = __webpack_require__(/*! ./only-tabbable */ "./node_modules/ally.js/is/only-tabbable.js");

var _onlyTabbable2 = _interopRequireDefault(_onlyTabbable);

var _contextToElement = __webpack_require__(/*! ../util/context-to-element */ "./node_modules/ally.js/util/context-to-element.js");

var _contextToElement2 = _interopRequireDefault(_contextToElement);

var _getFrameElement = __webpack_require__(/*! ../util/get-frame-element */ "./node_modules/ally.js/util/get-frame-element.js");

var _getFrameElement2 = _interopRequireDefault(_getFrameElement);

var _tabindexValue = __webpack_require__(/*! ../util/tabindex-value */ "./node_modules/ally.js/util/tabindex-value.js");

var _tabindexValue2 = _interopRequireDefault(_tabindexValue);

var _supports2 = __webpack_require__(/*! ../supports/supports */ "./node_modules/ally.js/supports/supports.js");

var _supports3 = _interopRequireDefault(_supports2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var supports = void 0;
// determine if an element can be focused

// https://www.w3.org/TR/html5/editing.html#focus-management

// NOTE: The following known issues exist:
//   Gecko: `svg a[xlink|href]` is not identified as focusable (because SVGElement.prototype.focus is missing)
//   Blink, WebKit: SVGElements that have been made focusable by adding a focus event listener are not identified as focusable

function isOnlyFocusRelevant(element) {
  var nodeName = element.nodeName.toLowerCase();
  if (nodeName === 'embed' || nodeName === 'keygen') {
    // embed is considered focus-relevant but not focusable
    // see https://github.com/medialize/ally.js/issues/82
    return true;
  }

  var _tabindex = (0, _tabindexValue2.default)(element);
  if (element.shadowRoot && _tabindex === null) {
    // ShadowDOM host elements *may* receive focus
    // even though they are not considered focuable
    return true;
  }

  if (nodeName === 'label') {
    // <label tabindex="0"> is only tabbable in Firefox, not script-focusable
    // there's no way to make an element focusable other than by adding a tabindex,
    // and focus behavior of the label element seems hard-wired to ignore tabindex
    // in some browsers (like Gecko, Blink and WebKit)
    return !supports.focusLabelTabindex || _tabindex === null;
  }

  if (nodeName === 'legend') {
    return _tabindex === null;
  }

  if (supports.focusSvgFocusableAttribute && (element.ownerSVGElement || nodeName === 'svg')) {
    // Internet Explorer understands the focusable attribute introduced in SVG Tiny 1.2
    var focusableAttribute = element.getAttribute('focusable');
    return focusableAttribute && focusableAttribute === 'false';
  }

  if (nodeName === 'img' && element.hasAttribute('usemap')) {
    // Gecko, Trident and Edge do not allow an image with an image map and tabindex to be focused,
    // it appears the tabindex is overruled so focus is still forwarded to the <map>
    return _tabindex === null || !supports.focusImgUsemapTabindex;
  }

  if (nodeName === 'area') {
    // all <area>s are considered relevant,
    // but only the valid <area>s are focusable
    return !(0, _validArea2.default)(element);
  }

  return false;
}

function isFocusableRules() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      context = _ref.context,
      _ref$except = _ref.except,
      except = _ref$except === undefined ? {
    disabled: false,
    visible: false,
    onlyTabbable: false
  } : _ref$except;

  if (!supports) {
    supports = (0, _supports3.default)();
  }

  var _isOnlyTabbable = _onlyTabbable2.default.rules.except({
    onlyFocusableBrowsingContext: true,
    visible: except.visible
  });

  var element = (0, _contextToElement2.default)({
    label: 'is/focusable',
    resolveDocument: true,
    context: context
  });

  var focusRelevant = _focusRelevant2.default.rules({
    context: element,
    except: except
  });

  if (!focusRelevant || isOnlyFocusRelevant(element)) {
    return false;
  }

  if (!except.disabled && (0, _disabled2.default)(element)) {
    return false;
  }

  if (!except.onlyTabbable && _isOnlyTabbable(element)) {
    // some elements may be keyboard focusable, but not script focusable
    return false;
  }

  // elements that are not rendered, cannot be focused
  if (!except.visible) {
    var visibilityOptions = {
      context: element,
      except: {}
    };

    if (supports.focusInHiddenIframe) {
      // WebKit and Blink can focus content in hidden <iframe> and <object>
      visibilityOptions.except.browsingContext = true;
    }

    if (supports.focusObjectSvgHidden) {
      // Blink allows focusing the object element, even if it has visibility: hidden;
      // @browser-issue Blink https://code.google.com/p/chromium/issues/detail?id=586191
      var _nodeName2 = element.nodeName.toLowerCase();
      if (_nodeName2 === 'object') {
        visibilityOptions.except.cssVisibility = true;
      }
    }

    if (!_visible2.default.rules(visibilityOptions)) {
      return false;
    }
  }

  var frameElement = (0, _getFrameElement2.default)(element);
  if (frameElement) {
    var _nodeName = frameElement.nodeName.toLowerCase();
    if (_nodeName === 'object' && !supports.focusInZeroDimensionObject) {
      if (!frameElement.offsetWidth || !frameElement.offsetHeight) {
        // WebKit can not focus content in <object> if it doesn't have dimensions
        return false;
      }
    }
  }

  var nodeName = element.nodeName.toLowerCase();
  if (nodeName === 'svg' && supports.focusSvgInIframe && !frameElement && element.getAttribute('tabindex') === null) {
    return false;
  }

  return true;
}

// bind exceptions to an iterator callback
isFocusableRules.except = function () {
  var except = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var isFocusable = function isFocusable(context) {
    return isFocusableRules({
      context: context,
      except: except
    });
  };

  isFocusable.rules = isFocusableRules;
  return isFocusable;
};

// provide isFocusRelevant(context) as default iterator callback
var isFocusable = isFocusableRules.except({});
exports.default = isFocusable;
module.exports = exports['default'];
//# sourceMappingURL=focusable.js.map

/***/ }),

/***/ "./node_modules/ally.js/is/is.util.js":
/*!********************************************!*\
  !*** ./node_modules/ally.js/is/is.util.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isUserModifyWritable = isUserModifyWritable;
exports.hasCssOverflowScroll = hasCssOverflowScroll;
exports.hasCssDisplayFlex = hasCssDisplayFlex;
exports.isScrollableContainer = isScrollableContainer;

// this is a shared utility file for focus-relevant.js and tabbable.js
// separate testing of this file's functions is not necessary,
// as they're implicitly tested by way of the consumers

function isUserModifyWritable(style) {
  // https://www.w3.org/TR/1999/WD-css3-userint-19990916#user-modify
  // https://github.com/medialize/ally.js/issues/17
  var userModify = style.webkitUserModify || '';
  return Boolean(userModify && userModify.indexOf('write') !== -1);
}

function hasCssOverflowScroll(style) {
  return [style.getPropertyValue('overflow'), style.getPropertyValue('overflow-x'), style.getPropertyValue('overflow-y')].some(function (overflow) {
    return overflow === 'auto' || overflow === 'scroll';
  });
}

function hasCssDisplayFlex(style) {
  return style.display.indexOf('flex') > -1;
}

function isScrollableContainer(element, nodeName, parentNodeName, parentStyle) {
  if (nodeName !== 'div' && nodeName !== 'span') {
    // Internet Explorer advances scrollable containers and bodies to focusable
    // only if the scrollable container is <div> or <span> - this does *not*
    // happen for <section>, <article>, 
    return false;
  }

  if (parentNodeName && parentNodeName !== 'div' && parentNodeName !== 'span' && !hasCssOverflowScroll(parentStyle)) {
    return false;
  }

  return element.offsetHeight < element.scrollHeight || element.offsetWidth < element.scrollWidth;
}
//# sourceMappingURL=is.util.js.map

/***/ }),

/***/ "./node_modules/ally.js/is/native-disabled-supported.js":
/*!**************************************************************!*\
  !*** ./node_modules/ally.js/is/native-disabled-supported.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (context) {
  if (!supports) {
    supports = (0, _supports3.default)();

    if (supports.focusFieldsetDisabled) {
      delete disabledElements.fieldset;
    }

    if (supports.focusFormDisabled) {
      delete disabledElements.form;
    }

    disabledElementsPattern = new RegExp('^(' + Object.keys(disabledElements).join('|') + ')$');
  }

  var element = (0, _contextToElement2.default)({
    label: 'is/native-disabled-supported',
    context: context
  });

  var nodeName = element.nodeName.toLowerCase();
  return Boolean(disabledElementsPattern.test(nodeName));
};

var _contextToElement = __webpack_require__(/*! ../util/context-to-element */ "./node_modules/ally.js/util/context-to-element.js");

var _contextToElement2 = _interopRequireDefault(_contextToElement);

var _supports2 = __webpack_require__(/*! ../supports/supports */ "./node_modules/ally.js/supports/supports.js");

var _supports3 = _interopRequireDefault(_supports2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Determine if an element supports the disabled attribute

var supports = void 0;

// https://www.w3.org/TR/html5/disabled-elements.html#concept-element-disabled
var disabledElementsPattern = void 0;
var disabledElements = {
  input: true,
  select: true,
  textarea: true,
  button: true,
  fieldset: true,
  form: true
};

module.exports = exports['default'];
//# sourceMappingURL=native-disabled-supported.js.map

/***/ }),

/***/ "./node_modules/ally.js/is/only-tabbable.js":
/*!**************************************************!*\
  !*** ./node_modules/ally.js/is/only-tabbable.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _visible = __webpack_require__(/*! ./visible */ "./node_modules/ally.js/is/visible.js");

var _visible2 = _interopRequireDefault(_visible);

var _contextToElement = __webpack_require__(/*! ../util/context-to-element */ "./node_modules/ally.js/util/context-to-element.js");

var _contextToElement2 = _interopRequireDefault(_contextToElement);

var _getFrameElement = __webpack_require__(/*! ../util/get-frame-element */ "./node_modules/ally.js/util/get-frame-element.js");

var _getFrameElement2 = _interopRequireDefault(_getFrameElement);

var _tabindexValue = __webpack_require__(/*! ../util/tabindex-value */ "./node_modules/ally.js/util/tabindex-value.js");

var _tabindexValue2 = _interopRequireDefault(_tabindexValue);

var _platform = __webpack_require__(/*! ../util/platform */ "./node_modules/ally.js/util/platform.js");

var _platform2 = _interopRequireDefault(_platform);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isOnlyTabbableRules() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      context = _ref.context,
      _ref$except = _ref.except,
      except = _ref$except === undefined ? {
    onlyFocusableBrowsingContext: false,
    visible: false
  } : _ref$except;

  var element = (0, _contextToElement2.default)({
    label: 'is/only-tabbable',
    resolveDocument: true,
    context: context
  });

  if (!except.visible && !(0, _visible2.default)(element)) {
    return false;
  }

  if (!except.onlyFocusableBrowsingContext && (_platform2.default.is.GECKO || _platform2.default.is.TRIDENT || _platform2.default.is.EDGE)) {
    var frameElement = (0, _getFrameElement2.default)(element);
    if (frameElement) {
      if ((0, _tabindexValue2.default)(frameElement) < 0) {
        // iframe[tabindex="-1"] and object[tabindex="-1"] inherit the
        // tabbable demotion onto elements of their browsing contexts
        return false;
      }
    }
  }

  var nodeName = element.nodeName.toLowerCase();
  var tabindex = (0, _tabindexValue2.default)(element);

  if (nodeName === 'label' && _platform2.default.is.GECKO) {
    // Firefox cannot focus, but tab to: label[tabindex=0]
    return tabindex !== null && tabindex >= 0;
  }

  // SVG Elements were keyboard focusable but not script focusable before Firefox 51.
  // Firefox 51 added the focus management DOM API (.focus and .blur) to SVGElement,
  // see https://bugzilla.mozilla.org/show_bug.cgi?id=778654
  if (_platform2.default.is.GECKO && element.ownerSVGElement && !element.focus) {
    if (nodeName === 'a' && element.hasAttribute('xlink:href')) {
      // any focusable child of <svg> cannot be focused, but tabbed to
      if (_platform2.default.is.GECKO) {
        return true;
      }
    }
  }

  return false;
}

// bind exceptions to an iterator callback
isOnlyTabbableRules.except = function () {
  var except = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var isOnlyTabbable = function isOnlyTabbable(context) {
    return isOnlyTabbableRules({
      context: context,
      except: except
    });
  };

  isOnlyTabbable.rules = isOnlyTabbableRules;
  return isOnlyTabbable;
};

// provide isOnlyTabbable(context) as default iterator callback
var isOnlyTabbable = isOnlyTabbableRules.except({});
exports.default = isOnlyTabbable;
module.exports = exports['default'];
//# sourceMappingURL=only-tabbable.js.map

/***/ }),

/***/ "./node_modules/ally.js/is/tabbable.js":
/*!*********************************************!*\
  !*** ./node_modules/ally.js/is/tabbable.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _visible = __webpack_require__(/*! ./visible */ "./node_modules/ally.js/is/visible.js");

var _visible2 = _interopRequireDefault(_visible);

var _contextToElement = __webpack_require__(/*! ../util/context-to-element */ "./node_modules/ally.js/util/context-to-element.js");

var _contextToElement2 = _interopRequireDefault(_contextToElement);

var _elementMatches = __webpack_require__(/*! ../util/element-matches */ "./node_modules/ally.js/util/element-matches.js");

var _elementMatches2 = _interopRequireDefault(_elementMatches);

var _tabindexValue = __webpack_require__(/*! ../util/tabindex-value */ "./node_modules/ally.js/util/tabindex-value.js");

var _tabindexValue2 = _interopRequireDefault(_tabindexValue);

var _focusRelevant = __webpack_require__(/*! ./focus-relevant */ "./node_modules/ally.js/is/focus-relevant.js");

var _focusRelevant2 = _interopRequireDefault(_focusRelevant);

var _getFrameElement = __webpack_require__(/*! ../util/get-frame-element */ "./node_modules/ally.js/util/get-frame-element.js");

var _getFrameElement2 = _interopRequireDefault(_getFrameElement);

var _platform = __webpack_require__(/*! ../util/platform */ "./node_modules/ally.js/util/platform.js");

var _platform2 = _interopRequireDefault(_platform);

var _imageMap = __webpack_require__(/*! ../util/image-map */ "./node_modules/ally.js/util/image-map.js");

var _is = __webpack_require__(/*! ./is.util */ "./node_modules/ally.js/is/is.util.js");

var _supports2 = __webpack_require__(/*! ../supports/supports */ "./node_modules/ally.js/supports/supports.js");

var _supports3 = _interopRequireDefault(_supports2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// determine if an element can be focused by keyboard (i.e. is part of the document's sequential focus navigation order)

var supports = void 0;

// Internet Explorer 11 considers fieldset, table, td focusable, but not tabbable
// Internet Explorer 11 considers body to have [tabindex=0], but does not allow tabbing to it
var focusableElementsPattern = /^(fieldset|table|td|body)$/;

function isTabbableRules() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      context = _ref.context,
      _ref$except = _ref.except,
      except = _ref$except === undefined ? {
    flexbox: false,
    scrollable: false,
    shadow: false,
    visible: false,
    onlyTabbable: false
  } : _ref$except;

  if (!supports) {
    supports = (0, _supports3.default)();
  }

  var element = (0, _contextToElement2.default)({
    label: 'is/tabbable',
    resolveDocument: true,
    context: context
  });

  if (_platform2.default.is.BLINK && _platform2.default.is.ANDROID && _platform2.default.majorVersion > 42) {
    // External keyboard support worked fine in CHrome 42, but stopped working in Chrome 45.
    // The on-screen keyboard does not provide a way to focus the next input element (like iOS does).
    // That leaves us with no option to advance focus by keyboard, ergo nothing is tabbable (keyboard focusable).
    return false;
  }

  var frameElement = (0, _getFrameElement2.default)(element);
  if (frameElement) {
    if (_platform2.default.is.WEBKIT && _platform2.default.is.IOS) {
      // iOS only does not consider anything from another browsing context keyboard focusable
      return false;
    }

    // iframe[tabindex="-1"] and object[tabindex="-1"] inherit the
    // tabbable demotion onto elements of their browsing contexts
    if ((0, _tabindexValue2.default)(frameElement) < 0) {
      return false;
    }

    if (!except.visible && (_platform2.default.is.BLINK || _platform2.default.is.WEBKIT) && !(0, _visible2.default)(frameElement)) {
      // Blink and WebKit consider elements in hidden browsing contexts focusable, but not tabbable
      return false;
    }

    // Webkit and Blink don't consider anything in <object> tabbable
    // Blink fixed that fixed in Chrome 54, Opera 41
    var frameNodeName = frameElement.nodeName.toLowerCase();
    if (frameNodeName === 'object') {
      var isFixedBlink = _platform2.default.name === 'Chrome' && _platform2.default.majorVersion >= 54 || _platform2.default.name === 'Opera' && _platform2.default.majorVersion >= 41;

      if (_platform2.default.is.WEBKIT || _platform2.default.is.BLINK && !isFixedBlink) {
        return false;
      }
    }
  }

  var nodeName = element.nodeName.toLowerCase();
  var _tabindex = (0, _tabindexValue2.default)(element);
  var tabindex = _tabindex === null ? null : _tabindex >= 0;

  if (_platform2.default.is.EDGE && _platform2.default.majorVersion >= 14 && frameElement && element.ownerSVGElement && _tabindex < 0) {
    // Edge 14+ considers <a xlink:href="" tabindex="-1"> keyboard focusable
    // if the element is in a nested browsing context
    return true;
  }

  var hasTabbableTabindexOrNone = tabindex !== false;
  var hasTabbableTabindex = _tabindex !== null && _tabindex >= 0;

  // NOTE: Firefox 31 considers [contenteditable] to have [tabindex=-1], but allows tabbing to it
  // fixed in Firefox 40 the latest - https://bugzilla.mozilla.org/show_bug.cgi?id=1185657
  if (element.hasAttribute('contenteditable')) {
    // tabbing can still be disabled by explicitly providing [tabindex="-1"]
    return hasTabbableTabindexOrNone;
  }

  if (focusableElementsPattern.test(nodeName) && tabindex !== true) {
    return false;
  }

  if (_platform2.default.is.WEBKIT && _platform2.default.is.IOS) {
    // iOS only considers a hand full of elements tabbable (keyboard focusable)
    // this holds true even with external keyboards
    var potentiallyTabbable = nodeName === 'input' && element.type === 'text' || element.type === 'password' || nodeName === 'select' || nodeName === 'textarea' || element.hasAttribute('contenteditable');

    if (!potentiallyTabbable) {
      var style = window.getComputedStyle(element, null);
      potentiallyTabbable = (0, _is.isUserModifyWritable)(style);
    }

    if (!potentiallyTabbable) {
      return false;
    }
  }

  if (nodeName === 'use' && _tabindex !== null) {
    if (_platform2.default.is.BLINK || _platform2.default.is.WEBKIT && _platform2.default.majorVersion === 9) {
      // In Chrome and Safari 9 the <use> element is keyboard focusable even for tabindex="-1"
      return true;
    }
  }

  if ((0, _elementMatches2.default)(element, 'svg a') && element.hasAttribute('xlink:href')) {
    if (hasTabbableTabindexOrNone) {
      // in Trident and Gecko SVGElement does not handle the tabIndex property properly
      return true;
    }

    if (element.focus && !supports.focusSvgNegativeTabindexAttribute) {
      // Firefox 51 and 52 treat any natively tabbable SVG element with
      // tabindex="-1" as tabbable and everything else as inert
      // see https://bugzilla.mozilla.org/show_bug.cgi?id=1302340
      return true;
    }
  }

  if (nodeName === 'svg' && supports.focusSvgInIframe && hasTabbableTabindexOrNone) {
    return true;
  }

  if (_platform2.default.is.TRIDENT || _platform2.default.is.EDGE) {
    if (nodeName === 'svg') {
      if (supports.focusSvg) {
        // older Internet Explorers consider <svg> keyboard focusable
        // unless they have focsable="false", but then they wouldn't
        // be focusable and thus not even reach this filter
        return true;
      }

      // elements that have [focusable] are automatically keyboard focusable regardless of the attribute's value
      return element.hasAttribute('focusable') || hasTabbableTabindex;
    }

    if (element.ownerSVGElement) {
      if (supports.focusSvgTabindexAttribute && hasTabbableTabindex) {
        return true;
      }

      // elements that have [focusable] are automatically keyboard focusable regardless of the attribute's value
      return element.hasAttribute('focusable');
    }
  }
  if (element.tabIndex === undefined) {
    return Boolean(except.onlyTabbable);
  }

  if (nodeName === 'audio') {
    if (!element.hasAttribute('controls')) {
      // In Internet Explorer the <audio> element is focusable, but not tabbable, and tabIndex property is wrong
      return false;
    } else if (_platform2.default.is.BLINK) {
      // In Chrome <audio controls tabindex="-1"> remains keyboard focusable
      return true;
    }
  }

  if (nodeName === 'video') {
    if (!element.hasAttribute('controls')) {
      if (_platform2.default.is.TRIDENT || _platform2.default.is.EDGE) {
        // In Internet Explorer and Edge the <video> element is focusable, but not tabbable, and tabIndex property is wrong
        return false;
      }
    } else if (_platform2.default.is.BLINK || _platform2.default.is.GECKO) {
      // In Chrome and Firefox <video controls tabindex="-1"> remains keyboard focusable
      return true;
    }
  }

  if (nodeName === 'object') {
    if (_platform2.default.is.BLINK || _platform2.default.is.WEBKIT) {
      // In all Blink and WebKit based browsers <embed> and <object> are never keyboard focusable, even with tabindex="0" set
      return false;
    }
  }

  if (nodeName === 'iframe') {
    // In Internet Explorer all iframes are only focusable
    // In WebKit, Blink and Gecko iframes may be tabbable depending on content.
    // Since we can't reliably investigate iframe documents because of the
    // SameOriginPolicy, we're declaring everything only focusable.
    return false;
  }

  if (!except.scrollable && _platform2.default.is.GECKO) {
    // Firefox considers scrollable containers keyboard focusable,
    // even though their tabIndex property is -1
    var _style = window.getComputedStyle(element, null);
    if ((0, _is.hasCssOverflowScroll)(_style)) {
      return hasTabbableTabindexOrNone;
    }
  }

  if (_platform2.default.is.TRIDENT || _platform2.default.is.EDGE) {
    // IE and Edge degrade <area> to script focusable, if the image
    // using the <map> has been given tabindex="-1"
    if (nodeName === 'area') {
      var img = (0, _imageMap.getImageOfArea)(element);
      if (img && (0, _tabindexValue2.default)(img) < 0) {
        return false;
      }
    }

    var _style2 = window.getComputedStyle(element, null);
    if ((0, _is.isUserModifyWritable)(_style2)) {
      // prevent being swallowed by the overzealous isScrollableContainer() below
      return element.tabIndex >= 0;
    }

    if (!except.flexbox && (0, _is.hasCssDisplayFlex)(_style2)) {
      if (_tabindex !== null) {
        return hasTabbableTabindex;
      }

      return isFocusRelevantWithoutFlexbox(element) && isTabbableWithoutFlexbox(element);
    }

    // IE considers scrollable containers script focusable only,
    // even though their tabIndex property is 0
    if ((0, _is.isScrollableContainer)(element, nodeName)) {
      return false;
    }

    var parent = element.parentElement;
    if (parent) {
      var parentNodeName = parent.nodeName.toLowerCase();
      var parentStyle = window.getComputedStyle(parent, null);
      // IE considers scrollable bodies script focusable only,
      if ((0, _is.isScrollableContainer)(parent, nodeName, parentNodeName, parentStyle)) {
        return false;
      }

      // Children of focusable elements with display:flex are focusable in IE10-11,
      // even though their tabIndex property suggests otherwise
      if ((0, _is.hasCssDisplayFlex)(parentStyle)) {
        // value of tabindex takes precedence
        return hasTabbableTabindex;
      }
    }
  }

  // https://www.w3.org/WAI/PF/aria-practices/#focus_tabindex
  return element.tabIndex >= 0;
}

// bind exceptions to an iterator callback
isTabbableRules.except = function () {
  var except = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var isTabbable = function isTabbable(context) {
    return isTabbableRules({
      context: context,
      except: except
    });
  };

  isTabbable.rules = isTabbableRules;
  return isTabbable;
};

var isFocusRelevantWithoutFlexbox = _focusRelevant2.default.rules.except({ flexbox: true });
var isTabbableWithoutFlexbox = isTabbableRules.except({ flexbox: true });

// provide isTabbable(context) as default iterator callback
var isTabbable = isTabbableRules.except({});
exports.default = isTabbable;
module.exports = exports['default'];
//# sourceMappingURL=tabbable.js.map

/***/ }),

/***/ "./node_modules/ally.js/is/valid-area.js":
/*!***********************************************!*\
  !*** ./node_modules/ally.js/is/valid-area.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (context) {
  if (!supports) {
    supports = (0, _supports3.default)();
  }

  var element = (0, _contextToElement2.default)({
    label: 'is/valid-area',
    context: context
  });

  var nodeName = element.nodeName.toLowerCase();
  if (nodeName !== 'area') {
    return false;
  }

  var hasTabindex = element.hasAttribute('tabindex');
  if (!supports.focusAreaTabindex && hasTabindex) {
    // Blink and WebKit do not consider <area tabindex="-1" href="#void"> focusable
    return false;
  }

  var img = (0, _imageMap.getImageOfArea)(element);
  if (!img || !(0, _visible2.default)(img)) {
    return false;
  }

  // Firefox only allows fully loaded images to reference image maps
  // https://stereochro.me/ideas/detecting-broken-images-js
  if (!supports.focusBrokenImageMap && (!img.complete || !img.naturalHeight || img.offsetWidth <= 0 || img.offsetHeight <= 0)) {
    return false;
  }

  // Firefox supports.can focus area elements even if they don't have an href attribute
  if (!supports.focusAreaWithoutHref && !element.href) {
    // Internet explorer supports.can focus area elements without href if either
    // the area element or the image element has a tabindex attribute
    return supports.focusAreaTabindex && hasTabindex || supports.focusAreaImgTabindex && img.hasAttribute('tabindex');
  }

  // https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img#attr-usemap
  var childOfInteractive = (0, _parents2.default)({ context: img }).slice(1).some(function (_element) {
    var name = _element.nodeName.toLowerCase();
    return name === 'button' || name === 'a';
  });

  if (childOfInteractive) {
    return false;
  }

  return true;
};

var _contextToElement = __webpack_require__(/*! ../util/context-to-element */ "./node_modules/ally.js/util/context-to-element.js");

var _contextToElement2 = _interopRequireDefault(_contextToElement);

var _visible = __webpack_require__(/*! ./visible */ "./node_modules/ally.js/is/visible.js");

var _visible2 = _interopRequireDefault(_visible);

var _parents = __webpack_require__(/*! ../get/parents */ "./node_modules/ally.js/get/parents.js");

var _parents2 = _interopRequireDefault(_parents);

var _imageMap = __webpack_require__(/*! ../util/image-map */ "./node_modules/ally.js/util/image-map.js");

var _supports2 = __webpack_require__(/*! ../supports/supports */ "./node_modules/ally.js/supports/supports.js");

var _supports3 = _interopRequireDefault(_supports2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var supports = void 0;

// https://developer.mozilla.org/en-US/docs/Web/HTML/Element/map
// https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img#attr-usemap
// https://github.com/jquery/jquery-ui/blob/master/ui/core.js#L88-L107

// determine if an <area> element is being properly used by and <img> via a <map>

module.exports = exports['default'];
//# sourceMappingURL=valid-area.js.map

/***/ }),

/***/ "./node_modules/ally.js/is/valid-tabindex.js":
/*!***************************************************!*\
  !*** ./node_modules/ally.js/is/valid-tabindex.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (context) {
  if (!supports) {
    supports = (0, _supports3.default)();
  }

  var validIntegerPattern = supports.focusTabindexTrailingCharacters ? validIntegerPatternWithTrailing : validIntegerPatternNoTrailing;

  var element = (0, _contextToElement2.default)({
    label: 'is/valid-tabindex',
    resolveDocument: true,
    context: context
  });

  // Edge 14 has a capitalization problem on SVG elements,
  // see https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/9282058/
  var hasTabindex = element.hasAttribute('tabindex');
  var hasTabIndex = element.hasAttribute('tabIndex');

  if (!hasTabindex && !hasTabIndex) {
    return false;
  }

  // older Firefox and Internet Explorer don't support tabindex on SVG elements
  var isSvgElement = element.ownerSVGElement || element.nodeName.toLowerCase() === 'svg';
  if (isSvgElement && !supports.focusSvgTabindexAttribute) {
    return false;
  }

  // @browser-issue Gecko https://bugzilla.mozilla.org/show_bug.cgi?id=1128054
  if (supports.focusInvalidTabindex) {
    return true;
  }

  // an element matches the tabindex selector even if its value is invalid
  var tabindex = element.getAttribute(hasTabindex ? 'tabindex' : 'tabIndex');
  // IE11 parses tabindex="" as the value "-32768"
  // @browser-issue Trident https://connect.microsoft.com/IE/feedback/details/1072965
  if (tabindex === '-32768') {
    return false;
  }

  return Boolean(tabindex && validIntegerPattern.test(tabindex));
};

var _contextToElement = __webpack_require__(/*! ../util/context-to-element */ "./node_modules/ally.js/util/context-to-element.js");

var _contextToElement2 = _interopRequireDefault(_contextToElement);

var _supports2 = __webpack_require__(/*! ../supports/supports */ "./node_modules/ally.js/supports/supports.js");

var _supports3 = _interopRequireDefault(_supports2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// determine if an element's tabindex attribute has a valid value

var supports = void 0;

// https://www.w3.org/TR/html5/infrastructure.html#rules-for-parsing-integers
// NOTE: all browsers agree to allow trailing spaces as well
var validIntegerPatternNoTrailing = /^\s*(-|\+)?[0-9]+\s*$/;
var validIntegerPatternWithTrailing = /^\s*(-|\+)?[0-9]+.*$/;

module.exports = exports['default'];
//# sourceMappingURL=valid-tabindex.js.map

/***/ }),

/***/ "./node_modules/ally.js/is/visible.js":
/*!********************************************!*\
  !*** ./node_modules/ally.js/is/visible.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _arrayFindIndex = __webpack_require__(/*! ../util/array-find-index */ "./node_modules/ally.js/util/array-find-index.js");

var _arrayFindIndex2 = _interopRequireDefault(_arrayFindIndex);

var _parents = __webpack_require__(/*! ../get/parents */ "./node_modules/ally.js/get/parents.js");

var _parents2 = _interopRequireDefault(_parents);

var _contextToElement = __webpack_require__(/*! ../util/context-to-element */ "./node_modules/ally.js/util/context-to-element.js");

var _contextToElement2 = _interopRequireDefault(_contextToElement);

var _getFrameElement = __webpack_require__(/*! ../util/get-frame-element */ "./node_modules/ally.js/util/get-frame-element.js");

var _getFrameElement2 = _interopRequireDefault(_getFrameElement);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// https://www.w3.org/TR/html5/rendering.html#being-rendered
// <area> is not rendered, but we *consider* it visible to simplfiy this function's usage

// determine if an element is rendered
// NOTE: that does not mean an element is visible in the viewport, see util/visible-area

var notRenderedElementsPattern = /^(area)$/;

function computedStyle(element, property) {
  return window.getComputedStyle(element, null).getPropertyValue(property);
}

function notDisplayed(_path) {
  return _path.some(function (element) {
    // display:none is not visible (optimized away at layout)
    return computedStyle(element, 'display') === 'none';
  });
}

function notVisible(_path) {
  // https://github.com/jquery/jquery-ui/blob/master/ui/core.js#L109-L114
  // NOTE: a nested element can reverse visibility:hidden|collapse by explicitly setting visibility:visible
  // NOTE: visibility can be ["", "visible", "hidden", "collapse"]
  var hidden = (0, _arrayFindIndex2.default)(_path, function (element) {
    var visibility = computedStyle(element, 'visibility');
    return visibility === 'hidden' || visibility === 'collapse';
  });

  if (hidden === -1) {
    // there is no hidden element
    return false;
  }

  var visible = (0, _arrayFindIndex2.default)(_path, function (element) {
    return computedStyle(element, 'visibility') === 'visible';
  });

  if (visible === -1) {
    // there is no visible element (but a hidden element)
    return true;
  }

  if (hidden < visible) {
    // there is a hidden element and it's closer than the first visible element
    return true;
  }

  // there may be a hidden element, but the closest element is visible
  return false;
}

function collapsedParent(_path) {
  var offset = 1;
  if (_path[0].nodeName.toLowerCase() === 'summary') {
    offset = 2;
  }

  return _path.slice(offset).some(function (element) {
    // "content children" of a closed details element are not visible
    return element.nodeName.toLowerCase() === 'details' && element.open === false;
  });
}

function isVisibleRules() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      context = _ref.context,
      _ref$except = _ref.except,
      except = _ref$except === undefined ? {
    notRendered: false,
    cssDisplay: false,
    cssVisibility: false,
    detailsElement: false,
    browsingContext: false
  } : _ref$except;

  var element = (0, _contextToElement2.default)({
    label: 'is/visible',
    resolveDocument: true,
    context: context
  });

  var nodeName = element.nodeName.toLowerCase();
  if (!except.notRendered && notRenderedElementsPattern.test(nodeName)) {
    return true;
  }

  var _path = (0, _parents2.default)({ context: element });

  // in Internet Explorer <audio> has a default display: none, where others have display: inline
  // but IE allows focusing <audio style="display:none">, but not <div display:none><audio>
  // this is irrelevant to other browsers, as the controls attribute is required to make <audio> focusable
  var isAudioWithoutControls = nodeName === 'audio' && !element.hasAttribute('controls');
  if (!except.cssDisplay && notDisplayed(isAudioWithoutControls ? _path.slice(1) : _path)) {
    return false;
  }

  if (!except.cssVisibility && notVisible(_path)) {
    return false;
  }

  if (!except.detailsElement && collapsedParent(_path)) {
    return false;
  }

  if (!except.browsingContext) {
    // elements within a browsing context are affected by the
    // browsing context host element's visibility and tabindex
    var frameElement = (0, _getFrameElement2.default)(element);
    var _isVisible = isVisibleRules.except(except);
    if (frameElement && !_isVisible(frameElement)) {
      return false;
    }
  }

  return true;
}

// bind exceptions to an iterator callback
isVisibleRules.except = function () {
  var except = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var isVisible = function isVisible(context) {
    return isVisibleRules({
      context: context,
      except: except
    });
  };

  isVisible.rules = isVisibleRules;
  return isVisible;
};

// provide isVisible(context) as default iterator callback
var isVisible = isVisibleRules.except({});
exports.default = isVisible;
module.exports = exports['default'];
//# sourceMappingURL=visible.js.map

/***/ }),

/***/ "./node_modules/ally.js/maintain/disabled.js":
/*!***************************************************!*\
  !*** ./node_modules/ally.js/maintain/disabled.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
/*
  Utility to make a sub-tree of the DOM inert. Inert means the elements cannot be interacted
  with and they cannot be focused via script, pointer or keyboard.

  inert attribute was [removed](https://html5.org/r/8536) [tweet by steve](https://twitter.com/stevefaulkner/status/443075900201259008)
  but definition of [inert subtrees](https://www.w3.org/html/wg/drafts/html/master/editing.html#inert-subtrees) remains.

  [implementation idea by Vasilis](https://codepen.io/vasilisvg/pen/scowI)
  [inert attribute polyfill by GoogleChrome](https://github.com/GoogleChrome/inert-polyfill)

  [Gecko Bug: Inert Attribute](https://bugzilla.mozilla.org/show_bug.cgi?id=921504)
  [Chromium Bug: Inert Attribute](https://code.google.com/p/chromium/issues/detail?id=269846)
  [Chromium Bug: Inert Subtree](https://code.google.com/p/chromium/issues/detail?id=241699)
  [WebKit Bug: Inert Subtree](https://bugs.webkit.org/show_bug.cgi?id=110952)
*/

exports.default = function () {
  var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      context = _ref2.context,
      filter = _ref2.filter;

  var service = new InertSubtree({ context: context, filter: filter });
  return { disengage: service.disengage };
};

var _nodeArray = __webpack_require__(/*! ../util/node-array */ "./node_modules/ally.js/util/node-array.js");

var _nodeArray2 = _interopRequireDefault(_nodeArray);

var _focusable = __webpack_require__(/*! ../query/focusable */ "./node_modules/ally.js/query/focusable.js");

var _focusable2 = _interopRequireDefault(_focusable);

var _disabled = __webpack_require__(/*! ../element/disabled */ "./node_modules/ally.js/element/disabled.js");

var _disabled2 = _interopRequireDefault(_disabled);

var _shadowMutations = __webpack_require__(/*! ../observe/shadow-mutations */ "./node_modules/ally.js/observe/shadow-mutations.js");

var _shadowMutations2 = _interopRequireDefault(_shadowMutations);

var _comparePosition = __webpack_require__(/*! ../util/compare-position */ "./node_modules/ally.js/util/compare-position.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function makeElementInert(element) {
  return (0, _disabled2.default)(element, true);
}

function undoElementInert(element) {
  return (0, _disabled2.default)(element, false);
}

var observerConfig = {
  attributes: true,
  childList: true,
  subtree: true,
  attributeFilter: ['tabindex', 'disabled', 'data-ally-disabled']
};

var InertSubtree = function () {
  function InertSubtree() {
    var _this = this;

    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        context = _ref.context,
        filter = _ref.filter;

    _classCallCheck(this, InertSubtree);

    this._context = (0, _nodeArray2.default)(context || document.documentElement)[0];
    this._filter = (0, _nodeArray2.default)(filter);
    this._inertElementCache = [];

    this.disengage = this.disengage.bind(this);
    this.handleMutation = this.handleMutation.bind(this);
    this.renderInert = this.renderInert.bind(this);
    this.filterElements = this.filterElements.bind(this);
    this.filterParentElements = this.filterParentElements.bind(this);

    var focusable = (0, _focusable2.default)({
      context: this._context,
      includeContext: true,
      strategy: 'all'
    });

    this.renderInert(focusable);

    this.shadowObserver = (0, _shadowMutations2.default)({
      context: this._context,
      config: observerConfig,
      callback: function callback(mutations) {
        return mutations.forEach(_this.handleMutation);
      }
    });
  }

  _createClass(InertSubtree, [{
    key: 'disengage',
    value: function disengage() {
      if (!this._context) {
        return;
      }

      undoElementInert(this._context);
      this._inertElementCache.forEach(function (element) {
        return undoElementInert(element);
      });

      this._inertElementCache = null;
      this._filter = null;
      this._context = null;
      this.shadowObserver && this.shadowObserver.disengage();
      this.shadowObserver = null;
    }
  }, {
    key: 'listQueryFocusable',
    value: function listQueryFocusable(list) {
      return list
      // find all focusable elements within the given contexts
      .map(function (element) {
        return (0, _focusable2.default)({ context: element, includeContext: true, strategy: 'all' });
      })
      // flatten nested arrays
      .reduce(function (previous, current) {
        return previous.concat(current);
      }, []);
    }
  }, {
    key: 'renderInert',
    value: function renderInert(elements) {
      var _this2 = this;

      var makeInert = function makeInert(element) {
        _this2._inertElementCache.push(element);
        makeElementInert(element);
      };

      elements.filter(this.filterElements).filter(this.filterParentElements)
      // ignore elements that already are disabled
      // so we don't enable them on disengage()
      .filter(function (element) {
        return !(0, _disabled2.default)(element);
      }).forEach(makeInert);
    }
  }, {
    key: 'filterElements',
    value: function filterElements(element) {
      // ignore elements within the exempted sub-trees
      var isParentOfElement = (0, _comparePosition.getParentComparator)({ element: element, includeSelf: true });
      return !this._filter.some(isParentOfElement);
    }
  }, {
    key: 'filterParentElements',
    value: function filterParentElements(element) {
      // ignore ancestors of the exempted sub-trees
      var isParentOfElement = (0, _comparePosition.getParentComparator)({ parent: element });
      return !this._filter.some(isParentOfElement);
    }
  }, {
    key: 'handleMutation',
    value: function handleMutation(mutation) {
      if (mutation.type === 'childList') {
        var addedElements = (0, _nodeArray2.default)(mutation.addedNodes).filter(function (element) {
          return element.nodeType === Node.ELEMENT_NODE;
        });
        if (!addedElements.length) {
          return;
        }

        var addedFocusableElements = this.listQueryFocusable(addedElements);
        this.renderInert(addedFocusableElements);
      } else if (mutation.type === 'attributes') {
        this.renderInert([mutation.target]);
      }
    }
  }]);

  return InertSubtree;
}();

module.exports = exports['default'];
//# sourceMappingURL=disabled.js.map

/***/ }),

/***/ "./node_modules/ally.js/maintain/tab-focus.js":
/*!****************************************************!*\
  !*** ./node_modules/ally.js/maintain/tab-focus.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function () {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      context = _ref.context;

  if (!context) {
    context = document.documentElement;
  }

  // Make sure the supports tests are run before intercepting the Tab key,
  // or IE10 and IE11 will fail to process the first Tab key event. Not
  // limiting this warm-up to IE because it may be a problem elsewhere, too.
  (0, _tabsequence2.default)();

  return (0, _key2.default)({
    // Safari on OSX may require ALT+TAB to reach links,
    // see https://github.com/medialize/ally.js/issues/146
    '?alt+?shift+tab': function altShiftTab(event) {
      // we're completely taking over the Tab key handling
      event.preventDefault();

      var sequence = (0, _tabsequence2.default)({
        context: context
      });

      var backward = event.shiftKey;
      var first = sequence[0];
      var last = sequence[sequence.length - 1];

      // wrap around first to last, last to first
      var source = backward ? first : last;
      var target = backward ? last : first;
      if ((0, _activeElement2.default)(source)) {
        target.focus();
        return;
      }

      // find current position in tabsequence
      var currentIndex = void 0;
      var found = sequence.some(function (element, index) {
        if (!(0, _activeElement2.default)(element)) {
          return false;
        }

        currentIndex = index;
        return true;
      });

      if (!found) {
        // redirect to first as we're not in our tabsequence
        first.focus();
        return;
      }

      // shift focus to previous/next element in the sequence
      var offset = backward ? -1 : 1;
      sequence[currentIndex + offset].focus();
    }
  });
};

var _activeElement = __webpack_require__(/*! ../is/active-element */ "./node_modules/ally.js/is/active-element.js");

var _activeElement2 = _interopRequireDefault(_activeElement);

var _tabsequence = __webpack_require__(/*! ../query/tabsequence */ "./node_modules/ally.js/query/tabsequence.js");

var _tabsequence2 = _interopRequireDefault(_tabsequence);

var _key = __webpack_require__(/*! ../when/key */ "./node_modules/ally.js/when/key.js");

var _key2 = _interopRequireDefault(_key);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

module.exports = exports['default'];
//# sourceMappingURL=tab-focus.js.map

/***/ }),

/***/ "./node_modules/ally.js/map/keycode.js":
/*!*********************************************!*\
  !*** ./node_modules/ally.js/map/keycode.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

// codes mostly cloned from https://github.com/keithamus/jwerty/blob/master/jwerty.js
// deliberately not exposing characters like <,.-#* because they vary *wildly*
// across keyboard layouts and may cause various problems
// (e.g. "*" is "Shift +" on a German Mac keyboard)
// (e.g. "@" is "Alt L" on a German Mac keyboard)

var keycode = {
  // Element Focus
  tab: 9,

  // Navigation
  left: 37,
  up: 38,
  right: 39,
  down: 40,
  pageUp: 33,
  'page-up': 33,
  pageDown: 34,
  'page-down': 34,
  end: 35,
  home: 36,

  // Action
  enter: 13,
  escape: 27,
  space: 32,

  // Modifier
  shift: 16,
  capsLock: 20,
  'caps-lock': 20,
  ctrl: 17,
  alt: 18,
  meta: 91,
  // in firefox: 224
  // on mac (chrome): meta-left=91, meta-right=93
  // on win (IE11): meta-left=91, meta-right=92
  pause: 19,

  // Content Manipulation
  insert: 45,
  'delete': 46,
  backspace: 8,

  // the same logical key may be identified through different keyCodes
  _alias: {
    91: [92, 93, 224]
  }
};

// Function keys (112 - 137)
// NOTE: not every keyboard knows F13+
for (var n = 1; n < 26; n++) {
  keycode['f' + n] = n + 111;
}

// Number keys (48-57, numpad 96-105)
// NOTE: not every keyboard knows num-0+
for (var _n = 0; _n < 10; _n++) {
  var code = _n + 48;
  var numCode = _n + 96;
  keycode[_n] = code;
  keycode['num-' + _n] = numCode;
  keycode._alias[code] = [numCode];
}

// Latin characters (65 - 90)
for (var _n2 = 0; _n2 < 26; _n2++) {
  var _code = _n2 + 65;
  var name = String.fromCharCode(_code).toLowerCase();
  keycode[name] = _code;
}

exports.default = keycode;
module.exports = exports['default'];
//# sourceMappingURL=keycode.js.map

/***/ }),

/***/ "./node_modules/ally.js/observe/shadow-mutations.js":
/*!**********************************************************!*\
  !*** ./node_modules/ally.js/observe/shadow-mutations.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.default = function () {
  var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      context = _ref2.context,
      callback = _ref2.callback,
      config = _ref2.config;

  if (typeof callback !== 'function') {
    throw new TypeError('observe/shadow-mutations requires options.callback to be a function');
  }

  if ((typeof config === 'undefined' ? 'undefined' : _typeof(config)) !== 'object') {
    throw new TypeError('observe/shadow-mutations requires options.config to be an object');
  }

  if (!window.MutationObserver) {
    // not supporting IE10 via Mutation Events, because they're too expensive
    // https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Mutation_events
    return {
      disengage: function disengage() {}
    };
  }

  var element = (0, _contextToElement2.default)({
    label: 'observe/shadow-mutations',
    resolveDocument: true,
    defaultToDocument: true,
    context: context
  });

  var service = new ShadowMutationObserver({
    context: element,
    callback: callback,
    config: config
  });

  return {
    disengage: service.disengage
  };
};

var _nodeArray = __webpack_require__(/*! ../util/node-array */ "./node_modules/ally.js/util/node-array.js");

var _nodeArray2 = _interopRequireDefault(_nodeArray);

var _shadowHosts = __webpack_require__(/*! ../query/shadow-hosts */ "./node_modules/ally.js/query/shadow-hosts.js");

var _shadowHosts2 = _interopRequireDefault(_shadowHosts);

var _contextToElement = __webpack_require__(/*! ../util/context-to-element */ "./node_modules/ally.js/util/context-to-element.js");

var _contextToElement2 = _interopRequireDefault(_contextToElement);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var shadowObserverConfig = {
  childList: true,
  subtree: true
};

var ShadowMutationObserver = function () {
  function ShadowMutationObserver() {
    var _this = this;

    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        context = _ref.context,
        callback = _ref.callback,
        config = _ref.config;

    _classCallCheck(this, ShadowMutationObserver);

    this.config = config;

    this.disengage = this.disengage.bind(this);

    this.clientObserver = new MutationObserver(callback);
    this.hostObserver = new MutationObserver(function (mutations) {
      return mutations.forEach(_this.handleHostMutation, _this);
    });

    this.observeContext(context);
    this.observeShadowHosts(context);
  }

  _createClass(ShadowMutationObserver, [{
    key: 'disengage',
    value: function disengage() {
      this.clientObserver && this.clientObserver.disconnect();
      this.clientObserver = null;
      this.hostObserver && this.hostObserver.disconnect();
      this.hostObserver = null;
    }
  }, {
    key: 'observeShadowHosts',
    value: function observeShadowHosts(context) {
      var _this2 = this;

      var hosts = (0, _shadowHosts2.default)({
        context: context
      });

      hosts.forEach(function (element) {
        return _this2.observeContext(element.shadowRoot);
      });
    }
  }, {
    key: 'observeContext',
    value: function observeContext(context) {
      this.clientObserver.observe(context, this.config);
      this.hostObserver.observe(context, shadowObserverConfig);
    }
  }, {
    key: 'handleHostMutation',
    value: function handleHostMutation(mutation) {
      if (mutation.type !== 'childList') {
        return;
      }

      var addedElements = (0, _nodeArray2.default)(mutation.addedNodes).filter(function (element) {
        return element.nodeType === Node.ELEMENT_NODE;
      });
      addedElements.forEach(this.observeShadowHosts, this);
    }
  }]);

  return ShadowMutationObserver;
}();

module.exports = exports['default'];
//# sourceMappingURL=shadow-mutations.js.map

/***/ }),

/***/ "./node_modules/ally.js/query/focusable.js":
/*!*************************************************!*\
  !*** ./node_modules/ally.js/query/focusable.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function () {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      context = _ref.context,
      includeContext = _ref.includeContext,
      includeOnlyTabbable = _ref.includeOnlyTabbable,
      _ref$strategy = _ref.strategy,
      strategy = _ref$strategy === undefined ? 'quick' : _ref$strategy;

  var element = (0, _contextToElement2.default)({
    label: 'query/focusable',
    resolveDocument: true,
    defaultToDocument: true,
    context: context
  });

  var options = {
    context: element,
    includeContext: includeContext,
    includeOnlyTabbable: includeOnlyTabbable,
    strategy: strategy
  };

  if (strategy === 'quick') {
    return (0, _focusable4.default)(options);
  } else if (strategy === 'strict' || strategy === 'all') {
    return (0, _focusable2.default)(options);
  }

  throw new TypeError('query/focusable requires option.strategy to be one of ["quick", "strict", "all"]');
};

var _contextToElement = __webpack_require__(/*! ../util/context-to-element */ "./node_modules/ally.js/util/context-to-element.js");

var _contextToElement2 = _interopRequireDefault(_contextToElement);

var _focusable = __webpack_require__(/*! ./focusable.strict */ "./node_modules/ally.js/query/focusable.strict.js");

var _focusable2 = _interopRequireDefault(_focusable);

var _focusable3 = __webpack_require__(/*! ./focusable.quick */ "./node_modules/ally.js/query/focusable.quick.js");

var _focusable4 = _interopRequireDefault(_focusable3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// https://www.w3.org/TR/html5/editing.html#focusable
// https://www.w3.org/WAI/PF/aria-practices/#keyboard

module.exports = exports['default'];
//# sourceMappingURL=focusable.js.map

/***/ }),

/***/ "./node_modules/ally.js/query/focusable.quick.js":
/*!*******************************************************!*\
  !*** ./node_modules/ally.js/query/focusable.quick.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = queryFocusableQuick;

var _focusable = __webpack_require__(/*! ../selector/focusable */ "./node_modules/ally.js/selector/focusable.js");

var _focusable2 = _interopRequireDefault(_focusable);

var _focusable3 = __webpack_require__(/*! ../is/focusable */ "./node_modules/ally.js/is/focusable.js");

var _focusable4 = _interopRequireDefault(_focusable3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// https://www.w3.org/TR/html5/editing.html#focusable
// https://www.w3.org/WAI/PF/aria-practices/#keyboard

function queryFocusableQuick() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      context = _ref.context,
      includeContext = _ref.includeContext,
      includeOnlyTabbable = _ref.includeOnlyTabbable;

  var _selector = (0, _focusable2.default)();
  var elements = context.querySelectorAll(_selector);
  // the selector potentially matches more than really is focusable

  var _isFocusable = _focusable4.default.rules.except({
    onlyTabbable: includeOnlyTabbable
  });

  var result = [].filter.call(elements, _isFocusable);

  // add context if requested and focusable
  if (includeContext && _isFocusable(context)) {
    result.unshift(context);
  }

  return result;
}
module.exports = exports['default'];
//# sourceMappingURL=focusable.quick.js.map

/***/ }),

/***/ "./node_modules/ally.js/query/focusable.strict.js":
/*!********************************************************!*\
  !*** ./node_modules/ally.js/query/focusable.strict.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = queryFocusableStrict;

var _focusable = __webpack_require__(/*! ../is/focusable */ "./node_modules/ally.js/is/focusable.js");

var _focusable2 = _interopRequireDefault(_focusable);

var _focusRelevant = __webpack_require__(/*! ../is/focus-relevant */ "./node_modules/ally.js/is/focus-relevant.js");

var _focusRelevant2 = _interopRequireDefault(_focusRelevant);

var _getDocument = __webpack_require__(/*! ../util/get-document */ "./node_modules/ally.js/util/get-document.js");

var _getDocument2 = _interopRequireDefault(_getDocument);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function createFilter(condition) {
  // see https://developer.mozilla.org/en-US/docs/Web/API/NodeFilter
  var filter = function filter(node) {
    if (node.shadowRoot) {
      // return ShadowRoot elements regardless of them being focusable,
      // so they can be walked recursively later
      return NodeFilter.FILTER_ACCEPT;
    }

    if (condition(node)) {
      // finds elements that could have been found by document.querySelectorAll()
      return NodeFilter.FILTER_ACCEPT;
    }

    return NodeFilter.FILTER_SKIP;
  };
  // IE requires a function, Browsers require {acceptNode: function}
  // see http://www.bennadel.com/blog/2607-finding-html-comment-nodes-in-the-dom-using-treewalker.htm
  filter.acceptNode = filter;
  return filter;
}
// https://www.w3.org/TR/html5/editing.html#focusable
// https://www.w3.org/WAI/PF/aria-practices/#keyboard

var PossiblyFocusableFilter = createFilter(_focusRelevant2.default);

function queryFocusableStrict() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      context = _ref.context,
      includeContext = _ref.includeContext,
      includeOnlyTabbable = _ref.includeOnlyTabbable,
      strategy = _ref.strategy;

  if (!context) {
    context = document.documentElement;
  }

  var _isFocusable = _focusable2.default.rules.except({
    onlyTabbable: includeOnlyTabbable
  });

  var _document = (0, _getDocument2.default)(context);
  // see https://developer.mozilla.org/en-US/docs/Web/API/Document/createTreeWalker
  var walker = _document.createTreeWalker(
  // root element to start search in
  context,
  // element type filter
  NodeFilter.SHOW_ELEMENT,
  // custom NodeFilter filter
  strategy === 'all' ? PossiblyFocusableFilter : createFilter(_isFocusable),
  // deprecated, but IE requires it
  false);

  var list = [];

  while (walker.nextNode()) {
    if (walker.currentNode.shadowRoot) {
      if (_isFocusable(walker.currentNode)) {
        list.push(walker.currentNode);
      }

      list = list.concat(queryFocusableStrict({
        context: walker.currentNode.shadowRoot,
        includeOnlyTabbable: includeOnlyTabbable,
        strategy: strategy
      }));
    } else {
      list.push(walker.currentNode);
    }
  }

  // add context if requested and focusable
  if (includeContext) {
    if (strategy === 'all') {
      if ((0, _focusRelevant2.default)(context)) {
        list.unshift(context);
      }
    } else if (_isFocusable(context)) {
      list.unshift(context);
    }
  }

  return list;
}
module.exports = exports['default'];
//# sourceMappingURL=focusable.strict.js.map

/***/ }),

/***/ "./node_modules/ally.js/query/shadow-hosts.js":
/*!****************************************************!*\
  !*** ./node_modules/ally.js/query/shadow-hosts.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = queryShadowHosts;

var _contextToElement = __webpack_require__(/*! ../util/context-to-element */ "./node_modules/ally.js/util/context-to-element.js");

var _contextToElement2 = _interopRequireDefault(_contextToElement);

var _getDocument = __webpack_require__(/*! ../util/get-document */ "./node_modules/ally.js/util/get-document.js");

var _getDocument2 = _interopRequireDefault(_getDocument);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// see https://developer.mozilla.org/en-US/docs/Web/API/NodeFilter
var filter = function filter(node) {
  if (node.shadowRoot) {
    return NodeFilter.FILTER_ACCEPT;
  }

  return NodeFilter.FILTER_SKIP;
};
// IE requires a function, Browsers require {acceptNode: function}
// see http://www.bennadel.com/blog/2607-finding-html-comment-nodes-in-the-dom-using-treewalker.htm
filter.acceptNode = filter;

function queryShadowHosts() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      context = _ref.context;

  var element = (0, _contextToElement2.default)({
    label: 'query/shadow-hosts',
    resolveDocument: true,
    defaultToDocument: true,
    context: context
  });

  var _document = (0, _getDocument2.default)(context);
  // see https://developer.mozilla.org/en-US/docs/Web/API/Document/createTreeWalker
  var walker = _document.createTreeWalker(
  // root element to start search in
  element,
  // element type filter
  NodeFilter.SHOW_ELEMENT,
  // custom NodeFilter filter
  filter,
  // deprecated, but IE requires it
  false);

  var list = [];

  if (element.shadowRoot) {
    // TreeWalker does not run the filter on the context element
    list.push(element);
    list = list.concat(queryShadowHosts({
      context: element.shadowRoot
    }));
  }

  while (walker.nextNode()) {
    list.push(walker.currentNode);
    list = list.concat(queryShadowHosts({
      context: walker.currentNode.shadowRoot
    }));
  }

  return list;
}
module.exports = exports['default'];
//# sourceMappingURL=shadow-hosts.js.map

/***/ }),

/***/ "./node_modules/ally.js/query/tabbable.js":
/*!************************************************!*\
  !*** ./node_modules/ally.js/query/tabbable.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function () {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      context = _ref.context,
      includeContext = _ref.includeContext,
      includeOnlyTabbable = _ref.includeOnlyTabbable,
      strategy = _ref.strategy;

  var _isTabbable = _tabbable2.default.rules.except({
    onlyTabbable: includeOnlyTabbable
  });

  return (0, _focusable2.default)({
    context: context,
    includeContext: includeContext,
    includeOnlyTabbable: includeOnlyTabbable,
    strategy: strategy
  }).filter(_isTabbable);
};

var _focusable = __webpack_require__(/*! ./focusable */ "./node_modules/ally.js/query/focusable.js");

var _focusable2 = _interopRequireDefault(_focusable);

var _tabbable = __webpack_require__(/*! ../is/tabbable */ "./node_modules/ally.js/is/tabbable.js");

var _tabbable2 = _interopRequireDefault(_tabbable);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

module.exports = exports['default'];
// https://www.w3.org/TR/html5/editing.html#sequential-focus-navigation-and-the-tabindex-attribute
// https://www.w3.org/WAI/PF/aria-practices/#keyboard
//# sourceMappingURL=tabbable.js.map

/***/ }),

/***/ "./node_modules/ally.js/query/tabsequence.js":
/*!***************************************************!*\
  !*** ./node_modules/ally.js/query/tabsequence.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function () {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      context = _ref.context,
      includeContext = _ref.includeContext,
      includeOnlyTabbable = _ref.includeOnlyTabbable,
      strategy = _ref.strategy;

  if (!supports) {
    supports = (0, _supports3.default)();
  }

  var _context = (0, _nodeArray2.default)(context)[0] || document.documentElement;
  var elements = (0, _tabbable2.default)({
    context: _context,
    includeContext: includeContext,
    includeOnlyTabbable: includeOnlyTabbable,
    strategy: strategy
  });

  if (document.body.createShadowRoot && _platform2.default.is.BLINK) {
    // sort tabindex localized to shadow dom
    // see https://github.com/medialize/ally.js/issues/6
    elements = (0, _tabsequence4.default)(elements, _context, sortElements);
  } else {
    elements = sortElements(elements, _context);
  }

  if (includeContext) {
    // if we include the context itself, it has to be the first
    // element of the sequence
    elements = moveContextToBeginning(elements, _context);
  }

  return elements;
};

var _tabbable = __webpack_require__(/*! ./tabbable */ "./node_modules/ally.js/query/tabbable.js");

var _tabbable2 = _interopRequireDefault(_tabbable);

var _nodeArray = __webpack_require__(/*! ../util/node-array */ "./node_modules/ally.js/util/node-array.js");

var _nodeArray2 = _interopRequireDefault(_nodeArray);

var _platform = __webpack_require__(/*! ../util/platform */ "./node_modules/ally.js/util/platform.js");

var _platform2 = _interopRequireDefault(_platform);

var _tabsequence = __webpack_require__(/*! ./tabsequence.sort-area */ "./node_modules/ally.js/query/tabsequence.sort-area.js");

var _tabsequence2 = _interopRequireDefault(_tabsequence);

var _tabsequence3 = __webpack_require__(/*! ./tabsequence.sort-shadowed */ "./node_modules/ally.js/query/tabsequence.sort-shadowed.js");

var _tabsequence4 = _interopRequireDefault(_tabsequence3);

var _tabsequence5 = __webpack_require__(/*! ./tabsequence.sort-tabindex */ "./node_modules/ally.js/query/tabsequence.sort-tabindex.js");

var _tabsequence6 = _interopRequireDefault(_tabsequence5);

var _supports2 = __webpack_require__(/*! ../supports/supports */ "./node_modules/ally.js/supports/supports.js");

var _supports3 = _interopRequireDefault(_supports2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var supports = void 0;
// https://www.w3.org/TR/html5/editing.html#sequential-focus-navigation-and-the-tabindex-attribute
// https://www.w3.org/WAI/PF/aria-practices/#keyboard

function moveContextToBeginning(elements, context) {
  var pos = elements.indexOf(context);
  if (pos > 0) {
    var tmp = elements.splice(pos, 1);
    return tmp.concat(elements);
  }

  return elements;
}

function sortElements(elements, _context) {
  if (supports.tabsequenceAreaAtImgPosition) {
    // Some browsers sort <area> in DOM order, some place the <area>s
    // where the <img> referecing them would've been in DOM order.
    // https://github.com/medialize/ally.js/issues/5
    elements = (0, _tabsequence2.default)(elements, _context);
  }

  elements = (0, _tabsequence6.default)(elements);
  return elements;
}

module.exports = exports['default'];
//# sourceMappingURL=tabsequence.js.map

/***/ }),

/***/ "./node_modules/ally.js/query/tabsequence.sort-area.js":
/*!*************************************************************!*\
  !*** ./node_modules/ally.js/query/tabsequence.sort-area.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
// move <area> elements to the location of the <img> elements that reference them

exports.default = function (elements, context) {
  // images - unless they are focusable themselves, likely not
  // part of the elements list, so we'll have to find them and
  // sort them into the elements list manually
  var usemaps = context.querySelectorAll('img[usemap]');
  var maps = new Maps(context);

  // remove all <area> elements from the elements list,
  // but put them the map for later retrieval
  var _elements = maps.extractAreasFromList(elements);

  if (!usemaps.length) {
    // the context does not contain any <area>s so no need
    // to replace anything, just remove any maps
    return _elements;
  }

  return (0, _mergeDomOrder2.default)({
    list: _elements,
    elements: usemaps,
    resolveElement: function resolveElement(image) {
      var name = image.getAttribute('usemap').slice(1);
      return maps.getAreasFor(name);
    }
  });
};

var _tabbable = __webpack_require__(/*! ./tabbable */ "./node_modules/ally.js/query/tabbable.js");

var _tabbable2 = _interopRequireDefault(_tabbable);

var _mergeDomOrder = __webpack_require__(/*! ../util/merge-dom-order */ "./node_modules/ally.js/util/merge-dom-order.js");

var _mergeDomOrder2 = _interopRequireDefault(_mergeDomOrder);

var _getDocument = __webpack_require__(/*! ../util/get-document */ "./node_modules/ally.js/util/get-document.js");

var _getDocument2 = _interopRequireDefault(_getDocument);

var _imageMap = __webpack_require__(/*! ../util/image-map */ "./node_modules/ally.js/util/image-map.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Maps = function () {
  function Maps(context) {
    _classCallCheck(this, Maps);

    this._document = (0, _getDocument2.default)(context);
    this.maps = {};
  }

  _createClass(Maps, [{
    key: 'getAreasFor',
    value: function getAreasFor(name) {
      if (!this.maps[name]) {
        // the map is not defined within the context, so we
        // have to go find it elsewhere in the document
        this.addMapByName(name);
      }

      return this.maps[name];
    }
  }, {
    key: 'addMapByName',
    value: function addMapByName(name) {
      var map = (0, _imageMap.getMapByName)(name, this._document);
      if (!map) {
        // if there is no map, the img[usemap] wasn't doing anything anyway
        return;
      }

      this.maps[map.name] = (0, _tabbable2.default)({ context: map });
    }
  }, {
    key: 'extractAreasFromList',
    value: function extractAreasFromList(elements) {
      // remove all <area> elements from the elements list,
      // but put them the map for later retrieval
      return elements.filter(function (element) {
        var nodeName = element.nodeName.toLowerCase();
        if (nodeName !== 'area') {
          return true;
        }

        var map = element.parentNode;
        if (!this.maps[map.name]) {
          this.maps[map.name] = [];
        }

        this.maps[map.name].push(element);
        return false;
      }, this);
    }
  }]);

  return Maps;
}();

module.exports = exports['default'];
//# sourceMappingURL=tabsequence.sort-area.js.map

/***/ }),

/***/ "./node_modules/ally.js/query/tabsequence.sort-shadowed.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ally.js/query/tabsequence.sort-shadowed.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.default = function (elements, context, sortElements) {
  var shadows = new Shadows(context, sortElements);
  var _elements = shadows.extractElements(elements);

  if (_elements.length === elements.length) {
    // no shadowed content found, no need to continue
    return sortElements(elements);
  }

  return shadows.sort(_elements);
};

var _shadowHost = __webpack_require__(/*! ../get/shadow-host */ "./node_modules/ally.js/get/shadow-host.js");

var _shadowHost2 = _interopRequireDefault(_shadowHost);

var _mergeDomOrder = __webpack_require__(/*! ../util/merge-dom-order */ "./node_modules/ally.js/util/merge-dom-order.js");

var _mergeDomOrder2 = _interopRequireDefault(_mergeDomOrder);

var _tabindexValue = __webpack_require__(/*! ../util/tabindex-value */ "./node_modules/ally.js/util/tabindex-value.js");

var _tabindexValue2 = _interopRequireDefault(_tabindexValue);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Shadows = function () {
  function Shadows(context, sortElements) {
    _classCallCheck(this, Shadows);

    // document context we're working with
    this.context = context;
    // callback that sorts an array of elements
    this.sortElements = sortElements;
    // reference to create unique IDs for each ShadowHost
    this.hostCounter = 1;
    // reference map for child-ShadowHosts of a ShadowHost
    this.inHost = {};
    // reference map for child-ShadowHost of the document
    this.inDocument = [];
    // reference map for ShadowHosts
    this.hosts = {};
    // reference map for tabbable elements of a ShadowHost
    this.elements = {};
  }

  // remember which hosts we have to sort within later


  _createClass(Shadows, [{
    key: '_registerHost',
    value: function _registerHost(host) {
      if (host._sortingId) {
        return;
      }

      // make the ShadowHost identifiable (see cleanup() for undo)
      host._sortingId = 'shadow-' + this.hostCounter++;
      this.hosts[host._sortingId] = host;

      // hosts may contain other hosts
      var parentHost = (0, _shadowHost2.default)({ context: host });
      if (parentHost) {
        this._registerHost(parentHost);
        this._registerHostParent(host, parentHost);
      } else {
        this.inDocument.push(host);
      }
    }

    // remember which host is the child of which other host

  }, {
    key: '_registerHostParent',
    value: function _registerHostParent(host, parent) {
      if (!this.inHost[parent._sortingId]) {
        this.inHost[parent._sortingId] = [];
      }

      this.inHost[parent._sortingId].push(host);
    }

    // remember which elements a host contains

  }, {
    key: '_registerElement',
    value: function _registerElement(element, host) {
      if (!this.elements[host._sortingId]) {
        this.elements[host._sortingId] = [];
      }

      this.elements[host._sortingId].push(element);
    }

    // remove shadowed elements from the sequence and register
    // the ShadowHosts they belong to so we know what to sort
    // later on

  }, {
    key: 'extractElements',
    value: function extractElements(elements) {
      return elements.filter(function (element) {
        var host = (0, _shadowHost2.default)({ context: element });
        if (!host) {
          return true;
        }

        this._registerHost(host);
        this._registerElement(element, host);
        return false;
      }, this);
    }

    // inject hosts into the sequence, sort everything,
    // and recoursively replace hosts by its descendants

  }, {
    key: 'sort',
    value: function sort(elements) {
      var _elements = this._injectHosts(elements);
      _elements = this._replaceHosts(_elements);
      this._cleanup();
      return _elements;
    }

    // merge ShadowHosts into the element lists of other ShadowHosts
    // or the document, then sort the individual lists

  }, {
    key: '_injectHosts',
    value: function _injectHosts(elements) {
      Object.keys(this.hosts).forEach(function (_sortingId) {
        var _list = this.elements[_sortingId];
        var _elements = this.inHost[_sortingId];
        var _context = this.hosts[_sortingId].shadowRoot;
        this.elements[_sortingId] = this._merge(_list, _elements, _context);
      }, this);

      return this._merge(elements, this.inDocument, this.context);
    }
  }, {
    key: '_merge',
    value: function _merge(list, elements, context) {
      var merged = (0, _mergeDomOrder2.default)({
        list: list,
        elements: elements
      });

      return this.sortElements(merged, context);
    }
  }, {
    key: '_replaceHosts',
    value: function _replaceHosts(elements) {
      return (0, _mergeDomOrder2.default)({
        list: elements,
        elements: this.inDocument,
        resolveElement: this._resolveHostElement.bind(this)
      });
    }
  }, {
    key: '_resolveHostElement',
    value: function _resolveHostElement(host) {
      var merged = (0, _mergeDomOrder2.default)({
        list: this.elements[host._sortingId],
        elements: this.inHost[host._sortingId],
        resolveElement: this._resolveHostElement.bind(this)
      });

      var _tabindex = (0, _tabindexValue2.default)(host);
      if (_tabindex !== null && _tabindex > -1) {
        return [host].concat(merged);
      }

      return merged;
    }
  }, {
    key: '_cleanup',
    value: function _cleanup() {
      // remove those identifers we put on the ShadowHost to avoid using Map()
      Object.keys(this.hosts).forEach(function (key) {
        delete this.hosts[key]._sortingId;
      }, this);
    }
  }]);

  return Shadows;
}();

module.exports = exports['default'];
//# sourceMappingURL=tabsequence.sort-shadowed.js.map

/***/ }),

/***/ "./node_modules/ally.js/query/tabsequence.sort-tabindex.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ally.js/query/tabsequence.sort-tabindex.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (elements) {
  // https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement.tabIndex
  // elements with tabIndex "0" (including tabbableElements without tabIndex) should be navigated in the order they appear.
  // elements with a positive tabIndex:
  //   Elements that have identical tabIndexes should be navigated in the order they appear.
  //   Navigation proceeds from the lowest tabIndex to the highest tabIndex.

  // NOTE: sort implementation may be unstable and thus mess up DOM order,
  // that's why we build a map that's being sorted instead. If we were able to rely
  // on a stable sorting algorithm, sortTabindex() could be as simple as
  // elements.sort(function(a, b) { return a.tabIndex - b.tabIndex; });
  // at this time Chrome does not use a stable sorting algorithm
  // see http://blog.rodneyrehm.de/archives/14-Sorting-Were-Doing-It-Wrong.html#stability

  // NOTE: compareDocumentPosition seemed like more overhead than just sorting this with buckets
  // https://developer.mozilla.org/en-US/docs/Web/API/Node.compareDocumentPosition

  var map = {};
  var indexes = [];
  var normal = elements.filter(function (element) {
    // in Trident and Gecko SVGElement does not know about the tabIndex property
    var tabIndex = element.tabIndex;
    if (tabIndex === undefined) {
      tabIndex = (0, _tabindexValue2.default)(element);
    }

    // extract elements that don't need sorting
    if (tabIndex <= 0 || tabIndex === null || tabIndex === undefined) {
      return true;
    }

    if (!map[tabIndex]) {
      // create sortable bucket for dom-order-preservation of elements with the same tabIndex
      map[tabIndex] = [];
      // maintain a list of unique tabIndexes
      indexes.push(tabIndex);
    }

    // sort element into the proper bucket
    map[tabIndex].push(element);
    // element moved to sorting map, so not "normal" anymore
    return false;
  });

  // sort the tabindex ascending,
  // then resolve them to their appropriate buckets,
  // then flatten the array of arrays to an array
  var _elements = indexes.sort().map(function (tabIndex) {
    return map[tabIndex];
  }).reduceRight(function (previous, current) {
    return current.concat(previous);
  }, normal);

  return _elements;
};

var _tabindexValue = __webpack_require__(/*! ../util/tabindex-value */ "./node_modules/ally.js/util/tabindex-value.js");

var _tabindexValue2 = _interopRequireDefault(_tabindexValue);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

module.exports = exports['default'];
//# sourceMappingURL=tabsequence.sort-tabindex.js.map

/***/ }),

/***/ "./node_modules/ally.js/selector/focusable.js":
/*!****************************************************!*\
  !*** ./node_modules/ally.js/selector/focusable.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function () {
  if (!supports) {
    supports = (0, _supports3.default)();
  }

  if (typeof selector === 'string') {
    return selector;
  }

  // https://www.w3.org/TR/html5/editing.html#sequential-focus-navigation-and-the-tabindex-attribute
  selector = ''
  // IE11 supports.can focus <table> and <td>
  + (supports.focusTable ? 'table, td,' : '')
  // IE11 supports.can focus <fieldset>
  + (supports.focusFieldset ? 'fieldset,' : '')
  // Namespace problems of [xlink:href] explained in https://stackoverflow.com/a/23047888/515124
  // svg a[*|href] does not match in IE9, but since we're filtering
  // through is/focusable we can include all <a> from SVG
  + 'svg a,'
  // may behave as 'svg, svg *,' in chrome as *every* svg element with a focus event listener is focusable
  // navigational elements
  + 'a[href],'
  // validity determined by is/valid-area.js
  + 'area[href],'
  // validity determined by is/disabled.js
  + 'input, select, textarea, button,'
  // browsing context containers
  + 'iframe, object, embed,'
  // interactive content
  + 'keygen,' + (supports.focusAudioWithoutControls ? 'audio,' : 'audio[controls],') + (supports.focusVideoWithoutControls ? 'video,' : 'video[controls],') + (supports.focusSummary ? 'summary,' : '')
  // validity determined by is/valid-tabindex.js
  + '[tabindex],'
  // editing hosts
  + '[contenteditable]';

  // where ShadowDOM is supported, we also want the shadowed focusable elements (via ">>>" or "/deep/")
  selector = (0, _selectInShadows2.default)(selector);

  return selector;
};

var _selectInShadows = __webpack_require__(/*! ../util/select-in-shadows */ "./node_modules/ally.js/util/select-in-shadows.js");

var _selectInShadows2 = _interopRequireDefault(_selectInShadows);

var _supports2 = __webpack_require__(/*! ../supports/supports */ "./node_modules/ally.js/supports/supports.js");

var _supports3 = _interopRequireDefault(_supports2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// NOTE: this selector MUST *never* be used directly,
// always go through query/focusable or is/focusable.js
// there are too many edge cases that they could be covered in
// a simple CSS selector

var supports = void 0;

var selector = void 0;

module.exports = exports['default'];
//# sourceMappingURL=focusable.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/css-shadow-piercing-deep-combinator.js":
/*!******************************************************************************!*\
  !*** ./node_modules/ally.js/supports/css-shadow-piercing-deep-combinator.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function () {
  var combinator = void 0;

  // see https://dev.w3.org/csswg/css-scoping-1/#deep-combinator
  // https://bugzilla.mozilla.org/show_bug.cgi?id=1117572
  // https://code.google.com/p/chromium/issues/detail?id=446051
  try {
    document.querySelector('html >>> :first-child');
    combinator = '>>>';
  } catch (noArrowArrowArrow) {
    try {
      // old syntax supported at least up to Chrome 41
      // https://code.google.com/p/chromium/issues/detail?id=446051
      document.querySelector('html /deep/ :first-child');
      combinator = '/deep/';
    } catch (noDeep) {
      combinator = '';
    }
  }

  return combinator;
};

module.exports = exports['default'];
//# sourceMappingURL=css-shadow-piercing-deep-combinator.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/detect-focus.js":
/*!*******************************************************!*\
  !*** ./node_modules/ally.js/supports/detect-focus.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (tests) {
  var data = before();

  var results = {};
  Object.keys(tests).map(function (key) {
    results[key] = test(data, tests[key]);
  });

  after(data);
  return results;
};

var _platform = __webpack_require__(/*! ../util/platform */ "./node_modules/ally.js/util/platform.js");

var _platform2 = _interopRequireDefault(_platform);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function before() {
  var data = {
    // remember what had focus to restore after test
    activeElement: document.activeElement,
    // remember scroll positions to restore after test
    windowScrollTop: window.scrollTop,
    windowScrollLeft: window.scrollLeft,
    bodyScrollTop: document.body.scrollTop,
    bodyScrollLeft: document.body.scrollLeft
  };

  // wrap tests in an element hidden from screen readers to prevent them
  // from announcing focus, which can be quite irritating to the user
  var iframe = document.createElement('iframe');
  iframe.setAttribute('style', 'position:absolute; position:fixed; top:0; left:-2px; width:1px; height:1px; overflow:hidden;');
  iframe.setAttribute('aria-live', 'off');
  iframe.setAttribute('aria-busy', 'true');
  iframe.setAttribute('aria-hidden', 'true');
  document.body.appendChild(iframe);

  var _window = iframe.contentWindow;
  var _document = _window.document;

  _document.open();
  _document.close();
  var wrapper = _document.createElement('div');
  _document.body.appendChild(wrapper);

  data.iframe = iframe;
  data.wrapper = wrapper;
  data.window = _window;
  data.document = _document;

  return data;
}

// options.element:
//  {string} element name
//  {function} callback(wrapper, document) to generate an element
// options.mutate: (optional)
//  {function} callback(element, wrapper, document) to manipulate element prior to focus-test.
//             Can return DOMElement to define focus target (default: element)
// options.validate: (optional)
//  {function} callback(element, focusTarget, document) to manipulate test-result
function test(data, options) {
  // make sure we operate on a clean slate
  data.wrapper.innerHTML = '';
  // create dummy element to test focusability of
  var element = typeof options.element === 'string' ? data.document.createElement(options.element) : options.element(data.wrapper, data.document);
  // allow callback to further specify dummy element
  // and optionally define element to focus
  var focus = options.mutate && options.mutate(element, data.wrapper, data.document);
  if (!focus && focus !== false) {
    focus = element;
  }
  // element needs to be part of the DOM to be focusable
  !element.parentNode && data.wrapper.appendChild(element);
  // test if the element with invalid tabindex can be focused
  focus && focus.focus && focus.focus();
  // validate test's result
  return options.validate ? options.validate(element, focus, data.document) : data.document.activeElement === focus;
}

function after(data) {
  // restore focus to what it was before test and cleanup
  if (data.activeElement === document.body) {
    document.activeElement && document.activeElement.blur && document.activeElement.blur();
    if (_platform2.default.is.IE10) {
      // IE10 does not redirect focus to <body> when the activeElement is removed
      document.body.focus();
    }
  } else {
    data.activeElement && data.activeElement.focus && data.activeElement.focus();
  }

  document.body.removeChild(data.iframe);

  // restore scroll position
  window.scrollTop = data.windowScrollTop;
  window.scrollLeft = data.windowScrollLeft;
  document.body.scrollTop = data.bodyScrollTop;
  document.body.scrollLeft = data.bodyScrollLeft;
}

module.exports = exports['default'];
//# sourceMappingURL=detect-focus.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-area-img-tabindex.js":
/*!******************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-area-img-tabindex.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _gif = __webpack_require__(/*! ./media/gif */ "./node_modules/ally.js/supports/media/gif.js");

var _gif2 = _interopRequireDefault(_gif);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img#attr-usemap
exports.default = {
  element: 'div',
  mutate: function mutate(element) {
    element.innerHTML = '<map name="image-map-tabindex-test">' + '<area shape="rect" coords="63,19,144,45"></map>' + '<img usemap="#image-map-tabindex-test" tabindex="-1" alt="" src="' + _gif2.default + '">';

    return element.querySelector('area');
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-area-img-tabindex.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-area-tabindex.js":
/*!**************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-area-tabindex.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _gif = __webpack_require__(/*! ./media/gif */ "./node_modules/ally.js/supports/media/gif.js");

var _gif2 = _interopRequireDefault(_gif);

var _platform = __webpack_require__(/*! ../util/platform */ "./node_modules/ally.js/util/platform.js");

var _platform2 = _interopRequireDefault(_platform);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img#attr-usemap
exports.default = {
  element: 'div',
  mutate: function mutate(element) {
    element.innerHTML = '<map name="image-map-tabindex-test">' + '<area href="#void" tabindex="-1" shape="rect" coords="63,19,144,45"></map>' + '<img usemap="#image-map-tabindex-test" alt="" src="' + _gif2.default + '">';

    return false;
  },
  validate: function validate(element, focusTarget, _document) {
    if (_platform2.default.is.GECKO) {
      // fixes https://github.com/medialize/ally.js/issues/35
      // Firefox loads the DataURI asynchronously, causing a false-negative
      return true;
    }

    var focus = element.querySelector('area');
    focus.focus();
    return _document.activeElement === focus;
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-area-tabindex.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-area-without-href.js":
/*!******************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-area-without-href.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _gif = __webpack_require__(/*! ./media/gif */ "./node_modules/ally.js/supports/media/gif.js");

var _gif2 = _interopRequireDefault(_gif);

var _platform = __webpack_require__(/*! ../util/platform */ "./node_modules/ally.js/util/platform.js");

var _platform2 = _interopRequireDefault(_platform);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img#attr-usemap
exports.default = {
  element: 'div',
  mutate: function mutate(element) {
    element.innerHTML = '<map name="image-map-area-href-test">' + '<area shape="rect" coords="63,19,144,45"></map>' + '<img usemap="#image-map-area-href-test" alt="" src="' + _gif2.default + '">';

    return element.querySelector('area');
  },
  validate: function validate(element, focusTarget, _document) {
    if (_platform2.default.is.GECKO) {
      // fixes https://github.com/medialize/ally.js/issues/35
      // Firefox loads the DataURI asynchronously, causing a false-negative
      return true;
    }

    return _document.activeElement === focusTarget;
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-area-without-href.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-audio-without-controls.js":
/*!***********************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-audio-without-controls.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _mp = __webpack_require__(/*! ./media/mp3 */ "./node_modules/ally.js/supports/media/mp3.js");

var _mp2 = _interopRequireDefault(_mp);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  name: 'can-focus-audio-without-controls',
  element: 'audio',
  mutate: function mutate(element) {
    try {
      // invalid media file can trigger warning in console, data-uri to prevent HTTP request
      element.setAttribute('src', _mp2.default);
    } catch (e) {
      // IE9 may throw "Error: Not implemented"
    }
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-audio-without-controls.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-broken-image-map.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-broken-image-map.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _gif = __webpack_require__(/*! ./media/gif.invalid */ "./node_modules/ally.js/supports/media/gif.invalid.js");

var _gif2 = _interopRequireDefault(_gif);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// NOTE: https://github.com/medialize/ally.js/issues/35
// https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img#attr-usemap
exports.default = {
  element: 'div',
  mutate: function mutate(element) {
    element.innerHTML = '<map name="broken-image-map-test"><area href="#void" shape="rect" coords="63,19,144,45"></map>' + '<img usemap="#broken-image-map-test" alt="" src="' + _gif2.default + '">';

    return element.querySelector('area');
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-broken-image-map.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-children-of-focusable-flexbox.js":
/*!******************************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-children-of-focusable-flexbox.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

// Children of focusable elements with display:flex are focusable in IE10-11
exports.default = {
  element: 'div',
  mutate: function mutate(element) {
    element.setAttribute('tabindex', '-1');
    element.setAttribute('style', 'display: -webkit-flex; display: -ms-flexbox; display: flex;');
    element.innerHTML = '<span style="display: block;">hello</span>';
    return element.querySelector('span');
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-children-of-focusable-flexbox.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-fieldset-disabled.js":
/*!******************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-fieldset-disabled.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

// fieldset[tabindex=0][disabled] should not be focusable, but Blink and WebKit disagree
// @specification https://www.w3.org/TR/html5/disabled-elements.html#concept-element-disabled
// @browser-issue Chromium https://crbug.com/453847
// @browser-issue WebKit https://bugs.webkit.org/show_bug.cgi?id=141086
exports.default = {
  element: 'fieldset',
  mutate: function mutate(element) {
    element.setAttribute('tabindex', 0);
    element.setAttribute('disabled', 'disabled');
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-fieldset-disabled.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-fieldset.js":
/*!*********************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-fieldset.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = {
  element: 'fieldset',
  mutate: function mutate(element) {
    element.innerHTML = '<legend>legend</legend><p>content</p>';
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-fieldset.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-flexbox-container.js":
/*!******************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-flexbox-container.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

// elements with display:flex are focusable in IE10-11
exports.default = {
  element: 'span',
  mutate: function mutate(element) {
    element.setAttribute('style', 'display: -webkit-flex; display: -ms-flexbox; display: flex;');
    element.innerHTML = '<span style="display: block;">hello</span>';
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-flexbox-container.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-form-disabled.js":
/*!**************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-form-disabled.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

// form[tabindex=0][disabled] should be focusable as the
// specification doesn't know the disabled attribute on the form element
// @specification https://www.w3.org/TR/html5/forms.html#the-form-element
exports.default = {
  element: 'form',
  mutate: function mutate(element) {
    element.setAttribute('tabindex', 0);
    element.setAttribute('disabled', 'disabled');
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-form-disabled.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-img-ismap.js":
/*!**********************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-img-ismap.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _gif = __webpack_require__(/*! ./media/gif */ "./node_modules/ally.js/supports/media/gif.js");

var _gif2 = _interopRequireDefault(_gif);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// NOTE: https://github.com/medialize/ally.js/issues/35
// fixes https://github.com/medialize/ally.js/issues/20
// https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img#attr-ismap
exports.default = {
  element: 'a',
  mutate: function mutate(element) {
    element.href = '#void';
    element.innerHTML = '<img ismap src="' + _gif2.default + '" alt="">';
    return element.querySelector('img');
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-img-ismap.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-img-usemap-tabindex.js":
/*!********************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-img-usemap-tabindex.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _gif = __webpack_require__(/*! ./media/gif */ "./node_modules/ally.js/supports/media/gif.js");

var _gif2 = _interopRequireDefault(_gif);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// NOTE: https://github.com/medialize/ally.js/issues/35
// https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img#attr-usemap
exports.default = {
  element: 'div',
  mutate: function mutate(element) {
    element.innerHTML = '<map name="image-map-tabindex-test"><area href="#void" shape="rect" coords="63,19,144,45"></map>' + '<img usemap="#image-map-tabindex-test" tabindex="-1" alt="" ' + 'src="' + _gif2.default + '">';

    return element.querySelector('img');
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-img-usemap-tabindex.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-in-hidden-iframe.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-in-hidden-iframe.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = {
  element: function element(wrapper, _document) {
    var iframe = _document.createElement('iframe');

    // iframe must be part of the DOM before accessing the contentWindow is possible
    wrapper.appendChild(iframe);

    // create the iframe's default document (<html><head></head><body></body></html>)
    var iframeDocument = iframe.contentWindow.document;
    iframeDocument.open();
    iframeDocument.close();
    return iframe;
  },
  mutate: function mutate(iframe) {
    iframe.style.visibility = 'hidden';

    var iframeDocument = iframe.contentWindow.document;
    var input = iframeDocument.createElement('input');
    iframeDocument.body.appendChild(input);
    return input;
  },
  validate: function validate(iframe) {
    var iframeDocument = iframe.contentWindow.document;
    var focus = iframeDocument.querySelector('input');
    return iframeDocument.activeElement === focus;
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-in-hidden-iframe.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-in-zero-dimension-object.js":
/*!*************************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-in-zero-dimension-object.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function () {
  return result;
};

var _platform = __webpack_require__(/*! ../util/platform */ "./node_modules/ally.js/util/platform.js");

var _platform2 = _interopRequireDefault(_platform);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var result = !_platform2.default.is.WEBKIT;

module.exports = exports['default'];
//# sourceMappingURL=focus-in-zero-dimension-object.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-invalid-tabindex.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-invalid-tabindex.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

// Firefox allows *any* value and treats invalid values like tabindex="-1"
// @browser-issue Gecko https://bugzilla.mozilla.org/show_bug.cgi?id=1128054
exports.default = {
  element: 'div',
  mutate: function mutate(element) {
    element.setAttribute('tabindex', 'invalid-value');
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-invalid-tabindex.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-label-tabindex.js":
/*!***************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-label-tabindex.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = {
  element: 'label',
  mutate: function mutate(element) {
    element.setAttribute('tabindex', '-1');
  },
  validate: function validate(element, focusTarget, _document) {
    // force layout in Chrome 49, otherwise the element won't be focusable
    /* eslint-disable no-unused-vars */
    var variableToPreventDeadCodeElimination = element.offsetHeight;
    /* eslint-enable no-unused-vars */
    element.focus();
    return _document.activeElement === element;
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-label-tabindex.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-object-svg-hidden.js":
/*!******************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-object-svg-hidden.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _svg = __webpack_require__(/*! ./media/svg */ "./node_modules/ally.js/supports/media/svg.js");

var _svg2 = _interopRequireDefault(_svg);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Note: IE10 on BrowserStack does not like this test

exports.default = {
  element: 'object',
  mutate: function mutate(element) {
    element.setAttribute('type', 'image/svg+xml');
    element.setAttribute('data', _svg2.default);
    element.setAttribute('width', '200');
    element.setAttribute('height', '50');
    element.style.visibility = 'hidden';
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-object-svg-hidden.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-object-svg.js":
/*!***********************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-object-svg.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _svg = __webpack_require__(/*! ./media/svg */ "./node_modules/ally.js/supports/media/svg.js");

var _svg2 = _interopRequireDefault(_svg);

var _platform = __webpack_require__(/*! ../util/platform */ "./node_modules/ally.js/util/platform.js");

var _platform2 = _interopRequireDefault(_platform);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Note: IE10 on BrowserStack does not like this test

exports.default = {
  name: 'can-focus-object-svg',
  element: 'object',
  mutate: function mutate(element) {
    element.setAttribute('type', 'image/svg+xml');
    element.setAttribute('data', _svg2.default);
    element.setAttribute('width', '200');
    element.setAttribute('height', '50');
  },
  validate: function validate(element, focusTarget, _document) {
    if (_platform2.default.is.GECKO) {
      // Firefox seems to be handling the object creation asynchronously and thereby produces a false negative test result.
      // Because we know Firefox is able to focus object elements referencing SVGs, we simply cheat by sniffing the user agent string
      return true;
    }

    return _document.activeElement === element;
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-object-svg.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-object-swf.js":
/*!***********************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-object-swf.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function () {
  return result;
};

var _platform = __webpack_require__(/*! ../util/platform */ "./node_modules/ally.js/util/platform.js");

var _platform2 = _interopRequireDefault(_platform);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Every Environment except IE9 considers SWF objects focusable
var result = !_platform2.default.is.IE9;

module.exports = exports['default'];
//# sourceMappingURL=focus-object-swf.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-redirect-img-usemap.js":
/*!********************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-redirect-img-usemap.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _gif = __webpack_require__(/*! ./media/gif */ "./node_modules/ally.js/supports/media/gif.js");

var _gif2 = _interopRequireDefault(_gif);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  element: 'div',
  mutate: function mutate(element) {
    element.innerHTML = '<map name="focus-redirect-img-usemap"><area href="#void" shape="rect" coords="63,19,144,45"></map>' + '<img usemap="#focus-redirect-img-usemap" alt="" ' + 'src="' + _gif2.default + '">';

    // focus the <img>, not the <div>
    return element.querySelector('img');
  },
  validate: function validate(element, focusTarget, _document) {
    var target = element.querySelector('area');
    return _document.activeElement === target;
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-redirect-img-usemap.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-redirect-legend.js":
/*!****************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-redirect-legend.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

// see https://jsbin.com/nenirisage/edit?html,js,console,output

exports.default = {
  element: 'fieldset',
  mutate: function mutate(element) {
    element.innerHTML = '<legend>legend</legend><input tabindex="-1"><input tabindex="0">';
    // take care of focus in validate();
    return false;
  },
  validate: function validate(element, focusTarget, _document) {
    var focusable = element.querySelector('input[tabindex="-1"]');
    var tabbable = element.querySelector('input[tabindex="0"]');

    // Firefox requires this test to focus the <fieldset> first, while this is not necessary in
    // https://jsbin.com/nenirisage/edit?html,js,console,output
    element.focus();

    element.querySelector('legend').focus();
    return _document.activeElement === focusable && 'focusable' || _document.activeElement === tabbable && 'tabbable' || '';
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-redirect-legend.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-scroll-body.js":
/*!************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-scroll-body.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

// https://github.com/medialize/ally.js/issues/21
exports.default = {
  element: 'div',
  mutate: function mutate(element) {
    element.setAttribute('style', 'width: 100px; height: 50px; overflow: auto;');
    element.innerHTML = '<div style="width: 500px; height: 40px;">scrollable content</div>';
    return element.querySelector('div');
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-scroll-body.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-scroll-container-without-overflow.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-scroll-container-without-overflow.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

// https://github.com/medialize/ally.js/issues/21
exports.default = {
  element: 'div',
  mutate: function mutate(element) {
    element.setAttribute('style', 'width: 100px; height: 50px;');
    element.innerHTML = '<div style="width: 500px; height: 40px;">scrollable content</div>';
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-scroll-container-without-overflow.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-scroll-container.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-scroll-container.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

// https://github.com/medialize/ally.js/issues/21
exports.default = {
  element: 'div',
  mutate: function mutate(element) {
    element.setAttribute('style', 'width: 100px; height: 50px; overflow: auto;');
    element.innerHTML = '<div style="width: 500px; height: 40px;">scrollable content</div>';
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-scroll-container.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-summary.js":
/*!********************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-summary.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = {
  element: 'details',
  mutate: function mutate(element) {
    element.innerHTML = '<summary>foo</summary><p>content</p>';
    return element.firstElementChild;
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-summary.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-svg-focusable-attribute.js":
/*!************************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-svg-focusable-attribute.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _svg = __webpack_require__(/*! ./helper/svg */ "./node_modules/ally.js/supports/helper/svg.js");

exports.default = {
  element: 'div',
  mutate: function mutate(element) {
    element.innerHTML = (0, _svg.generate)('<text focusable="true">a</text>');
    return element.querySelector('text');
  },
  validate: _svg.validate
};
module.exports = exports['default'];
//# sourceMappingURL=focus-svg-focusable-attribute.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-svg-foreignobject-tabindex.js":
/*!***************************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-svg-foreignobject-tabindex.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _svg = __webpack_require__(/*! ./helper/svg */ "./node_modules/ally.js/supports/helper/svg.js");

exports.default = {
  element: 'div',
  mutate: function mutate(element) {
    element.innerHTML = (0, _svg.generate)('<foreignObject tabindex="-1"><input type="text" /></foreignObject>');
    // Safari 8's quersSelector() can't identify foreignObject, but getElementyByTagName() can
    return element.querySelector('foreignObject') || element.getElementsByTagName('foreignObject')[0];
  },
  validate: _svg.validate

};
module.exports = exports['default'];
//# sourceMappingURL=focus-svg-foreignobject-tabindex.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-svg-in-iframe.js":
/*!**************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-svg-in-iframe.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function () {
  return result;
};

var _platform = __webpack_require__(/*! ../util/platform */ "./node_modules/ally.js/util/platform.js");

var _platform2 = _interopRequireDefault(_platform);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Firefox seems to be handling the SVG-document-in-iframe creation asynchronously
// and thereby produces a false negative test result. Thus the test is pointless
// and we resort to UA sniffing once again.
// see http://jsbin.com/vunadohoko/1/edit?js,console,output

var result = Boolean(_platform2.default.is.GECKO && typeof SVGElement !== 'undefined' && SVGElement.prototype.focus);

module.exports = exports['default'];
//# sourceMappingURL=focus-svg-in-iframe.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-svg-negative-tabindex-attribute.js":
/*!********************************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-svg-negative-tabindex-attribute.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _svg = __webpack_require__(/*! ./helper/svg */ "./node_modules/ally.js/supports/helper/svg.js");

exports.default = {
  element: 'div',
  mutate: function mutate(element) {
    element.innerHTML = (0, _svg.generate)('<text tabindex="-1">a</text>');
    return element.querySelector('text');
  },
  validate: _svg.validate
};
module.exports = exports['default'];
//# sourceMappingURL=focus-svg-negative-tabindex-attribute.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-svg-tabindex-attribute.js":
/*!***********************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-svg-tabindex-attribute.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _svg = __webpack_require__(/*! ./helper/svg */ "./node_modules/ally.js/supports/helper/svg.js");

exports.default = {
  element: 'div',
  mutate: function mutate(element) {
    element.innerHTML = (0, _svg.generate)('<text tabindex="0">a</text>');
    return element.querySelector('text');
  },
  validate: _svg.validate
};
module.exports = exports['default'];
//# sourceMappingURL=focus-svg-tabindex-attribute.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-svg-use-tabindex.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-svg-use-tabindex.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _svg = __webpack_require__(/*! ./helper/svg */ "./node_modules/ally.js/supports/helper/svg.js");

exports.default = {
  element: 'div',
  mutate: function mutate(element) {
    element.innerHTML = (0, _svg.generate)(['<g id="ally-test-target"><a xlink:href="#void"><text>link</text></a></g>', '<use xlink:href="#ally-test-target" x="0" y="0" tabindex="-1" />'].join(''));

    return element.querySelector('use');
  },
  validate: _svg.validate
};
module.exports = exports['default'];
//# sourceMappingURL=focus-svg-use-tabindex.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-svg.js":
/*!****************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-svg.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _svg = __webpack_require__(/*! ./helper/svg */ "./node_modules/ally.js/supports/helper/svg.js");

exports.default = {
  element: 'div',
  mutate: function mutate(element) {
    element.innerHTML = (0, _svg.generate)('');
    return element.firstChild;
  },
  validate: _svg.validate
};
module.exports = exports['default'];
//# sourceMappingURL=focus-svg.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-tabindex-trailing-characters.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-tabindex-trailing-characters.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

// Firefox allows *any* value and treats invalid values like tabindex="-1"
// @browser-issue Gecko https://bugzilla.mozilla.org/show_bug.cgi?id=1128054
exports.default = {
  element: 'div',
  mutate: function mutate(element) {
    element.setAttribute('tabindex', '3x');
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-tabindex-trailing-characters.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-table.js":
/*!******************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-table.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = {
  element: 'table',
  mutate: function mutate(element, wrapper, _document) {
    // IE9 has a problem replacing TBODY contents with innerHTML.
    // https://stackoverflow.com/a/8097055/515124
    // element.innerHTML = '<tr><td>cell</td></tr>';
    var fragment = _document.createDocumentFragment();
    fragment.innerHTML = '<tr><td>cell</td></tr>';
    element.appendChild(fragment);
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-table.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-video-without-controls.js":
/*!***********************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-video-without-controls.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _mp = __webpack_require__(/*! ./media/mp4 */ "./node_modules/ally.js/supports/media/mp4.js");

var _mp2 = _interopRequireDefault(_mp);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  element: 'video',
  mutate: function mutate(element) {
    try {
      // invalid media file can trigger warning in console, data-uri to prevent HTTP request
      element.setAttribute('src', _mp2.default);
    } catch (e) {
      // IE9 may throw "Error: Not implemented"
    }
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-video-without-controls.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/helper/svg.js":
/*!*****************************************************!*\
  !*** ./node_modules/ally.js/supports/helper/svg.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.generate = generate;
exports.focus = focus;
exports.validate = validate;

var _focus = __webpack_require__(/*! ../../element/focus.svg-foreign-object-hack */ "./node_modules/ally.js/element/focus.svg-foreign-object-hack.js");

var _focus2 = _interopRequireDefault(_focus);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function generate(element) {
  return '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">' + element + '</svg>';
}

function focus(element) {
  if (element.focus) {
    return;
  }

  try {
    HTMLElement.prototype.focus.call(element);
  } catch (e) {
    (0, _focus2.default)(element);
  }
}

function validate(element, focusTarget, _document) {
  focus(focusTarget);
  return _document.activeElement === focusTarget;
}
//# sourceMappingURL=svg.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/media/gif.invalid.js":
/*!************************************************************!*\
  !*** ./node_modules/ally.js/supports/media/gif.invalid.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ';
module.exports = exports['default'];
//# sourceMappingURL=gif.invalid.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/media/gif.js":
/*!****************************************************!*\
  !*** ./node_modules/ally.js/supports/media/gif.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
module.exports = exports['default'];
//# sourceMappingURL=gif.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/media/mp3.js":
/*!****************************************************!*\
  !*** ./node_modules/ally.js/supports/media/mp3.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _gif = __webpack_require__(/*! ./gif */ "./node_modules/ally.js/supports/media/gif.js");

var _gif2 = _interopRequireDefault(_gif);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _gif2.default;
// export default 'data:audio/mp3;base64,audio-focus-test';

module.exports = exports['default'];
//# sourceMappingURL=mp3.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/media/mp4.js":
/*!****************************************************!*\
  !*** ./node_modules/ally.js/supports/media/mp4.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _gif = __webpack_require__(/*! ./gif */ "./node_modules/ally.js/supports/media/gif.js");

var _gif2 = _interopRequireDefault(_gif);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _gif2.default;
// export default 'data:video/mp4;base64,video-focus-test';

module.exports = exports['default'];
//# sourceMappingURL=mp4.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/media/svg.js":
/*!****************************************************!*\
  !*** ./node_modules/ally.js/supports/media/svg.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtb' + 'G5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiBpZD0ic3ZnIj48dGV4dCB4PSIxMCIgeT0iMjAiIGlkPSJ' + 'zdmctbGluay10ZXh0Ij50ZXh0PC90ZXh0Pjwvc3ZnPg==';
module.exports = exports['default'];
//# sourceMappingURL=svg.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/supports-cache.js":
/*!*********************************************************!*\
  !*** ./node_modules/ally.js/supports/supports-cache.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _version = __webpack_require__(/*! ../version */ "./node_modules/ally.js/version.js");

var _version2 = _interopRequireDefault(_version);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function readLocalStorage(key) {
  // allow reading from storage to retrieve previous support results
  // even while the document does not have focus
  var data = void 0;

  try {
    data = window.localStorage && window.localStorage.getItem(key);
    data = data ? JSON.parse(data) : {};
  } catch (e) {
    data = {};
  }

  return data;
} /*
      Facility to cache test results in localStorage.
  
      USAGE:
        cache.get('key');
        cache.set('key', 'value');
   */

function writeLocalStorage(key, value) {
  if (!document.hasFocus()) {
    // if the document does not have focus when tests are executed, focus() may
    // not be handled properly and events may not be dispatched immediately.
    // This can happen when a document is reloaded while Developer Tools have focus.
    try {
      window.localStorage && window.localStorage.removeItem(key);
    } catch (e) {
      // ignore
    }

    return;
  }

  try {
    window.localStorage && window.localStorage.setItem(key, JSON.stringify(value));
  } catch (e) {
    // ignore
  }
}

var userAgent = typeof window !== 'undefined' && window.navigator.userAgent || '';
var cacheKey = 'ally-supports-cache';
var cache = readLocalStorage(cacheKey);

// update the cache if ally or the user agent changed (newer version, etc)
if (cache.userAgent !== userAgent || cache.version !== _version2.default) {
  cache = {};
}

cache.userAgent = userAgent;
cache.version = _version2.default;

exports.default = {
  get: function get() {
    return cache;
  },
  set: function set(values) {
    Object.keys(values).forEach(function (key) {
      cache[key] = values[key];
    });

    cache.time = new Date().toISOString();
    writeLocalStorage(cacheKey, cache);
  }
};
module.exports = exports['default'];
//# sourceMappingURL=supports-cache.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/supports.js":
/*!***************************************************!*\
  !*** ./node_modules/ally.js/supports/supports.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function () {
  if (supportsCache) {
    return supportsCache;
  }

  supportsCache = _supportsCache2.default.get();
  if (!supportsCache.time) {
    _supportsCache2.default.set(executeTests());
    supportsCache = _supportsCache2.default.get();
  }

  return supportsCache;
};

var _detectFocus = __webpack_require__(/*! ./detect-focus */ "./node_modules/ally.js/supports/detect-focus.js");

var _detectFocus2 = _interopRequireDefault(_detectFocus);

var _supportsCache = __webpack_require__(/*! ./supports-cache */ "./node_modules/ally.js/supports/supports-cache.js");

var _supportsCache2 = _interopRequireDefault(_supportsCache);

var _cssShadowPiercingDeepCombinator = __webpack_require__(/*! ./css-shadow-piercing-deep-combinator */ "./node_modules/ally.js/supports/css-shadow-piercing-deep-combinator.js");

var _cssShadowPiercingDeepCombinator2 = _interopRequireDefault(_cssShadowPiercingDeepCombinator);

var _focusAreaImgTabindex = __webpack_require__(/*! ./focus-area-img-tabindex */ "./node_modules/ally.js/supports/focus-area-img-tabindex.js");

var _focusAreaImgTabindex2 = _interopRequireDefault(_focusAreaImgTabindex);

var _focusAreaTabindex = __webpack_require__(/*! ./focus-area-tabindex */ "./node_modules/ally.js/supports/focus-area-tabindex.js");

var _focusAreaTabindex2 = _interopRequireDefault(_focusAreaTabindex);

var _focusAreaWithoutHref = __webpack_require__(/*! ./focus-area-without-href */ "./node_modules/ally.js/supports/focus-area-without-href.js");

var _focusAreaWithoutHref2 = _interopRequireDefault(_focusAreaWithoutHref);

var _focusAudioWithoutControls = __webpack_require__(/*! ./focus-audio-without-controls */ "./node_modules/ally.js/supports/focus-audio-without-controls.js");

var _focusAudioWithoutControls2 = _interopRequireDefault(_focusAudioWithoutControls);

var _focusBrokenImageMap = __webpack_require__(/*! ./focus-broken-image-map */ "./node_modules/ally.js/supports/focus-broken-image-map.js");

var _focusBrokenImageMap2 = _interopRequireDefault(_focusBrokenImageMap);

var _focusChildrenOfFocusableFlexbox = __webpack_require__(/*! ./focus-children-of-focusable-flexbox */ "./node_modules/ally.js/supports/focus-children-of-focusable-flexbox.js");

var _focusChildrenOfFocusableFlexbox2 = _interopRequireDefault(_focusChildrenOfFocusableFlexbox);

var _focusFieldsetDisabled = __webpack_require__(/*! ./focus-fieldset-disabled */ "./node_modules/ally.js/supports/focus-fieldset-disabled.js");

var _focusFieldsetDisabled2 = _interopRequireDefault(_focusFieldsetDisabled);

var _focusFieldset = __webpack_require__(/*! ./focus-fieldset */ "./node_modules/ally.js/supports/focus-fieldset.js");

var _focusFieldset2 = _interopRequireDefault(_focusFieldset);

var _focusFlexboxContainer = __webpack_require__(/*! ./focus-flexbox-container */ "./node_modules/ally.js/supports/focus-flexbox-container.js");

var _focusFlexboxContainer2 = _interopRequireDefault(_focusFlexboxContainer);

var _focusFormDisabled = __webpack_require__(/*! ./focus-form-disabled */ "./node_modules/ally.js/supports/focus-form-disabled.js");

var _focusFormDisabled2 = _interopRequireDefault(_focusFormDisabled);

var _focusImgIsmap = __webpack_require__(/*! ./focus-img-ismap */ "./node_modules/ally.js/supports/focus-img-ismap.js");

var _focusImgIsmap2 = _interopRequireDefault(_focusImgIsmap);

var _focusImgUsemapTabindex = __webpack_require__(/*! ./focus-img-usemap-tabindex */ "./node_modules/ally.js/supports/focus-img-usemap-tabindex.js");

var _focusImgUsemapTabindex2 = _interopRequireDefault(_focusImgUsemapTabindex);

var _focusInHiddenIframe = __webpack_require__(/*! ./focus-in-hidden-iframe */ "./node_modules/ally.js/supports/focus-in-hidden-iframe.js");

var _focusInHiddenIframe2 = _interopRequireDefault(_focusInHiddenIframe);

var _focusInZeroDimensionObject = __webpack_require__(/*! ./focus-in-zero-dimension-object */ "./node_modules/ally.js/supports/focus-in-zero-dimension-object.js");

var _focusInZeroDimensionObject2 = _interopRequireDefault(_focusInZeroDimensionObject);

var _focusInvalidTabindex = __webpack_require__(/*! ./focus-invalid-tabindex */ "./node_modules/ally.js/supports/focus-invalid-tabindex.js");

var _focusInvalidTabindex2 = _interopRequireDefault(_focusInvalidTabindex);

var _focusLabelTabindex = __webpack_require__(/*! ./focus-label-tabindex */ "./node_modules/ally.js/supports/focus-label-tabindex.js");

var _focusLabelTabindex2 = _interopRequireDefault(_focusLabelTabindex);

var _focusObjectSvgHidden = __webpack_require__(/*! ./focus-object-svg-hidden */ "./node_modules/ally.js/supports/focus-object-svg-hidden.js");

var _focusObjectSvgHidden2 = _interopRequireDefault(_focusObjectSvgHidden);

var _focusObjectSvg = __webpack_require__(/*! ./focus-object-svg */ "./node_modules/ally.js/supports/focus-object-svg.js");

var _focusObjectSvg2 = _interopRequireDefault(_focusObjectSvg);

var _focusObjectSwf = __webpack_require__(/*! ./focus-object-swf */ "./node_modules/ally.js/supports/focus-object-swf.js");

var _focusObjectSwf2 = _interopRequireDefault(_focusObjectSwf);

var _focusRedirectImgUsemap = __webpack_require__(/*! ./focus-redirect-img-usemap */ "./node_modules/ally.js/supports/focus-redirect-img-usemap.js");

var _focusRedirectImgUsemap2 = _interopRequireDefault(_focusRedirectImgUsemap);

var _focusRedirectLegend = __webpack_require__(/*! ./focus-redirect-legend */ "./node_modules/ally.js/supports/focus-redirect-legend.js");

var _focusRedirectLegend2 = _interopRequireDefault(_focusRedirectLegend);

var _focusScrollBody = __webpack_require__(/*! ./focus-scroll-body */ "./node_modules/ally.js/supports/focus-scroll-body.js");

var _focusScrollBody2 = _interopRequireDefault(_focusScrollBody);

var _focusScrollContainerWithoutOverflow = __webpack_require__(/*! ./focus-scroll-container-without-overflow */ "./node_modules/ally.js/supports/focus-scroll-container-without-overflow.js");

var _focusScrollContainerWithoutOverflow2 = _interopRequireDefault(_focusScrollContainerWithoutOverflow);

var _focusScrollContainer = __webpack_require__(/*! ./focus-scroll-container */ "./node_modules/ally.js/supports/focus-scroll-container.js");

var _focusScrollContainer2 = _interopRequireDefault(_focusScrollContainer);

var _focusSummary = __webpack_require__(/*! ./focus-summary */ "./node_modules/ally.js/supports/focus-summary.js");

var _focusSummary2 = _interopRequireDefault(_focusSummary);

var _focusSvgFocusableAttribute = __webpack_require__(/*! ./focus-svg-focusable-attribute */ "./node_modules/ally.js/supports/focus-svg-focusable-attribute.js");

var _focusSvgFocusableAttribute2 = _interopRequireDefault(_focusSvgFocusableAttribute);

var _focusSvgTabindexAttribute = __webpack_require__(/*! ./focus-svg-tabindex-attribute */ "./node_modules/ally.js/supports/focus-svg-tabindex-attribute.js");

var _focusSvgTabindexAttribute2 = _interopRequireDefault(_focusSvgTabindexAttribute);

var _focusSvgNegativeTabindexAttribute = __webpack_require__(/*! ./focus-svg-negative-tabindex-attribute */ "./node_modules/ally.js/supports/focus-svg-negative-tabindex-attribute.js");

var _focusSvgNegativeTabindexAttribute2 = _interopRequireDefault(_focusSvgNegativeTabindexAttribute);

var _focusSvgUseTabindex = __webpack_require__(/*! ./focus-svg-use-tabindex */ "./node_modules/ally.js/supports/focus-svg-use-tabindex.js");

var _focusSvgUseTabindex2 = _interopRequireDefault(_focusSvgUseTabindex);

var _focusSvgForeignobjectTabindex = __webpack_require__(/*! ./focus-svg-foreignobject-tabindex */ "./node_modules/ally.js/supports/focus-svg-foreignobject-tabindex.js");

var _focusSvgForeignobjectTabindex2 = _interopRequireDefault(_focusSvgForeignobjectTabindex);

var _focusSvgInIframe = __webpack_require__(/*! ./focus-svg-in-iframe */ "./node_modules/ally.js/supports/focus-svg-in-iframe.js");

var _focusSvgInIframe2 = _interopRequireDefault(_focusSvgInIframe);

var _focusSvg = __webpack_require__(/*! ./focus-svg */ "./node_modules/ally.js/supports/focus-svg.js");

var _focusSvg2 = _interopRequireDefault(_focusSvg);

var _focusTabindexTrailingCharacters = __webpack_require__(/*! ./focus-tabindex-trailing-characters */ "./node_modules/ally.js/supports/focus-tabindex-trailing-characters.js");

var _focusTabindexTrailingCharacters2 = _interopRequireDefault(_focusTabindexTrailingCharacters);

var _focusTable = __webpack_require__(/*! ./focus-table */ "./node_modules/ally.js/supports/focus-table.js");

var _focusTable2 = _interopRequireDefault(_focusTable);

var _focusVideoWithoutControls = __webpack_require__(/*! ./focus-video-without-controls */ "./node_modules/ally.js/supports/focus-video-without-controls.js");

var _focusVideoWithoutControls2 = _interopRequireDefault(_focusVideoWithoutControls);

var _tabsequenceAreaAtImgPosition = __webpack_require__(/*! ./tabsequence-area-at-img-position */ "./node_modules/ally.js/supports/tabsequence-area-at-img-position.js");

var _tabsequenceAreaAtImgPosition2 = _interopRequireDefault(_tabsequenceAreaAtImgPosition);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var testCallbacks = {
  cssShadowPiercingDeepCombinator: _cssShadowPiercingDeepCombinator2.default,
  focusInZeroDimensionObject: _focusInZeroDimensionObject2.default,
  focusObjectSwf: _focusObjectSwf2.default,
  focusSvgInIframe: _focusSvgInIframe2.default,
  tabsequenceAreaAtImgPosition: _tabsequenceAreaAtImgPosition2.default
};

var testDescriptions = {
  focusAreaImgTabindex: _focusAreaImgTabindex2.default,
  focusAreaTabindex: _focusAreaTabindex2.default,
  focusAreaWithoutHref: _focusAreaWithoutHref2.default,
  focusAudioWithoutControls: _focusAudioWithoutControls2.default,
  focusBrokenImageMap: _focusBrokenImageMap2.default,
  focusChildrenOfFocusableFlexbox: _focusChildrenOfFocusableFlexbox2.default,
  focusFieldsetDisabled: _focusFieldsetDisabled2.default,
  focusFieldset: _focusFieldset2.default,
  focusFlexboxContainer: _focusFlexboxContainer2.default,
  focusFormDisabled: _focusFormDisabled2.default,
  focusImgIsmap: _focusImgIsmap2.default,
  focusImgUsemapTabindex: _focusImgUsemapTabindex2.default,
  focusInHiddenIframe: _focusInHiddenIframe2.default,
  focusInvalidTabindex: _focusInvalidTabindex2.default,
  focusLabelTabindex: _focusLabelTabindex2.default,
  focusObjectSvg: _focusObjectSvg2.default,
  focusObjectSvgHidden: _focusObjectSvgHidden2.default,
  focusRedirectImgUsemap: _focusRedirectImgUsemap2.default,
  focusRedirectLegend: _focusRedirectLegend2.default,
  focusScrollBody: _focusScrollBody2.default,
  focusScrollContainerWithoutOverflow: _focusScrollContainerWithoutOverflow2.default,
  focusScrollContainer: _focusScrollContainer2.default,
  focusSummary: _focusSummary2.default,
  focusSvgFocusableAttribute: _focusSvgFocusableAttribute2.default,
  focusSvgTabindexAttribute: _focusSvgTabindexAttribute2.default,
  focusSvgNegativeTabindexAttribute: _focusSvgNegativeTabindexAttribute2.default,
  focusSvgUseTabindex: _focusSvgUseTabindex2.default,
  focusSvgForeignobjectTabindex: _focusSvgForeignobjectTabindex2.default,
  focusSvg: _focusSvg2.default,
  focusTabindexTrailingCharacters: _focusTabindexTrailingCharacters2.default,
  focusTable: _focusTable2.default,
  focusVideoWithoutControls: _focusVideoWithoutControls2.default
};

function executeTests() {
  var results = (0, _detectFocus2.default)(testDescriptions);
  Object.keys(testCallbacks).forEach(function (key) {
    results[key] = testCallbacks[key]();
  });

  return results;
}

var supportsCache = null;

module.exports = exports['default'];
//# sourceMappingURL=supports.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/tabsequence-area-at-img-position.js":
/*!***************************************************************************!*\
  !*** ./node_modules/ally.js/supports/tabsequence-area-at-img-position.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function () {
  return result;
};

var _platform = __webpack_require__(/*! ../util/platform */ "./node_modules/ally.js/util/platform.js");

var _platform2 = _interopRequireDefault(_platform);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// https://jsbin.com/vafaba/3/edit?html,js,console,output
var result = _platform2.default.is.GECKO || _platform2.default.is.TRIDENT || _platform2.default.is.EDGE;

module.exports = exports['default'];
//# sourceMappingURL=tabsequence-area-at-img-position.js.map

/***/ }),

/***/ "./node_modules/ally.js/util/array-find-index.js":
/*!*******************************************************!*\
  !*** ./node_modules/ally.js/util/array-find-index.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = findIndex;
function findIndex(array, callback) {
  // attempt to use native or polyfilled Array#findIndex first
  if (array.findIndex) {
    return array.findIndex(callback);
  }

  var length = array.length;

  // shortcut if the array is empty
  if (length === 0) {
    return -1;
  }

  // otherwise loop over array
  for (var i = 0; i < length; i++) {
    if (callback(array[i], i, array)) {
      return i;
    }
  }

  return -1;
}
module.exports = exports["default"];
//# sourceMappingURL=array-find-index.js.map

/***/ }),

/***/ "./node_modules/ally.js/util/compare-position.js":
/*!*******************************************************!*\
  !*** ./node_modules/ally.js/util/compare-position.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getParentComparator = getParentComparator;

// Node.compareDocumentPosition is available since IE9
// see https://developer.mozilla.org/en-US/docs/Web/API/Node.compareDocumentPosition

// callback returns true when element is contained by parent or is the parent suited for use with Array.some()
/*
  USAGE:
    var isChildOf = getParentComparator({parent: someNode});
    listOfElements.some(isChildOf)
*/

function getParentComparator() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      parent = _ref.parent,
      element = _ref.element,
      includeSelf = _ref.includeSelf;

  if (parent) {
    return function isChildOf(node) {
      return Boolean(includeSelf && node === parent || parent.compareDocumentPosition(node) & Node.DOCUMENT_POSITION_CONTAINED_BY);
    };
  } else if (element) {
    return function isParentOf(node) {
      return Boolean(includeSelf && element === node || node.compareDocumentPosition(element) & Node.DOCUMENT_POSITION_CONTAINED_BY);
    };
  }

  throw new TypeError('util/compare-position#getParentComparator required either options.parent or options.element');
}
//# sourceMappingURL=compare-position.js.map

/***/ }),

/***/ "./node_modules/ally.js/util/context-to-element.js":
/*!*********************************************************!*\
  !*** ./node_modules/ally.js/util/context-to-element.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (_ref) {
  var context = _ref.context,
      _ref$label = _ref.label,
      label = _ref$label === undefined ? 'context-to-element' : _ref$label,
      resolveDocument = _ref.resolveDocument,
      defaultToDocument = _ref.defaultToDocument;

  var element = (0, _nodeArray2.default)(context)[0];

  if (resolveDocument && element && element.nodeType === Node.DOCUMENT_NODE) {
    element = element.documentElement;
  }

  if (!element && defaultToDocument) {
    return document.documentElement;
  }

  if (!element) {
    throw new TypeError(label + ' requires valid options.context');
  }

  if (element.nodeType !== Node.ELEMENT_NODE && element.nodeType !== Node.DOCUMENT_FRAGMENT_NODE) {
    throw new TypeError(label + ' requires options.context to be an Element');
  }

  return element;
};

var _nodeArray = __webpack_require__(/*! ../util/node-array */ "./node_modules/ally.js/util/node-array.js");

var _nodeArray2 = _interopRequireDefault(_nodeArray);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

module.exports = exports['default'];
//# sourceMappingURL=context-to-element.js.map

/***/ }),

/***/ "./node_modules/ally.js/util/element-matches.js":
/*!******************************************************!*\
  !*** ./node_modules/ally.js/util/element-matches.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = elementMatches;

// Element.prototype.matches may be available at a different name
// https://developer.mozilla.org/en/docs/Web/API/Element/matches

var names = ['matches', 'webkitMatchesSelector', 'mozMatchesSelector', 'msMatchesSelector'];
var name = null;

function findMethodName(element) {
  names.some(function (_name) {
    if (!element[_name]) {
      return false;
    }

    name = _name;
    return true;
  });
}

function elementMatches(element, selector) {
  if (!name) {
    findMethodName(element);
  }

  return element[name](selector);
}
module.exports = exports['default'];
//# sourceMappingURL=element-matches.js.map

/***/ }),

/***/ "./node_modules/ally.js/util/get-content-document.js":
/*!***********************************************************!*\
  !*** ./node_modules/ally.js/util/get-content-document.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (node) {
  try {
    // works on <object> and <iframe>
    return node.contentDocument
    // works on <object> and <iframe>
    || node.contentWindow && node.contentWindow.document
    // works on <object> and <iframe> that contain SVG
    || node.getSVGDocument && node.getSVGDocument() || null;
  } catch (e) {
    // SecurityError: Failed to read the 'contentDocument' property from 'HTMLObjectElement'
    // also IE may throw member not found exception e.g. on <object type="image/png">
    return null;
  }
};

module.exports = exports["default"];
//# sourceMappingURL=get-content-document.js.map

/***/ }),

/***/ "./node_modules/ally.js/util/get-document.js":
/*!***************************************************!*\
  !*** ./node_modules/ally.js/util/get-document.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (node) {
  if (!node) {
    return document;
  }

  if (node.nodeType === Node.DOCUMENT_NODE) {
    return node;
  }

  return node.ownerDocument || document;
};

module.exports = exports["default"];
//# sourceMappingURL=get-document.js.map

/***/ }),

/***/ "./node_modules/ally.js/util/get-frame-element.js":
/*!********************************************************!*\
  !*** ./node_modules/ally.js/util/get-frame-element.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getFrameElement;

var _getContentDocument = __webpack_require__(/*! ./get-content-document */ "./node_modules/ally.js/util/get-content-document.js");

var _getContentDocument2 = _interopRequireDefault(_getContentDocument);

var _getWindow = __webpack_require__(/*! ./get-window */ "./node_modules/ally.js/util/get-window.js");

var _getWindow2 = _interopRequireDefault(_getWindow);

var _selectInShadows = __webpack_require__(/*! ./select-in-shadows */ "./node_modules/ally.js/util/select-in-shadows.js");

var _selectInShadows2 = _interopRequireDefault(_selectInShadows);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var selector = void 0;

function findDocumentHostElement(_window) {
  if (!selector) {
    selector = (0, _selectInShadows2.default)('object, iframe');
  }

  if (_window._frameElement !== undefined) {
    return _window._frameElement;
  }

  _window._frameElement = null;

  var potentialHosts = _window.parent.document.querySelectorAll(selector);
  [].some.call(potentialHosts, function (element) {
    var _document = (0, _getContentDocument2.default)(element);
    if (_document !== _window.document) {
      return false;
    }

    _window._frameElement = element;
    return true;
  });

  return _window._frameElement;
}

function getFrameElement(element) {
  var _window = (0, _getWindow2.default)(element);
  if (!_window.parent || _window.parent === _window) {
    // if there is no parent browsing context,
    // we're not going to get a frameElement either way
    return null;
  }

  try {
    // see https://developer.mozilla.org/en-US/docs/Web/API/Window/frameElement
    // does not work within <embed> anywhere, and not within in <object> in IE
    return _window.frameElement || findDocumentHostElement(_window);
  } catch (e) {
    return null;
  }
}
module.exports = exports['default'];
//# sourceMappingURL=get-frame-element.js.map

/***/ }),

/***/ "./node_modules/ally.js/util/get-window.js":
/*!*************************************************!*\
  !*** ./node_modules/ally.js/util/get-window.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (node) {
  var _document = (0, _getDocument2.default)(node);
  return _document.defaultView || window;
};

var _getDocument = __webpack_require__(/*! ./get-document */ "./node_modules/ally.js/util/get-document.js");

var _getDocument2 = _interopRequireDefault(_getDocument);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

module.exports = exports['default'];
//# sourceMappingURL=get-window.js.map

/***/ }),

/***/ "./node_modules/ally.js/util/image-map.js":
/*!************************************************!*\
  !*** ./node_modules/ally.js/util/image-map.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getMapByName = getMapByName;
exports.getMapOfImage = getMapOfImage;
exports.getImageOfArea = getImageOfArea;

var _css = __webpack_require__(/*! css.escape */ "./node_modules/css.escape/css.escape.js");

var _css2 = _interopRequireDefault(_css);

var _getDocument = __webpack_require__(/*! ../util/get-document */ "./node_modules/ally.js/util/get-document.js");

var _getDocument2 = _interopRequireDefault(_getDocument);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getMapByName(name, _document) {
  // apparently getElementsByName() also considers id attribute in IE & opera
  // https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByName
  var map = _document.querySelector('map[name="' + (0, _css2.default)(name) + '"]');
  return map || null;
}

function getMapOfImage(element) {
  var usemap = element.getAttribute('usemap');
  if (!usemap) {
    return null;
  }

  var _document = (0, _getDocument2.default)(element);
  return getMapByName(usemap.slice(1), _document);
}

function getImageOfArea(element) {
  var map = element.parentElement;

  if (!map.name || map.nodeName.toLowerCase() !== 'map') {
    return null;
  }

  // NOTE: image maps can also be applied to <object> with image content,
  // but no browser supports this at the moment

  // HTML5 specifies HTMLMapElement.images to be an HTMLCollection of all
  // <img> and <object> referencing the <map> element, but no browser implements this
  //   https://www.w3.org/TR/html5/embedded-content-0.html#the-map-element
  //   https://developer.mozilla.org/en-US/docs/Web/API/HTMLMapElement
  // the image must be valid and loaded for the map to take effect
  var _document = (0, _getDocument2.default)(element);
  return _document.querySelector('img[usemap="#' + (0, _css2.default)(map.name) + '"]') || null;
}
//# sourceMappingURL=image-map.js.map

/***/ }),

/***/ "./node_modules/ally.js/util/logger.js":
/*!*********************************************!*\
  !*** ./node_modules/ally.js/util/logger.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var noop = function noop() {};
var _console = {
  log: noop,
  debug: noop,
  info: noop,
  warn: noop,
  error: noop
};

exports.default = typeof console !== 'undefined' ? console : _console;
module.exports = exports['default'];
//# sourceMappingURL=logger.js.map

/***/ }),

/***/ "./node_modules/ally.js/util/merge-dom-order.js":
/*!******************************************************!*\
  !*** ./node_modules/ally.js/util/merge-dom-order.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function () {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      list = _ref.list,
      elements = _ref.elements,
      resolveElement = _ref.resolveElement;

  // operate on a copy so we don't mutate the original array
  var _list = list.slice(0);
  // make sure the elements we're injecting are provided in DOM order
  var _elements = (0, _nodeArray2.default)(elements).slice(0);
  (0, _sortDomOrder2.default)(_elements);
  // find the offsets within the target array (list) at which to inject
  // each individual element (from elements)
  var insertions = findInsertionOffsets(_list, _elements, resolveElement);
  // actually inject the elements into the target array at the identified positions
  insertElementsAtOffsets(_list, insertions);
  return _list;
};

var _arrayFindIndex = __webpack_require__(/*! ../util/array-find-index */ "./node_modules/ally.js/util/array-find-index.js");

var _arrayFindIndex2 = _interopRequireDefault(_arrayFindIndex);

var _nodeArray = __webpack_require__(/*! ./node-array */ "./node_modules/ally.js/util/node-array.js");

var _nodeArray2 = _interopRequireDefault(_nodeArray);

var _sortDomOrder = __webpack_require__(/*! ./sort-dom-order */ "./node_modules/ally.js/util/sort-dom-order.js");

var _sortDomOrder2 = _interopRequireDefault(_sortDomOrder);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getFirstSuccessorOffset(list, target) {
  // find the first element that comes AFTER the target element
  return (0, _arrayFindIndex2.default)(list, function (element) {
    return target.compareDocumentPosition(element) & Node.DOCUMENT_POSITION_FOLLOWING;
  });
}
// sort a list of elements into another list of elements in DOM order

/*
  USAGE:
    mergeDomOrder({
      // DOM ordered array of elements to use as base of merge
      list: [],
      // unordered array of elements to merge into base list
      elements: [],
      // callback function to resolve an element
      resolveElement: function(element) {
        // return null to skip
        // return element to replace insertion
        // return [element1, element2, ] to replace insertion with multiple elements
        return element;
      },
    })
*/

function findInsertionOffsets(list, elements, resolveElement) {
  // instead of mutating the elements list directly, remember position and map
  // to inject later, when we can do this more efficiently
  var insertions = [];
  elements.forEach(function (element) {
    var replace = true;
    var offset = list.indexOf(element);

    if (offset === -1) {
      // element is not in target list
      offset = getFirstSuccessorOffset(list, element);
      replace = false;
    }

    if (offset === -1) {
      // there is no successor in the tabsequence,
      // meaning the image must be the last element
      offset = list.length;
    }

    // allow the consumer to replace the injected element
    var injections = (0, _nodeArray2.default)(resolveElement ? resolveElement(element) : element);
    if (!injections.length) {
      // we can't inject zero elements
      return;
    }

    insertions.push({
      offset: offset,
      replace: replace,
      elements: injections
    });
  });

  return insertions;
}

function insertElementsAtOffsets(list, insertions) {
  // remember the number of elements we have already injected
  // so we account for the caused index offset
  var inserted = 0;
  // make sure that we insert the elements in sequence,
  // otherwise the offset compensation won't work
  insertions.sort(function (a, b) {
    return a.offset - b.offset;
  });
  insertions.forEach(function (insertion) {
    // array.splice has an annoying function signature :(
    var remove = insertion.replace ? 1 : 0;
    var args = [insertion.offset + inserted, remove].concat(insertion.elements);
    list.splice.apply(list, args);
    inserted += insertion.elements.length - remove;
  });
}

module.exports = exports['default'];
//# sourceMappingURL=merge-dom-order.js.map

/***/ }),

/***/ "./node_modules/ally.js/util/node-array.js":
/*!*************************************************!*\
  !*** ./node_modules/ally.js/util/node-array.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (input) {
  if (!input) {
    return [];
  }

  if (Array.isArray(input)) {
    return input;
  }

  // instanceof Node - does not work with iframes
  if (input.nodeType !== undefined) {
    return [input];
  }

  if (typeof input === 'string') {
    input = document.querySelectorAll(input);
  }

  if (input.length !== undefined) {
    return [].slice.call(input, 0);
  }

  throw new TypeError('unexpected input ' + String(input));
};

module.exports = exports['default'];
// input may be undefined, selector-tring, Node, NodeList, HTMLCollection, array of Nodes
// yes, to some extent this is a bad replica of jQuery's constructor function
//# sourceMappingURL=node-array.js.map

/***/ }),

/***/ "./node_modules/ally.js/util/platform.js":
/*!***********************************************!*\
  !*** ./node_modules/ally.js/util/platform.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _platform2 = __webpack_require__(/*! platform */ "./node_modules/platform/platform.js");

var _platform3 = _interopRequireDefault(_platform2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// deep clone of original platform
var platform = JSON.parse(JSON.stringify(_platform3.default));

// operating system

// sugar for https://github.com/bestiejs/platform.js
// make sure to ALWAYS reference the layout engine,
// even if it is not necessary for the condition,
// as this makes grepping for this stuff simpler

var os = platform.os.family || '';
var ANDROID = os === 'Android';
var WINDOWS = os.slice(0, 7) === 'Windows';
var OSX = os === 'OS X';
var IOS = os === 'iOS';

// layout
var BLINK = platform.layout === 'Blink';
var GECKO = platform.layout === 'Gecko';
var TRIDENT = platform.layout === 'Trident';
var EDGE = platform.layout === 'EdgeHTML';
var WEBKIT = platform.layout === 'WebKit';

// browser version (not layout engine version!)
var version = parseFloat(platform.version);
var majorVersion = Math.floor(version);
platform.majorVersion = majorVersion;

platform.is = {
  // operating system
  ANDROID: ANDROID,
  WINDOWS: WINDOWS,
  OSX: OSX,
  IOS: IOS,
  // layout
  BLINK: BLINK, // "Chrome", "Chrome Mobile", "Opera"
  GECKO: GECKO, // "Firefox"
  TRIDENT: TRIDENT, // "Internet Explorer"
  EDGE: EDGE, // "Microsoft Edge"
  WEBKIT: WEBKIT, // "Safari"
  // INTERNET EXPLORERS
  IE9: TRIDENT && majorVersion === 9,
  IE10: TRIDENT && majorVersion === 10,
  IE11: TRIDENT && majorVersion === 11
};

exports.default = platform;
module.exports = exports['default'];
//# sourceMappingURL=platform.js.map

/***/ }),

/***/ "./node_modules/ally.js/util/select-in-shadows.js":
/*!********************************************************!*\
  !*** ./node_modules/ally.js/util/select-in-shadows.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (selector) {
  if (typeof shadowPrefix !== 'string') {
    var operator = (0, _cssShadowPiercingDeepCombinator2.default)();
    if (operator) {
      shadowPrefix = ', html ' + operator + ' ';
    }
  }

  if (!shadowPrefix) {
    return selector;
  }

  return selector + shadowPrefix + selector.replace(/\s*,\s*/g, ',').split(',').join(shadowPrefix);
};

var _cssShadowPiercingDeepCombinator = __webpack_require__(/*! ../supports/css-shadow-piercing-deep-combinator */ "./node_modules/ally.js/supports/css-shadow-piercing-deep-combinator.js");

var _cssShadowPiercingDeepCombinator2 = _interopRequireDefault(_cssShadowPiercingDeepCombinator);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var shadowPrefix = void 0;
// convert a CSS selector so that it also pierces ShadowDOM
// takes ".a, #b" and turns it into ".a, #b, html >>> .a, html >>> #b"

module.exports = exports['default'];
//# sourceMappingURL=select-in-shadows.js.map

/***/ }),

/***/ "./node_modules/ally.js/util/sort-dom-order.js":
/*!*****************************************************!*\
  !*** ./node_modules/ally.js/util/sort-dom-order.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (elements) {
  return elements.sort(compareDomPosition);
};

// sorts a list of elements according to their order in the DOM

function compareDomPosition(a, b) {
  return a.compareDocumentPosition(b) & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : 1;
}

module.exports = exports["default"];
//# sourceMappingURL=sort-dom-order.js.map

/***/ }),

/***/ "./node_modules/ally.js/util/tabindex-value.js":
/*!*****************************************************!*\
  !*** ./node_modules/ally.js/util/tabindex-value.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (element) {
  if (!(0, _validTabindex2.default)(element)) {
    return null;
  }

  // Edge 14 has a capitalization problem on SVG elements,
  // see https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/9282058/
  var hasTabindex = element.hasAttribute('tabindex');
  var attributeName = hasTabindex ? 'tabindex' : 'tabIndex';

  // @browser-issue Gecko https://bugzilla.mozilla.org/show_bug.cgi?id=1128054
  var tabindex = parseInt(element.getAttribute(attributeName), 10);
  return isNaN(tabindex) ? -1 : tabindex;
};

var _validTabindex = __webpack_require__(/*! ../is/valid-tabindex */ "./node_modules/ally.js/is/valid-tabindex.js");

var _validTabindex2 = _interopRequireDefault(_validTabindex);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

module.exports = exports['default'];
//# sourceMappingURL=tabindex-value.js.map

/***/ }),

/***/ "./node_modules/ally.js/util/toggle-attribute-value.js":
/*!*************************************************************!*\
  !*** ./node_modules/ally.js/util/toggle-attribute-value.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (_ref) {
  var element = _ref.element,
      attribute = _ref.attribute,
      temporaryValue = _ref.temporaryValue,
      saveValue = _ref.saveValue;

  var temporaryAttribute = 'data-cached-' + attribute;

  if (temporaryValue !== undefined) {
    var _value = saveValue || element.getAttribute(attribute);
    element.setAttribute(temporaryAttribute, _value || '');
    element.setAttribute(attribute, temporaryValue);
  } else {
    var _value2 = element.getAttribute(temporaryAttribute);
    element.removeAttribute(temporaryAttribute);
    if (_value2 === '') {
      element.removeAttribute(attribute);
    } else {
      element.setAttribute(attribute, _value2);
    }
  }
};

module.exports = exports['default'];
// helper to turn
//  <div some-attribute="original">
// into
//  <div some-attribute="new" data-cached-some-attribute="original">
// and back
//# sourceMappingURL=toggle-attribute-value.js.map

/***/ }),

/***/ "./node_modules/ally.js/util/toggle-attribute.js":
/*!*******************************************************!*\
  !*** ./node_modules/ally.js/util/toggle-attribute.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (_ref) {
  var element = _ref.element,
      attribute = _ref.attribute;

  var temporaryAttribute = 'data-cached-' + attribute;
  var temporaryAttributeValue = element.getAttribute(temporaryAttribute);

  if (temporaryAttributeValue === null) {
    var _value = element.getAttribute(attribute);
    if (_value === null) {
      // can't remove what's not there
      return;
    }

    element.setAttribute(temporaryAttribute, _value || '');
    element.removeAttribute(attribute);
  } else {
    var _value2 = element.getAttribute(temporaryAttribute);
    element.removeAttribute(temporaryAttribute);
    element.setAttribute(attribute, _value2);
  }
};

module.exports = exports['default'];
// helper to turn
//  <div some-attribute="original">
// into
//  <div data-cached-some-attribute="original">
// and back
//# sourceMappingURL=toggle-attribute.js.map

/***/ }),

/***/ "./node_modules/ally.js/version.js":
/*!*****************************************!*\
  !*** ./node_modules/ally.js/version.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

// this file is overwritten by `npm run build:pre`
var version = '1.4.1';
exports.default = version;
module.exports = exports['default'];
//# sourceMappingURL=version.js.map

/***/ }),

/***/ "./node_modules/ally.js/when/key.binding.js":
/*!**************************************************!*\
  !*** ./node_modules/ally.js/when/key.binding.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (text) {
  return text.split(/\s+/).map(function (_text) {
    var tokens = _text.split('+');
    var _modifiers = resolveModifiers(tokens.slice(0, -1));
    var _keyCodes = resolveKey(tokens.slice(-1));
    return {
      keyCodes: _keyCodes,
      modifiers: _modifiers,
      matchModifiers: matchModifiers.bind(null, _modifiers)
    };
  });
};

var _keycode = __webpack_require__(/*! ../map/keycode */ "./node_modules/ally.js/map/keycode.js");

var _keycode2 = _interopRequireDefault(_keycode);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var modifier = {
  alt: 'altKey',
  ctrl: 'ctrlKey',
  meta: 'metaKey',
  shift: 'shiftKey'
};
/*
  decodes a key binding token to a JavaScript structure

  returns an array of objects:
    {
      // key name translated to keyCode (possibly more than one)
      keyCodes: [<number>],
      // translated modifiers
      modifiers: {
        altKey: null,   // ignore
        ctrKey: false,  // expect not pressed
        metaKey: true,  // expect pressed
        shiftKey: true, // expect pressed
      },
      // callback that returns true if event's
      // modifier keys match the expected state
      matchModifiers: function(event){},
    }
*/

var modifierSequence = Object.keys(modifier).map(function (name) {
  return modifier[name];
});

function createExpectedModifiers(ignoreModifiers) {
  var value = ignoreModifiers ? null : false;
  return {
    altKey: value,
    ctrlKey: value,
    metaKey: value,
    shiftKey: value
  };
}

function resolveModifiers(modifiers) {
  var ignoreModifiers = modifiers.indexOf('*') !== -1;
  var expected = createExpectedModifiers(ignoreModifiers);

  modifiers.forEach(function (token) {
    if (token === '*') {
      // we've already covered the all-in operator
      return;
    }

    // we want the modifier pressed
    var value = true;
    var operator = token.slice(0, 1);
    if (operator === '?') {
      // we don't care if the modifier is pressed
      value = null;
    } else if (operator === '!') {
      // we do not want the modifier pressed
      value = false;
    }

    if (value !== true) {
      // compensate for the modifier's operator
      token = token.slice(1);
    }

    var propertyName = modifier[token];
    if (!propertyName) {
      throw new TypeError('Unknown modifier "' + token + '"');
    }

    expected[propertyName] = value;
  });

  return expected;
}

function resolveKey(key) {
  var code = _keycode2.default[key] || parseInt(key, 10);
  if (!code || typeof code !== 'number' || isNaN(code)) {
    throw new TypeError('Unknown key "' + key + '"');
  }

  return [code].concat(_keycode2.default._alias[code] || []);
}

function matchModifiers(expected, event) {
  // returns true on match
  return !modifierSequence.some(function (prop) {
    // returns true on mismatch
    return typeof expected[prop] === 'boolean' && Boolean(event[prop]) !== expected[prop];
  });
}

module.exports = exports['default'];
//# sourceMappingURL=key.binding.js.map

/***/ }),

/***/ "./node_modules/ally.js/when/key.js":
/*!******************************************!*\
  !*** ./node_modules/ally.js/when/key.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function () {
  var map = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var bindings = {};

  var context = (0, _nodeArray2.default)(map.context)[0] || document.documentElement;
  delete map.context;
  var filter = (0, _nodeArray2.default)(map.filter);
  delete map.filter;

  var mapKeys = Object.keys(map);
  if (!mapKeys.length) {
    throw new TypeError('when/key requires at least one option key');
  }

  var registerBinding = function registerBinding(event) {
    event.keyCodes.forEach(function (code) {
      if (!bindings[code]) {
        bindings[code] = [];
      }

      bindings[code].push(event);
    });
  };

  mapKeys.forEach(function (text) {
    if (typeof map[text] !== 'function') {
      throw new TypeError('when/key requires option["' + text + '"] to be a function');
    }

    var addCallback = function addCallback(event) {
      event.callback = map[text];
      return event;
    };

    (0, _key2.default)(text).map(addCallback).forEach(registerBinding);
  });

  var handleKeyDown = function handleKeyDown(event) {
    if (event.defaultPrevented) {
      return;
    }

    if (filter.length) {
      // ignore elements within the exempted sub-trees
      var isParentOfElement = (0, _comparePosition.getParentComparator)({ element: event.target, includeSelf: true });
      if (filter.some(isParentOfElement)) {
        return;
      }
    }

    var key = event.keyCode || event.which;
    if (!bindings[key]) {
      return;
    }

    bindings[key].forEach(function (_event) {
      if (!_event.matchModifiers(event)) {
        return;
      }

      _event.callback.call(context, event, disengage);
    });
  };

  context.addEventListener('keydown', handleKeyDown, false);

  var disengage = function disengage() {
    context.removeEventListener('keydown', handleKeyDown, false);
  };

  return { disengage: disengage };
};

var _key = __webpack_require__(/*! ./key.binding */ "./node_modules/ally.js/when/key.binding.js");

var _key2 = _interopRequireDefault(_key);

var _nodeArray = __webpack_require__(/*! ../util/node-array */ "./node_modules/ally.js/util/node-array.js");

var _nodeArray2 = _interopRequireDefault(_nodeArray);

var _comparePosition = __webpack_require__(/*! ../util/compare-position */ "./node_modules/ally.js/util/compare-position.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

module.exports = exports['default'];

// Bug 286933 - Key events in the autocomplete popup should be hidden from page scripts
// @browser-issue Gecko https://bugzilla.mozilla.org/show_bug.cgi?id=286933
//# sourceMappingURL=key.js.map

/***/ }),

/***/ "./node_modules/anser/lib/index.js":
/*!*****************************************!*\
  !*** ./node_modules/anser/lib/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// This file was originally written by @drudru (https://github.com/drudru/ansi_up), MIT, 2011

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ANSI_COLORS = [[{ color: "0, 0, 0", "class": "ansi-black" }, { color: "187, 0, 0", "class": "ansi-red" }, { color: "0, 187, 0", "class": "ansi-green" }, { color: "187, 187, 0", "class": "ansi-yellow" }, { color: "0, 0, 187", "class": "ansi-blue" }, { color: "187, 0, 187", "class": "ansi-magenta" }, { color: "0, 187, 187", "class": "ansi-cyan" }, { color: "255,255,255", "class": "ansi-white" }], [{ color: "85, 85, 85", "class": "ansi-bright-black" }, { color: "255, 85, 85", "class": "ansi-bright-red" }, { color: "0, 255, 0", "class": "ansi-bright-green" }, { color: "255, 255, 85", "class": "ansi-bright-yellow" }, { color: "85, 85, 255", "class": "ansi-bright-blue" }, { color: "255, 85, 255", "class": "ansi-bright-magenta" }, { color: "85, 255, 255", "class": "ansi-bright-cyan" }, { color: "255, 255, 255", "class": "ansi-bright-white" }]];

var Anser = function () {
    _createClass(Anser, null, [{
        key: "escapeForHtml",


        /**
         * Anser.escapeForHtml
         * Escape the input HTML.
         *
         * This does the minimum escaping of text to make it compliant with HTML.
         * In particular, the '&','<', and '>' characters are escaped. This should
         * be run prior to `ansiToHtml`.
         *
         * @name Anser.escapeForHtml
         * @function
         * @param {String} txt The input text (containing the ANSI snippets).
         * @returns {String} The escaped html.
         */
        value: function escapeForHtml(txt) {
            return new Anser().escapeForHtml(txt);
        }

        /**
         * Anser.linkify
         * Adds the links in the HTML.
         *
         * This replaces any links in the text with anchor tags that display the
         * link. The links should have at least one whitespace character
         * surrounding it. Also, you should apply this after you have run
         * `ansiToHtml` on the text.
         *
         * @name Anser.linkify
         * @function
         * @param {String} txt The input text.
         * @returns {String} The HTML containing the <a> tags (unescaped).
         */

    }, {
        key: "linkify",
        value: function linkify(txt) {
            return new Anser().linkify(txt);
        }

        /**
         * Anser.ansiToHtml
         * This replaces ANSI terminal escape codes with SPAN tags that wrap the
         * content.
         *
         * This function only interprets ANSI SGR (Select Graphic Rendition) codes
         * that can be represented in HTML.
         * For example, cursor movement codes are ignored and hidden from output.
         * The default style uses colors that are very close to the prescribed
         * standard. The standard assumes that the text will have a black
         * background. These colors are set as inline styles on the SPAN tags.
         *
         * Another option is to set `use_classes: true` in the options argument.
         * This will instead set classes on the spans so the colors can be set via
         * CSS. The class names used are of the format `ansi-*-fg/bg` and
         * `ansi-bright-*-fg/bg` where `*` is the color name,
         * i.e black/red/green/yellow/blue/magenta/cyan/white.
         *
         * @name Anser.ansiToHtml
         * @function
         * @param {String} txt The input text.
         * @param {Object} options The options passed to the ansiToHTML method.
         * @returns {String} The HTML output.
         */

    }, {
        key: "ansiToHtml",
        value: function ansiToHtml(txt, options) {
            return new Anser().ansiToHtml(txt, options);
        }

        /**
         * Anser.ansiToJson
         * Converts ANSI input into JSON output.
         *
         * @name Anser.ansiToJson
         * @function
         * @param {String} txt The input text.
         * @param {Object} options The options passed to the ansiToHTML method.
         * @returns {String} The HTML output.
         */

    }, {
        key: "ansiToJson",
        value: function ansiToJson(txt, options) {
            return new Anser().ansiToJson(txt, options);
        }

        /**
         * Anser.ansiToText
         * Converts ANSI input into text output.
         *
         * @name Anser.ansiToText
         * @function
         * @param {String} txt The input text.
         * @returns {String} The text output.
         */

    }, {
        key: "ansiToText",
        value: function ansiToText(txt) {
            return new Anser().ansiToText(txt);
        }

        /**
         * Anser
         * The `Anser` class.
         *
         * @name Anser
         * @function
         * @returns {Anser}
         */

    }]);

    function Anser() {
        _classCallCheck(this, Anser);

        this.fg = this.bg = this.fg_truecolor = this.bg_truecolor = null;
        this.bright = 0;
    }

    /**
     * setupPalette
     * Sets up the palette.
     *
     * @name setupPalette
     * @function
     */


    _createClass(Anser, [{
        key: "setupPalette",
        value: function setupPalette() {
            this.PALETTE_COLORS = [];

            // Index 0..15 : System color
            for (var i = 0; i < 2; ++i) {
                for (var j = 0; j < 8; ++j) {
                    this.PALETTE_COLORS.push(ANSI_COLORS[i][j].color);
                }
            }

            // Index 16..231 : RGB 6x6x6
            // https://gist.github.com/jasonm23/2868981#file-xterm-256color-yaml
            var levels = [0, 95, 135, 175, 215, 255];
            var format = function format(r, g, b) {
                return levels[r] + ", " + levels[g] + ", " + levels[b];
            };
            var r = void 0,
                g = void 0,
                b = void 0;
            for (var _r = 0; _r < 6; ++_r) {
                for (var _g = 0; _g < 6; ++_g) {
                    for (var _b = 0; _b < 6; ++_b) {
                        this.PALETTE_COLORS.push(format(_r, _g, _b));
                    }
                }
            }

            // Index 232..255 : Grayscale
            var level = 8;
            for (var _i = 0; _i < 24; ++_i, level += 10) {
                this.PALETTE_COLORS.push(format(level, level, level));
            }
        }

        /**
         * escapeForHtml
         * Escapes the input text.
         *
         * @name escapeForHtml
         * @function
         * @param {String} txt The input text.
         * @returns {String} The escpaed HTML output.
         */

    }, {
        key: "escapeForHtml",
        value: function escapeForHtml(txt) {
            return txt.replace(/[&<>]/gm, function (str) {
                return str == "&" ? "&amp;" : str == "<" ? "&lt;" : str == ">" ? "&gt;" : "";
            });
        }

        /**
         * linkify
         * Adds HTML link elements.
         *
         * @name linkify
         * @function
         * @param {String} txt The input text.
         * @returns {String} The HTML output containing link elements.
         */

    }, {
        key: "linkify",
        value: function linkify(txt) {
            return txt.replace(/(https?:\/\/[^\s]+)/gm, function (str) {
                return "<a href=\"" + str + "\">" + str + "</a>";
            });
        }

        /**
         * ansiToHtml
         * Converts ANSI input into HTML output.
         *
         * @name ansiToHtml
         * @function
         * @param {String} txt The input text.
         * @param {Object} options The options passed ot the `process` method.
         * @returns {String} The HTML output.
         */

    }, {
        key: "ansiToHtml",
        value: function ansiToHtml(txt, options) {
            return this.process(txt, options, true);
        }

        /**
         * ansiToJson
         * Converts ANSI input into HTML output.
         *
         * @name ansiToJson
         * @function
         * @param {String} txt The input text.
         * @param {Object} options The options passed ot the `process` method.
         * @returns {String} The JSON output.
         */

    }, {
        key: "ansiToJson",
        value: function ansiToJson(txt, options) {
            options = options || {};
            options.json = true;
            options.clearLine = false;
            return this.process(txt, options, true);
        }

        /**
         * ansiToText
         * Converts ANSI input into HTML output.
         *
         * @name ansiToText
         * @function
         * @param {String} txt The input text.
         * @returns {String} The text output.
         */

    }, {
        key: "ansiToText",
        value: function ansiToText(txt) {
            return this.process(txt, {}, false);
        }

        /**
         * process
         * Processes the input.
         *
         * @name process
         * @function
         * @param {String} txt The input text.
         * @param {Object} options An object passed to `processChunk` method, extended with:
         *
         *  - `json` (Boolean): If `true`, the result will be an object.
         *  - `use_classes` (Boolean): If `true`, HTML classes will be appended to the HTML output.
         *
         * @param {Boolean} markup
         */

    }, {
        key: "process",
        value: function process(txt, options, markup) {
            var _this = this;

            var self = this;
            var raw_text_chunks = txt.split(/\033\[/);
            var first_chunk = raw_text_chunks.shift(); // the first chunk is not the result of the split

            if (options === undefined || options === null) {
                options = {};
            }
            options.clearLine = /\r/.test(txt); // check for Carriage Return
            var color_chunks = raw_text_chunks.map(function (chunk) {
                return _this.processChunk(chunk, options, markup);
            });

            if (options && options.json) {
                var first = self.processChunkJson("");
                first.content = first_chunk;
                first.clearLine = options.clearLine;
                color_chunks.unshift(first);
                if (options.remove_empty) {
                    color_chunks = color_chunks.filter(function (c) {
                        return !c.isEmpty();
                    });
                }
                return color_chunks;
            } else {
                color_chunks.unshift(first_chunk);
            }

            return color_chunks.join("");
        }

        /**
         * processChunkJson
         * Processes the current chunk into json output.
         *
         * @name processChunkJson
         * @function
         * @param {String} text The input text.
         * @param {Object} options An object containing the following fields:
         *
         *  - `json` (Boolean): If `true`, the result will be an object.
         *  - `use_classes` (Boolean): If `true`, HTML classes will be appended to the HTML output.
         *
         * @param {Boolean} markup If false, the colors will not be parsed.
         * @return {Object} The result object:
         *
         *  - `content` (String): The text.
         *  - `fg` (String|null): The foreground color.
         *  - `bg` (String|null): The background color.
         *  - `fg_truecolor` (String|null): The foreground true color (if 16m color is enabled).
         *  - `bg_truecolor` (String|null): The background true color (if 16m color is enabled).
         *  - `clearLine` (Boolean): `true` if a carriageReturn \r was fount at end of line.
         *  - `was_processed` (Bolean): `true` if the colors were processed, `false` otherwise.
         *  - `isEmpty` (Function): A function returning `true` if the content is empty, or `false` otherwise.
         *
         */

    }, {
        key: "processChunkJson",
        value: function processChunkJson(text, options, markup) {

            // Are we using classes or styles?
            options = typeof options == "undefined" ? {} : options;
            var use_classes = options.use_classes = typeof options.use_classes != "undefined" && options.use_classes;
            var key = options.key = use_classes ? "class" : "color";

            var result = {
                content: text,
                fg: null,
                bg: null,
                fg_truecolor: null,
                bg_truecolor: null,
                clearLine: options.clearLine,
                decoration: null,
                was_processed: false,
                isEmpty: function isEmpty() {
                    return !result.content;
                }
            };

            // Each "chunk" is the text after the CSI (ESC + "[") and before the next CSI/EOF.
            //
            // This regex matches four groups within a chunk.
            //
            // The first and third groups match code type.
            // We supported only SGR command. It has empty first group and "m" in third.
            //
            // The second group matches all of the number+semicolon command sequences
            // before the "m" (or other trailing) character.
            // These are the graphics or SGR commands.
            //
            // The last group is the text (including newlines) that is colored by
            // the other group"s commands.
            var matches = text.match(/^([!\x3c-\x3f]*)([\d;]*)([\x20-\x2c]*[\x40-\x7e])([\s\S]*)/m);

            if (!matches) return result;

            var orig_txt = result.content = matches[4];
            var nums = matches[2].split(";");

            // We currently support only "SGR" (Select Graphic Rendition)
            // Simply ignore if not a SGR command.
            if (matches[1] !== "" || matches[3] !== "m") {
                return result;
            }

            if (!markup) {
                return result;
            }

            var self = this;

            self.decoration = null;

            while (nums.length > 0) {
                var num_str = nums.shift();
                var num = parseInt(num_str);

                if (isNaN(num) || num === 0) {
                    self.fg = self.bg = self.decoration = null;
                } else if (num === 1) {
                    self.decoration = "bold";
                } else if (num === 2) {
                    self.decoration = "dim";
                    // Enable code 2 to get string
                } else if (num == 3) {
                    self.decoration = "italic";
                } else if (num == 4) {
                    self.decoration = "underline";
                } else if (num == 5) {
                    self.decoration = "blink";
                } else if (num === 7) {
                    self.decoration = "reverse";
                } else if (num === 8) {
                    self.decoration = "hidden";
                    // Enable code 9 to get strikethrough
                } else if (num === 9) {
                    self.decoration = "strikethrough";
                } else if (num == 39) {
                    self.fg = null;
                } else if (num == 49) {
                    self.bg = null;
                    // Foreground color
                } else if (num >= 30 && num < 38) {
                    self.fg = ANSI_COLORS[0][num % 10][key];
                    // Foreground bright color
                } else if (num >= 90 && num < 98) {
                    self.fg = ANSI_COLORS[1][num % 10][key];
                    // Background color
                } else if (num >= 40 && num < 48) {
                    self.bg = ANSI_COLORS[0][num % 10][key];
                    // Background bright color
                } else if (num >= 100 && num < 108) {
                    self.bg = ANSI_COLORS[1][num % 10][key];
                } else if (num === 38 || num === 48) {
                    // extend color (38=fg, 48=bg)
                    var is_foreground = num === 38;
                    if (nums.length >= 1) {
                        var mode = nums.shift();
                        if (mode === "5" && nums.length >= 1) {
                            // palette color
                            var palette_index = parseInt(nums.shift());
                            if (palette_index >= 0 && palette_index <= 255) {
                                if (!use_classes) {
                                    if (!this.PALETTE_COLORS) {
                                        self.setupPalette();
                                    }
                                    if (is_foreground) {
                                        self.fg = this.PALETTE_COLORS[palette_index];
                                    } else {
                                        self.bg = this.PALETTE_COLORS[palette_index];
                                    }
                                } else {
                                    var klass = palette_index >= 16 ? "ansi-palette-" + palette_index : ANSI_COLORS[palette_index > 7 ? 1 : 0][palette_index % 8]["class"];
                                    if (is_foreground) {
                                        self.fg = klass;
                                    } else {
                                        self.bg = klass;
                                    }
                                }
                            }
                        } else if (mode === "2" && nums.length >= 3) {
                            // true color
                            var r = parseInt(nums.shift());
                            var g = parseInt(nums.shift());
                            var b = parseInt(nums.shift());
                            if (r >= 0 && r <= 255 && g >= 0 && g <= 255 && b >= 0 && b <= 255) {
                                var color = r + ", " + g + ", " + b;
                                if (!use_classes) {
                                    if (is_foreground) {
                                        self.fg = color;
                                    } else {
                                        self.bg = color;
                                    }
                                } else {
                                    if (is_foreground) {
                                        self.fg = "ansi-truecolor";
                                        self.fg_truecolor = color;
                                    } else {
                                        self.bg = "ansi-truecolor";
                                        self.bg_truecolor = color;
                                    }
                                }
                            }
                        }
                    }
                }
            }

            if (self.fg === null && self.bg === null && self.decoration === null) {
                return result;
            } else {
                var styles = [];
                var classes = [];
                var data = {};

                result.fg = self.fg;
                result.bg = self.bg;
                result.fg_truecolor = self.fg_truecolor;
                result.bg_truecolor = self.bg_truecolor;
                result.decoration = self.decoration;
                result.was_processed = true;

                return result;
            }
        }

        /**
         * processChunk
         * Processes the current chunk of text.
         *
         * @name processChunk
         * @function
         * @param {String} text The input text.
         * @param {Object} options An object containing the following fields:
         *
         *  - `json` (Boolean): If `true`, the result will be an object.
         *  - `use_classes` (Boolean): If `true`, HTML classes will be appended to the HTML output.
         *
         * @param {Boolean} markup If false, the colors will not be parsed.
         * @return {Object|String} The result (object if `json` is wanted back or string otherwise).
         */

    }, {
        key: "processChunk",
        value: function processChunk(text, options, markup) {
            var _this2 = this;

            var self = this;
            options = options || {};
            var jsonChunk = this.processChunkJson(text, options, markup);

            if (options.json) {
                return jsonChunk;
            }
            if (jsonChunk.isEmpty()) {
                return "";
            }
            if (!jsonChunk.was_processed) {
                return jsonChunk.content;
            }

            var use_classes = options.use_classes;

            var styles = [];
            var classes = [];
            var data = {};
            var render_data = function render_data(data) {
                var fragments = [];
                var key = void 0;
                for (key in data) {
                    if (data.hasOwnProperty(key)) {
                        fragments.push("data-" + key + "=\"" + _this2.escapeForHtml(data[key]) + "\"");
                    }
                }
                return fragments.length > 0 ? " " + fragments.join(" ") : "";
            };

            if (jsonChunk.fg) {
                if (use_classes) {
                    classes.push(jsonChunk.fg + "-fg");
                    if (jsonChunk.fg_truecolor !== null) {
                        data["ansi-truecolor-fg"] = jsonChunk.fg_truecolor;
                        jsonChunk.fg_truecolor = null;
                    }
                } else {
                    styles.push("color:rgb(" + jsonChunk.fg + ")");
                }
            }

            if (jsonChunk.bg) {
                if (use_classes) {
                    classes.push(jsonChunk.bg + "-bg");
                    if (jsonChunk.bg_truecolor !== null) {
                        data["ansi-truecolor-bg"] = jsonChunk.bg_truecolor;
                        jsonChunk.bg_truecolor = null;
                    }
                } else {
                    styles.push("background-color:rgb(" + jsonChunk.bg + ")");
                }
            }

            if (jsonChunk.decoration) {
                if (use_classes) {
                    classes.push("ansi-" + jsonChunk.decoration);
                } else if (jsonChunk.decoration === "bold") {
                    styles.push("font-weight:bold");
                } else if (jsonChunk.decoration === "dim") {
                    styles.push("opacity:0.5");
                } else if (jsonChunk.decoration === "italic") {
                    styles.push("font-style:italic");
                    // underline and blink are treated bellow
                } else if (jsonChunk.decoration === "reverse") {
                    styles.push("filter:invert(100%)");
                } else if (jsonChunk.decoration === "hidden") {
                    styles.push("visibility:hidden");
                } else if (jsonChunk.decoration === "strikethrough") {
                    styles.push("text-decoration:line-through");
                } else {
                    styles.push("text-decoration:" + jsonChunk.decoration);
                }
            }

            if (use_classes) {
                return "<span class=\"" + classes.join(" ") + "\"" + render_data(data) + ">" + jsonChunk.content + "</span>";
            } else {
                return "<span style=\"" + styles.join(";") + "\"" + render_data(data) + ">" + jsonChunk.content + "</span>";
            }
        }
    }]);

    return Anser;
}();

;

module.exports = Anser;

/***/ }),

/***/ "./node_modules/ansi-regex/index.js":
/*!******************************************!*\
  !*** ./node_modules/ansi-regex/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

module.exports = function () {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$onlyFirst = _ref.onlyFirst,
      onlyFirst = _ref$onlyFirst === void 0 ? false : _ref$onlyFirst;

  var pattern = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", '(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))'].join('|');
  return new RegExp(pattern, onlyFirst ? undefined : 'g');
};

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/css.escape/css.escape.js":
/*!***********************************************!*\
  !*** ./node_modules/css.escape/css.escape.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/*! https://mths.be/cssescape v1.5.1 by @mathias | MIT license */
;(function(root, factory) {
	// https://github.com/umdjs/umd/blob/master/returnExports.js
	if (true) {
		// For Node.js.
		module.exports = factory(root);
	} else {}
}(typeof global != 'undefined' ? global : this, function(root) {

	if (root.CSS && root.CSS.escape) {
		return root.CSS.escape;
	}

	// https://drafts.csswg.org/cssom/#serialize-an-identifier
	var cssEscape = function(value) {
		if (arguments.length == 0) {
			throw new TypeError('`CSS.escape` requires an argument.');
		}
		var string = String(value);
		var length = string.length;
		var index = -1;
		var codeUnit;
		var result = '';
		var firstCodeUnit = string.charCodeAt(0);
		while (++index < length) {
			codeUnit = string.charCodeAt(index);
			// Note: theres no need to special-case astral symbols, surrogate
			// pairs, or lone surrogates.

			// If the character is NULL (U+0000), then the REPLACEMENT CHARACTER
			// (U+FFFD).
			if (codeUnit == 0x0000) {
				result += '\uFFFD';
				continue;
			}

			if (
				// If the character is in the range [\1-\1F] (U+0001 to U+001F) or is
				// U+007F, []
				(codeUnit >= 0x0001 && codeUnit <= 0x001F) || codeUnit == 0x007F ||
				// If the character is the first character and is in the range [0-9]
				// (U+0030 to U+0039), []
				(index == 0 && codeUnit >= 0x0030 && codeUnit <= 0x0039) ||
				// If the character is the second character and is in the range [0-9]
				// (U+0030 to U+0039) and the first character is a `-` (U+002D), []
				(
					index == 1 &&
					codeUnit >= 0x0030 && codeUnit <= 0x0039 &&
					firstCodeUnit == 0x002D
				)
			) {
				// https://drafts.csswg.org/cssom/#escape-a-character-as-code-point
				result += '\\' + codeUnit.toString(16) + ' ';
				continue;
			}

			if (
				// If the character is the first character and is a `-` (U+002D), and
				// there is no second character, []
				index == 0 &&
				length == 1 &&
				codeUnit == 0x002D
			) {
				result += '\\' + string.charAt(index);
				continue;
			}

			// If the character is not handled by one of the above rules and is
			// greater than or equal to U+0080, is `-` (U+002D) or `_` (U+005F), or
			// is in one of the ranges [0-9] (U+0030 to U+0039), [A-Z] (U+0041 to
			// U+005A), or [a-z] (U+0061 to U+007A), []
			if (
				codeUnit >= 0x0080 ||
				codeUnit == 0x002D ||
				codeUnit == 0x005F ||
				codeUnit >= 0x0030 && codeUnit <= 0x0039 ||
				codeUnit >= 0x0041 && codeUnit <= 0x005A ||
				codeUnit >= 0x0061 && codeUnit <= 0x007A
			) {
				// the character itself
				result += string.charAt(index);
				continue;
			}

			// Otherwise, the escaped character.
			// https://drafts.csswg.org/cssom/#escape-a-character
			result += '\\' + string.charAt(index);

		}
		return result;
	};

	if (!root.CSS) {
		root.CSS = {};
	}

	root.CSS.escape = cssEscape;
	return cssEscape;

}));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/native-url/dist/index.js":
/*!***********************************************!*\
  !*** ./node_modules/native-url/dist/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var e,t=(e=__webpack_require__(/*! querystring */ "./node_modules/querystring-es3/index.js"))&&"object"==typeof e&&"default"in e?e.default:e,r=/https?|ftp|gopher|file/;function o(e){"string"==typeof e&&(e=g(e));var o=function(e,t,r){var o=e.auth,a=e.hostname,s=e.protocol||"",c=e.pathname||"",h=e.hash||"",p=e.query||"",n=!1;o=o?encodeURIComponent(o).replace(/%3A/i,":")+"@":"",e.host?n=o+e.host:a&&(n=o+(~a.indexOf(":")?"["+a+"]":a),e.port&&(n+=":"+e.port)),p&&"object"==typeof p&&(p=t.encode(p));var l=e.search||p&&"?"+p||"";return s&&":"!==s.substr(-1)&&(s+=":"),e.slashes||(!s||r.test(s))&&!1!==n?(n="//"+(n||""),c&&"/"!==c[0]&&(c="/"+c)):n||(n=""),h&&"#"!==h[0]&&(h="#"+h),l&&"?"!==l[0]&&(l="?"+l),{protocol:s,host:n,pathname:c=c.replace(/[?#]/g,encodeURIComponent),search:l=l.replace("#","%23"),hash:h}}(e,t,r);return""+o.protocol+o.host+o.pathname+o.search+o.hash}var a="http://",s="w.w",c=a+s,h=/^([a-z0-9.+-]*:\/\/\/)([a-z0-9.+-]:\/*)?/i,p=/https?|ftp|gopher|file/;function n(e,t){var r="string"==typeof e?g(e):e;e="object"==typeof e?o(e):e;var s=g(t),n="";r.protocol&&!r.slashes&&(n=r.protocol,e=e.replace(r.protocol,""),n+="/"===t[0]||"/"===e[0]?"/":""),n&&s.protocol&&(n="",s.slashes||(n=s.protocol,t=t.replace(s.protocol,"")));var l=e.match(h);l&&!s.protocol&&(e=e.substr((n=l[1]+(l[2]||"")).length),/^\/\/[^/]/.test(t)&&(n=n.slice(0,-1)));var i=new URL(e,c+"/"),f=new URL(t,i).toString().replace(c,""),u=s.protocol||r.protocol;return u+=r.slashes||s.slashes?"//":"",!n&&u?f=f.replace(a,u):n&&(f=f.replace(a,"")),p.test(f)||~t.indexOf(".")||"/"===e.slice(-1)||"/"===t.slice(-1)||"/"!==f.slice(-1)||(f=f.slice(0,-1)),n&&(f=n+("/"===f[0]?f.substr(1):f)),f}function l(){}l.parse=g,l.format=o,l.resolve=n,l.resolveObject=n;var i=/^https?|ftp|gopher|file/,f=/^(.*?)([#?].*)/,u=/^([a-z0-9.+-]*:)(\/{0,3})(.*)/i,m=/^([a-z0-9.+-]*:)?\/\/\/*/i,v=/^([a-z0-9.+-]*:)(\/{0,2})\[(.*)\]$/i;function d(e){try{return decodeURI(e)}catch(t){return e}}function g(e,r,a){if(void 0===r&&(r=!1),void 0===a&&(a=!1),e&&"object"==typeof e&&e instanceof l)return e;var h=(e=e.trim()).match(f);e=h?d(h[1]).replace(/\\/g,"/")+h[2]:d(e).replace(/\\/g,"/"),v.test(e)&&"/"!==e.slice(-1)&&(e+="/");var p=!/(^javascript)/.test(e)&&e.match(u),n=m.test(e),g="";p&&(i.test(p[1])||(g=p[1].toLowerCase(),e=""+p[2]+p[3]),p[2]||(n=!1,i.test(p[1])?(g=p[1],e=""+p[3]):e="//"+p[3]),3!==p[2].length&&1!==p[2].length||(g=p[1],e="/"+p[3]));var b,y=(h?h[1]:e).match(/(:[0-9]+)/),j="";y&&y[1]&&3===y[1].length&&(e=e.replace(j=y[1],j+"00"));var w=new l,x="",U="";try{b=new URL(e)}catch(t){x=t,g||a||!/^\/\//.test(e)||/^\/\/.+[@.]/.test(e)||(U="/",e=e.substr(1));try{b=new URL(e,c)}catch(e){return w.protocol=g,w.href=g,w}}w.slashes=n&&!U,w.host=b.host===s?"":b.host,w.hostname=b.hostname===s?"":b.hostname.replace(/(\[|\])/g,""),w.protocol=x?g||null:b.protocol,w.search=b.search.replace(/\\/g,"%5C"),w.hash=b.hash.replace(/\\/g,"%5C");var R=e.split("#");!w.search&&~R[0].indexOf("?")&&(w.search="?"),w.hash||""!==R[1]||(w.hash="#"),w.query=r?t.decode(b.search.substr(1)):w.search.substr(1),w.pathname=U+d(b.pathname).replace(/"/g,"%22"),"about:"===w.protocol&&"blank"===w.pathname&&(w.protocol="",w.pathname=""),x&&"/"!==e[0]&&(w.pathname=w.pathname.substr(1)),g&&!i.test(g)&&"/"!==e.slice(-1)&&"/"===w.pathname&&(w.pathname=""),w.path=w.pathname+w.search,w.auth=[b.username,b.password].map(decodeURIComponent).filter(Boolean).join(":"),w.port=b.port,j&&(w.host=w.host.replace(j+"00",j),w.port=w.port.slice(0,-2)),w.href=U?""+w.pathname+w.search+w.hash:o(w);var O=/^(file)/.test(w.href)?["host","hostname"]:[];return Object.keys(w).forEach(function(e){~O.indexOf(e)||(w[e]=w[e]||null)}),w}exports.parse=g,exports.format=o,exports.resolve=n,exports.resolveObject=function(e,t){return g(n(e,t))},exports.Url=l;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/next/dist/build/polyfills/finally-polyfill.min.js":
/*!************************************************************************!*\
  !*** ./node_modules/next/dist/build/polyfills/finally-polyfill.min.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

Promise.prototype.finally=function(n){if("function"!=typeof n)return this.then(n,n);var t=this.constructor||Promise;return this.then(function(r){return t.resolve(n()).then(function(){return r})},function(r){return t.resolve(n()).then(function(){throw r})})};

/***/ }),

/***/ "./node_modules/next/dist/build/polyfills/unfetch.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/build/polyfills/unfetch.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports=function(e,n){return n=n||{},new Promise(function(t,r){var s=new XMLHttpRequest,o=[],u=[],i={},a=function(){return{ok:2==(s.status/100|0),statusText:s.statusText,status:s.status,url:s.responseURL,text:function(){return Promise.resolve(s.responseText)},json:function(){return Promise.resolve(JSON.parse(s.responseText))},blob:function(){return Promise.resolve(new Blob([s.response]))},clone:a,headers:{keys:function(){return o},entries:function(){return u},get:function(e){return i[e.toLowerCase()]},has:function(e){return e.toLowerCase()in i}}}};for(var l in s.open(n.method||"get",e,!0),s.onload=function(){s.getAllResponseHeaders().replace(/^(.*?):[^\S\n]*([\s\S]*?)$/gm,function(e,n,t){o.push(n=n.toLowerCase()),u.push([n,t]),i[n]=i[n]?i[n]+","+t:t}),t(a())},s.onerror=r,s.withCredentials="include"==n.credentials,n.headers)s.setRequestHeader(l,n.headers[l]);s.send(n.body||null)})};
//# sourceMappingURL=unfetch.js.map


/***/ }),

/***/ "./node_modules/next/dist/client/dev/dev-build-watcher.js":
/*!****************************************************************!*\
  !*** ./node_modules/next/dist/client/dev/dev-build-watcher.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports["default"] = initializeBuildWatcher;

var _eventsource = __webpack_require__(/*! ./error-overlay/eventsource */ "./node_modules/next/dist/client/dev/error-overlay/eventsource.js");

function initializeBuildWatcher() {
  var shadowHost = document.createElement('div');
  shadowHost.id = '__next-build-watcher'; // Make sure container is fixed and on a high zIndex so it shows

  shadowHost.style.position = 'fixed';
  shadowHost.style.bottom = '10px';
  shadowHost.style.right = '20px';
  shadowHost.style.width = 0;
  shadowHost.style.height = 0;
  shadowHost.style.zIndex = 99999;
  document.body.appendChild(shadowHost);
  var shadowRoot;
  var prefix = '';

  if (shadowHost.attachShadow) {
    shadowRoot = shadowHost.attachShadow({
      mode: 'open'
    });
  } else {
    // If attachShadow is undefined then the browser does not support
    // the Shadow DOM, we need to prefix all the names so there
    // will be no conflicts
    shadowRoot = shadowHost;
    prefix = '__next-build-watcher-';
  } // Container


  var container = createContainer(prefix);
  shadowRoot.appendChild(container); // CSS

  var css = createCss(prefix);
  shadowRoot.appendChild(css); // State

  var isVisible = false;
  var isBuilding = false;
  var timeoutId = null; // Handle events

  var evtSource = (0, _eventsource.getEventSourceWrapper)({
    path: '/_next/webpack-hmr'
  });
  evtSource.addMessageListener(function (event) {
    // This is the heartbeat event
    if (event.data === "\uD83D\uDC93") {
      return;
    }

    try {
      handleMessage(event);
    } catch (_unused) {}
  });

  function handleMessage(event) {
    var obj = JSON.parse(event.data); // eslint-disable-next-line default-case

    switch (obj.action) {
      case 'building':
        timeoutId && clearTimeout(timeoutId);
        isVisible = true;
        isBuilding = true;
        updateContainer();
        break;

      case 'built':
      case 'sync':
        isBuilding = false; // Wait for the fade out transtion to complete

        timeoutId = setTimeout(function () {
          isVisible = false;
          updateContainer();
        }, 100);
        updateContainer();
        break;
    }
  }

  function updateContainer() {
    if (isBuilding) {
      container.classList.add("".concat(prefix, "building"));
    } else {
      container.classList.remove("".concat(prefix, "building"));
    }

    if (isVisible) {
      container.classList.add("".concat(prefix, "visible"));
    } else {
      container.classList.remove("".concat(prefix, "visible"));
    }
  }
}

function createContainer(prefix) {
  var container = document.createElement('div');
  container.id = "".concat(prefix, "container");
  container.innerHTML = "\n    <div id=\"".concat(prefix, "icon-wrapper\">\n      <svg viewBox=\"0 0 226 200\">\n        <defs>\n          <linearGradient\n            x1=\"114.720775%\"\n            y1=\"181.283245%\"\n            x2=\"39.5399306%\"\n            y2=\"100%\"\n            id=\"").concat(prefix, "linear-gradient\"\n          >\n            <stop stop-color=\"#FFFFFF\" offset=\"0%\" />\n            <stop stop-color=\"#000000\" offset=\"100%\" />\n          </linearGradient>\n        </defs>\n        <g id=\"").concat(prefix, "icon-group\" fill=\"none\" stroke=\"url(#").concat(prefix, "linear-gradient)\" stroke-width=\"18\">\n          <path d=\"M113,5.08219117 L4.28393801,197.5 L221.716062,197.5 L113,5.08219117 Z\" />\n        </g>\n      </svg>\n    </div>\n  ");
  return container;
}

function createCss(prefix) {
  var css = document.createElement('style');
  css.textContent = "\n    #".concat(prefix, "container {\n      position: absolute;\n      bottom: 10px;\n      right: 30px;\n\n      background: #fff;\n      color: #000;\n      font: initial;\n      cursor: initial;\n      letter-spacing: initial;\n      text-shadow: initial;\n      text-transform: initial;\n      visibility: initial;\n\n      padding: 8px 10px;\n      align-items: center;\n      box-shadow: 0 11px 40px 0 rgba(0, 0, 0, 0.25), 0 2px 10px 0 rgba(0, 0, 0, 0.12);\n\n      display: none;\n      opacity: 0;\n      transition: opacity 0.1s ease, bottom 0.1s ease;\n      animation: ").concat(prefix, "fade-in 0.1s ease-in-out;\n    }\n\n    #").concat(prefix, "container.").concat(prefix, "visible {\n      display: flex;\n    }\n\n    #").concat(prefix, "container.").concat(prefix, "building {\n      bottom: 20px;\n      opacity: 1;\n    }\n\n    #").concat(prefix, "icon-wrapper {\n      width: 16px;\n      height: 16px;\n    }\n\n    #").concat(prefix, "icon-wrapper > svg {\n      width: 100%;\n      height: 100%;\n    }\n\n    #").concat(prefix, "icon-group {\n      animation: ").concat(prefix, "strokedash 1s ease-in-out both infinite;\n    }\n\n    @keyframes ").concat(prefix, "fade-in {\n      from {\n        bottom: 10px;\n        opacity: 0;\n      }\n      to {\n        bottom: 20px;\n        opacity: 1;\n      }\n    }\n\n    @keyframes ").concat(prefix, "strokedash {\n      0% {\n        stroke-dasharray: 0 226;\n      }\n      80%,\n      100% {\n        stroke-dasharray: 659 226;\n      }\n    }\n  ");
  return css;
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/dev/error-overlay/eventsource.js":
/*!************************************************************************!*\
  !*** ./node_modules/next/dist/client/dev/error-overlay/eventsource.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.getEventSourceWrapper = getEventSourceWrapper;
var eventCallbacks = [];

function EventSourceWrapper(options) {
  var source;
  var lastActivity = new Date();
  var listeners = [];

  if (!options.timeout) {
    options.timeout = 20 * 1000;
  }

  init();
  var timer = setInterval(function () {
    if (new Date() - lastActivity > options.timeout) {
      handleDisconnect();
    }
  }, options.timeout / 2);

  function init() {
    source = new window.EventSource(options.path);
    source.onopen = handleOnline;
    source.onerror = handleDisconnect;
    source.onmessage = handleMessage;
  }

  function handleOnline() {
    if (options.log) console.log('[HMR] connected');
    lastActivity = new Date();
  }

  function handleMessage(event) {
    lastActivity = new Date();

    for (var i = 0; i < listeners.length; i++) {
      listeners[i](event);
    }

    if (event.data.indexOf('action') !== -1) {
      eventCallbacks.forEach(function (cb) {
        return cb(event);
      });
    }
  }

  function handleDisconnect() {
    clearInterval(timer);
    source.close();
    setTimeout(init, options.timeout);
  }

  return {
    close: function close() {
      clearInterval(timer);
      source.close();
    },
    addMessageListener: function addMessageListener(fn) {
      listeners.push(fn);
    }
  };
}

_c = EventSourceWrapper;

function getEventSourceWrapper(options) {
  if (!options.ondemand) {
    return {
      addMessageListener: function addMessageListener(cb) {
        eventCallbacks.push(cb);
      }
    };
  }

  return EventSourceWrapper(options);
}

var _c;

$RefreshReg$(_c, "EventSourceWrapper");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/dev/error-overlay/format-webpack-messages.js":
/*!************************************************************************************!*\
  !*** ./node_modules/next/dist/client/dev/error-overlay/format-webpack-messages.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {
/**
MIT License
Copyright (c) 2015-present, Facebook, Inc.
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/
// This file is based on https://github.com/facebook/create-react-app/blob/7b1a32be6ec9f99a6c9a3c66813f3ac09c4736b9/packages/react-dev-utils/formatWebpackMessages.js
// It's been edited to remove chalk and CRA-specific logic

var _toConsumableArray = __webpack_require__(/*! @babel/runtime/helpers/toConsumableArray */ "./node_modules/@babel/runtime/helpers/toConsumableArray.js");

var _slicedToArray = __webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ "./node_modules/@babel/runtime/helpers/slicedToArray.js");

var friendlySyntaxErrorLabel = 'Syntax error:';

function isLikelyASyntaxError(message) {
  return message.indexOf(friendlySyntaxErrorLabel) !== -1;
} // Cleans up webpack error messages.


function formatMessage(message) {
  var lines = message.split('\n'); // Strip Webpack-added headers off errors/warnings
  // https://github.com/webpack/webpack/blob/master/lib/ModuleError.js

  lines = lines.filter(function (line) {
    return !/Module [A-z ]+\(from/.test(line);
  }); // Transform parsing error into syntax error
  // TODO: move this to our ESLint formatter?

  lines = lines.map(function (line) {
    var parsingError = /Line (\d+):(?:(\d+):)?\s*Parsing error: (.+)$/.exec(line);

    if (!parsingError) {
      return line;
    }

    var _parsingError = _slicedToArray(parsingError, 4),
        errorLine = _parsingError[1],
        errorColumn = _parsingError[2],
        errorMessage = _parsingError[3];

    return "".concat(friendlySyntaxErrorLabel, " ").concat(errorMessage, " (").concat(errorLine, ":").concat(errorColumn, ")");
  });
  message = lines.join('\n'); // Smoosh syntax errors (commonly found in CSS)

  message = message.replace(/SyntaxError\s+\((\d+):(\d+)\)\s*(.+?)\n/g, "".concat(friendlySyntaxErrorLabel, " $3 ($1:$2)\n")); // Clean up export errors

  message = message.replace(/^.*export '(.+?)' was not found in '(.+?)'.*$/gm, "Attempted import error: '$1' is not exported from '$2'.");
  message = message.replace(/^.*export 'default' \(imported as '(.+?)'\) was not found in '(.+?)'.*$/gm, "Attempted import error: '$2' does not contain a default export (imported as '$1').");
  message = message.replace(/^.*export '(.+?)' \(imported as '(.+?)'\) was not found in '(.+?)'.*$/gm, "Attempted import error: '$1' is not exported from '$3' (imported as '$2').");
  lines = message.split('\n'); // Remove leading newline

  if (lines.length > 2 && lines[1].trim() === '') {
    lines.splice(1, 1);
  } // Clean up file name


  lines[0] = lines[0].replace(/^(.*) \d+:\d+-\d+$/, '$1'); // Cleans up verbose "module not found" messages for files and packages.

  if (lines[1] && lines[1].indexOf('Module not found: ') === 0) {
    lines = [lines[0], lines[1].replace('Error: ', '').replace('Module not found: Cannot find file:', 'Cannot find file:')].concat(_toConsumableArray(lines.slice(2).filter(function (line) {
      return line.indexOf(' @ ') !== 0;
    })));
  } // Add helpful message for users trying to use Sass for the first time


  if (lines[1] && lines[1].match(/Cannot find module.+node-sass/)) {
    // ./file.module.scss (<<loader info>>) => ./file.module.scss
    lines[0] = lines[0].replace(/(.+) \(.+?(?=\?\?).+?\)/, '$1');
    lines[1] = "To use Next.js' built-in Sass support, you first need to install `sass`.\n";
    lines[1] += 'Run `npm i sass` or `yarn add sass` inside your workspace.\n';
    lines[1] += '\nLearn more: https://err.sh/next.js/install-sass';
  }

  message = lines.join('\n'); // Internal stacks are generally useless so we strip them... with the
  // exception of stacks containing `webpack:` because they're normally
  // from user code generated by Webpack. For more information see
  // https://github.com/facebook/create-react-app/pull/1050

  message = message.replace(/^\s*at\s((?!webpack:).)*:\d+:\d+[\s)]*(\n|$)/gm, ''); // at ... ...:x:y

  message = message.replace(/^\s*at\s<anonymous>(\n|$)/gm, ''); // at <anonymous>

  lines = message.split('\n'); // Remove duplicated newlines

  lines = lines.filter(function (line, index, arr) {
    return index === 0 || line.trim() !== '' || line.trim() !== arr[index - 1].trim();
  }); // Reassemble the message

  message = lines.join('\n');
  return message.trim();
}

function formatWebpackMessages(json) {
  var formattedErrors = json.errors.map(function (message) {
    return formatMessage(message, true);
  });
  var formattedWarnings = json.warnings.map(function (message) {
    return formatMessage(message, false);
  });
  var result = {
    errors: formattedErrors,
    warnings: formattedWarnings
  };

  if (result.errors.some(isLikelyASyntaxError)) {
    // If there are any syntax errors, show just them.
    result.errors = result.errors.filter(isLikelyASyntaxError);
  }

  return result;
}

module.exports = formatWebpackMessages;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/dev/error-overlay/hot-dev-client.js":
/*!***************************************************************************!*\
  !*** ./node_modules/next/dist/client/dev/error-overlay/hot-dev-client.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

var _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "./node_modules/@babel/runtime/helpers/interopRequireWildcard.js");

exports.__esModule = true;
exports["default"] = connect;

var DevOverlay = _interopRequireWildcard(__webpack_require__(/*! @next/react-dev-overlay/lib/client */ "./node_modules/@next/react-dev-overlay/lib/client.js"));

var _stripAnsi = _interopRequireDefault(__webpack_require__(/*! next/dist/compiled/strip-ansi */ "./node_modules/next/dist/compiled/strip-ansi/index.js"));

var _eventsource = __webpack_require__(/*! ./eventsource */ "./node_modules/next/dist/client/dev/error-overlay/eventsource.js");

var _formatWebpackMessages = _interopRequireDefault(__webpack_require__(/*! ./format-webpack-messages */ "./node_modules/next/dist/client/dev/error-overlay/format-webpack-messages.js"));
/**
* MIT License
*
* Copyright (c) 2013-present, Facebook, Inc.
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in all
* copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
* SOFTWARE.
*/
// This file is a modified version of the Create React App HMR dev client that
// can be found here:
// https://github.com/facebook/create-react-app/blob/v3.4.1/packages/react-dev-utils/webpackHotDevClient.js
// This alternative WebpackDevServer combines the functionality of:
// https://github.com/webpack/webpack-dev-server/blob/webpack-1/client/index.js
// https://github.com/webpack/webpack/blob/webpack-1/hot/dev-server.js
// It only supports their simplest configuration (hot updates on same server).
// It makes some opinionated choices on top, like adding a syntax error overlay
// that looks similar to our console output. The error overlay is inspired by:
// https://github.com/glenjamin/webpack-hot-middleware


var hadRuntimeError = false;
var customHmrEventHandler;

function connect(options) {
  DevOverlay.register();
  (0, _eventsource.getEventSourceWrapper)(options).addMessageListener(function (event) {
    // This is the heartbeat event
    if (event.data === "\uD83D\uDC93") {
      return;
    }

    try {
      processMessage(event);
    } catch (ex) {
      console.warn('Invalid HMR message: ' + event.data + '\n' + ex);
    }
  });
  return {
    subscribeToHmrEvent: function subscribeToHmrEvent(handler) {
      customHmrEventHandler = handler;
    },
    onUnrecoverableError: function onUnrecoverableError() {
      hadRuntimeError = true;
    }
  };
} // Remember some state related to hot module replacement.


var isFirstCompilation = true;
var mostRecentCompilationHash = null;
var hasCompileErrors = false;

function clearOutdatedErrors() {
  // Clean up outdated compile errors, if any.
  if (typeof console !== 'undefined' && typeof console.clear === 'function') {
    if (hasCompileErrors) {
      console.clear();
    }
  }
} // Successful compilation.


function handleSuccess() {
  clearOutdatedErrors();
  var isHotUpdate = !isFirstCompilation;
  isFirstCompilation = false;
  hasCompileErrors = false; // Attempt to apply hot updates or reload.

  if (isHotUpdate) {
    tryApplyUpdates(function onSuccessfulHotUpdate(hasUpdates) {
      // Only dismiss it when we're sure it's a hot update.
      // Otherwise it would flicker right before the reload.
      onFastRefresh(hasUpdates);
    });
  }
} // Compilation with warnings (e.g. ESLint).


function handleWarnings(warnings) {
  clearOutdatedErrors();
  var isHotUpdate = !isFirstCompilation;
  isFirstCompilation = false;
  hasCompileErrors = false;

  function printWarnings() {
    // Print warnings to the console.
    var formatted = (0, _formatWebpackMessages["default"])({
      warnings: warnings,
      errors: []
    });

    if (typeof console !== 'undefined' && typeof console.warn === 'function') {
      for (var i = 0; i < formatted.warnings.length; i++) {
        if (i === 5) {
          console.warn('There were more warnings in other files.\n' + 'You can find a complete log in the terminal.');
          break;
        }

        console.warn((0, _stripAnsi["default"])(formatted.warnings[i]));
      }
    }
  }

  printWarnings(); // Attempt to apply hot updates or reload.

  if (isHotUpdate) {
    tryApplyUpdates(function onSuccessfulHotUpdate(hasUpdates) {
      // Only dismiss it when we're sure it's a hot update.
      // Otherwise it would flicker right before the reload.
      onFastRefresh(hasUpdates);
    });
  }
} // Compilation with errors (e.g. syntax error or missing modules).


function handleErrors(errors) {
  clearOutdatedErrors();
  isFirstCompilation = false;
  hasCompileErrors = true; // "Massage" webpack messages.

  var formatted = (0, _formatWebpackMessages["default"])({
    errors: errors,
    warnings: []
  }); // Only show the first error.

  DevOverlay.onBuildError(formatted.errors[0]); // Also log them to the console.

  if (typeof console !== 'undefined' && typeof console.error === 'function') {
    for (var i = 0; i < formatted.errors.length; i++) {
      console.error((0, _stripAnsi["default"])(formatted.errors[i]));
    }
  } // Do not attempt to reload now.
  // We will reload on next success instead.


  if (undefined) {
    if (self.__NEXT_HMR_CB) {
      self.__NEXT_HMR_CB(formatted.errors[0]);

      self.__NEXT_HMR_CB = null;
    }
  }
}

function onFastRefresh(hasUpdates) {
  DevOverlay.onBuildOk();

  if (hasUpdates) {
    DevOverlay.onRefresh();
  }

  console.log('[Fast Refresh] done');
} // There is a newer version of the code available.


function handleAvailableHash(hash) {
  // Update last known compilation hash.
  mostRecentCompilationHash = hash;
} // Handle messages from the server.


function processMessage(e) {
  var obj = JSON.parse(e.data);

  switch (obj.action) {
    case 'building':
      {
        console.log('[Fast Refresh] rebuilding');
        break;
      }

    case 'built':
    case 'sync':
      {
        if (obj.hash) {
          handleAvailableHash(obj.hash);
        }

        var errors = obj.errors,
            warnings = obj.warnings;
        var hasErrors = Boolean(errors && errors.length);

        if (hasErrors) {
          return handleErrors(errors);
        }

        var hasWarnings = Boolean(warnings && warnings.length);

        if (hasWarnings) {
          return handleWarnings(warnings);
        }

        return handleSuccess();
      }

    default:
      {
        if (customHmrEventHandler) {
          customHmrEventHandler(obj);
          break;
        }

        break;
      }
  }
} // Is there a newer version of this code available?


function isUpdateAvailable() {
  /* globals __webpack_hash__ */
  // __webpack_hash__ is the hash of the current compilation.
  // It's a global variable injected by Webpack.
  return mostRecentCompilationHash !== __webpack_require__.h();
} // Webpack disallows updates in other states.


function canApplyUpdates() {
  return module.hot.status() === 'idle';
}

function afterApplyUpdates(fn) {
  if (canApplyUpdates()) {
    fn();
  } else {
    var handler = function handler(status) {
      if (status === 'idle') {
        module.hot.removeStatusHandler(handler);
        fn();
      }
    };

    module.hot.addStatusHandler(handler);
  }
} // Attempt to update code on the fly, fall back to a hard reload.


function tryApplyUpdates(onHotUpdateSuccess) {
  if (false) {}

  if (!isUpdateAvailable() || !canApplyUpdates()) {
    return;
  }

  function handleApplyUpdates(err, updatedModules) {
    if (err || hadRuntimeError || !updatedModules) {
      if (err) {
        console.warn('[Fast Refresh] performing full reload\n\n' + "Fast Refresh will perform a full reload when you edit a file that's imported by modules outside of the React tree.\n" + 'You might have a file which renders a React component but also exports a value that is imported by a non-React component.\n' + 'Consider migrating the non-React component export to a separate file and importing it into both files.\n\n' + 'It is also possible you are using class components at the top-level of your application, which disables Fast Refresh.\n' + 'Fast Refresh requires at least one function component in your React tree.');
      } else if (hadRuntimeError) {
        console.warn('[Fast Refresh] performing full reload because your application had an unrecoverable error');
      }

      window.location.reload();
      return;
    }

    var hasUpdates = Boolean(updatedModules.length);

    if (typeof onHotUpdateSuccess === 'function') {
      // Maybe we want to do something.
      onHotUpdateSuccess(hasUpdates);
    }

    if (isUpdateAvailable()) {
      // While we were updating, there was a new update! Do it again.
      tryApplyUpdates(hasUpdates ? undefined : onHotUpdateSuccess);
    } else {
      if (undefined) {
        afterApplyUpdates(function () {
          if (self.__NEXT_HMR_CB) {
            self.__NEXT_HMR_CB();

            self.__NEXT_HMR_CB = null;
          }
        });
      }
    }
  } // https://webpack.js.org/api/hot-module-replacement/#check


  module.hot.check(
  /* autoApply */
  true).then(function (updatedModules) {
    handleApplyUpdates(null, updatedModules);
  }, function (err) {
    handleApplyUpdates(err, null);
  });
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/dev/event-source-polyfill.js":
/*!********************************************************************!*\
  !*** ./node_modules/next/dist/client/dev/event-source-polyfill.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

exports.__esModule = true;
exports["default"] = void 0;

var _unfetch = _interopRequireDefault(__webpack_require__(/*! next/dist/build/polyfills/unfetch */ "./node_modules/next/dist/build/polyfills/unfetch.js"));
/* eslint-disable */
// Improved version of https://github.com/Yaffle/EventSource/
// Available under MIT License (MIT)
// Only tries to support IE11 and nothing below


var document = window.document;
var Response = window.Response;
var TextDecoder = window.TextDecoder;
var TextEncoder = window.TextEncoder;
var AbortController = window.AbortController;

if (AbortController == undefined) {
  AbortController = function AbortController() {
    this.signal = null;

    this.abort = function () {};
  };
}

function TextDecoderPolyfill() {
  this.bitsNeeded = 0;
  this.codePoint = 0;
}

_c = TextDecoderPolyfill;

TextDecoderPolyfill.prototype.decode = function (octets) {
  function valid(codePoint, shift, octetsCount) {
    if (octetsCount === 1) {
      return codePoint >= 0x0080 >> shift && codePoint << shift <= 0x07ff;
    }

    if (octetsCount === 2) {
      return codePoint >= 0x0800 >> shift && codePoint << shift <= 0xd7ff || codePoint >= 0xe000 >> shift && codePoint << shift <= 0xffff;
    }

    if (octetsCount === 3) {
      return codePoint >= 0x010000 >> shift && codePoint << shift <= 0x10ffff;
    }

    throw new Error();
  }

  function octetsCount(bitsNeeded, codePoint) {
    if (bitsNeeded === 6 * 1) {
      return codePoint >> 6 > 15 ? 3 : codePoint > 31 ? 2 : 1;
    }

    if (bitsNeeded === 6 * 2) {
      return codePoint > 15 ? 3 : 2;
    }

    if (bitsNeeded === 6 * 3) {
      return 3;
    }

    throw new Error();
  }

  var REPLACER = 0xfffd;
  var string = '';
  var bitsNeeded = this.bitsNeeded;
  var codePoint = this.codePoint;

  for (var i = 0; i < octets.length; i += 1) {
    var octet = octets[i];

    if (bitsNeeded !== 0) {
      if (octet < 128 || octet > 191 || !valid(codePoint << 6 | octet & 63, bitsNeeded - 6, octetsCount(bitsNeeded, codePoint))) {
        bitsNeeded = 0;
        codePoint = REPLACER;
        string += String.fromCharCode(codePoint);
      }
    }

    if (bitsNeeded === 0) {
      if (octet >= 0 && octet <= 127) {
        bitsNeeded = 0;
        codePoint = octet;
      } else if (octet >= 192 && octet <= 223) {
        bitsNeeded = 6 * 1;
        codePoint = octet & 31;
      } else if (octet >= 224 && octet <= 239) {
        bitsNeeded = 6 * 2;
        codePoint = octet & 15;
      } else if (octet >= 240 && octet <= 247) {
        bitsNeeded = 6 * 3;
        codePoint = octet & 7;
      } else {
        bitsNeeded = 0;
        codePoint = REPLACER;
      }

      if (bitsNeeded !== 0 && !valid(codePoint, bitsNeeded, octetsCount(bitsNeeded, codePoint))) {
        bitsNeeded = 0;
        codePoint = REPLACER;
      }
    } else {
      bitsNeeded -= 6;
      codePoint = codePoint << 6 | octet & 63;
    }

    if (bitsNeeded === 0) {
      if (codePoint <= 0xffff) {
        string += String.fromCharCode(codePoint);
      } else {
        string += String.fromCharCode(0xd800 + (codePoint - 0xffff - 1 >> 10));
        string += String.fromCharCode(0xdc00 + (codePoint - 0xffff - 1 & 0x3ff));
      }
    }
  }

  this.bitsNeeded = bitsNeeded;
  this.codePoint = codePoint;
  return string;
}; // Firefox < 38 throws an error with stream option


var supportsStreamOption = function supportsStreamOption() {
  try {
    return new TextDecoder().decode(new TextEncoder().encode('test'), {
      stream: true
    }) === 'test';
  } catch (error) {
    console.log(error);
  }

  return false;
}; // IE, Edge


if (TextDecoder == undefined || TextEncoder == undefined || !supportsStreamOption()) {
  TextDecoder = TextDecoderPolyfill;
}

var k = function k() {};

function XHRWrapper(xhr) {
  this.withCredentials = false;
  this.responseType = '';
  this.readyState = 0;
  this.status = 0;
  this.statusText = '';
  this.responseText = '';
  this.onprogress = k;
  this.onreadystatechange = k;
  this._contentType = '';
  this._xhr = xhr;
  this._sendTimeout = 0;
  this._abort = k;
}

_c2 = XHRWrapper;

XHRWrapper.prototype.open = function (method, url) {
  this._abort(true);

  var that = this;
  var xhr = this._xhr;
  var state = 1;
  var timeout = 0;

  this._abort = function (silent) {
    if (that._sendTimeout !== 0) {
      clearTimeout(that._sendTimeout);
      that._sendTimeout = 0;
    }

    if (state === 1 || state === 2 || state === 3) {
      state = 4;
      xhr.onload = k;
      xhr.onerror = k;
      xhr.onabort = k;
      xhr.onprogress = k;
      xhr.onreadystatechange = k; // IE 8 - 9: XDomainRequest#abort() does not fire any event
      // Opera < 10: XMLHttpRequest#abort() does not fire any event

      xhr.abort();

      if (timeout !== 0) {
        clearTimeout(timeout);
        timeout = 0;
      }

      if (!silent) {
        that.readyState = 4;
        that.onreadystatechange();
      }
    }

    state = 0;
  };

  var onStart = function onStart() {
    if (state === 1) {
      // state = 2;
      var status = 0;
      var statusText = '';
      var contentType = undefined;

      if (!('contentType' in xhr)) {
        try {
          status = xhr.status;
          statusText = xhr.statusText;
          contentType = xhr.getResponseHeader('Content-Type');
        } catch (error) {
          // IE < 10 throws exception for `xhr.status` when xhr.readyState === 2 || xhr.readyState === 3
          // Opera < 11 throws exception for `xhr.status` when xhr.readyState === 2
          // https://bugs.webkit.org/show_bug.cgi?id=29121
          status = 0;
          statusText = '';
          contentType = undefined; // Firefox < 14, Chrome ?, Safari ?
          // https://bugs.webkit.org/show_bug.cgi?id=29658
          // https://bugs.webkit.org/show_bug.cgi?id=77854
        }
      } else {
        status = 200;
        statusText = 'OK';
        contentType = xhr.contentType;
      }

      if (status !== 0) {
        state = 2;
        that.readyState = 2;
        that.status = status;
        that.statusText = statusText;
        that._contentType = contentType;
        that.onreadystatechange();
      }
    }
  };

  var onProgress = function onProgress() {
    onStart();

    if (state === 2 || state === 3) {
      state = 3;
      var responseText = '';

      try {
        responseText = xhr.responseText;
      } catch (error) {// IE 8 - 9 with XMLHttpRequest
      }

      that.readyState = 3;
      that.responseText = responseText;
      that.onprogress();
    }
  };

  var onFinish = function onFinish() {
    // Firefox 52 fires "readystatechange" (xhr.readyState === 4) without final "readystatechange" (xhr.readyState === 3)
    // IE 8 fires "onload" without "onprogress"
    onProgress();

    if (state === 1 || state === 2 || state === 3) {
      state = 4;

      if (timeout !== 0) {
        clearTimeout(timeout);
        timeout = 0;
      }

      that.readyState = 4;
      that.onreadystatechange();
    }
  };

  var onReadyStateChange = function onReadyStateChange() {
    if (xhr != undefined) {
      // Opera 12
      if (xhr.readyState === 4) {
        onFinish();
      } else if (xhr.readyState === 3) {
        onProgress();
      } else if (xhr.readyState === 2) {
        onStart();
      }
    }
  };

  var onTimeout = function onTimeout() {
    timeout = setTimeout(function () {
      onTimeout();
    }, 500);

    if (xhr.readyState === 3) {
      onProgress();
    }
  }; // XDomainRequest#abort removes onprogress, onerror, onload


  xhr.onload = onFinish;
  xhr.onerror = onFinish; // improper fix to match Firefox behaviour, but it is better than just ignore abort
  // see https://bugzilla.mozilla.org/show_bug.cgi?id=768596
  // https://bugzilla.mozilla.org/show_bug.cgi?id=880200
  // https://code.google.com/p/chromium/issues/detail?id=153570
  // IE 8 fires "onload" without "onprogress

  xhr.onabort = onFinish; // https://bugzilla.mozilla.org/show_bug.cgi?id=736723

  if (!('sendAsBinary' in XMLHttpRequest.prototype) && !('mozAnon' in XMLHttpRequest.prototype)) {
    xhr.onprogress = onProgress;
  } // IE 8 - 9 (XMLHTTPRequest)
  // Opera < 12
  // Firefox < 3.5
  // Firefox 3.5 - 3.6 - ? < 9.0
  // onprogress is not fired sometimes or delayed
  // see also #64


  xhr.onreadystatechange = onReadyStateChange;

  if ('contentType' in xhr) {
    url += (url.indexOf('?') === -1 ? '?' : '&') + 'padding=true';
  }

  xhr.open(method, url, true);

  if ('readyState' in xhr) {
    // workaround for Opera 12 issue with "progress" events
    // #91
    timeout = setTimeout(function () {
      onTimeout();
    }, 0);
  }
};

XHRWrapper.prototype.abort = function () {
  this._abort(false);
};

XHRWrapper.prototype.getResponseHeader = function (name) {
  return this._contentType;
};

XHRWrapper.prototype.setRequestHeader = function (name, value) {
  var xhr = this._xhr;

  if ('setRequestHeader' in xhr) {
    xhr.setRequestHeader(name, value);
  }
};

XHRWrapper.prototype.getAllResponseHeaders = function () {
  return this._xhr.getAllResponseHeaders != undefined ? this._xhr.getAllResponseHeaders() : '';
};

XHRWrapper.prototype.send = function () {
  // loading indicator in Safari < ? (6), Chrome < 14, Firefox
  if (!('ontimeout' in XMLHttpRequest.prototype) && document != undefined && document.readyState != undefined && document.readyState !== 'complete') {
    var that = this;
    that._sendTimeout = setTimeout(function () {
      that._sendTimeout = 0;
      that.send();
    }, 4);
    return;
  }

  var xhr = this._xhr; // withCredentials should be set after "open" for Safari and Chrome (< 19 ?)

  xhr.withCredentials = this.withCredentials;
  xhr.responseType = this.responseType;

  try {
    // xhr.send(); throws "Not enough arguments" in Firefox 3.0
    xhr.send(undefined);
  } catch (error1) {
    // Safari 5.1.7, Opera 12
    throw error1;
  }
};

function toLowerCase(name) {
  return name.replace(/[A-Z]/g, function (c) {
    return String.fromCharCode(c.charCodeAt(0) + 0x20);
  });
}

function HeadersPolyfill(all) {
  // Get headers: implemented according to mozilla's example code: https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/getAllResponseHeaders#Example
  var map = Object.create(null);
  var array = all.split('\r\n');

  for (var i = 0; i < array.length; i += 1) {
    var line = array[i];
    var parts = line.split(': ');
    var name = parts.shift();
    var value = parts.join(': ');
    map[toLowerCase(name)] = value;
  }

  this._map = map;
}

_c3 = HeadersPolyfill;

HeadersPolyfill.prototype.get = function (name) {
  return this._map[toLowerCase(name)];
};

function XHRTransport() {}

_c4 = XHRTransport;

XHRTransport.prototype.open = function (xhr, onStartCallback, onProgressCallback, onFinishCallback, url, withCredentials, headers) {
  xhr.open('GET', url);
  var offset = 0;

  xhr.onprogress = function () {
    var responseText = xhr.responseText;
    var chunk = responseText.slice(offset);
    offset += chunk.length;
    onProgressCallback(chunk);
  };

  xhr.onreadystatechange = function () {
    if (xhr.readyState === 2) {
      var status = xhr.status;
      var statusText = xhr.statusText;
      var contentType = xhr.getResponseHeader('Content-Type');
      var headers = xhr.getAllResponseHeaders();
      onStartCallback(status, statusText, contentType, new HeadersPolyfill(headers), function () {
        xhr.abort();
      });
    } else if (xhr.readyState === 4) {
      onFinishCallback();
    }
  };

  xhr.withCredentials = withCredentials;
  xhr.responseType = 'text';

  for (var name in headers) {
    if (Object.prototype.hasOwnProperty.call(headers, name)) {
      xhr.setRequestHeader(name, headers[name]);
    }
  }

  xhr.send();
};

function HeadersWrapper(headers) {
  this._headers = headers;
}

_c5 = HeadersWrapper;

HeadersWrapper.prototype.get = function (name) {
  return this._headers.get(name);
};

function FetchTransport() {}

_c6 = FetchTransport;

FetchTransport.prototype.open = function (xhr, onStartCallback, onProgressCallback, onFinishCallback, url, withCredentials, headers) {
  var controller = new AbortController();
  var signal = controller.signal; // see #120

  var textDecoder = new TextDecoder();
  (0, _unfetch["default"])(url, {
    headers: headers,
    credentials: withCredentials ? 'include' : 'same-origin',
    signal: signal,
    cache: 'no-store'
  }).then(function (response) {
    var reader = response.body.getReader();
    onStartCallback(response.status, response.statusText, response.headers.get('Content-Type'), new HeadersWrapper(response.headers), function () {
      controller.abort();
      reader.cancel();
    });
    return new Promise(function (resolve, reject) {
      var readNextChunk = function readNextChunk() {
        reader.read().then(function (result) {
          if (result.done) {
            // Note: bytes in textDecoder are ignored
            resolve(undefined);
          } else {
            var chunk = textDecoder.decode(result.value, {
              stream: true
            });
            onProgressCallback(chunk);
            readNextChunk();
          }
        })['catch'](function (error) {
          reject(error);
        });
      };

      readNextChunk();
    });
  }).then(function (result) {
    onFinishCallback();
    return result;
  }, function (error) {
    onFinishCallback();
    return Promise.reject(error);
  });
};

function EventTarget() {
  this._listeners = Object.create(null);
}

_c7 = EventTarget;

function throwError(e) {
  setTimeout(function () {
    throw e;
  }, 0);
}

EventTarget.prototype.dispatchEvent = function (event) {
  event.target = this;
  var typeListeners = this._listeners[event.type];

  if (typeListeners != undefined) {
    var length = typeListeners.length;

    for (var i = 0; i < length; i += 1) {
      var listener = typeListeners[i];

      try {
        if (typeof listener.handleEvent === 'function') {
          listener.handleEvent(event);
        } else {
          listener.call(this, event);
        }
      } catch (e) {
        throwError(e);
      }
    }
  }
};

EventTarget.prototype.addEventListener = function (type, listener) {
  type = String(type);
  var listeners = this._listeners;
  var typeListeners = listeners[type];

  if (typeListeners == undefined) {
    typeListeners = [];
    listeners[type] = typeListeners;
  }

  var found = false;

  for (var i = 0; i < typeListeners.length; i += 1) {
    if (typeListeners[i] === listener) {
      found = true;
    }
  }

  if (!found) {
    typeListeners.push(listener);
  }
};

EventTarget.prototype.removeEventListener = function (type, listener) {
  type = String(type);
  var listeners = this._listeners;
  var typeListeners = listeners[type];

  if (typeListeners != undefined) {
    var filtered = [];

    for (var i = 0; i < typeListeners.length; i += 1) {
      if (typeListeners[i] !== listener) {
        filtered.push(typeListeners[i]);
      }
    }

    if (filtered.length === 0) {
      delete listeners[type];
    } else {
      listeners[type] = filtered;
    }
  }
};

function Event(type) {
  this.type = type;
  this.target = undefined;
}

_c8 = Event;

function MessageEvent(type, options) {
  Event.call(this, type);
  this.data = options.data;
  this.lastEventId = options.lastEventId;
}

_c9 = MessageEvent;
MessageEvent.prototype = Object.create(Event.prototype);

function ConnectionEvent(type, options) {
  Event.call(this, type);
  this.status = options.status;
  this.statusText = options.statusText;
  this.headers = options.headers;
}

_c10 = ConnectionEvent;
ConnectionEvent.prototype = Object.create(Event.prototype);
var WAITING = -1;
var CONNECTING = 0;
var OPEN = 1;
var CLOSED = 2;
var AFTER_CR = -1;
var FIELD_START = 0;
var FIELD = 1;
var VALUE_START = 2;
var VALUE = 3;
var contentTypeRegExp = /^text\/event\-stream;?(\s*charset\=utf\-8)?$/i;
var MINIMUM_DURATION = 1000;
var MAXIMUM_DURATION = 18000000;

var parseDuration = function parseDuration(value, def) {
  var n = parseInt(value, 10);

  if (n !== n) {
    n = def;
  }

  return clampDuration(n);
};

var clampDuration = function clampDuration(n) {
  return Math.min(Math.max(n, MINIMUM_DURATION), MAXIMUM_DURATION);
};

var fire = function fire(that, f, event) {
  try {
    if (typeof f === 'function') {
      f.call(that, event);
    }
  } catch (e) {
    throwError(e);
  }
};

function EventSourcePolyfill(url, options) {
  EventTarget.call(this);
  this.onopen = undefined;
  this.onmessage = undefined;
  this.onerror = undefined;
  this.url = undefined;
  this.readyState = undefined;
  this.withCredentials = undefined;
  this._close = undefined;
  start(this, url, options);
}

_c11 = EventSourcePolyfill;
var isFetchSupported = _unfetch["default"] != undefined && Response != undefined && 'body' in Response.prototype;

function start(es, url, options) {
  url = String(url);
  var withCredentials = options != undefined && Boolean(options.withCredentials);
  var initialRetry = clampDuration(1000);
  var heartbeatTimeout = options != undefined && options.heartbeatTimeout != undefined ? parseDuration(options.heartbeatTimeout, 45000) : clampDuration(45000);
  var lastEventId = '';
  var retry = initialRetry;
  var wasActivity = false;
  var headers = options != undefined && options.headers != undefined ? JSON.parse(JSON.stringify(options.headers)) : undefined;
  var CurrentTransport = options != undefined && options.Transport != undefined ? options.Transport : XMLHttpRequest;
  var xhr = isFetchSupported && !(options != undefined && options.Transport != undefined) ? undefined : new XHRWrapper(new CurrentTransport());
  var transport = xhr == undefined ? new FetchTransport() : new XHRTransport();
  var cancelFunction = undefined;
  var timeout = 0;
  var currentState = WAITING;
  var dataBuffer = '';
  var lastEventIdBuffer = '';
  var eventTypeBuffer = '';
  var textBuffer = '';
  var state = FIELD_START;
  var fieldStart = 0;
  var valueStart = 0;

  var onStart = function onStart(status, statusText, contentType, headers, cancel) {
    if (currentState === CONNECTING) {
      cancelFunction = cancel;

      if (status === 200 && contentType != undefined && contentTypeRegExp.test(contentType)) {
        currentState = OPEN;
        wasActivity = true;
        retry = initialRetry;
        es.readyState = OPEN;
        var event = new ConnectionEvent('open', {
          status: status,
          statusText: statusText,
          headers: headers
        });
        es.dispatchEvent(event);
        fire(es, es.onopen, event);
      } else {
        var message = '';

        if (status !== 200) {
          if (statusText) {
            statusText = statusText.replace(/\s+/g, ' ');
          }

          message = "EventSource's response has a status " + status + ' ' + statusText + ' that is not 200. Aborting the connection.';
        } else {
          message = "EventSource's response has a Content-Type specifying an unsupported type: " + (contentType == undefined ? '-' : contentType.replace(/\s+/g, ' ')) + '. Aborting the connection.';
        }

        throwError(new Error(message));
        close();
        var event = new ConnectionEvent('error', {
          status: status,
          statusText: statusText,
          headers: headers
        });
        es.dispatchEvent(event);
        fire(es, es.onerror, event);
      }
    }
  };

  var onProgress = function onProgress(textChunk) {
    if (currentState === OPEN) {
      var n = -1;

      for (var i = 0; i < textChunk.length; i += 1) {
        var c = textChunk.charCodeAt(i);

        if (c === '\n'.charCodeAt(0) || c === '\r'.charCodeAt(0)) {
          n = i;
        }
      }

      var chunk = (n !== -1 ? textBuffer : '') + textChunk.slice(0, n + 1);
      textBuffer = (n === -1 ? textBuffer : '') + textChunk.slice(n + 1);

      if (chunk !== '') {
        wasActivity = true;
      }

      for (var position = 0; position < chunk.length; position += 1) {
        var c = chunk.charCodeAt(position);

        if (state === AFTER_CR && c === '\n'.charCodeAt(0)) {
          state = FIELD_START;
        } else {
          if (state === AFTER_CR) {
            state = FIELD_START;
          }

          if (c === '\r'.charCodeAt(0) || c === '\n'.charCodeAt(0)) {
            if (state !== FIELD_START) {
              if (state === FIELD) {
                valueStart = position + 1;
              }

              var field = chunk.slice(fieldStart, valueStart - 1);
              var value = chunk.slice(valueStart + (valueStart < position && chunk.charCodeAt(valueStart) === ' '.charCodeAt(0) ? 1 : 0), position);

              if (field === 'data') {
                dataBuffer += '\n';
                dataBuffer += value;
              } else if (field === 'id') {
                lastEventIdBuffer = value;
              } else if (field === 'event') {
                eventTypeBuffer = value;
              } else if (field === 'retry') {
                initialRetry = parseDuration(value, initialRetry);
                retry = initialRetry;
              } else if (field === 'heartbeatTimeout') {
                heartbeatTimeout = parseDuration(value, heartbeatTimeout);

                if (timeout !== 0) {
                  clearTimeout(timeout);
                  timeout = setTimeout(function () {
                    onTimeout();
                  }, heartbeatTimeout);
                }
              }
            }

            if (state === FIELD_START) {
              if (dataBuffer !== '') {
                lastEventId = lastEventIdBuffer;

                if (eventTypeBuffer === '') {
                  eventTypeBuffer = 'message';
                }

                var event = new MessageEvent(eventTypeBuffer, {
                  data: dataBuffer.slice(1),
                  lastEventId: lastEventIdBuffer
                });
                es.dispatchEvent(event);

                if (eventTypeBuffer === 'message') {
                  fire(es, es.onmessage, event);
                }

                if (currentState === CLOSED) {
                  return;
                }
              }

              dataBuffer = '';
              eventTypeBuffer = '';
            }

            state = c === '\r'.charCodeAt(0) ? AFTER_CR : FIELD_START;
          } else {
            if (state === FIELD_START) {
              fieldStart = position;
              state = FIELD;
            }

            if (state === FIELD) {
              if (c === ':'.charCodeAt(0)) {
                valueStart = position + 1;
                state = VALUE_START;
              }
            } else if (state === VALUE_START) {
              state = VALUE;
            }
          }
        }
      }
    }
  };

  var onFinish = function onFinish() {
    if (currentState === OPEN || currentState === CONNECTING) {
      currentState = WAITING;

      if (timeout !== 0) {
        clearTimeout(timeout);
        timeout = 0;
      }

      timeout = setTimeout(function () {
        onTimeout();
      }, retry);
      retry = clampDuration(Math.min(initialRetry * 16, retry * 2));
      es.readyState = CONNECTING;
      var event = new Event('error');
      es.dispatchEvent(event);
      fire(es, es.onerror, event);
    }
  };

  var close = function close() {
    currentState = CLOSED;

    if (cancelFunction != undefined) {
      cancelFunction();
      cancelFunction = undefined;
    }

    if (timeout !== 0) {
      clearTimeout(timeout);
      timeout = 0;
    }

    es.readyState = CLOSED;
  };

  var onTimeout = function onTimeout() {
    timeout = 0;

    if (currentState !== WAITING) {
      if (!wasActivity && cancelFunction != undefined) {
        throwError(new Error('No activity within ' + heartbeatTimeout + ' milliseconds. Reconnecting.'));
        cancelFunction();
        cancelFunction = undefined;
      } else {
        wasActivity = false;
        timeout = setTimeout(function () {
          onTimeout();
        }, heartbeatTimeout);
      }

      return;
    }

    wasActivity = false;
    timeout = setTimeout(function () {
      onTimeout();
    }, heartbeatTimeout);
    currentState = CONNECTING;
    dataBuffer = '';
    eventTypeBuffer = '';
    lastEventIdBuffer = lastEventId;
    textBuffer = '';
    fieldStart = 0;
    valueStart = 0;
    state = FIELD_START; // https://bugzilla.mozilla.org/show_bug.cgi?id=428916
    // Request header field Last-Event-ID is not allowed by Access-Control-Allow-Headers.

    var requestURL = url;

    if (url.slice(0, 5) !== 'data:' && url.slice(0, 5) !== 'blob:') {
      if (lastEventId !== '') {
        requestURL += (url.indexOf('?') === -1 ? '?' : '&') + 'lastEventId=' + encodeURIComponent(lastEventId);
      }
    }

    var requestHeaders = {};
    requestHeaders['Accept'] = 'text/event-stream';

    if (headers != undefined) {
      for (var name in headers) {
        if (Object.prototype.hasOwnProperty.call(headers, name)) {
          requestHeaders[name] = headers[name];
        }
      }
    }

    try {
      transport.open(xhr, onStart, onProgress, onFinish, requestURL, withCredentials, requestHeaders);
    } catch (error) {
      close();
      throw error;
    }
  };

  es.url = url;
  es.readyState = CONNECTING;
  es.withCredentials = withCredentials;
  es._close = close;
  onTimeout();
}

EventSourcePolyfill.prototype = Object.create(EventTarget.prototype);
EventSourcePolyfill.prototype.CONNECTING = CONNECTING;
EventSourcePolyfill.prototype.OPEN = OPEN;
EventSourcePolyfill.prototype.CLOSED = CLOSED;

EventSourcePolyfill.prototype.close = function () {
  this._close();
};

EventSourcePolyfill.CONNECTING = CONNECTING;
EventSourcePolyfill.OPEN = OPEN;
EventSourcePolyfill.CLOSED = CLOSED;
EventSourcePolyfill.prototype.withCredentials = undefined;
var _default = EventSourcePolyfill;
exports["default"] = _default;

var _c, _c2, _c3, _c4, _c5, _c6, _c7, _c8, _c9, _c10, _c11;

$RefreshReg$(_c, "TextDecoderPolyfill");
$RefreshReg$(_c2, "XHRWrapper");
$RefreshReg$(_c3, "HeadersPolyfill");
$RefreshReg$(_c4, "XHRTransport");
$RefreshReg$(_c5, "HeadersWrapper");
$RefreshReg$(_c6, "FetchTransport");
$RefreshReg$(_c7, "EventTarget");
$RefreshReg$(_c8, "Event");
$RefreshReg$(_c9, "MessageEvent");
$RefreshReg$(_c10, "ConnectionEvent");
$RefreshReg$(_c11, "EventSourcePolyfill");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/dev/fouc.js":
/*!***************************************************!*\
  !*** ./node_modules/next/dist/client/dev/fouc.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.displayContent = displayContent;

function displayContent(callback) {
  // This is the fallback helper that removes Next.js' no-FOUC styles when
  // CSS mode is enabled. This only really activates if you haven't created
  // _any_ styles in your application yet.
  ;
  (window.requestAnimationFrame || setTimeout)(function () {
    for (var x = document.querySelectorAll('[data-next-hide-fouc]'), i = x.length; i--;) {
      x[i].parentNode.removeChild(x[i]);
    }

    if (callback) {
      callback();
    }
  });
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/dev/on-demand-entries-client.js":
/*!***********************************************************************!*\
  !*** ./node_modules/next/dist/client/dev/on-demand-entries-client.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _regeneratorRuntime = __webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js");

var _asyncToGenerator = __webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js");

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

exports.__esModule = true;
exports["default"] = void 0;

var _router = _interopRequireDefault(__webpack_require__(/*! next/router */ "./node_modules/next/dist/client/router.js"));

var _onDemandEntriesUtils = __webpack_require__(/*! ./on-demand-entries-utils */ "./node_modules/next/dist/client/dev/on-demand-entries-utils.js");

var _default = /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(_ref) {
    var assetPrefix;
    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            assetPrefix = _ref.assetPrefix;

            _router["default"].ready(function () {
              _router["default"].events.on('routeChangeComplete', _onDemandEntriesUtils.setupPing.bind(void 0, assetPrefix, function () {
                return _router["default"].pathname;
              }));
            });

            (0, _onDemandEntriesUtils.setupPing)(assetPrefix, function () {
              return _router["default"].pathname;
            }, _onDemandEntriesUtils.currentPage); // prevent HMR connection from being closed when running tests

            if (!undefined) {
              document.addEventListener('visibilitychange', function (event) {
                var state = document.visibilityState;

                if (state === 'visible') {
                  (0, _onDemandEntriesUtils.setupPing)(assetPrefix, function () {
                    return _router["default"].pathname;
                  }, true);
                } else {
                  (0, _onDemandEntriesUtils.closePing)();
                }
              });
              window.addEventListener('beforeunload', function () {
                (0, _onDemandEntriesUtils.closePing)();
              });
            }

          case 4:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function _default(_x) {
    return _ref2.apply(this, arguments);
  };
}();

exports["default"] = _default;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/dev/on-demand-entries-utils.js":
/*!**********************************************************************!*\
  !*** ./node_modules/next/dist/client/dev/on-demand-entries-utils.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

exports.__esModule = true;
exports.closePing = closePing;
exports.setupPing = setupPing;
exports.currentPage = void 0;

var _unfetch = _interopRequireDefault(__webpack_require__(/*! next/dist/build/polyfills/unfetch */ "./node_modules/next/dist/build/polyfills/unfetch.js"));

var _eventsource = __webpack_require__(/*! ./error-overlay/eventsource */ "./node_modules/next/dist/client/dev/error-overlay/eventsource.js");
/* global location */


var evtSource;
var currentPage;
exports.currentPage = currentPage;

function closePing() {
  if (evtSource) evtSource.close();
  evtSource = null;
}

function setupPing(assetPrefix, pathnameFn, retry) {
  var pathname = pathnameFn(); // Make sure to only create new EventSource request if page has changed

  if (pathname === currentPage && !retry) return;
  exports.currentPage = currentPage = pathname; // close current EventSource connection

  closePing();
  var url = "".concat(assetPrefix, "/_next/webpack-hmr?page=").concat(currentPage);
  evtSource = (0, _eventsource.getEventSourceWrapper)({
    path: url,
    timeout: 5000,
    ondemand: 1
  });
  evtSource.addMessageListener(function (event) {
    if (event.data.indexOf('{') === -1) return;

    try {
      var payload = JSON.parse(event.data);

      if (payload.invalid) {
        // Payload can be invalid even if the page does not exist.
        // So, we need to make sure it exists before reloading.
        (0, _unfetch["default"])(location.href, {
          credentials: 'same-origin'
        }).then(function (pageRes) {
          if (pageRes.status === 200) {
            location.reload();
          }
        });
      }
    } catch (err) {
      console.error('on-demand-entries failed to parse response', err);
    }
  });
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/dev/prerender-indicator.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/client/dev/prerender-indicator.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

exports.__esModule = true;
exports["default"] = initializeBuildWatcher;

var _router = _interopRequireDefault(__webpack_require__(/*! ../router */ "./node_modules/next/dist/client/router.js"));

function initializeBuildWatcher() {
  var shadowHost = document.createElement('div');
  shadowHost.id = '__next-prerender-indicator'; // Make sure container is fixed and on a high zIndex so it shows

  shadowHost.style.position = 'fixed';
  shadowHost.style.bottom = '20px';
  shadowHost.style.right = '10px';
  shadowHost.style.width = 0;
  shadowHost.style.height = 0;
  shadowHost.style.zIndex = 99998;
  shadowHost.style.transition = 'all 100ms ease';
  document.body.appendChild(shadowHost);
  var shadowRoot;
  var prefix = '';

  if (shadowHost.attachShadow) {
    shadowRoot = shadowHost.attachShadow({
      mode: 'open'
    });
  } else {
    // If attachShadow is undefined then the browser does not support
    // the Shadow DOM, we need to prefix all the names so there
    // will be no conflicts
    shadowRoot = shadowHost;
    prefix = '__next-prerender-indicator-';
  } // Container


  var container = createContainer(prefix);
  shadowRoot.appendChild(container); // CSS

  var css = createCss(prefix);
  shadowRoot.appendChild(css);
  var expandEl = container.querySelector('a');
  var closeEl = container.querySelector("#".concat(prefix, "close")); // State

  var dismissKey = '__NEXT_DISMISS_PRERENDER_INDICATOR';
  var dismissUntil = parseInt(window.localStorage.getItem(dismissKey), 10);
  var dismissed = dismissUntil > new Date().getTime();
  var isVisible = !dismissed && window.__NEXT_DATA__.nextExport;

  function updateContainer() {
    if (isVisible) {
      container.classList.add("".concat(prefix, "visible"));
    } else {
      container.classList.remove("".concat(prefix, "visible"));
    }
  }

  var expandedClass = "".concat(prefix, "expanded");
  var toggleTimeout;

  var toggleExpand = function toggleExpand() {
    var expand = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
    clearTimeout(toggleTimeout);
    toggleTimeout = setTimeout(function () {
      if (expand) {
        expandEl.classList.add(expandedClass);
        closeEl.style.display = 'flex';
      } else {
        expandEl.classList.remove(expandedClass);
        closeEl.style.display = 'none';
      }
    }, 50);
  };

  closeEl.addEventListener('click', function () {
    var oneHourAway = new Date().getTime() + 1 * 60 * 60 * 1000;
    window.localStorage.setItem(dismissKey, oneHourAway + '');
    isVisible = false;
    updateContainer();
  });
  closeEl.addEventListener('mouseenter', function () {
    return toggleExpand();
  });
  closeEl.addEventListener('mouseleave', function () {
    return toggleExpand(false);
  });
  expandEl.addEventListener('mouseenter', function () {
    return toggleExpand();
  });
  expandEl.addEventListener('mouseleave', function () {
    return toggleExpand(false);
  });

  _router["default"].events.on('routeChangeComplete', function () {
    isVisible = window.next.isPrerendered;
    updateContainer();
  });

  updateContainer();
}

function createContainer(prefix) {
  var container = document.createElement('div');
  container.id = "".concat(prefix, "container");
  container.innerHTML = "\n    <button id=\"".concat(prefix, "close\" title=\"Hide indicator for session\">\n      <span>\xD7</span>\n    </button>\n    <a href=\"https://nextjs.org/docs#automatic-static-optimization-indicator\" target=\"_blank\" rel=\"noreferrer\">\n      <div id=\"").concat(prefix, "icon-wrapper\">\n          <svg width=\"15\" height=\"20\" viewBox=\"0 0 60 80\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n          <path d=\"M36 3L30.74 41H8L36 3Z\" fill=\"black\"/>\n          <path d=\"M25 77L30.26 39H53L25 77Z\" fill=\"black\"/>\n          <path d=\"M13.5 33.5L53 39L47.5 46.5L7 41.25L13.5 33.5Z\" fill=\"black\"/>\n          </svg>\n          Prerendered Page\n      </div>\n    </a>\n  ");
  return container;
}

function createCss(prefix) {
  var css = document.createElement('style');
  css.textContent = "\n    #".concat(prefix, "container {\n      position: absolute;\n      display: none;\n      bottom: 10px;\n      right: 15px;\n    }\n\n    #").concat(prefix, "close {\n      top: -10px;\n      right: -10px;\n      border: none;\n      width: 18px;\n      height: 18px;\n      color: #333333;\n      font-size: 16px;\n      cursor: pointer;\n      display: none;\n      position: absolute;\n      background: #ffffff;\n      border-radius: 100%;\n      align-items: center;\n      flex-direction: column;\n      justify-content: center;\n    }\n\n    #").concat(prefix, "container a {\n      color: inherit;\n      text-decoration: none;\n      width: 15px;\n      height: 23px;\n      overflow: hidden;\n\n      border-radius: 3px;\n      background: #fff;\n      color: #000;\n      font: initial;\n      cursor: pointer;\n      letter-spacing: initial;\n      text-shadow: initial;\n      text-transform: initial;\n      visibility: initial;\n      font-size: 14px;\n      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;\n\n      padding: 4px 2px;\n      align-items: center;\n      box-shadow: 0 11px 40px 0 rgba(0, 0, 0, 0.25), 0 2px 10px 0 rgba(0, 0, 0, 0.12);\n\n      display: flex;\n      transition: opacity 0.1s ease, bottom 0.1s ease, width 0.3s ease;\n      animation: ").concat(prefix, "fade-in 0.1s ease-in-out;\n    }\n\n    #").concat(prefix, "icon-wrapper {\n      width: 140px;\n      height: 20px;\n      display: flex;\n      flex-shrink: 0;\n      align-items: center;\n      position: relative;\n    }\n\n    #").concat(prefix, "icon-wrapper svg {\n      flex-shrink: 0;\n      margin-right: 3px;\n    }\n\n    #").concat(prefix, "container a.").concat(prefix, "expanded {\n      width: 135px;\n    }\n\n    #").concat(prefix, "container.").concat(prefix, "visible {\n      display: flex;\n      bottom: 10px;\n      opacity: 1;\n    }\n\n    @keyframes ").concat(prefix, "fade-in {\n      from {\n        bottom: 0px;\n        opacity: 0;\n      }\n      to {\n        bottom: 10px;\n        opacity: 1;\n      }\n    }\n  ");
  return css;
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/dev/webpack-hot-middleware-client.js":
/*!****************************************************************************!*\
  !*** ./node_modules/next/dist/client/dev/webpack-hot-middleware-client.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _slicedToArray = __webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ "./node_modules/@babel/runtime/helpers/slicedToArray.js");

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

exports.__esModule = true;
exports["default"] = void 0;

var _hotDevClient = _interopRequireDefault(__webpack_require__(/*! ./error-overlay/hot-dev-client */ "./node_modules/next/dist/client/dev/error-overlay/hot-dev-client.js"));

var _default = function _default(_ref) {
  var assetPrefix = _ref.assetPrefix;
  var options = {
    path: "".concat(assetPrefix, "/_next/webpack-hmr")
  };
  var devClient = (0, _hotDevClient["default"])(options);
  devClient.subscribeToHmrEvent(function (obj) {
    if (obj.action === 'reloadPage') {
      return window.location.reload();
    }

    if (obj.action === 'removedPage') {
      var _obj$data = _slicedToArray(obj.data, 1),
          page = _obj$data[0];

      if (page === window.next.router.pathname) {
        return window.location.reload();
      }

      return;
    }

    if (obj.action === 'addedPage') {
      var _obj$data2 = _slicedToArray(obj.data, 1),
          _page = _obj$data2[0];

      if (_page === window.next.router.pathname && typeof window.next.router.components[_page] === 'undefined') {
        return window.location.reload();
      }

      return;
    }

    throw new Error('Unexpected action ' + obj.action);
  });
  return devClient;
};

exports["default"] = _default;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/head-manager.js":
/*!*******************************************************!*\
  !*** ./node_modules/next/dist/client/head-manager.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports["default"] = initHeadManager;
var DOMAttributeNames = {
  acceptCharset: 'accept-charset',
  className: 'class',
  htmlFor: 'for',
  httpEquiv: 'http-equiv'
};

function reactElementToDOM(_ref) {
  var type = _ref.type,
      props = _ref.props;
  var el = document.createElement(type);

  for (var p in props) {
    if (!props.hasOwnProperty(p)) continue;
    if (p === 'children' || p === 'dangerouslySetInnerHTML') continue; // we don't render undefined props to the DOM

    if (props[p] === undefined) continue;
    var attr = DOMAttributeNames[p] || p.toLowerCase();
    el.setAttribute(attr, props[p]);
  }

  var children = props.children,
      dangerouslySetInnerHTML = props.dangerouslySetInnerHTML;

  if (dangerouslySetInnerHTML) {
    el.innerHTML = dangerouslySetInnerHTML.__html || '';
  } else if (children) {
    el.textContent = typeof children === 'string' ? children : children.join('');
  }

  return el;
}

function updateElements(type, components) {
  var headEl = document.getElementsByTagName('head')[0];
  var headCountEl = headEl.querySelector('meta[name=next-head-count]');

  if (true) {
    if (!headCountEl) {
      console.error('Warning: next-head-count is missing. https://err.sh/next.js/next-head-count-missing');
      return;
    }
  }

  var headCount = Number(headCountEl.content);
  var oldTags = [];

  for (var i = 0, j = headCountEl.previousElementSibling; i < headCount; i++, j = j.previousElementSibling) {
    if (j.tagName.toLowerCase() === type) {
      oldTags.push(j);
    }
  }

  var newTags = components.map(reactElementToDOM).filter(function (newTag) {
    for (var k = 0, len = oldTags.length; k < len; k++) {
      var oldTag = oldTags[k];

      if (oldTag.isEqualNode(newTag)) {
        oldTags.splice(k, 1);
        return false;
      }
    }

    return true;
  });
  oldTags.forEach(function (t) {
    return t.parentNode.removeChild(t);
  });
  newTags.forEach(function (t) {
    return headEl.insertBefore(t, headCountEl);
  });
  headCountEl.content = (headCount - oldTags.length + newTags.length).toString();
}

function initHeadManager() {
  var updatePromise = null;
  return function (head) {
    var promise = updatePromise = Promise.resolve().then(function () {
      if (promise !== updatePromise) return;
      updatePromise = null;
      var tags = {};
      head.forEach(function (h) {
        var components = tags[h.type] || [];
        components.push(h);
        tags[h.type] = components;
      });
      var titleComponent = tags.title ? tags.title[0] : null;
      var title = '';

      if (titleComponent) {
        var children = titleComponent.props.children;
        title = typeof children === 'string' ? children : children.join('');
      }

      if (title !== document.title) document.title = title;
      ['meta', 'base', 'link', 'style', 'script'].forEach(function (type) {
        updateElements(type, tags[type] || []);
      });
    });
  };
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/index.js":
/*!************************************************!*\
  !*** ./node_modules/next/dist/client/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _regeneratorRuntime = __webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js");

var _asyncToGenerator = __webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js");

var _classCallCheck = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js");

var _createClass = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js");

var _inherits = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js");

var _possibleConstructorReturn = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js");

var _getPrototypeOf = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js");

var _slicedToArray = __webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ "./node_modules/@babel/runtime/helpers/slicedToArray.js");

var _s = $RefreshSig$();

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

var _interopRequireWildcard3 = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "./node_modules/@babel/runtime/helpers/interopRequireWildcard.js");

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

exports.__esModule = true;
exports.render = render;
exports.renderError = renderError;
exports["default"] = exports.emitter = exports.router = exports.version = void 0;

var _extends2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/extends */ "./node_modules/@babel/runtime/helpers/extends.js"));

var _interopRequireWildcard2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "./node_modules/@babel/runtime/helpers/interopRequireWildcard.js"));

var _router = __webpack_require__(/*! next/router */ "./node_modules/next/dist/client/router.js");

var _querystring = __webpack_require__(/*! querystring */ "./node_modules/querystring-es3/index.js");

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

var _reactDom = _interopRequireDefault(__webpack_require__(/*! react-dom */ "./node_modules/react-dom/index.js"));

var _headManagerContext = __webpack_require__(/*! ../next-server/lib/head-manager-context */ "./node_modules/next/dist/next-server/lib/head-manager-context.js");

var _mitt = _interopRequireDefault(__webpack_require__(/*! ../next-server/lib/mitt */ "./node_modules/next/dist/next-server/lib/mitt.js"));

var _routerContext = __webpack_require__(/*! ../next-server/lib/router-context */ "./node_modules/next/dist/next-server/lib/router-context.js");

var _isDynamic = __webpack_require__(/*! ../next-server/lib/router/utils/is-dynamic */ "./node_modules/next/dist/next-server/lib/router/utils/is-dynamic.js");

var envConfig = _interopRequireWildcard3(__webpack_require__(/*! ../next-server/lib/runtime-config */ "./node_modules/next/dist/next-server/lib/runtime-config.js"));

var _utils = __webpack_require__(/*! ../next-server/lib/utils */ "./node_modules/next/dist/next-server/lib/utils.js");

var _headManager = _interopRequireDefault(__webpack_require__(/*! ./head-manager */ "./node_modules/next/dist/client/head-manager.js"));

var _pageLoader = _interopRequireDefault(__webpack_require__(/*! ./page-loader */ "./node_modules/next/dist/client/page-loader.js"));

var _performanceRelayer = _interopRequireDefault(__webpack_require__(/*! ./performance-relayer */ "./node_modules/next/dist/client/performance-relayer.js"));
/* global location */
/// <reference types="react-dom/experimental" />


if (!('finally' in Promise.prototype)) {
  // eslint-disable-next-line no-extend-native
  Promise.prototype["finally"] = __webpack_require__(/*! next/dist/build/polyfills/finally-polyfill.min */ "./node_modules/next/dist/build/polyfills/finally-polyfill.min.js");
}

var data = JSON.parse(document.getElementById('__NEXT_DATA__').textContent);
window.__NEXT_DATA__ = data;
var version = "9.4.4";
exports.version = version;
var props = data.props,
    err = data.err,
    page = data.page,
    query = data.query,
    buildId = data.buildId,
    assetPrefix = data.assetPrefix,
    runtimeConfig = data.runtimeConfig,
    dynamicIds = data.dynamicIds,
    isFallback = data.isFallback;
var prefix = assetPrefix || ''; // With dynamic assetPrefix it's no longer possible to set assetPrefix at the build time
// So, this is how we do it in the client side at runtime

__webpack_require__.p = "".concat(prefix, "/_next/"); //eslint-disable-line
// Initialize next/config with the environment configuration

envConfig.setConfig({
  serverRuntimeConfig: {},
  publicRuntimeConfig: runtimeConfig || {}
});
var asPath = (0, _utils.getURL)();
var pageLoader = new _pageLoader["default"](buildId, prefix);

var register = function register(_ref) {
  var _ref2 = _slicedToArray(_ref, 2),
      r = _ref2[0],
      f = _ref2[1];

  return pageLoader.registerPage(r, f);
};

if (window.__NEXT_P) {
  // Defer page registration for another tick. This will increase the overall
  // latency in hydrating the page, but reduce the total blocking time.
  window.__NEXT_P.map(function (p) {
    return setTimeout(function () {
      return register(p);
    }, 0);
  });
}

window.__NEXT_P = [];
window.__NEXT_P.push = register;
var updateHead = (0, _headManager["default"])();
var appElement = document.getElementById('__next');
var lastAppProps;

var _lastRenderReject;

var webpackHMR;
var router;
exports.router = router;
var Component;
var App, onPerfEntry;

var Container = /*#__PURE__*/function (_react$default$Compon) {
  _inherits(Container, _react$default$Compon);

  var _super = _createSuper(Container);

  function Container() {
    _classCallCheck(this, Container);

    return _super.apply(this, arguments);
  }

  _createClass(Container, [{
    key: "componentDidCatch",
    value: function componentDidCatch(err, info) {
      this.props.fn(err, info);
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      this.scrollToHash();

      if (false) {} // We need to replace the router state if:
      // - the page was (auto) exported and has a query string or search (hash)
      // - it was auto exported and is a dynamic route (to provide params)
      // - if it is a client-side skeleton (fallback render)


      if (router.isSsr && (isFallback || data.nextExport && ((0, _isDynamic.isDynamicRoute)(router.pathname) || location.search) || props && props.__N_SSG && location.search)) {
        // update query on mount for exported pages
        router.replace(router.pathname + '?' + (0, _querystring.stringify)((0, _extends2["default"])((0, _extends2["default"])({}, router.query), (0, _querystring.parse)(location.search.substr(1)))), asPath, {
          // WARNING: `_h` is an internal option for handing Next.js
          // client-side hydration. Your app should _never_ use this property.
          // It may change at any time without notice.
          _h: 1,
          // Fallback pages must trigger the data fetch, so the transition is
          // not shallow.
          // Other pages (strictly updating query) happens shallowly, as data
          // requirements would already be present.
          shallow: !isFallback
        });
      }

      if (undefined) {
        window.__NEXT_HYDRATED = true;

        if (window.__NEXT_HYDRATED_CB) {
          window.__NEXT_HYDRATED_CB();
        }
      }
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      this.scrollToHash();
    }
  }, {
    key: "scrollToHash",
    value: function scrollToHash() {
      var _location = location,
          hash = _location.hash;
      hash = hash && hash.substring(1);
      if (!hash) return;
      var el = document.getElementById(hash);
      if (!el) return; // If we call scrollIntoView() in here without a setTimeout
      // it won't scroll properly.

      setTimeout(function () {
        return el.scrollIntoView();
      }, 0);
    }
  }, {
    key: "render",
    value: function render() {
      if (false) {}

      if (true) {
        var _require = __webpack_require__(/*! @next/react-dev-overlay/lib/client */ "./node_modules/@next/react-dev-overlay/lib/client.js"),
            ReactDevOverlay = _require.ReactDevOverlay;

        return /*#__PURE__*/_react["default"].createElement(ReactDevOverlay, null, this.props.children);
      }
    }
  }]);

  return Container;
}(_react["default"].Component);

var emitter = (0, _mitt["default"])();
exports.emitter = emitter;

var _default = /*#__PURE__*/function () {
  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
    var _ref4,
        passedWebpackHMR,
        _yield$pageLoader$loa,
        app,
        mod,
        initialErr,
        _yield$pageLoader$loa2,
        _require2,
        isValidElementType,
        _require3,
        getNodeError,
        renderCtx,
        _args = arguments;

    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _ref4 = _args.length > 0 && _args[0] !== undefined ? _args[0] : {}, passedWebpackHMR = _ref4.webpackHMR;

            // This makes sure this specific lines are removed in production
            if (true) {
              webpackHMR = passedWebpackHMR;
            }

            _context.next = 4;
            return pageLoader.loadPageScript('/_app');

          case 4:
            _yield$pageLoader$loa = _context.sent;
            app = _yield$pageLoader$loa.page;
            mod = _yield$pageLoader$loa.mod;
            App = app;

            if (mod && mod.reportWebVitals) {
              onPerfEntry = function onPerfEntry(_ref5) {
                var id = _ref5.id,
                    name = _ref5.name,
                    startTime = _ref5.startTime,
                    value = _ref5.value,
                    duration = _ref5.duration,
                    entryType = _ref5.entryType,
                    entries = _ref5.entries;
                // Combines timestamp with random number for unique ID
                var uniqueID = "".concat(Date.now(), "-").concat(Math.floor(Math.random() * (9e12 - 1)) + 1e12);
                var perfStartEntry;

                if (entries && entries.length) {
                  perfStartEntry = entries[0].startTime;
                }

                mod.reportWebVitals({
                  id: id || uniqueID,
                  name: name,
                  startTime: startTime || perfStartEntry,
                  value: value == null ? duration : value,
                  label: entryType === 'mark' || entryType === 'measure' ? 'custom' : 'web-vital'
                });
              };
            }

            initialErr = err;
            _context.prev = 10;
            ;
            _context.next = 14;
            return pageLoader.loadPage(page);

          case 14:
            _yield$pageLoader$loa2 = _context.sent;
            Component = _yield$pageLoader$loa2.page;

            if (false) {}

            _require2 = __webpack_require__(/*! react-is */ "./node_modules/react-is/index.js"), isValidElementType = _require2.isValidElementType;

            if (isValidElementType(Component)) {
              _context.next = 20;
              break;
            }

            throw new Error("The default export is not a React Component in page: \"".concat(page, "\""));

          case 20:
            _context.next = 25;
            break;

          case 22:
            _context.prev = 22;
            _context.t0 = _context["catch"](10);
            // This catches errors like throwing in the top level of a module
            initialErr = _context.t0;

          case 25:
            if (true) {
              _require3 = __webpack_require__(/*! @next/react-dev-overlay/lib/client */ "./node_modules/@next/react-dev-overlay/lib/client.js"), getNodeError = _require3.getNodeError; // Server-side runtime errors need to be re-thrown on the client-side so
              // that the overlay is rendered.

              if (initialErr) {
                if (initialErr === err) {
                  setTimeout(function () {
                    var error;

                    try {
                      // Generate a new error object. We `throw` it because some browsers
                      // will set the `stack` when thrown, and we want to ensure ours is
                      // not overridden when we re-throw it below.
                      throw new Error(initialErr.message);
                    } catch (e) {
                      error = e;
                    }

                    error.name = initialErr.name;
                    error.stack = initialErr.stack;
                    var node = getNodeError(error);
                    throw node;
                  });
                } // We replaced the server-side error with a client-side error, and should
                // no longer rewrite the stack trace to a Node error.
                else {
                    setTimeout(function () {
                      throw initialErr;
                    });
                  }
              }
            }

            if (!window.__NEXT_PRELOADREADY) {
              _context.next = 29;
              break;
            }

            _context.next = 29;
            return window.__NEXT_PRELOADREADY(dynamicIds);

          case 29:
            exports.router = router = (0, _router.createRouter)(page, query, asPath, {
              initialProps: props,
              pageLoader: pageLoader,
              App: App,
              Component: Component,
              wrapApp: wrapApp,
              err: initialErr,
              isFallback: isFallback,
              subscription: function subscription(_ref6, App) {
                var Component = _ref6.Component,
                    props = _ref6.props,
                    err = _ref6.err;
                return render({
                  App: App,
                  Component: Component,
                  props: props,
                  err: err
                });
              }
            }); // call init-client middleware

            if (false) {}

            renderCtx = {
              App: App,
              Component: Component,
              props: props,
              err: initialErr
            };

            if (true) {
              _context.next = 35;
              break;
            }

            render(renderCtx);
            return _context.abrupt("return", emitter);

          case 35:
            if (false) {}

            return _context.abrupt("return", {
              emitter: emitter,
              render: render,
              renderCtx: renderCtx
            });

          case 37:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[10, 22]]);
  }));

  return function _default() {
    return _ref3.apply(this, arguments);
  };
}();

exports["default"] = _default;

function render(_x) {
  return _render.apply(this, arguments);
} // This method handles all runtime and debug errors.
// 404 and 500 errors are special kind of errors
// and they are still handle via the main render method.


function _render() {
  _render = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(props) {
    return _regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            if (!props.err) {
              _context2.next = 4;
              break;
            }

            _context2.next = 3;
            return renderError(props);

          case 3:
            return _context2.abrupt("return");

          case 4:
            _context2.prev = 4;
            _context2.next = 7;
            return doRender(props);

          case 7:
            _context2.next = 14;
            break;

          case 9:
            _context2.prev = 9;
            _context2.t0 = _context2["catch"](4);

            if (true) {
              // Ensure this error is displayed in the overlay in development
              setTimeout(function () {
                throw _context2.t0;
              });
            }

            _context2.next = 14;
            return renderError((0, _extends2["default"])((0, _extends2["default"])({}, props), {}, {
              err: _context2.t0
            }));

          case 14:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[4, 9]]);
  }));
  return _render.apply(this, arguments);
}

function renderError(props) {
  var App = props.App,
      err = props.err; // In development runtime errors are caught by our overlay
  // In production we catch runtime errors using componentDidCatch which will trigger renderError

  if (true) {
    // A Next.js rendering runtime error is always unrecoverable
    // FIXME: let's make this recoverable (error in GIP client-transition)
    webpackHMR.onUnrecoverableError(); // We need to render an empty <App> so that the `<ReactDevOverlay>` can
    // render itself.

    return doRender({
      App: function App() {
        return null;
      },
      props: {},
      Component: function Component() {
        return null;
      },
      err: null
    });
  }

  if (false) {} // Make sure we log the error to the console, otherwise users can't track down issues.


  console.error(err);
  return pageLoader.loadPage('/_error').then(function (_ref7) {
    var ErrorComponent = _ref7.page;
    // In production we do a normal render with the `ErrorComponent` as component.
    // If we've gotten here upon initial render, we can use the props from the server.
    // Otherwise, we need to call `getInitialProps` on `App` before mounting.
    var AppTree = wrapApp(App);
    var appCtx = {
      Component: ErrorComponent,
      AppTree: AppTree,
      router: router,
      ctx: {
        err: err,
        pathname: page,
        query: query,
        asPath: asPath,
        AppTree: AppTree
      }
    };
    return Promise.resolve(props.props ? props.props : (0, _utils.loadGetInitialProps)(App, appCtx)).then(function (initProps) {
      return doRender((0, _extends2["default"])((0, _extends2["default"])({}, props), {}, {
        err: err,
        Component: ErrorComponent,
        props: initProps
      }));
    });
  });
} // If hydrate does not exist, eg in preact.


var isInitialRender = typeof _reactDom["default"].hydrate === 'function';
var reactRoot = null;

function renderReactElement(reactEl, domEl) {
  if (false) { var opts; } else {
    // mark start of hydrate/render
    if (_utils.ST) {
      performance.mark('beforeRender');
    } // The check for `.hydrate` is there to support React alternatives like preact


    if (isInitialRender) {
      _reactDom["default"].hydrate(reactEl, domEl, markHydrateComplete);

      isInitialRender = false;

      if (onPerfEntry && _utils.ST) {
        (0, _performanceRelayer["default"])(onPerfEntry);
      }
    } else {
      _reactDom["default"].render(reactEl, domEl, markRenderComplete);
    }
  }
}

function markHydrateComplete() {
  if (!_utils.ST) return;
  performance.mark('afterHydrate'); // mark end of hydration

  performance.measure('Next.js-before-hydration', 'navigationStart', 'beforeRender');
  performance.measure('Next.js-hydration', 'beforeRender', 'afterHydrate');

  if (onPerfEntry) {
    performance.getEntriesByName('Next.js-hydration').forEach(onPerfEntry);
  }

  clearMarks();
}

function markRenderComplete() {
  if (!_utils.ST) return;
  performance.mark('afterRender'); // mark end of render

  var navStartEntries = performance.getEntriesByName('routeChange', 'mark');

  if (!navStartEntries.length) {
    return;
  }

  performance.measure('Next.js-route-change-to-render', navStartEntries[0].name, 'beforeRender');
  performance.measure('Next.js-render', 'beforeRender', 'afterRender');

  if (onPerfEntry) {
    performance.getEntriesByName('Next.js-render').forEach(onPerfEntry);
    performance.getEntriesByName('Next.js-route-change-to-render').forEach(onPerfEntry);
  }

  clearMarks();
  ['Next.js-route-change-to-render', 'Next.js-render'].forEach(function (measure) {
    return performance.clearMeasures(measure);
  });
}

function clearMarks() {
  ;
  ['beforeRender', 'afterHydrate', 'afterRender', 'routeChange'].forEach(function (mark) {
    return performance.clearMarks(mark);
  });
}

function AppContainer(_ref8) {
  var children = _ref8.children;
  return /*#__PURE__*/_react["default"].createElement(Container, {
    fn: function fn(error) {
      return renderError({
        App: App,
        err: error
      })["catch"](function (err) {
        return console.error('Error rendering page: ', err);
      });
    }
  }, /*#__PURE__*/_react["default"].createElement(_routerContext.RouterContext.Provider, {
    value: (0, _router.makePublicRouterInstance)(router)
  }, /*#__PURE__*/_react["default"].createElement(_headManagerContext.HeadManagerContext.Provider, {
    value: updateHead
  }, children)));
}

_c = AppContainer;

var wrapApp = function wrapApp(App) {
  return function (props) {
    var appProps = (0, _extends2["default"])((0, _extends2["default"])({}, props), {}, {
      Component: Component,
      err: err,
      router: router
    });
    return /*#__PURE__*/_react["default"].createElement(AppContainer, null, /*#__PURE__*/_react["default"].createElement(App, appProps));
  };
};

function doRender(_x2) {
  return _doRender.apply(this, arguments);
}

function _doRender() {
  _doRender = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(_ref9) {
    var App, Component, props, err, appProps, resolvePromise, renderPromise, elem;
    return _regeneratorRuntime.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            App = _ref9.App, Component = _ref9.Component, props = _ref9.props, err = _ref9.err;
            Component = Component || lastAppProps.Component;
            props = props || lastAppProps.props;
            appProps = (0, _extends2["default"])((0, _extends2["default"])({}, props), {}, {
              Component: Component,
              err: err,
              router: router
            }); // lastAppProps has to be set before ReactDom.render to account for ReactDom throwing an error.

            lastAppProps = appProps;
            renderPromise = new Promise(function (resolve, reject) {
              if (_lastRenderReject) {
                _lastRenderReject();
              }

              resolvePromise = function resolvePromise() {
                _lastRenderReject = null;
                resolve();
              };

              _lastRenderReject = function lastRenderReject() {
                _lastRenderReject = null;
                reject();
              };
            });
            elem = /*#__PURE__*/_react["default"].createElement(Root, {
              callback: resolvePromise
            }, /*#__PURE__*/_react["default"].createElement(AppContainer, null, /*#__PURE__*/_react["default"].createElement(App, appProps))); // We catch runtime errors using componentDidCatch which will trigger renderError

            renderReactElement( false ? /*#__PURE__*/undefined : elem, appElement);
            _context3.next = 10;
            return renderPromise;

          case 10:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _doRender.apply(this, arguments);
}

function Root(_ref10) {
  _s();

  var callback = _ref10.callback,
      children = _ref10.children;

  // We use `useLayoutEffect` to guarantee the callback is executed
  // as soon as React flushes the update.
  _react["default"].useLayoutEffect(function () {
    return callback();
  }, [callback]);

  return children;
}

_s(Root, "n7/vCynhJvM+pLkyL2DMQUF0odM=");

_c2 = Root;

var _c, _c2;

$RefreshReg$(_c, "AppContainer");
$RefreshReg$(_c2, "Root");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/next-dev.js":
/*!***************************************************!*\
  !*** ./node_modules/next/dist/client/next-dev.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process, module) {

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

var _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "./node_modules/@babel/runtime/helpers/interopRequireWildcard.js");

var next = _interopRequireWildcard(__webpack_require__(/*! ./ */ "./node_modules/next/dist/client/index.js"));

var _eventSourcePolyfill = _interopRequireDefault(__webpack_require__(/*! ./dev/event-source-polyfill */ "./node_modules/next/dist/client/dev/event-source-polyfill.js"));

var _onDemandEntriesClient = _interopRequireDefault(__webpack_require__(/*! ./dev/on-demand-entries-client */ "./node_modules/next/dist/client/dev/on-demand-entries-client.js"));

var _webpackHotMiddlewareClient = _interopRequireDefault(__webpack_require__(/*! ./dev/webpack-hot-middleware-client */ "./node_modules/next/dist/client/dev/webpack-hot-middleware-client.js"));

var _devBuildWatcher = _interopRequireDefault(__webpack_require__(/*! ./dev/dev-build-watcher */ "./node_modules/next/dist/client/dev/dev-build-watcher.js"));

var _prerenderIndicator = _interopRequireDefault(__webpack_require__(/*! ./dev/prerender-indicator */ "./node_modules/next/dist/client/dev/prerender-indicator.js"));

var _fouc = __webpack_require__(/*! ./dev/fouc */ "./node_modules/next/dist/client/dev/fouc.js");
/* globals import('./dev/noop'); */
// Temporary workaround for the issue described here:
// https://github.com/vercel/next.js/issues/3775#issuecomment-407438123
// The runtimeChunk doesn't have dynamic import handling code when there hasn't been a dynamic import
// The runtimeChunk can't hot reload itself currently to correct it when adding pages using on-demand-entries
// eslint-disable-next-line no-unused-expressions


__webpack_require__.e(/*! import() */ 0).then(__webpack_require__.t.bind(null, /*! ./dev/noop */ "./node_modules/next/dist/client/dev/noop.js", 7));
; // Support EventSource on Internet Explorer 11

if (!window.EventSource) {
  window.EventSource = _eventSourcePolyfill["default"];
}

var _window = window,
    assetPrefix = _window.__NEXT_DATA__.assetPrefix;
var prefix = assetPrefix || '';
var webpackHMR = (0, _webpackHotMiddlewareClient["default"])({
  assetPrefix: prefix
});
window.next = next;
(0, next["default"])({
  webpackHMR: webpackHMR
}).then(function (_ref) {
  var emitter = _ref.emitter,
      renderCtx = _ref.renderCtx,
      render = _ref.render;
  (0, _onDemandEntriesClient["default"])({
    assetPrefix: prefix
  });
  if (true) (0, _devBuildWatcher["default"])();

  if ( true && // disable by default in electron
  !(typeof process !== 'undefined' && 'electron' in process.versions)) {
    (0, _prerenderIndicator["default"])();
  } // delay rendering until after styles have been applied in development


  (0, _fouc.displayContent)(function () {
    render(renderCtx);
  });
})["catch"](function (err) {
  console.error('Error was not caught', err);
});

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../process/browser.js */ "./node_modules/process/browser.js"), __webpack_require__(/*! ./../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/page-loader.js":
/*!******************************************************!*\
  !*** ./node_modules/next/dist/client/page-loader.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _classCallCheck = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js");

var _createClass = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js");

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

exports.__esModule = true;
exports["default"] = void 0;

var _url = __webpack_require__(/*! url */ "./node_modules/native-url/dist/index.js");

var _mitt = _interopRequireDefault(__webpack_require__(/*! ../next-server/lib/mitt */ "./node_modules/next/dist/next-server/lib/mitt.js"));

var _isDynamic = __webpack_require__(/*! ./../next-server/lib/router/utils/is-dynamic */ "./node_modules/next/dist/next-server/lib/router/utils/is-dynamic.js");

var _routeMatcher = __webpack_require__(/*! ./../next-server/lib/router/utils/route-matcher */ "./node_modules/next/dist/next-server/lib/router/utils/route-matcher.js");

var _routeRegex = __webpack_require__(/*! ./../next-server/lib/router/utils/route-regex */ "./node_modules/next/dist/next-server/lib/router/utils/route-regex.js");

var _router = __webpack_require__(/*! ./../next-server/lib/router/router */ "./node_modules/next/dist/next-server/lib/router/router.js");

function hasRel(rel, link) {
  try {
    link = document.createElement('link');
    return link.relList.supports(rel);
  } catch (_unused) {}
}

var relPrefetch = hasRel('preload') && !hasRel('prefetch') ? // https://caniuse.com/#feat=link-rel-preload
// macOS and iOS (Safari does not support prefetch)
'preload' : // https://caniuse.com/#feat=link-rel-prefetch
// IE 11, Edge 12+, nearly all evergreen
'prefetch';
var hasNoModule = ('noModule' in document.createElement('script'));
/** @param {string} route */

function normalizeRoute(route) {
  if (route[0] !== '/') {
    throw new Error("Route name should start with a \"/\", got \"".concat(route, "\""));
  }

  route = route.replace(/\/index$/, '/');
  if (route === '/') return route;
  return route.replace(/\/$/, '');
}

function appendLink(href, rel, as) {
  return new Promise(function (res, rej, link) {
    link = document.createElement('link');
    link.crossOrigin = undefined;
    link.href = href;
    link.rel = rel;
    if (as) link.as = as;
    link.onload = res;
    link.onerror = rej;
    document.head.appendChild(link);
  });
}

var PageLoader = /*#__PURE__*/function () {
  function PageLoader(buildId, assetPrefix) {
    _classCallCheck(this, PageLoader);

    this.buildId = buildId;
    this.assetPrefix = assetPrefix;
    this.pageCache = {};
    this.pageRegisterEvents = (0, _mitt["default"])();
    this.loadingRoutes = {};

    if (false) {}
    /** @type {Promise<Set<string>>} */


    this.promisedSsgManifest = new Promise(function (resolve) {
      if (window.__SSG_MANIFEST) {
        resolve(window.__SSG_MANIFEST);
      } else {
        window.__SSG_MANIFEST_CB = function () {
          resolve(window.__SSG_MANIFEST);
        };
      }
    });
  } // Returns a promise for the dependencies for a particular route


  _createClass(PageLoader, [{
    key: "getDependencies",
    value: function getDependencies(route) {
      var _this = this;

      return this.promisedBuildManifest.then(function (man) {
        return man[route] && man[route].map(function (url) {
          return "".concat(_this.assetPrefix, "/_next/").concat(encodeURI(url));
        }) || [];
      });
    }
    /**
    * @param {string} href the route href (file-system path)
    * @param {string} asPath the URL as shown in browser (virtual path); used for dynamic routes
    */

  }, {
    key: "getDataHref",
    value: function getDataHref(href, asPath) {
      var _this2 = this;

      var getHrefForSlug =
      /** @type string */
      function getHrefForSlug(path) {
        path = (0, _router.delBasePath)(path);
        return "".concat(_this2.assetPrefix, "/_next/data/").concat(_this2.buildId).concat(path === '/' ? '/index' : path, ".json");
      };

      var _ref = (0, _url.parse)(href, true),
          hrefPathname = _ref.pathname,
          query = _ref.query;

      var _ref2 = (0, _url.parse)(asPath),
          asPathname = _ref2.pathname;

      var route = normalizeRoute(hrefPathname);
      var isDynamic = (0, _isDynamic.isDynamicRoute)(route),
          interpolatedRoute;

      if (isDynamic) {
        var dynamicRegex = (0, _routeRegex.getRouteRegex)(route);
        var dynamicGroups = dynamicRegex.groups;
        var dynamicMatches = // Try to match the dynamic route against the asPath
        (0, _routeMatcher.getRouteMatcher)(dynamicRegex)(asPathname) || // Fall back to reading the values from the href
        // TODO: should this take priority; also need to change in the router.
        query;
        interpolatedRoute = route;

        if (!Object.keys(dynamicGroups).every(function (param) {
          var value = dynamicMatches[param];
          var repeat = dynamicGroups[param].repeat; // support single-level catch-all
          // TODO: more robust handling for user-error (passing `/`)

          if (repeat && !Array.isArray(value)) value = [value];
          return param in dynamicMatches && ( // Interpolate group into data URL if present
          interpolatedRoute = interpolatedRoute.replace("[".concat(repeat ? '...' : '').concat(param, "]"), repeat ? value.map(encodeURIComponent).join('/') : encodeURIComponent(value)));
        })) {
          interpolatedRoute = ''; // did not satisfy all requirements
          // n.b. We ignore this error because we handle warning for this case in
          // development in the `<Link>` component directly.
        }
      }

      return isDynamic ? interpolatedRoute && getHrefForSlug(interpolatedRoute) : getHrefForSlug(route);
    }
    /**
    * @param {string} href the route href (file-system path)
    * @param {string} asPath the URL as shown in browser (virtual path); used for dynamic routes
    */

  }, {
    key: "prefetchData",
    value: function prefetchData(href, asPath) {
      var _this3 = this;

      var _ref3 = (0, _url.parse)(href, true),
          hrefPathname = _ref3.pathname;

      var route = normalizeRoute(hrefPathname);
      return this.promisedSsgManifest.then(function (s, _dataHref) {
        return (// Check if the route requires a data file
          s.has(route) && ( // Try to generate data href, noop when falsy
          _dataHref = _this3.getDataHref(href, asPath)) && // noop when data has already been prefetched (dedupe)
          !document.querySelector("link[rel=\"".concat(relPrefetch, "\"][href^=\"").concat(_dataHref, "\"]")) && // Inject the `<link rel=prefetch>` tag for above computed `href`.
          appendLink(_dataHref, relPrefetch, 'fetch')
        );
      });
    }
  }, {
    key: "loadPage",
    value: function loadPage(route) {
      return this.loadPageScript(route);
    }
  }, {
    key: "loadPageScript",
    value: function loadPageScript(route) {
      var _this4 = this;

      route = normalizeRoute(route);
      return new Promise(function (resolve, reject) {
        var fire = function fire(_ref4) {
          var error = _ref4.error,
              page = _ref4.page,
              mod = _ref4.mod;

          _this4.pageRegisterEvents.off(route, fire);

          delete _this4.loadingRoutes[route];

          if (error) {
            reject(error);
          } else {
            resolve({
              page: page,
              mod: mod
            });
          }
        }; // If there's a cached version of the page, let's use it.


        var cachedPage = _this4.pageCache[route];

        if (cachedPage) {
          var error = cachedPage.error,
              page = cachedPage.page,
              mod = cachedPage.mod;
          error ? reject(error) : resolve({
            page: page,
            mod: mod
          });
          return;
        } // Register a listener to get the page


        _this4.pageRegisterEvents.on(route, fire); // If the page is loading via SSR, we need to wait for it
        // rather downloading it again.


        if (document.querySelector("script[data-next-page=\"".concat(route, "\"]"))) {
          return;
        }

        if (!_this4.loadingRoutes[route]) {
          _this4.loadingRoutes[route] = true;

          if (false) {} else {
            _this4.loadRoute(route);
          }
        }
      });
    }
  }, {
    key: "loadRoute",
    value: function loadRoute(route) {
      route = normalizeRoute(route);
      var scriptRoute = route === '/' ? '/index.js' : "".concat(route, ".js");
      var url = "".concat(this.assetPrefix, "/_next/static/").concat(encodeURIComponent(this.buildId), "/pages").concat(encodeURI(scriptRoute));
      this.loadScript(url, route, true);
    }
  }, {
    key: "loadScript",
    value: function loadScript(url, route, isPage) {
      var _this5 = this;

      var script = document.createElement('script');

      if (false) {}

      script.crossOrigin = undefined;
      script.src = url;

      script.onerror = function () {
        var error = new Error("Error loading script ".concat(url));
        error.code = 'PAGE_LOAD_ERROR';

        _this5.pageRegisterEvents.emit(route, {
          error: error
        });
      };

      document.body.appendChild(script);
    } // This method if called by the route code.

  }, {
    key: "registerPage",
    value: function registerPage(route, regFn) {
      var _this6 = this;

      var register = function register() {
        try {
          var mod = regFn();
          var pageData = {
            page: mod["default"] || mod,
            mod: mod
          };
          _this6.pageCache[route] = pageData;

          _this6.pageRegisterEvents.emit(route, pageData);
        } catch (error) {
          _this6.pageCache[route] = {
            error: error
          };

          _this6.pageRegisterEvents.emit(route, {
            error: error
          });
        }
      };

      if (true) {
        // Wait for webpack to become idle if it's not.
        // More info: https://github.com/vercel/next.js/pull/1511
        if ( true && module.hot.status() !== 'idle') {
          console.log("Waiting for webpack to become \"idle\" to initialize the page: \"".concat(route, "\""));

          var check = function check(status) {
            if (status === 'idle') {
              module.hot.removeStatusHandler(check);
              register();
            }
          };

          module.hot.status(check);
          return;
        }
      }

      register();
    }
    /**
    * @param {string} route
    * @param {boolean} [isDependency]
    */

  }, {
    key: "prefetch",
    value: function prefetch(route, isDependency) {
      var _this7 = this;

      // https://github.com/GoogleChromeLabs/quicklink/blob/453a661fa1fa940e2d2e044452398e38c67a98fb/src/index.mjs#L115-L118
      // License: Apache 2.0
      var cn;

      if (cn = navigator.connection) {
        // Don't prefetch if using 2G or if Save-Data is enabled.
        if (cn.saveData || /2g/.test(cn.effectiveType)) return Promise.resolve();
      }
      /** @type {string} */


      var url;

      if (isDependency) {
        url = route;
      } else {
        route = normalizeRoute(route);
        var scriptRoute = "".concat(route === '/' ? '/index' : route, ".js");

        if (false) {}

        url = "".concat(this.assetPrefix, "/_next/static/").concat(encodeURIComponent(this.buildId), "/pages").concat(encodeURI(scriptRoute));
      }

      return Promise.all(document.querySelector("link[rel=\"".concat(relPrefetch, "\"][href^=\"").concat(url, "\"], script[data-next-page=\"").concat(route, "\"]")) ? [] : [appendLink(url, relPrefetch, url.match(/\.css$/) ? 'style' : 'script'),  false && false]).then( // do not return any data
      function () {}, // swallow prefetch errors
      function () {});
    }
  }]);

  return PageLoader;
}();

exports["default"] = PageLoader;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/performance-relayer.js":
/*!**************************************************************!*\
  !*** ./node_modules/next/dist/client/performance-relayer.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports["default"] = void 0;

var _webVitals = __webpack_require__(/*! web-vitals */ "./node_modules/web-vitals/dist/web-vitals.es5.min.js");

var _default = function _default(onPerfEntry) {
  (0, _webVitals.getCLS)(onPerfEntry);
  (0, _webVitals.getFID)(onPerfEntry);
  (0, _webVitals.getFCP)(onPerfEntry);
  (0, _webVitals.getLCP)(onPerfEntry);
  (0, _webVitals.getTTFB)(onPerfEntry);
};

exports["default"] = _default;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/router.js":
/*!*************************************************!*\
  !*** ./node_modules/next/dist/client/router.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _construct = __webpack_require__(/*! @babel/runtime/helpers/construct */ "./node_modules/@babel/runtime/helpers/construct.js");

var _s = $RefreshSig$();

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "./node_modules/@babel/runtime/helpers/interopRequireWildcard.js");

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

exports.__esModule = true;
exports.useRouter = useRouter;
exports.makePublicRouterInstance = makePublicRouterInstance;
exports.createRouter = exports.withRouter = exports["default"] = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

var _router2 = _interopRequireWildcard(__webpack_require__(/*! ../next-server/lib/router/router */ "./node_modules/next/dist/next-server/lib/router/router.js"));

exports.Router = _router2["default"];
exports.NextRouter = _router2.NextRouter;

var _routerContext = __webpack_require__(/*! ../next-server/lib/router-context */ "./node_modules/next/dist/next-server/lib/router-context.js");

var _withRouter = _interopRequireDefault(__webpack_require__(/*! ./with-router */ "./node_modules/next/dist/client/with-router.js"));

exports.withRouter = _withRouter["default"];
/* global window */

var singletonRouter = {
  router: null,
  // holds the actual router instance
  readyCallbacks: [],
  ready: function ready(cb) {
    if (this.router) return cb();

    if (true) {
      this.readyCallbacks.push(cb);
    }
  }
}; // Create public properties and methods of the router in the singletonRouter

var urlPropertyFields = ['pathname', 'route', 'query', 'asPath', 'components', 'isFallback', 'basePath'];
var routerEvents = ['routeChangeStart', 'beforeHistoryChange', 'routeChangeComplete', 'routeChangeError', 'hashChangeStart', 'hashChangeComplete'];
var coreMethodFields = ['push', 'replace', 'reload', 'back', 'prefetch', 'beforePopState']; // Events is a static property on the router, the router doesn't have to be initialized to use it

Object.defineProperty(singletonRouter, 'events', {
  get: function get() {
    return _router2["default"].events;
  }
});
urlPropertyFields.forEach(function (field) {
  // Here we need to use Object.defineProperty because, we need to return
  // the property assigned to the actual router
  // The value might get changed as we change routes and this is the
  // proper way to access it
  Object.defineProperty(singletonRouter, field, {
    get: function get() {
      var router = getRouter();
      return router[field];
    }
  });
});
coreMethodFields.forEach(function (field) {
  // We don't really know the types here, so we add them later instead
  ;

  singletonRouter[field] = function () {
    var router = getRouter();
    return router[field].apply(router, arguments);
  };
});
routerEvents.forEach(function (event) {
  singletonRouter.ready(function () {
    _router2["default"].events.on(event, function () {
      var eventField = "on".concat(event.charAt(0).toUpperCase()).concat(event.substring(1));
      var _singletonRouter = singletonRouter;

      if (_singletonRouter[eventField]) {
        try {
          _singletonRouter[eventField].apply(_singletonRouter, arguments);
        } catch (err) {
          // tslint:disable-next-line:no-console
          console.error("Error when running the Router event: ".concat(eventField)); // tslint:disable-next-line:no-console

          console.error("".concat(err.message, "\n").concat(err.stack));
        }
      }
    });
  });
});

function getRouter() {
  if (!singletonRouter.router) {
    var message = 'No router instance found.\n' + 'You should only use "next/router" inside the client side of your app.\n';
    throw new Error(message);
  }

  return singletonRouter.router;
} // Export the singletonRouter and this is the public API.


var _default = singletonRouter; // Reexport the withRoute HOC

exports["default"] = _default;

function useRouter() {
  _s();

  return _react["default"].useContext(_routerContext.RouterContext);
} // INTERNAL APIS
// -------------
// (do not use following exports inside the app)
// Create a router and assign it as the singleton instance.
// This is used in client side when we are initilizing the app.
// This should **not** use inside the server.


_s(useRouter, "gDsCjeeItUuvgOWf1v4qoK9RF6k=");

var createRouter = function createRouter() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  singletonRouter.router = _construct(_router2["default"], args);
  singletonRouter.readyCallbacks.forEach(function (cb) {
    return cb();
  });
  singletonRouter.readyCallbacks = [];
  return singletonRouter.router;
}; // This function is used to create the `withRouter` router instance


exports.createRouter = createRouter;

function makePublicRouterInstance(router) {
  var _router = router;
  var instance = {};

  var _iterator = _createForOfIteratorHelper(urlPropertyFields),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var property = _step.value;

      if (typeof _router[property] === 'object') {
        instance[property] = Object.assign({}, _router[property]); // makes sure query is not stateful

        continue;
      }

      instance[property] = _router[property];
    } // Events is a static property on the router, the router doesn't have to be initialized to use it

  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  instance.events = _router2["default"].events;
  coreMethodFields.forEach(function (field) {
    instance[field] = function () {
      return _router[field].apply(_router, arguments);
    };
  });
  return instance;
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/with-router.js":
/*!******************************************************!*\
  !*** ./node_modules/next/dist/client/with-router.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

exports.__esModule = true;
exports["default"] = withRouter;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

var _router = __webpack_require__(/*! ./router */ "./node_modules/next/dist/client/router.js");

function withRouter(ComposedComponent) {
  function WithRouterWrapper(props) {
    return /*#__PURE__*/_react["default"].createElement(ComposedComponent, Object.assign({
      router: (0, _router.useRouter)()
    }, props));
  }

  WithRouterWrapper.getInitialProps = ComposedComponent.getInitialProps // This is needed to allow checking for custom getInitialProps in _app
  ;
  WithRouterWrapper.origGetInitialProps = ComposedComponent.origGetInitialProps;

  if (true) {
    var name = ComposedComponent.displayName || ComposedComponent.name || 'Unknown';
    WithRouterWrapper.displayName = "withRouter(".concat(name, ")");
  }

  return WithRouterWrapper;
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/compiled/strip-ansi/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/next/dist/compiled/strip-ansi/index.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(__dirname, module) {module.exports = function (e, r) {
  "use strict";

  var t = {};

  function __webpack_require__(r) {
    if (t[r]) {
      return t[r].exports;
    }

    var n = t[r] = {
      i: r,
      l: false,
      exports: {}
    };
    e[r].call(n.exports, n, n.exports, __webpack_require__);
    n.l = true;
    return n.exports;
  }

  __webpack_require__.ab = __dirname + "/";

  function startup() {
    return __webpack_require__(855);
  }

  return startup();
}({
  849: function _(e) {
    "use strict";

    e.exports = function () {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref$onlyFirst = _ref.onlyFirst,
          e = _ref$onlyFirst === void 0 ? false : _ref$onlyFirst;

      var r = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|");
      return new RegExp(r, e ? undefined : "g");
    };
  },
  855: function _(e, r, t) {
    "use strict";

    var n = t(849);

    e.exports = function (e) {
      return typeof e === "string" ? e.replace(n(), "") : e;
    };
  }
});

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, "/", __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/head-manager-context.js":
/*!************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/head-manager-context.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.HeadManagerContext = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

var HeadManagerContext = _react["default"].createContext(null);

exports.HeadManagerContext = HeadManagerContext;

if (true) {
  HeadManagerContext.displayName = 'HeadManagerContext';
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/mitt.js":
/*!********************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/mitt.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports["default"] = mitt;
/*
MIT License
Copyright (c) Jason Miller (https://jasonformat.com/)
Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
// This file is based on https://github.com/developit/mitt/blob/v1.1.3/src/index.js
// It's been edited for the needs of this script
// See the LICENSE at the top of the file

function mitt() {
  var all = Object.create(null);
  return {
    on: function on(type, handler) {
      ;
      (all[type] || (all[type] = [])).push(handler);
    },
    off: function off(type, handler) {
      if (all[type]) {
        // tslint:disable-next-line:no-bitwise
        all[type].splice(all[type].indexOf(handler) >>> 0, 1);
      }
    },
    emit: function emit(type) {
      for (var _len = arguments.length, evts = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        evts[_key - 1] = arguments[_key];
      }

      // eslint-disable-next-line array-callback-return
      ;
      (all[type] || []).slice().map(function (handler) {
        handler.apply(void 0, evts);
      });
    }
  };
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router-context.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router-context.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.RouterContext = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

var RouterContext = _react["default"].createContext(null);

exports.RouterContext = RouterContext;

if (true) {
  RouterContext.displayName = 'RouterContext';
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/router.js":
/*!*****************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/router.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _regeneratorRuntime = __webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js");

var _asyncToGenerator = __webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js");

var _slicedToArray = __webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ "./node_modules/@babel/runtime/helpers/slicedToArray.js");

var _classCallCheck = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js");

var _createClass = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js");

exports.__esModule = true;
exports.addBasePath = addBasePath;
exports.delBasePath = delBasePath;
exports["default"] = void 0;

var _url2 = __webpack_require__(/*! url */ "./node_modules/native-url/dist/index.js");

var _mitt = _interopRequireDefault(__webpack_require__(/*! ../mitt */ "./node_modules/next/dist/next-server/lib/mitt.js"));

var _utils = __webpack_require__(/*! ../utils */ "./node_modules/next/dist/next-server/lib/utils.js");

var _isDynamic = __webpack_require__(/*! ./utils/is-dynamic */ "./node_modules/next/dist/next-server/lib/router/utils/is-dynamic.js");

var _routeMatcher = __webpack_require__(/*! ./utils/route-matcher */ "./node_modules/next/dist/next-server/lib/router/utils/route-matcher.js");

var _routeRegex = __webpack_require__(/*! ./utils/route-regex */ "./node_modules/next/dist/next-server/lib/router/utils/route-regex.js");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
/* global __NEXT_DATA__ */
// tslint:disable:no-console


var basePath =  false || '';

function addBasePath(path) {
  return path.indexOf(basePath) !== 0 ? basePath + path : path;
}

function delBasePath(path) {
  return path.indexOf(basePath) === 0 ? path.substr(basePath.length) || '/' : path;
}

function toRoute(path) {
  return path.replace(/\/$/, '') || '/';
}

var prepareRoute = function prepareRoute(path) {
  return toRoute(!path || path === '/' ? '/index' : path);
};

function fetchNextData(pathname, query, isServerRender, cb) {
  var attempts = isServerRender ? 3 : 1;

  function getResponse() {
    return fetch((0, _utils.formatWithValidation)({
      pathname: addBasePath( // @ts-ignore __NEXT_DATA__
      "/_next/data/".concat(__NEXT_DATA__.buildId).concat(delBasePath(pathname), ".json")),
      query: query
    }), {
      // Cookies are required to be present for Next.js' SSG "Preview Mode".
      // Cookies may also be required for `getServerSideProps`.
      //
      // > `fetch` wont send cookies, unless you set the credentials init
      // > option.
      // https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch
      //
      // > For maximum browser compatibility when it comes to sending &
      // > receiving cookies, always supply the `credentials: 'same-origin'`
      // > option instead of relying on the default.
      // https://github.com/github/fetch#caveats
      credentials: 'same-origin'
    }).then(function (res) {
      if (!res.ok) {
        if (--attempts > 0 && res.status >= 500) {
          return getResponse();
        }

        throw new Error("Failed to load static props");
      }

      return res.json();
    });
  }

  return getResponse().then(function (data) {
    return cb ? cb(data) : data;
  })["catch"](function (err) {
    // We should only trigger a server-side transition if this was caused
    // on a client-side transition. Otherwise, we'd get into an infinite
    // loop.
    if (!isServerRender) {
      ;
      err.code = 'PAGE_LOAD_ERROR';
    }

    throw err;
  });
}

var Router = /*#__PURE__*/function () {
  /**
  * Map of all components loaded in `Router`
  */
  // Static Data Cache
  function Router(_pathname, _query, _as2, _ref) {
    var _this = this;

    var initialProps = _ref.initialProps,
        pageLoader = _ref.pageLoader,
        App = _ref.App,
        wrapApp = _ref.wrapApp,
        Component = _ref.Component,
        err = _ref.err,
        subscription = _ref.subscription,
        isFallback = _ref.isFallback;

    _classCallCheck(this, Router);

    this.route = void 0;
    this.pathname = void 0;
    this.query = void 0;
    this.asPath = void 0;
    this.basePath = void 0;
    this.components = void 0;
    this.sdc = {};
    this.sub = void 0;
    this.clc = void 0;
    this.pageLoader = void 0;
    this._bps = void 0;
    this.events = void 0;
    this._wrapApp = void 0;
    this.isSsr = void 0;
    this.isFallback = void 0;

    this.onPopState = function (e) {
      if (!e.state) {
        // We get state as undefined for two reasons.
        //  1. With older safari (< 8) and older chrome (< 34)
        //  2. When the URL changed with #
        //
        // In the both cases, we don't need to proceed and change the route.
        // (as it's already changed)
        // But we can simply replace the state with the new changes.
        // Actually, for (1) we don't need to nothing. But it's hard to detect that event.
        // So, doing the following for (1) does no harm.
        var pathname = _this.pathname,
            query = _this.query;

        _this.changeState('replaceState', (0, _utils.formatWithValidation)({
          pathname: pathname,
          query: query
        }), (0, _utils.getURL)());

        return;
      } // Make sure we don't re-render on initial load,
      // can be caused by navigating back from an external site


      if (e.state && _this.isSsr && e.state.as === _this.asPath && (0, _url2.parse)(e.state.url).pathname === _this.pathname) {
        return;
      } // If the downstream application returns falsy, return.
      // They will then be responsible for handling the event.


      if (_this._bps && !_this._bps(e.state)) {
        return;
      }

      var _e$state = e.state,
          url = _e$state.url,
          as = _e$state.as,
          options = _e$state.options;

      if (true) {
        if (typeof url === 'undefined' || typeof as === 'undefined') {
          console.warn('`popstate` event triggered but `event.state` did not have `url` or `as` https://err.sh/vercel/next.js/popstate-state-empty');
        }
      }

      _this.replace(url, as, options);
    };

    this._getStaticData = function (asPath) {
      var pathname = prepareRoute((0, _url2.parse)(asPath).pathname);
      return  false ? undefined : fetchNextData(pathname, null, _this.isSsr, function (data) {
        return _this.sdc[pathname] = data;
      });
    };

    this._getServerData = function (asPath) {
      var _ref2 = (0, _url2.parse)(asPath, true),
          pathname = _ref2.pathname,
          query = _ref2.query;

      pathname = prepareRoute(pathname);
      return fetchNextData(pathname, query, _this.isSsr);
    }; // represents the current component key


    this.route = toRoute(_pathname); // set up the component cache (by route keys)

    this.components = {}; // We should not keep the cache, if there's an error
    // Otherwise, this cause issues when when going back and
    // come again to the errored page.

    if (_pathname !== '/_error') {
      this.components[this.route] = {
        Component: Component,
        props: initialProps,
        err: err,
        __N_SSG: initialProps && initialProps.__N_SSG,
        __N_SSP: initialProps && initialProps.__N_SSP
      };
    }

    this.components['/_app'] = {
      Component: App
    }; // Backwards compat for Router.router.events
    // TODO: Should be remove the following major version as it was never documented

    this.events = Router.events;
    this.pageLoader = pageLoader;
    this.pathname = _pathname;
    this.query = _query; // if auto prerendered and dynamic route wait to update asPath
    // until after mount to prevent hydration mismatch

    this.asPath = // @ts-ignore this is temporarily global (attached to window)
    (0, _isDynamic.isDynamicRoute)(_pathname) && __NEXT_DATA__.autoExport ? _pathname : _as2;
    this.basePath = basePath;
    this.sub = subscription;
    this.clc = null;
    this._wrapApp = wrapApp; // make sure to ignore extra popState in safari on navigating
    // back from external site

    this.isSsr = true;
    this.isFallback = isFallback;

    if (true) {
      // make sure "as" doesn't start with double slashes or else it can
      // throw an error as it's considered invalid
      if (_as2.substr(0, 2) !== '//') {
        // in order for `e.state` to work on the `onpopstate` event
        // we have to register the initial route upon initialization
        this.changeState('replaceState', (0, _utils.formatWithValidation)({
          pathname: _pathname,
          query: _query
        }), _as2);
      }

      window.addEventListener('popstate', this.onPopState);
    }
  } // @deprecated backwards compatibility even though it's a private method.


  _createClass(Router, [{
    key: "update",
    value: function update(route, mod) {
      var Component = mod["default"] || mod;
      var data = this.components[route];

      if (!data) {
        throw new Error("Cannot update unavailable route: ".concat(route));
      }

      var newData = Object.assign({}, data, {
        Component: Component,
        __N_SSG: mod.__N_SSG,
        __N_SSP: mod.__N_SSP
      });
      this.components[route] = newData; // pages/_app.js updated

      if (route === '/_app') {
        this.notify(this.components[this.route]);
        return;
      }

      if (route === this.route) {
        this.notify(newData);
      }
    }
  }, {
    key: "reload",
    value: function reload() {
      window.location.reload();
    }
    /**
    * Go back in history
    */

  }, {
    key: "back",
    value: function back() {
      window.history.back();
    }
    /**
    * Performs a `pushState` with arguments
    * @param url of the route
    * @param as masks `url` for the browser
    * @param options object you can define `shallow` and other options
    */

  }, {
    key: "push",
    value: function push(url) {
      var as = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : url;
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      return this.change('pushState', url, as, options);
    }
    /**
    * Performs a `replaceState` with arguments
    * @param url of the route
    * @param as masks `url` for the browser
    * @param options object you can define `shallow` and other options
    */

  }, {
    key: "replace",
    value: function replace(url) {
      var as = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : url;
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      return this.change('replaceState', url, as, options);
    }
  }, {
    key: "change",
    value: function change(method, _url, _as, options) {
      var _this2 = this;

      return new Promise(function (resolve, reject) {
        if (!options._h) {
          _this2.isSsr = false;
        } // marking route changes as a navigation start entry


        if (_utils.ST) {
          performance.mark('routeChange');
        } // If url and as provided as an object representation,
        // we'll format them into the string version here.


        var url = typeof _url === 'object' ? (0, _utils.formatWithValidation)(_url) : _url;
        var as = typeof _as === 'object' ? (0, _utils.formatWithValidation)(_as) : _as;
        url = addBasePath(url);
        as = addBasePath(as); // Add the ending slash to the paths. So, we can serve the
        // "<page>/index.html" directly for the SSR page.

        if (false) { var rewriteUrlForNextExport; }

        _this2.abortComponentLoad(as); // If the url change is only related to a hash change
        // We should not proceed. We should only change the state.
        // WARNING: `_h` is an internal option for handing Next.js client-side
        // hydration. Your app should _never_ use this property. It may change at
        // any time without notice.


        if (!options._h && _this2.onlyAHashChange(as)) {
          _this2.asPath = as;
          Router.events.emit('hashChangeStart', as);

          _this2.changeState(method, url, as, options);

          _this2.scrollToHash(as);

          Router.events.emit('hashChangeComplete', as);
          return resolve(true);
        }

        var _ref3 = (0, _url2.parse)(url, true),
            pathname = _ref3.pathname,
            query = _ref3.query,
            protocol = _ref3.protocol;

        if (!pathname || protocol) {
          if (true) {
            throw new Error("Invalid href passed to router: ".concat(url, " https://err.sh/vercel/next.js/invalid-href-passed"));
          }

          return resolve(false);
        } // If asked to change the current URL we should reload the current page
        // (not location.reload() but reload getInitialProps and other Next.js stuffs)
        // We also need to set the method = replaceState always
        // as this should not go into the history (That's how browsers work)
        // We should compare the new asPath to the current asPath, not the url


        if (!_this2.urlIsNew(as)) {
          method = 'replaceState';
        }

        var route = toRoute(pathname);
        var _options$shallow = options.shallow,
            shallow = _options$shallow === void 0 ? false : _options$shallow;

        if ((0, _isDynamic.isDynamicRoute)(route)) {
          var _ref4 = (0, _url2.parse)(as),
              asPathname = _ref4.pathname;

          var routeRegex = (0, _routeRegex.getRouteRegex)(route);
          var routeMatch = (0, _routeMatcher.getRouteMatcher)(routeRegex)(asPathname);

          if (!routeMatch) {
            var missingParams = Object.keys(routeRegex.groups).filter(function (param) {
              return !query[param];
            });

            if (missingParams.length > 0) {
              if (true) {
                console.warn("Mismatching `as` and `href` failed to manually provide " + "the params: ".concat(missingParams.join(', '), " in the `href`'s `query`"));
              }

              return reject(new Error("The provided `as` value (".concat(asPathname, ") is incompatible with the `href` value (").concat(route, "). ") + "Read more: https://err.sh/vercel/next.js/incompatible-href-as"));
            }
          } else {
            // Merge params into `query`, overwriting any specified in search
            Object.assign(query, routeMatch);
          }
        }

        Router.events.emit('routeChangeStart', as); // If shallow is true and the route exists in the router cache we reuse the previous result

        _this2.getRouteInfo(route, pathname, query, as, shallow).then(function (routeInfo) {
          var error = routeInfo.error;

          if (error && error.cancelled) {
            return resolve(false);
          }

          Router.events.emit('beforeHistoryChange', as);

          _this2.changeState(method, url, as, options);

          if (true) {
            var appComp = _this2.components['/_app'].Component;
            window.next.isPrerendered = appComp.getInitialProps === appComp.origGetInitialProps && !routeInfo.Component.getInitialProps;
          }

          _this2.set(route, pathname, query, as, routeInfo).then(function () {
            if (error) {
              Router.events.emit('routeChangeError', error, as);
              throw error;
            }

            Router.events.emit('routeChangeComplete', as);
            return resolve(true);
          });
        }, reject);
      });
    }
  }, {
    key: "changeState",
    value: function changeState(method, url, as) {
      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

      if (true) {
        if (typeof window.history === 'undefined') {
          console.error("Warning: window.history is not available.");
          return;
        }

        if (typeof window.history[method] === 'undefined') {
          console.error("Warning: window.history.".concat(method, " is not available"));
          return;
        }
      }

      if (method !== 'pushState' || (0, _utils.getURL)() !== as) {
        window.history[method]({
          url: url,
          as: as,
          options: options
        }, // Most browsers currently ignores this parameter, although they may use it in the future.
        // Passing the empty string here should be safe against future changes to the method.
        // https://developer.mozilla.org/en-US/docs/Web/API/History/replaceState
        '', as);
      }
    }
  }, {
    key: "getRouteInfo",
    value: function getRouteInfo(route, pathname, query, as) {
      var _this3 = this;

      var shallow = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
      var cachedRouteInfo = this.components[route]; // If there is a shallow route transition possible
      // If the route is already rendered on the screen.

      if (shallow && cachedRouteInfo && this.route === route) {
        return Promise.resolve(cachedRouteInfo);
      }

      var handleError = function handleError(err, loadErrorFail) {
        return new Promise(function (resolve) {
          if (err.code === 'PAGE_LOAD_ERROR' || loadErrorFail) {
            // If we can't load the page it could be one of following reasons
            //  1. Page doesn't exists
            //  2. Page does exist in a different zone
            //  3. Internal error while loading the page
            // So, doing a hard reload is the proper way to deal with this.
            window.location.href = as; // Changing the URL doesn't block executing the current code path.
            // So, we need to mark it as a cancelled error and stop the routing logic.

            err.cancelled = true; // @ts-ignore TODO: fix the control flow here

            return resolve({
              error: err
            });
          }

          if (err.cancelled) {
            // @ts-ignore TODO: fix the control flow here
            return resolve({
              error: err
            });
          }

          resolve(_this3.fetchComponent('/_error').then(function (res) {
            var Component = res.page;
            var routeInfo = {
              Component: Component,
              err: err
            };
            return new Promise(function (resolve) {
              _this3.getInitialProps(Component, {
                err: err,
                pathname: pathname,
                query: query
              }).then(function (props) {
                routeInfo.props = props;
                routeInfo.error = err;
                resolve(routeInfo);
              }, function (gipErr) {
                console.error('Error in error page `getInitialProps`: ', gipErr);
                routeInfo.error = err;
                routeInfo.props = {};
                resolve(routeInfo);
              });
            });
          })["catch"](function (err) {
            return handleError(err, true);
          }));
        });
      };

      return new Promise(function (resolve, reject) {
        if (cachedRouteInfo) {
          return resolve(cachedRouteInfo);
        }

        _this3.fetchComponent(route).then(function (res) {
          return resolve({
            Component: res.page,
            __N_SSG: res.mod.__N_SSG,
            __N_SSP: res.mod.__N_SSP
          });
        }, reject);
      }).then(function (routeInfo) {
        var Component = routeInfo.Component,
            __N_SSG = routeInfo.__N_SSG,
            __N_SSP = routeInfo.__N_SSP;

        if (true) {
          var _require = __webpack_require__(/*! react-is */ "./node_modules/react-is/index.js"),
              isValidElementType = _require.isValidElementType;

          if (!isValidElementType(Component)) {
            throw new Error("The default export is not a React Component in page: \"".concat(pathname, "\""));
          }
        }

        return _this3._getData(function () {
          return __N_SSG ? _this3._getStaticData(as) : __N_SSP ? _this3._getServerData(as) : _this3.getInitialProps(Component, // we provide AppTree later so this needs to be `any`
          {
            pathname: pathname,
            query: query,
            asPath: as
          });
        }).then(function (props) {
          routeInfo.props = props;
          _this3.components[route] = routeInfo;
          return routeInfo;
        });
      })["catch"](handleError);
    }
  }, {
    key: "set",
    value: function set(route, pathname, query, as, data) {
      this.isFallback = false;
      this.route = route;
      this.pathname = pathname;
      this.query = query;
      this.asPath = as;
      return this.notify(data);
    }
    /**
    * Callback to execute before replacing router state
    * @param cb callback to be executed
    */

  }, {
    key: "beforePopState",
    value: function beforePopState(cb) {
      this._bps = cb;
    }
  }, {
    key: "onlyAHashChange",
    value: function onlyAHashChange(as) {
      if (!this.asPath) return false;

      var _this$asPath$split = this.asPath.split('#'),
          _this$asPath$split2 = _slicedToArray(_this$asPath$split, 2),
          oldUrlNoHash = _this$asPath$split2[0],
          oldHash = _this$asPath$split2[1];

      var _as$split = as.split('#'),
          _as$split2 = _slicedToArray(_as$split, 2),
          newUrlNoHash = _as$split2[0],
          newHash = _as$split2[1]; // Makes sure we scroll to the provided hash if the url/hash are the same


      if (newHash && oldUrlNoHash === newUrlNoHash && oldHash === newHash) {
        return true;
      } // If the urls are change, there's more than a hash change


      if (oldUrlNoHash !== newUrlNoHash) {
        return false;
      } // If the hash has changed, then it's a hash only change.
      // This check is necessary to handle both the enter and
      // leave hash === '' cases. The identity case falls through
      // and is treated as a next reload.


      return oldHash !== newHash;
    }
  }, {
    key: "scrollToHash",
    value: function scrollToHash(as) {
      var _as$split3 = as.split('#'),
          _as$split4 = _slicedToArray(_as$split3, 2),
          hash = _as$split4[1]; // Scroll to top if the hash is just `#` with no value


      if (hash === '') {
        window.scrollTo(0, 0);
        return;
      } // First we check if the element by id is found


      var idEl = document.getElementById(hash);

      if (idEl) {
        idEl.scrollIntoView();
        return;
      } // If there's no element with the id, we check the `name` property
      // To mirror browsers


      var nameEl = document.getElementsByName(hash)[0];

      if (nameEl) {
        nameEl.scrollIntoView();
      }
    }
  }, {
    key: "urlIsNew",
    value: function urlIsNew(asPath) {
      return this.asPath !== asPath;
    }
    /**
    * Prefetch page code, you may wait for the data during page rendering.
    * This feature only works in production!
    * @param url the href of prefetched page
    * @param asPath the as path of the prefetched page
    */

  }, {
    key: "prefetch",
    value: function prefetch(url) {
      var _this4 = this;

      var asPath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : url;
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      return new Promise(function (resolve, reject) {
        var _ref5 = (0, _url2.parse)(url),
            pathname = _ref5.pathname,
            protocol = _ref5.protocol;

        if (!pathname || protocol) {
          if (true) {
            throw new Error("Invalid href passed to router: ".concat(url, " https://err.sh/vercel/next.js/invalid-href-passed"));
          }

          return;
        } // Prefetch is not supported in development mode because it would trigger on-demand-entries


        if (true) {
          return;
        }

        var route = delBasePath(toRoute(pathname));
        Promise.all([_this4.pageLoader.prefetchData(url, delBasePath(asPath)), _this4.pageLoader[options.priority ? 'loadPage' : 'prefetch'](route)]).then(function () {
          return resolve();
        }, reject);
      });
    }
  }, {
    key: "fetchComponent",
    value: function () {
      var _fetchComponent = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(route) {
        var cancelled, cancel, componentResult, error;
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                cancelled = false;

                cancel = this.clc = function () {
                  cancelled = true;
                };

                route = delBasePath(route);
                _context.next = 5;
                return this.pageLoader.loadPage(route);

              case 5:
                componentResult = _context.sent;

                if (!cancelled) {
                  _context.next = 10;
                  break;
                }

                error = new Error("Abort fetching component for route: \"".concat(route, "\""));
                error.cancelled = true;
                throw error;

              case 10:
                if (cancel === this.clc) {
                  this.clc = null;
                }

                return _context.abrupt("return", componentResult);

              case 12:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function fetchComponent(_x) {
        return _fetchComponent.apply(this, arguments);
      }

      return fetchComponent;
    }()
  }, {
    key: "_getData",
    value: function _getData(fn) {
      var _this5 = this;

      var cancelled = false;

      var cancel = function cancel() {
        cancelled = true;
      };

      this.clc = cancel;
      return fn().then(function (data) {
        if (cancel === _this5.clc) {
          _this5.clc = null;
        }

        if (cancelled) {
          var err = new Error('Loading initial props cancelled');
          err.cancelled = true;
          throw err;
        }

        return data;
      });
    }
  }, {
    key: "getInitialProps",
    value: function getInitialProps(Component, ctx) {
      var App = this.components['/_app'].Component;

      var AppTree = this._wrapApp(App);

      ctx.AppTree = AppTree;
      return (0, _utils.loadGetInitialProps)(App, {
        AppTree: AppTree,
        Component: Component,
        router: this,
        ctx: ctx
      });
    }
  }, {
    key: "abortComponentLoad",
    value: function abortComponentLoad(as) {
      if (this.clc) {
        var e = new Error('Route Cancelled');
        e.cancelled = true;
        Router.events.emit('routeChangeError', e, as);
        this.clc();
        this.clc = null;
      }
    }
  }, {
    key: "notify",
    value: function notify(data) {
      return this.sub(data, this.components['/_app'].Component);
    }
  }], [{
    key: "_rewriteUrlForNextExport",
    value: function _rewriteUrlForNextExport(url) {
      if (false) { var rewriteUrlForNextExport; } else {
        return url;
      }
    }
  }]);

  return Router;
}();

exports["default"] = Router;
Router.events = (0, _mitt["default"])();

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/is-dynamic.js":
/*!***************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/is-dynamic.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.isDynamicRoute = isDynamicRoute; // Identify /[param]/ in route string

var TEST_ROUTE = /\/\[[^/]+?\](?=\/|$)/;

function isDynamicRoute(route) {
  return TEST_ROUTE.test(route);
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/route-matcher.js":
/*!******************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/route-matcher.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.getRouteMatcher = getRouteMatcher;

function getRouteMatcher(routeRegex) {
  var re = routeRegex.re,
      groups = routeRegex.groups;
  return function (pathname) {
    var routeMatch = re.exec(pathname);

    if (!routeMatch) {
      return false;
    }

    var decode = function decode(param) {
      try {
        return decodeURIComponent(param);
      } catch (_) {
        var err = new Error('failed to decode param');
        err.code = 'DECODE_FAILED';
        throw err;
      }
    };

    var params = {};
    Object.keys(groups).forEach(function (slugName) {
      var g = groups[slugName];
      var m = routeMatch[g.pos];

      if (m !== undefined) {
        params[slugName] = ~m.indexOf('/') ? m.split('/').map(function (entry) {
          return decode(entry);
        }) : g.repeat ? [decode(m)] : decode(m);
      }
    });
    return params;
  };
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/route-regex.js":
/*!****************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/route-regex.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.getRouteRegex = getRouteRegex; // this isn't importing the escape-string-regex module
// to reduce bytes

function escapeRegex(str) {
  return str.replace(/[|\\{}()[\]^$+*?.-]/g, '\\$&');
}

function getRouteRegex(normalizedRoute) {
  // Escape all characters that could be considered RegEx
  var escapedRoute = escapeRegex(normalizedRoute.replace(/\/$/, '') || '/');
  var groups = {};
  var groupIndex = 1;
  var parameterizedRoute = escapedRoute.replace(/\/\\\[([^/]+?)\\\](?=\/|$)/g, function (_, $1) {
    var isOptional = /^\\\[.*\\\]$/.test($1);

    if (isOptional) {
      $1 = $1.slice(2, -2);
    }

    var isCatchAll = /^(\\\.){3}/.test($1);

    if (isCatchAll) {
      $1 = $1.slice(6);
    }

    groups[$1 // Un-escape key
    .replace(/\\([|\\{}()[\]^$+*?.-])/g, '$1') // eslint-disable-next-line no-sequences
    ] = {
      pos: groupIndex++,
      repeat: isCatchAll
    };
    return isCatchAll ? isOptional ? '(?:/(.+?))?' : '/(.+?)' : '/([^/]+?)';
  });
  var namedParameterizedRoute; // dead code eliminate for browser since it's only needed
  // while generating routes-manifest

  if (false) {}

  return {
    re: new RegExp('^' + parameterizedRoute + '(?:/)?$', 'i'),
    groups: groups,
    namedRegex: namedParameterizedRoute ? "^".concat(namedParameterizedRoute, "(?:/)?$") : undefined
  };
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/runtime-config.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/runtime-config.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.setConfig = setConfig;
exports["default"] = void 0;
var runtimeConfig;

var _default = function _default() {
  return runtimeConfig;
};

exports["default"] = _default;

function setConfig(configValue) {
  runtimeConfig = configValue;
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/utils.js":
/*!*********************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/utils.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _regeneratorRuntime = __webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js");

var _asyncToGenerator = __webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js");

exports.__esModule = true;
exports.execOnce = execOnce;
exports.getLocationOrigin = getLocationOrigin;
exports.getURL = getURL;
exports.getDisplayName = getDisplayName;
exports.isResSent = isResSent;
exports.loadGetInitialProps = loadGetInitialProps;
exports.formatWithValidation = formatWithValidation;
exports.ST = exports.SP = exports.urlObjectKeys = void 0;

var _url = __webpack_require__(/*! url */ "./node_modules/native-url/dist/index.js");
/**
* Utils
*/


function execOnce(fn) {
  var used = false;
  var result;
  return function () {
    if (!used) {
      used = true;
      result = fn.apply(void 0, arguments);
    }

    return result;
  };
}

function getLocationOrigin() {
  var _window$location = window.location,
      protocol = _window$location.protocol,
      hostname = _window$location.hostname,
      port = _window$location.port;
  return "".concat(protocol, "//").concat(hostname).concat(port ? ':' + port : '');
}

function getURL() {
  var href = window.location.href;
  var origin = getLocationOrigin();
  return href.substring(origin.length);
}

function getDisplayName(Component) {
  return typeof Component === 'string' ? Component : Component.displayName || Component.name || 'Unknown';
}

function isResSent(res) {
  return res.finished || res.headersSent;
}

function loadGetInitialProps(_x, _x2) {
  return _loadGetInitialProps.apply(this, arguments);
}

function _loadGetInitialProps() {
  _loadGetInitialProps = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(App, ctx) {
    var _App$prototype, message, res, props, _message;

    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (false) {}

            if (!((_App$prototype = App.prototype) === null || _App$prototype === void 0 ? void 0 : _App$prototype.getInitialProps)) {
              _context.next = 4;
              break;
            }

            message = "\"".concat(getDisplayName(App), ".getInitialProps()\" is defined as an instance method - visit https://err.sh/vercel/next.js/get-initial-props-as-an-instance-method for more information.");
            throw new Error(message);

          case 4:
            // when called from _app `ctx` is nested in `ctx`
            res = ctx.res || ctx.ctx && ctx.ctx.res;

            if (App.getInitialProps) {
              _context.next = 12;
              break;
            }

            if (!(ctx.ctx && ctx.Component)) {
              _context.next = 11;
              break;
            }

            _context.next = 9;
            return loadGetInitialProps(ctx.Component, ctx.ctx);

          case 9:
            _context.t0 = _context.sent;
            return _context.abrupt("return", {
              pageProps: _context.t0
            });

          case 11:
            return _context.abrupt("return", {});

          case 12:
            _context.next = 14;
            return App.getInitialProps(ctx);

          case 14:
            props = _context.sent;

            if (!(res && isResSent(res))) {
              _context.next = 17;
              break;
            }

            return _context.abrupt("return", props);

          case 17:
            if (props) {
              _context.next = 20;
              break;
            }

            _message = "\"".concat(getDisplayName(App), ".getInitialProps()\" should resolve to an object. But found \"").concat(props, "\" instead.");
            throw new Error(_message);

          case 20:
            if (true) {
              if (Object.keys(props).length === 0 && !ctx.ctx) {
                console.warn("".concat(getDisplayName(App), " returned an empty object from `getInitialProps`. This de-optimizes and prevents automatic static optimization. https://err.sh/vercel/next.js/empty-object-getInitialProps"));
              }
            }

            return _context.abrupt("return", props);

          case 22:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _loadGetInitialProps.apply(this, arguments);
}

var urlObjectKeys = ['auth', 'hash', 'host', 'hostname', 'href', 'path', 'pathname', 'port', 'protocol', 'query', 'search', 'slashes'];
exports.urlObjectKeys = urlObjectKeys;

function formatWithValidation(url, options) {
  if (true) {
    if (url !== null && typeof url === 'object') {
      Object.keys(url).forEach(function (key) {
        if (urlObjectKeys.indexOf(key) === -1) {
          console.warn("Unknown key passed via urlObject into url.format: ".concat(key));
        }
      });
    }
  }

  return (0, _url.format)(url, options);
}

var SP = typeof performance !== 'undefined';
exports.SP = SP;
var ST = SP && typeof performance.mark === 'function' && typeof performance.measure === 'function';
exports.ST = ST;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/platform/platform.js":
/*!*******************************************!*\
  !*** ./node_modules/platform/platform.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module, global) {var __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * Platform.js <https://mths.be/platform>
 * Copyright 2014-2016 Benjamin Tan <https://demoneaux.github.io/>
 * Copyright 2011-2013 John-David Dalton <http://allyoucanleet.com/>
 * Available under MIT license <https://mths.be/mit>
 */
;(function() {
  'use strict';

  /** Used to determine if values are of the language type `Object`. */
  var objectTypes = {
    'function': true,
    'object': true
  };

  /** Used as a reference to the global object. */
  var root = (objectTypes[typeof window] && window) || this;

  /** Backup possible global object. */
  var oldRoot = root;

  /** Detect free variable `exports`. */
  var freeExports = objectTypes[typeof exports] && exports;

  /** Detect free variable `module`. */
  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;

  /** Detect free variable `global` from Node.js or Browserified code and use it as `root`. */
  var freeGlobal = freeExports && freeModule && typeof global == 'object' && global;
  if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal)) {
    root = freeGlobal;
  }

  /**
   * Used as the maximum length of an array-like object.
   * See the [ES6 spec](http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength)
   * for more details.
   */
  var maxSafeInteger = Math.pow(2, 53) - 1;

  /** Regular expression to detect Opera. */
  var reOpera = /\bOpera/;

  /** Possible global object. */
  var thisBinding = this;

  /** Used for native method references. */
  var objectProto = Object.prototype;

  /** Used to check for own properties of an object. */
  var hasOwnProperty = objectProto.hasOwnProperty;

  /** Used to resolve the internal `[[Class]]` of values. */
  var toString = objectProto.toString;

  /*--------------------------------------------------------------------------*/

  /**
   * Capitalizes a string value.
   *
   * @private
   * @param {string} string The string to capitalize.
   * @returns {string} The capitalized string.
   */
  function capitalize(string) {
    string = String(string);
    return string.charAt(0).toUpperCase() + string.slice(1);
  }

  /**
   * A utility function to clean up the OS name.
   *
   * @private
   * @param {string} os The OS name to clean up.
   * @param {string} [pattern] A `RegExp` pattern matching the OS name.
   * @param {string} [label] A label for the OS.
   */
  function cleanupOS(os, pattern, label) {
    // Platform tokens are defined at:
    // http://msdn.microsoft.com/en-us/library/ms537503(VS.85).aspx
    // http://web.archive.org/web/20081122053950/http://msdn.microsoft.com/en-us/library/ms537503(VS.85).aspx
    var data = {
      '10.0': '10',
      '6.4':  '10 Technical Preview',
      '6.3':  '8.1',
      '6.2':  '8',
      '6.1':  'Server 2008 R2 / 7',
      '6.0':  'Server 2008 / Vista',
      '5.2':  'Server 2003 / XP 64-bit',
      '5.1':  'XP',
      '5.01': '2000 SP1',
      '5.0':  '2000',
      '4.0':  'NT',
      '4.90': 'ME'
    };
    // Detect Windows version from platform tokens.
    if (pattern && label && /^Win/i.test(os) && !/^Windows Phone /i.test(os) &&
        (data = data[/[\d.]+$/.exec(os)])) {
      os = 'Windows ' + data;
    }
    // Correct character case and cleanup string.
    os = String(os);

    if (pattern && label) {
      os = os.replace(RegExp(pattern, 'i'), label);
    }

    os = format(
      os.replace(/ ce$/i, ' CE')
        .replace(/\bhpw/i, 'web')
        .replace(/\bMacintosh\b/, 'Mac OS')
        .replace(/_PowerPC\b/i, ' OS')
        .replace(/\b(OS X) [^ \d]+/i, '$1')
        .replace(/\bMac (OS X)\b/, '$1')
        .replace(/\/(\d)/, ' $1')
        .replace(/_/g, '.')
        .replace(/(?: BePC|[ .]*fc[ \d.]+)$/i, '')
        .replace(/\bx86\.64\b/gi, 'x86_64')
        .replace(/\b(Windows Phone) OS\b/, '$1')
        .replace(/\b(Chrome OS \w+) [\d.]+\b/, '$1')
        .split(' on ')[0]
    );

    return os;
  }

  /**
   * An iteration utility for arrays and objects.
   *
   * @private
   * @param {Array|Object} object The object to iterate over.
   * @param {Function} callback The function called per iteration.
   */
  function each(object, callback) {
    var index = -1,
        length = object ? object.length : 0;

    if (typeof length == 'number' && length > -1 && length <= maxSafeInteger) {
      while (++index < length) {
        callback(object[index], index, object);
      }
    } else {
      forOwn(object, callback);
    }
  }

  /**
   * Trim and conditionally capitalize string values.
   *
   * @private
   * @param {string} string The string to format.
   * @returns {string} The formatted string.
   */
  function format(string) {
    string = trim(string);
    return /^(?:webOS|i(?:OS|P))/.test(string)
      ? string
      : capitalize(string);
  }

  /**
   * Iterates over an object's own properties, executing the `callback` for each.
   *
   * @private
   * @param {Object} object The object to iterate over.
   * @param {Function} callback The function executed per own property.
   */
  function forOwn(object, callback) {
    for (var key in object) {
      if (hasOwnProperty.call(object, key)) {
        callback(object[key], key, object);
      }
    }
  }

  /**
   * Gets the internal `[[Class]]` of a value.
   *
   * @private
   * @param {*} value The value.
   * @returns {string} The `[[Class]]`.
   */
  function getClassOf(value) {
    return value == null
      ? capitalize(value)
      : toString.call(value).slice(8, -1);
  }

  /**
   * Host objects can return type values that are different from their actual
   * data type. The objects we are concerned with usually return non-primitive
   * types of "object", "function", or "unknown".
   *
   * @private
   * @param {*} object The owner of the property.
   * @param {string} property The property to check.
   * @returns {boolean} Returns `true` if the property value is a non-primitive, else `false`.
   */
  function isHostType(object, property) {
    var type = object != null ? typeof object[property] : 'number';
    return !/^(?:boolean|number|string|undefined)$/.test(type) &&
      (type == 'object' ? !!object[property] : true);
  }

  /**
   * Prepares a string for use in a `RegExp` by making hyphens and spaces optional.
   *
   * @private
   * @param {string} string The string to qualify.
   * @returns {string} The qualified string.
   */
  function qualify(string) {
    return String(string).replace(/([ -])(?!$)/g, '$1?');
  }

  /**
   * A bare-bones `Array#reduce` like utility function.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} callback The function called per iteration.
   * @returns {*} The accumulated result.
   */
  function reduce(array, callback) {
    var accumulator = null;
    each(array, function(value, index) {
      accumulator = callback(accumulator, value, index, array);
    });
    return accumulator;
  }

  /**
   * Removes leading and trailing whitespace from a string.
   *
   * @private
   * @param {string} string The string to trim.
   * @returns {string} The trimmed string.
   */
  function trim(string) {
    return String(string).replace(/^ +| +$/g, '');
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Creates a new platform object.
   *
   * @memberOf platform
   * @param {Object|string} [ua=navigator.userAgent] The user agent string or
   *  context object.
   * @returns {Object} A platform object.
   */
  function parse(ua) {

    /** The environment context object. */
    var context = root;

    /** Used to flag when a custom context is provided. */
    var isCustomContext = ua && typeof ua == 'object' && getClassOf(ua) != 'String';

    // Juggle arguments.
    if (isCustomContext) {
      context = ua;
      ua = null;
    }

    /** Browser navigator object. */
    var nav = context.navigator || {};

    /** Browser user agent string. */
    var userAgent = nav.userAgent || '';

    ua || (ua = userAgent);

    /** Used to flag when `thisBinding` is the [ModuleScope]. */
    var isModuleScope = isCustomContext || thisBinding == oldRoot;

    /** Used to detect if browser is like Chrome. */
    var likeChrome = isCustomContext
      ? !!nav.likeChrome
      : /\bChrome\b/.test(ua) && !/internal|\n/i.test(toString.toString());

    /** Internal `[[Class]]` value shortcuts. */
    var objectClass = 'Object',
        airRuntimeClass = isCustomContext ? objectClass : 'ScriptBridgingProxyObject',
        enviroClass = isCustomContext ? objectClass : 'Environment',
        javaClass = (isCustomContext && context.java) ? 'JavaPackage' : getClassOf(context.java),
        phantomClass = isCustomContext ? objectClass : 'RuntimeObject';

    /** Detect Java environments. */
    var java = /\bJava/.test(javaClass) && context.java;

    /** Detect Rhino. */
    var rhino = java && getClassOf(context.environment) == enviroClass;

    /** A character to represent alpha. */
    var alpha = java ? 'a' : '\u03b1';

    /** A character to represent beta. */
    var beta = java ? 'b' : '\u03b2';

    /** Browser document object. */
    var doc = context.document || {};

    /**
     * Detect Opera browser (Presto-based).
     * http://www.howtocreate.co.uk/operaStuff/operaObject.html
     * http://dev.opera.com/articles/view/opera-mini-web-content-authoring-guidelines/#operamini
     */
    var opera = context.operamini || context.opera;

    /** Opera `[[Class]]`. */
    var operaClass = reOpera.test(operaClass = (isCustomContext && opera) ? opera['[[Class]]'] : getClassOf(opera))
      ? operaClass
      : (opera = null);

    /*------------------------------------------------------------------------*/

    /** Temporary variable used over the script's lifetime. */
    var data;

    /** The CPU architecture. */
    var arch = ua;

    /** Platform description array. */
    var description = [];

    /** Platform alpha/beta indicator. */
    var prerelease = null;

    /** A flag to indicate that environment features should be used to resolve the platform. */
    var useFeatures = ua == userAgent;

    /** The browser/environment version. */
    var version = useFeatures && opera && typeof opera.version == 'function' && opera.version();

    /** A flag to indicate if the OS ends with "/ Version" */
    var isSpecialCasedOS;

    /* Detectable layout engines (order is important). */
    var layout = getLayout([
      { 'label': 'EdgeHTML', 'pattern': 'Edge' },
      'Trident',
      { 'label': 'WebKit', 'pattern': 'AppleWebKit' },
      'iCab',
      'Presto',
      'NetFront',
      'Tasman',
      'KHTML',
      'Gecko'
    ]);

    /* Detectable browser names (order is important). */
    var name = getName([
      'Adobe AIR',
      'Arora',
      'Avant Browser',
      'Breach',
      'Camino',
      'Epiphany',
      'Fennec',
      'Flock',
      'Galeon',
      'GreenBrowser',
      'iCab',
      'Iceweasel',
      'K-Meleon',
      'Konqueror',
      'Lunascape',
      'Maxthon',
      { 'label': 'Microsoft Edge', 'pattern': 'Edge' },
      'Midori',
      'Nook Browser',
      'PaleMoon',
      'PhantomJS',
      'Raven',
      'Rekonq',
      'RockMelt',
      'SeaMonkey',
      { 'label': 'Silk', 'pattern': '(?:Cloud9|Silk-Accelerated)' },
      'Sleipnir',
      'SlimBrowser',
      { 'label': 'SRWare Iron', 'pattern': 'Iron' },
      'Sunrise',
      'Swiftfox',
      'WebPositive',
      'Opera Mini',
      { 'label': 'Opera Mini', 'pattern': 'OPiOS' },
      'Opera',
      { 'label': 'Opera', 'pattern': 'OPR' },
      'Chrome',
      { 'label': 'Chrome Mobile', 'pattern': '(?:CriOS|CrMo)' },
      { 'label': 'Firefox', 'pattern': '(?:Firefox|Minefield)' },
      { 'label': 'Firefox for iOS', 'pattern': 'FxiOS' },
      { 'label': 'IE', 'pattern': 'IEMobile' },
      { 'label': 'IE', 'pattern': 'MSIE' },
      'Safari'
    ]);

    /* Detectable products (order is important). */
    var product = getProduct([
      { 'label': 'BlackBerry', 'pattern': 'BB10' },
      'BlackBerry',
      { 'label': 'Galaxy S', 'pattern': 'GT-I9000' },
      { 'label': 'Galaxy S2', 'pattern': 'GT-I9100' },
      { 'label': 'Galaxy S3', 'pattern': 'GT-I9300' },
      { 'label': 'Galaxy S4', 'pattern': 'GT-I9500' },
      'Google TV',
      'Lumia',
      'iPad',
      'iPod',
      'iPhone',
      'Kindle',
      { 'label': 'Kindle Fire', 'pattern': '(?:Cloud9|Silk-Accelerated)' },
      'Nexus',
      'Nook',
      'PlayBook',
      'PlayStation 3',
      'PlayStation 4',
      'PlayStation Vita',
      'TouchPad',
      'Transformer',
      { 'label': 'Wii U', 'pattern': 'WiiU' },
      'Wii',
      'Xbox One',
      { 'label': 'Xbox 360', 'pattern': 'Xbox' },
      'Xoom'
    ]);

    /* Detectable manufacturers. */
    var manufacturer = getManufacturer({
      'Apple': { 'iPad': 1, 'iPhone': 1, 'iPod': 1 },
      'Archos': {},
      'Amazon': { 'Kindle': 1, 'Kindle Fire': 1 },
      'Asus': { 'Transformer': 1 },
      'Barnes & Noble': { 'Nook': 1 },
      'BlackBerry': { 'PlayBook': 1 },
      'Google': { 'Google TV': 1, 'Nexus': 1 },
      'HP': { 'TouchPad': 1 },
      'HTC': {},
      'LG': {},
      'Microsoft': { 'Xbox': 1, 'Xbox One': 1 },
      'Motorola': { 'Xoom': 1 },
      'Nintendo': { 'Wii U': 1,  'Wii': 1 },
      'Nokia': { 'Lumia': 1 },
      'Samsung': { 'Galaxy S': 1, 'Galaxy S2': 1, 'Galaxy S3': 1, 'Galaxy S4': 1 },
      'Sony': { 'PlayStation 4': 1, 'PlayStation 3': 1, 'PlayStation Vita': 1 }
    });

    /* Detectable operating systems (order is important). */
    var os = getOS([
      'Windows Phone',
      'Android',
      'CentOS',
      { 'label': 'Chrome OS', 'pattern': 'CrOS' },
      'Debian',
      'Fedora',
      'FreeBSD',
      'Gentoo',
      'Haiku',
      'Kubuntu',
      'Linux Mint',
      'OpenBSD',
      'Red Hat',
      'SuSE',
      'Ubuntu',
      'Xubuntu',
      'Cygwin',
      'Symbian OS',
      'hpwOS',
      'webOS ',
      'webOS',
      'Tablet OS',
      'Linux',
      'Mac OS X',
      'Macintosh',
      'Mac',
      'Windows 98;',
      'Windows '
    ]);

    /*------------------------------------------------------------------------*/

    /**
     * Picks the layout engine from an array of guesses.
     *
     * @private
     * @param {Array} guesses An array of guesses.
     * @returns {null|string} The detected layout engine.
     */
    function getLayout(guesses) {
      return reduce(guesses, function(result, guess) {
        return result || RegExp('\\b' + (
          guess.pattern || qualify(guess)
        ) + '\\b', 'i').exec(ua) && (guess.label || guess);
      });
    }

    /**
     * Picks the manufacturer from an array of guesses.
     *
     * @private
     * @param {Array} guesses An object of guesses.
     * @returns {null|string} The detected manufacturer.
     */
    function getManufacturer(guesses) {
      return reduce(guesses, function(result, value, key) {
        // Lookup the manufacturer by product or scan the UA for the manufacturer.
        return result || (
          value[product] ||
          value[/^[a-z]+(?: +[a-z]+\b)*/i.exec(product)] ||
          RegExp('\\b' + qualify(key) + '(?:\\b|\\w*\\d)', 'i').exec(ua)
        ) && key;
      });
    }

    /**
     * Picks the browser name from an array of guesses.
     *
     * @private
     * @param {Array} guesses An array of guesses.
     * @returns {null|string} The detected browser name.
     */
    function getName(guesses) {
      return reduce(guesses, function(result, guess) {
        return result || RegExp('\\b' + (
          guess.pattern || qualify(guess)
        ) + '\\b', 'i').exec(ua) && (guess.label || guess);
      });
    }

    /**
     * Picks the OS name from an array of guesses.
     *
     * @private
     * @param {Array} guesses An array of guesses.
     * @returns {null|string} The detected OS name.
     */
    function getOS(guesses) {
      return reduce(guesses, function(result, guess) {
        var pattern = guess.pattern || qualify(guess);
        if (!result && (result =
              RegExp('\\b' + pattern + '(?:/[\\d.]+|[ \\w.]*)', 'i').exec(ua)
            )) {
          result = cleanupOS(result, pattern, guess.label || guess);
        }
        return result;
      });
    }

    /**
     * Picks the product name from an array of guesses.
     *
     * @private
     * @param {Array} guesses An array of guesses.
     * @returns {null|string} The detected product name.
     */
    function getProduct(guesses) {
      return reduce(guesses, function(result, guess) {
        var pattern = guess.pattern || qualify(guess);
        if (!result && (result =
              RegExp('\\b' + pattern + ' *\\d+[.\\w_]*', 'i').exec(ua) ||
              RegExp('\\b' + pattern + '(?:; *(?:[a-z]+[_-])?[a-z]+\\d+|[^ ();-]*)', 'i').exec(ua)
            )) {
          // Split by forward slash and append product version if needed.
          if ((result = String((guess.label && !RegExp(pattern, 'i').test(guess.label)) ? guess.label : result).split('/'))[1] && !/[\d.]+/.test(result[0])) {
            result[0] += ' ' + result[1];
          }
          // Correct character case and cleanup string.
          guess = guess.label || guess;
          result = format(result[0]
            .replace(RegExp(pattern, 'i'), guess)
            .replace(RegExp('; *(?:' + guess + '[_-])?', 'i'), ' ')
            .replace(RegExp('(' + guess + ')[-_.]?(\\w)', 'i'), '$1 $2'));
        }
        return result;
      });
    }

    /**
     * Resolves the version using an array of UA patterns.
     *
     * @private
     * @param {Array} patterns An array of UA patterns.
     * @returns {null|string} The detected version.
     */
    function getVersion(patterns) {
      return reduce(patterns, function(result, pattern) {
        return result || (RegExp(pattern +
          '(?:-[\\d.]+/|(?: for [\\w-]+)?[ /-])([\\d.]+[^ ();/_-]*)', 'i').exec(ua) || 0)[1] || null;
      });
    }

    /**
     * Returns `platform.description` when the platform object is coerced to a string.
     *
     * @name toString
     * @memberOf platform
     * @returns {string} Returns `platform.description` if available, else an empty string.
     */
    function toStringPlatform() {
      return this.description || '';
    }

    /*------------------------------------------------------------------------*/

    // Convert layout to an array so we can add extra details.
    layout && (layout = [layout]);

    // Detect product names that contain their manufacturer's name.
    if (manufacturer && !product) {
      product = getProduct([manufacturer]);
    }
    // Clean up Google TV.
    if ((data = /\bGoogle TV\b/.exec(product))) {
      product = data[0];
    }
    // Detect simulators.
    if (/\bSimulator\b/i.test(ua)) {
      product = (product ? product + ' ' : '') + 'Simulator';
    }
    // Detect Opera Mini 8+ running in Turbo/Uncompressed mode on iOS.
    if (name == 'Opera Mini' && /\bOPiOS\b/.test(ua)) {
      description.push('running in Turbo/Uncompressed mode');
    }
    // Detect IE Mobile 11.
    if (name == 'IE' && /\blike iPhone OS\b/.test(ua)) {
      data = parse(ua.replace(/like iPhone OS/, ''));
      manufacturer = data.manufacturer;
      product = data.product;
    }
    // Detect iOS.
    else if (/^iP/.test(product)) {
      name || (name = 'Safari');
      os = 'iOS' + ((data = / OS ([\d_]+)/i.exec(ua))
        ? ' ' + data[1].replace(/_/g, '.')
        : '');
    }
    // Detect Kubuntu.
    else if (name == 'Konqueror' && !/buntu/i.test(os)) {
      os = 'Kubuntu';
    }
    // Detect Android browsers.
    else if ((manufacturer && manufacturer != 'Google' &&
        ((/Chrome/.test(name) && !/\bMobile Safari\b/i.test(ua)) || /\bVita\b/.test(product))) ||
        (/\bAndroid\b/.test(os) && /^Chrome/.test(name) && /\bVersion\//i.test(ua))) {
      name = 'Android Browser';
      os = /\bAndroid\b/.test(os) ? os : 'Android';
    }
    // Detect Silk desktop/accelerated modes.
    else if (name == 'Silk') {
      if (!/\bMobi/i.test(ua)) {
        os = 'Android';
        description.unshift('desktop mode');
      }
      if (/Accelerated *= *true/i.test(ua)) {
        description.unshift('accelerated');
      }
    }
    // Detect PaleMoon identifying as Firefox.
    else if (name == 'PaleMoon' && (data = /\bFirefox\/([\d.]+)\b/.exec(ua))) {
      description.push('identifying as Firefox ' + data[1]);
    }
    // Detect Firefox OS and products running Firefox.
    else if (name == 'Firefox' && (data = /\b(Mobile|Tablet|TV)\b/i.exec(ua))) {
      os || (os = 'Firefox OS');
      product || (product = data[1]);
    }
    // Detect false positives for Firefox/Safari.
    else if (!name || (data = !/\bMinefield\b/i.test(ua) && /\b(?:Firefox|Safari)\b/.exec(name))) {
      // Escape the `/` for Firefox 1.
      if (name && !product && /[\/,]|^[^(]+?\)/.test(ua.slice(ua.indexOf(data + '/') + 8))) {
        // Clear name of false positives.
        name = null;
      }
      // Reassign a generic name.
      if ((data = product || manufacturer || os) &&
          (product || manufacturer || /\b(?:Android|Symbian OS|Tablet OS|webOS)\b/.test(os))) {
        name = /[a-z]+(?: Hat)?/i.exec(/\bAndroid\b/.test(os) ? os : data) + ' Browser';
      }
    }
    // Detect non-Opera (Presto-based) versions (order is important).
    if (!version) {
      version = getVersion([
        '(?:Cloud9|CriOS|CrMo|Edge|FxiOS|IEMobile|Iron|Opera ?Mini|OPiOS|OPR|Raven|Silk(?!/[\\d.]+$))',
        'Version',
        qualify(name),
        '(?:Firefox|Minefield|NetFront)'
      ]);
    }
    // Detect stubborn layout engines.
    if ((data =
          layout == 'iCab' && parseFloat(version) > 3 && 'WebKit' ||
          /\bOpera\b/.test(name) && (/\bOPR\b/.test(ua) ? 'Blink' : 'Presto') ||
          /\b(?:Midori|Nook|Safari)\b/i.test(ua) && !/^(?:Trident|EdgeHTML)$/.test(layout) && 'WebKit' ||
          !layout && /\bMSIE\b/i.test(ua) && (os == 'Mac OS' ? 'Tasman' : 'Trident') ||
          layout == 'WebKit' && /\bPlayStation\b(?! Vita\b)/i.test(name) && 'NetFront'
        )) {
      layout = [data];
    }
    // Detect Windows Phone 7 desktop mode.
    if (name == 'IE' && (data = (/; *(?:XBLWP|ZuneWP)(\d+)/i.exec(ua) || 0)[1])) {
      name += ' Mobile';
      os = 'Windows Phone ' + (/\+$/.test(data) ? data : data + '.x');
      description.unshift('desktop mode');
    }
    // Detect Windows Phone 8.x desktop mode.
    else if (/\bWPDesktop\b/i.test(ua)) {
      name = 'IE Mobile';
      os = 'Windows Phone 8.x';
      description.unshift('desktop mode');
      version || (version = (/\brv:([\d.]+)/.exec(ua) || 0)[1]);
    }
    // Detect IE 11.
    else if (name != 'IE' && layout == 'Trident' && (data = /\brv:([\d.]+)/.exec(ua))) {
      if (name) {
        description.push('identifying as ' + name + (version ? ' ' + version : ''));
      }
      name = 'IE';
      version = data[1];
    }
    // Leverage environment features.
    if (useFeatures) {
      // Detect server-side environments.
      // Rhino has a global function while others have a global object.
      if (isHostType(context, 'global')) {
        if (java) {
          data = java.lang.System;
          arch = data.getProperty('os.arch');
          os = os || data.getProperty('os.name') + ' ' + data.getProperty('os.version');
        }
        if (isModuleScope && isHostType(context, 'system') && (data = [context.system])[0]) {
          os || (os = data[0].os || null);
          try {
            data[1] = context.require('ringo/engine').version;
            version = data[1].join('.');
            name = 'RingoJS';
          } catch(e) {
            if (data[0].global.system == context.system) {
              name = 'Narwhal';
            }
          }
        }
        else if (
          typeof context.process == 'object' && !context.process.browser &&
          (data = context.process)
        ) {
          name = 'Node.js';
          arch = data.arch;
          os = data.platform;
          version = /[\d.]+/.exec(data.version)[0];
        }
        else if (rhino) {
          name = 'Rhino';
        }
      }
      // Detect Adobe AIR.
      else if (getClassOf((data = context.runtime)) == airRuntimeClass) {
        name = 'Adobe AIR';
        os = data.flash.system.Capabilities.os;
      }
      // Detect PhantomJS.
      else if (getClassOf((data = context.phantom)) == phantomClass) {
        name = 'PhantomJS';
        version = (data = data.version || null) && (data.major + '.' + data.minor + '.' + data.patch);
      }
      // Detect IE compatibility modes.
      else if (typeof doc.documentMode == 'number' && (data = /\bTrident\/(\d+)/i.exec(ua))) {
        // We're in compatibility mode when the Trident version + 4 doesn't
        // equal the document mode.
        version = [version, doc.documentMode];
        if ((data = +data[1] + 4) != version[1]) {
          description.push('IE ' + version[1] + ' mode');
          layout && (layout[1] = '');
          version[1] = data;
        }
        version = name == 'IE' ? String(version[1].toFixed(1)) : version[0];
      }
      os = os && format(os);
    }
    // Detect prerelease phases.
    if (version && (data =
          /(?:[ab]|dp|pre|[ab]\d+pre)(?:\d+\+?)?$/i.exec(version) ||
          /(?:alpha|beta)(?: ?\d)?/i.exec(ua + ';' + (useFeatures && nav.appMinorVersion)) ||
          /\bMinefield\b/i.test(ua) && 'a'
        )) {
      prerelease = /b/i.test(data) ? 'beta' : 'alpha';
      version = version.replace(RegExp(data + '\\+?$'), '') +
        (prerelease == 'beta' ? beta : alpha) + (/\d+\+?/.exec(data) || '');
    }
    // Detect Firefox Mobile.
    if (name == 'Fennec' || name == 'Firefox' && /\b(?:Android|Firefox OS)\b/.test(os)) {
      name = 'Firefox Mobile';
    }
    // Obscure Maxthon's unreliable version.
    else if (name == 'Maxthon' && version) {
      version = version.replace(/\.[\d.]+/, '.x');
    }
    // Detect Xbox 360 and Xbox One.
    else if (/\bXbox\b/i.test(product)) {
      os = null;
      if (product == 'Xbox 360' && /\bIEMobile\b/.test(ua)) {
        description.unshift('mobile mode');
      }
    }
    // Add mobile postfix.
    else if ((/^(?:Chrome|IE|Opera)$/.test(name) || name && !product && !/Browser|Mobi/.test(name)) &&
        (os == 'Windows CE' || /Mobi/i.test(ua))) {
      name += ' Mobile';
    }
    // Detect IE platform preview.
    else if (name == 'IE' && useFeatures && context.external === null) {
      description.unshift('platform preview');
    }
    // Detect BlackBerry OS version.
    // http://docs.blackberry.com/en/developers/deliverables/18169/HTTP_headers_sent_by_BB_Browser_1234911_11.jsp
    else if ((/\bBlackBerry\b/.test(product) || /\bBB10\b/.test(ua)) && (data =
          (RegExp(product.replace(/ +/g, ' *') + '/([.\\d]+)', 'i').exec(ua) || 0)[1] ||
          version
        )) {
      data = [data, /BB10/.test(ua)];
      os = (data[1] ? (product = null, manufacturer = 'BlackBerry') : 'Device Software') + ' ' + data[0];
      version = null;
    }
    // Detect Opera identifying/masking itself as another browser.
    // http://www.opera.com/support/kb/view/843/
    else if (this != forOwn && product != 'Wii' && (
          (useFeatures && opera) ||
          (/Opera/.test(name) && /\b(?:MSIE|Firefox)\b/i.test(ua)) ||
          (name == 'Firefox' && /\bOS X (?:\d+\.){2,}/.test(os)) ||
          (name == 'IE' && (
            (os && !/^Win/.test(os) && version > 5.5) ||
            /\bWindows XP\b/.test(os) && version > 8 ||
            version == 8 && !/\bTrident\b/.test(ua)
          ))
        ) && !reOpera.test((data = parse.call(forOwn, ua.replace(reOpera, '') + ';'))) && data.name) {
      // When "identifying", the UA contains both Opera and the other browser's name.
      data = 'ing as ' + data.name + ((data = data.version) ? ' ' + data : '');
      if (reOpera.test(name)) {
        if (/\bIE\b/.test(data) && os == 'Mac OS') {
          os = null;
        }
        data = 'identify' + data;
      }
      // When "masking", the UA contains only the other browser's name.
      else {
        data = 'mask' + data;
        if (operaClass) {
          name = format(operaClass.replace(/([a-z])([A-Z])/g, '$1 $2'));
        } else {
          name = 'Opera';
        }
        if (/\bIE\b/.test(data)) {
          os = null;
        }
        if (!useFeatures) {
          version = null;
        }
      }
      layout = ['Presto'];
      description.push(data);
    }
    // Detect WebKit Nightly and approximate Chrome/Safari versions.
    if ((data = (/\bAppleWebKit\/([\d.]+\+?)/i.exec(ua) || 0)[1])) {
      // Correct build number for numeric comparison.
      // (e.g. "532.5" becomes "532.05")
      data = [parseFloat(data.replace(/\.(\d)$/, '.0$1')), data];
      // Nightly builds are postfixed with a "+".
      if (name == 'Safari' && data[1].slice(-1) == '+') {
        name = 'WebKit Nightly';
        prerelease = 'alpha';
        version = data[1].slice(0, -1);
      }
      // Clear incorrect browser versions.
      else if (version == data[1] ||
          version == (data[2] = (/\bSafari\/([\d.]+\+?)/i.exec(ua) || 0)[1])) {
        version = null;
      }
      // Use the full Chrome version when available.
      data[1] = (/\bChrome\/([\d.]+)/i.exec(ua) || 0)[1];
      // Detect Blink layout engine.
      if (data[0] == 537.36 && data[2] == 537.36 && parseFloat(data[1]) >= 28 && layout == 'WebKit') {
        layout = ['Blink'];
      }
      // Detect JavaScriptCore.
      // http://stackoverflow.com/questions/6768474/how-can-i-detect-which-javascript-engine-v8-or-jsc-is-used-at-runtime-in-androi
      if (!useFeatures || (!likeChrome && !data[1])) {
        layout && (layout[1] = 'like Safari');
        data = (data = data[0], data < 400 ? 1 : data < 500 ? 2 : data < 526 ? 3 : data < 533 ? 4 : data < 534 ? '4+' : data < 535 ? 5 : data < 537 ? 6 : data < 538 ? 7 : data < 601 ? 8 : '8');
      } else {
        layout && (layout[1] = 'like Chrome');
        data = data[1] || (data = data[0], data < 530 ? 1 : data < 532 ? 2 : data < 532.05 ? 3 : data < 533 ? 4 : data < 534.03 ? 5 : data < 534.07 ? 6 : data < 534.10 ? 7 : data < 534.13 ? 8 : data < 534.16 ? 9 : data < 534.24 ? 10 : data < 534.30 ? 11 : data < 535.01 ? 12 : data < 535.02 ? '13+' : data < 535.07 ? 15 : data < 535.11 ? 16 : data < 535.19 ? 17 : data < 536.05 ? 18 : data < 536.10 ? 19 : data < 537.01 ? 20 : data < 537.11 ? '21+' : data < 537.13 ? 23 : data < 537.18 ? 24 : data < 537.24 ? 25 : data < 537.36 ? 26 : layout != 'Blink' ? '27' : '28');
      }
      // Add the postfix of ".x" or "+" for approximate versions.
      layout && (layout[1] += ' ' + (data += typeof data == 'number' ? '.x' : /[.+]/.test(data) ? '' : '+'));
      // Obscure version for some Safari 1-2 releases.
      if (name == 'Safari' && (!version || parseInt(version) > 45)) {
        version = data;
      }
    }
    // Detect Opera desktop modes.
    if (name == 'Opera' &&  (data = /\bzbov|zvav$/.exec(os))) {
      name += ' ';
      description.unshift('desktop mode');
      if (data == 'zvav') {
        name += 'Mini';
        version = null;
      } else {
        name += 'Mobile';
      }
      os = os.replace(RegExp(' *' + data + '$'), '');
    }
    // Detect Chrome desktop mode.
    else if (name == 'Safari' && /\bChrome\b/.exec(layout && layout[1])) {
      description.unshift('desktop mode');
      name = 'Chrome Mobile';
      version = null;

      if (/\bOS X\b/.test(os)) {
        manufacturer = 'Apple';
        os = 'iOS 4.3+';
      } else {
        os = null;
      }
    }
    // Strip incorrect OS versions.
    if (version && version.indexOf((data = /[\d.]+$/.exec(os))) == 0 &&
        ua.indexOf('/' + data + '-') > -1) {
      os = trim(os.replace(data, ''));
    }
    // Add layout engine.
    if (layout && !/\b(?:Avant|Nook)\b/.test(name) && (
        /Browser|Lunascape|Maxthon/.test(name) ||
        name != 'Safari' && /^iOS/.test(os) && /\bSafari\b/.test(layout[1]) ||
        /^(?:Adobe|Arora|Breach|Midori|Opera|Phantom|Rekonq|Rock|Sleipnir|Web)/.test(name) && layout[1])) {
      // Don't add layout details to description if they are falsey.
      (data = layout[layout.length - 1]) && description.push(data);
    }
    // Combine contextual information.
    if (description.length) {
      description = ['(' + description.join('; ') + ')'];
    }
    // Append manufacturer to description.
    if (manufacturer && product && product.indexOf(manufacturer) < 0) {
      description.push('on ' + manufacturer);
    }
    // Append product to description.
    if (product) {
      description.push((/^on /.test(description[description.length - 1]) ? '' : 'on ') + product);
    }
    // Parse the OS into an object.
    if (os) {
      data = / ([\d.+]+)$/.exec(os);
      isSpecialCasedOS = data && os.charAt(os.length - data[0].length - 1) == '/';
      os = {
        'architecture': 32,
        'family': (data && !isSpecialCasedOS) ? os.replace(data[0], '') : os,
        'version': data ? data[1] : null,
        'toString': function() {
          var version = this.version;
          return this.family + ((version && !isSpecialCasedOS) ? ' ' + version : '') + (this.architecture == 64 ? ' 64-bit' : '');
        }
      };
    }
    // Add browser/OS architecture.
    if ((data = /\b(?:AMD|IA|Win|WOW|x86_|x)64\b/i.exec(arch)) && !/\bi686\b/i.test(arch)) {
      if (os) {
        os.architecture = 64;
        os.family = os.family.replace(RegExp(' *' + data), '');
      }
      if (
          name && (/\bWOW64\b/i.test(ua) ||
          (useFeatures && /\w(?:86|32)$/.test(nav.cpuClass || nav.platform) && !/\bWin64; x64\b/i.test(ua)))
      ) {
        description.unshift('32-bit');
      }
    }
    // Chrome 39 and above on OS X is always 64-bit.
    else if (
        os && /^OS X/.test(os.family) &&
        name == 'Chrome' && parseFloat(version) >= 39
    ) {
      os.architecture = 64;
    }

    ua || (ua = null);

    /*------------------------------------------------------------------------*/

    /**
     * The platform object.
     *
     * @name platform
     * @type Object
     */
    var platform = {};

    /**
     * The platform description.
     *
     * @memberOf platform
     * @type string|null
     */
    platform.description = ua;

    /**
     * The name of the browser's layout engine.
     *
     * @memberOf platform
     * @type string|null
     */
    platform.layout = layout && layout[0];

    /**
     * The name of the product's manufacturer.
     *
     * @memberOf platform
     * @type string|null
     */
    platform.manufacturer = manufacturer;

    /**
     * The name of the browser/environment.
     *
     * @memberOf platform
     * @type string|null
     */
    platform.name = name;

    /**
     * The alpha/beta release indicator.
     *
     * @memberOf platform
     * @type string|null
     */
    platform.prerelease = prerelease;

    /**
     * The name of the product hosting the browser.
     *
     * @memberOf platform
     * @type string|null
     */
    platform.product = product;

    /**
     * The browser's user agent string.
     *
     * @memberOf platform
     * @type string|null
     */
    platform.ua = ua;

    /**
     * The browser/environment version.
     *
     * @memberOf platform
     * @type string|null
     */
    platform.version = name && version;

    /**
     * The name of the operating system.
     *
     * @memberOf platform
     * @type Object
     */
    platform.os = os || {

      /**
       * The CPU architecture the OS is built for.
       *
       * @memberOf platform.os
       * @type number|null
       */
      'architecture': null,

      /**
       * The family of the OS.
       *
       * Common values include:
       * "Windows", "Windows Server 2008 R2 / 7", "Windows Server 2008 / Vista",
       * "Windows XP", "OS X", "Ubuntu", "Debian", "Fedora", "Red Hat", "SuSE",
       * "Android", "iOS" and "Windows Phone"
       *
       * @memberOf platform.os
       * @type string|null
       */
      'family': null,

      /**
       * The version of the OS.
       *
       * @memberOf platform.os
       * @type string|null
       */
      'version': null,

      /**
       * Returns the OS string.
       *
       * @memberOf platform.os
       * @returns {string} The OS string.
       */
      'toString': function() { return 'null'; }
    };

    platform.parse = parse;
    platform.toString = toStringPlatform;

    if (platform.version) {
      description.unshift(version);
    }
    if (platform.name) {
      description.unshift(name);
    }
    if (os && name && !(os == String(os).split(' ')[0] && (os == name.split(' ')[0] || product))) {
      description.push(product ? '(' + os + ')' : 'on ' + os);
    }
    if (description.length) {
      platform.description = description.join(' ');
    }
    return platform;
  }

  /*--------------------------------------------------------------------------*/

  // Export platform.
  var platform = parse();

  // Some AMD build optimizers, like r.js, check for condition patterns like the following:
  if (true) {
    // Expose platform on the global object to prevent errors when platform is
    // loaded by a script tag in the presence of an AMD loader.
    // See http://requirejs.org/docs/errors.html#mismatch for more details.
    root.platform = platform;

    // Define as an anonymous module so platform can be aliased through path mapping.
    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
      return platform;
    }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  }
  // Check for `exports` after `define` in case a build optimizer adds an `exports` object.
  else {}
}.call(this));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module), __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./node_modules/querystring-es3/decode.js":
/*!************************************************!*\
  !*** ./node_modules/querystring-es3/decode.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};


/***/ }),

/***/ "./node_modules/querystring-es3/encode.js":
/*!************************************************!*\
  !*** ./node_modules/querystring-es3/encode.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};


/***/ }),

/***/ "./node_modules/querystring-es3/index.js":
/*!***********************************************!*\
  !*** ./node_modules/querystring-es3/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.decode = exports.parse = __webpack_require__(/*! ./decode */ "./node_modules/querystring-es3/decode.js");
exports.encode = exports.stringify = __webpack_require__(/*! ./encode */ "./node_modules/querystring-es3/encode.js");


/***/ }),

/***/ "./node_modules/react-dom/index.js":
/*!***********************************************************************************************!*\
  !*** delegated ./node_modules/react-dom/index.js from dll-reference dll_a0ea8196e869b9b4425e ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(/*! dll-reference dll_a0ea8196e869b9b4425e */ "dll-reference dll_a0ea8196e869b9b4425e"))("./node_modules/react-dom/index.js");

/***/ }),

/***/ "./node_modules/react-is/cjs/react-is.development.js":
/*!***********************************************************!*\
  !*** ./node_modules/react-is/cjs/react-is.development.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */





if (true) {
  (function() {
'use strict';

// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var hasSymbol = typeof Symbol === 'function' && Symbol.for;
var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary
// (unstable) APIs that have been removed. Can we remove the symbols?

var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;
var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;
var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;
var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 0xead9;
var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;
var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;
var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;

function isValidElementType(type) {
  return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
  type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
}

function typeOf(object) {
  if (typeof object === 'object' && object !== null) {
    var $$typeof = object.$$typeof;

    switch ($$typeof) {
      case REACT_ELEMENT_TYPE:
        var type = object.type;

        switch (type) {
          case REACT_ASYNC_MODE_TYPE:
          case REACT_CONCURRENT_MODE_TYPE:
          case REACT_FRAGMENT_TYPE:
          case REACT_PROFILER_TYPE:
          case REACT_STRICT_MODE_TYPE:
          case REACT_SUSPENSE_TYPE:
            return type;

          default:
            var $$typeofType = type && type.$$typeof;

            switch ($$typeofType) {
              case REACT_CONTEXT_TYPE:
              case REACT_FORWARD_REF_TYPE:
              case REACT_LAZY_TYPE:
              case REACT_MEMO_TYPE:
              case REACT_PROVIDER_TYPE:
                return $$typeofType;

              default:
                return $$typeof;
            }

        }

      case REACT_PORTAL_TYPE:
        return $$typeof;
    }
  }

  return undefined;
} // AsyncMode is deprecated along with isAsyncMode

var AsyncMode = REACT_ASYNC_MODE_TYPE;
var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
var ContextConsumer = REACT_CONTEXT_TYPE;
var ContextProvider = REACT_PROVIDER_TYPE;
var Element = REACT_ELEMENT_TYPE;
var ForwardRef = REACT_FORWARD_REF_TYPE;
var Fragment = REACT_FRAGMENT_TYPE;
var Lazy = REACT_LAZY_TYPE;
var Memo = REACT_MEMO_TYPE;
var Portal = REACT_PORTAL_TYPE;
var Profiler = REACT_PROFILER_TYPE;
var StrictMode = REACT_STRICT_MODE_TYPE;
var Suspense = REACT_SUSPENSE_TYPE;
var hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated

function isAsyncMode(object) {
  {
    if (!hasWarnedAboutDeprecatedIsAsyncMode) {
      hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint

      console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');
    }
  }

  return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
}
function isConcurrentMode(object) {
  return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
}
function isContextConsumer(object) {
  return typeOf(object) === REACT_CONTEXT_TYPE;
}
function isContextProvider(object) {
  return typeOf(object) === REACT_PROVIDER_TYPE;
}
function isElement(object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
}
function isForwardRef(object) {
  return typeOf(object) === REACT_FORWARD_REF_TYPE;
}
function isFragment(object) {
  return typeOf(object) === REACT_FRAGMENT_TYPE;
}
function isLazy(object) {
  return typeOf(object) === REACT_LAZY_TYPE;
}
function isMemo(object) {
  return typeOf(object) === REACT_MEMO_TYPE;
}
function isPortal(object) {
  return typeOf(object) === REACT_PORTAL_TYPE;
}
function isProfiler(object) {
  return typeOf(object) === REACT_PROFILER_TYPE;
}
function isStrictMode(object) {
  return typeOf(object) === REACT_STRICT_MODE_TYPE;
}
function isSuspense(object) {
  return typeOf(object) === REACT_SUSPENSE_TYPE;
}

exports.AsyncMode = AsyncMode;
exports.ConcurrentMode = ConcurrentMode;
exports.ContextConsumer = ContextConsumer;
exports.ContextProvider = ContextProvider;
exports.Element = Element;
exports.ForwardRef = ForwardRef;
exports.Fragment = Fragment;
exports.Lazy = Lazy;
exports.Memo = Memo;
exports.Portal = Portal;
exports.Profiler = Profiler;
exports.StrictMode = StrictMode;
exports.Suspense = Suspense;
exports.isAsyncMode = isAsyncMode;
exports.isConcurrentMode = isConcurrentMode;
exports.isContextConsumer = isContextConsumer;
exports.isContextProvider = isContextProvider;
exports.isElement = isElement;
exports.isForwardRef = isForwardRef;
exports.isFragment = isFragment;
exports.isLazy = isLazy;
exports.isMemo = isMemo;
exports.isPortal = isPortal;
exports.isProfiler = isProfiler;
exports.isStrictMode = isStrictMode;
exports.isSuspense = isSuspense;
exports.isValidElementType = isValidElementType;
exports.typeOf = typeOf;
  })();
}


/***/ }),

/***/ "./node_modules/react-is/index.js":
/*!****************************************!*\
  !*** ./node_modules/react-is/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react-is.development.js */ "./node_modules/react-is/cjs/react-is.development.js");
}


/***/ }),

/***/ "./node_modules/react/index.js":
/*!*******************************************************************************************!*\
  !*** delegated ./node_modules/react/index.js from dll-reference dll_a0ea8196e869b9b4425e ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(/*! dll-reference dll_a0ea8196e869b9b4425e */ "dll-reference dll_a0ea8196e869b9b4425e"))("./node_modules/react/index.js");

/***/ }),

/***/ "./node_modules/regenerator-runtime/runtime.js":
/*!*****************************************************!*\
  !*** ./node_modules/regenerator-runtime/runtime.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var runtime = (function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return PromiseImpl.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return PromiseImpl.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    if (PromiseImpl === void 0) PromiseImpl = Promise;

    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList),
      PromiseImpl
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
   true ? module.exports : undefined
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  Function("r", "regeneratorRuntime = r")(runtime);
}


/***/ }),

/***/ "./node_modules/stacktrace-parser/dist/stack-trace-parser.esm.js":
/*!***********************************************************************!*\
  !*** ./node_modules/stacktrace-parser/dist/stack-trace-parser.esm.js ***!
  \***********************************************************************/
/*! exports provided: parse */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parse", function() { return parse; });
var UNKNOWN_FUNCTION = '<unknown>';
/**
 * This parses the different stack traces and puts them into one format
 * This borrows heavily from TraceKit (https://github.com/csnover/TraceKit)
 */

function parse(stackString) {
  var lines = stackString.split('\n');
  return lines.reduce(function (stack, line) {
    var parseResult = parseChrome(line) || parseWinjs(line) || parseGecko(line) || parseNode(line) || parseJSC(line);

    if (parseResult) {
      stack.push(parseResult);
    }

    return stack;
  }, []);
}
var chromeRe = /^\s*at (.*?) ?\(((?:file|https?|blob|chrome-extension|native|eval|webpack|<anonymous>|\/|[a-z]:\\|\\\\).*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i;
var chromeEvalRe = /\((\S*)(?::(\d+))(?::(\d+))\)/;

function parseChrome(line) {
  var parts = chromeRe.exec(line);

  if (!parts) {
    return null;
  }

  var isNative = parts[2] && parts[2].indexOf('native') === 0; // start of line

  var isEval = parts[2] && parts[2].indexOf('eval') === 0; // start of line

  var submatch = chromeEvalRe.exec(parts[2]);

  if (isEval && submatch != null) {
    // throw out eval line/column and use top-most line/column number
    parts[2] = submatch[1]; // url

    parts[3] = submatch[2]; // line

    parts[4] = submatch[3]; // column
  }

  return {
    file: !isNative ? parts[2] : null,
    methodName: parts[1] || UNKNOWN_FUNCTION,
    arguments: isNative ? [parts[2]] : [],
    lineNumber: parts[3] ? +parts[3] : null,
    column: parts[4] ? +parts[4] : null
  };
}

var winjsRe = /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:file|ms-appx|https?|webpack|blob):.*?):(\d+)(?::(\d+))?\)?\s*$/i;

function parseWinjs(line) {
  var parts = winjsRe.exec(line);

  if (!parts) {
    return null;
  }

  return {
    file: parts[2],
    methodName: parts[1] || UNKNOWN_FUNCTION,
    arguments: [],
    lineNumber: +parts[3],
    column: parts[4] ? +parts[4] : null
  };
}

var geckoRe = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)((?:file|https?|blob|chrome|webpack|resource|\[native).*?|[^@]*bundle)(?::(\d+))?(?::(\d+))?\s*$/i;
var geckoEvalRe = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i;

function parseGecko(line) {
  var parts = geckoRe.exec(line);

  if (!parts) {
    return null;
  }

  var isEval = parts[3] && parts[3].indexOf(' > eval') > -1;
  var submatch = geckoEvalRe.exec(parts[3]);

  if (isEval && submatch != null) {
    // throw out eval line/column and use top-most line number
    parts[3] = submatch[1];
    parts[4] = submatch[2];
    parts[5] = null; // no column when eval
  }

  return {
    file: parts[3],
    methodName: parts[1] || UNKNOWN_FUNCTION,
    arguments: parts[2] ? parts[2].split(',') : [],
    lineNumber: parts[4] ? +parts[4] : null,
    column: parts[5] ? +parts[5] : null
  };
}

var javaScriptCoreRe = /^\s*(?:([^@]*)(?:\((.*?)\))?@)?(\S.*?):(\d+)(?::(\d+))?\s*$/i;

function parseJSC(line) {
  var parts = javaScriptCoreRe.exec(line);

  if (!parts) {
    return null;
  }

  return {
    file: parts[3],
    methodName: parts[1] || UNKNOWN_FUNCTION,
    arguments: [],
    lineNumber: +parts[4],
    column: parts[5] ? +parts[5] : null
  };
}

var nodeRe = /^\s*at (?:((?:\[object object\])?[^\\/]+(?: \[as \S+\])?) )?\(?(.*?):(\d+)(?::(\d+))?\)?\s*$/i;

function parseNode(line) {
  var parts = nodeRe.exec(line);

  if (!parts) {
    return null;
  }

  return {
    file: parts[2],
    methodName: parts[1] || UNKNOWN_FUNCTION,
    arguments: [],
    lineNumber: +parts[3],
    column: parts[4] ? +parts[4] : null
  };
}




/***/ }),

/***/ "./node_modules/strip-ansi/index.js":
/*!******************************************!*\
  !*** ./node_modules/strip-ansi/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var ansiRegex = __webpack_require__(/*! ansi-regex */ "./node_modules/ansi-regex/index.js");

module.exports = function (string) {
  return typeof string === 'string' ? string.replace(ansiRegex(), '') : string;
};

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/web-vitals/dist/web-vitals.es5.min.js":
/*!************************************************************!*\
  !*** ./node_modules/web-vitals/dist/web-vitals.es5.min.js ***!
  \************************************************************/
/*! exports provided: getCLS, getFCP, getFID, getLCP, getTTFB */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCLS", function() { return p; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getFCP", function() { return m; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getFID", function() { return v; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getLCP", function() { return g; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTTFB", function() { return h; });
var t,n,e=function(){return"".concat(Date.now(),"-").concat(Math.floor(8999999999999*Math.random())+1e12)},i=function(t){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;return{name:t,value:n,delta:0,entries:[],id:e(),isFinal:!1}},a=function(t,n){try{if(PerformanceObserver.supportedEntryTypes.includes(t)){var e=new PerformanceObserver((function(t){return t.getEntries().map(n)}));return e.observe({type:t,buffered:!0}),e}}catch(t){}},r=!1,o=!1,s=function(t){r=!t.persisted},u=function(){addEventListener("pagehide",s),addEventListener("unload",(function(){}))},c=function(t){var n=arguments.length>1&&void 0!==arguments[1]&&arguments[1];o||(u(),o=!0),addEventListener("visibilitychange",(function(n){var e=n.timeStamp;"hidden"===document.visibilityState&&t({timeStamp:e,isUnloading:r})}),{capture:!0,once:n})},l=function(t,n,e,i){var a;return function(){e&&n.isFinal&&e.disconnect(),n.value>=0&&(i||n.isFinal||"hidden"===document.visibilityState)&&(n.delta=n.value-(a||0),(n.delta||n.isFinal||void 0===a)&&(t(n),a=n.value))}},p=function(t){var n=arguments.length>1&&void 0!==arguments[1]&&arguments[1],e=i("CLS",0),r=function(t){t.hadRecentInput||(e.value+=t.value,e.entries.push(t),s())},o=a("layout-shift",r),s=l(t,e,o,n);c((function(t){var n=t.isUnloading;o&&o.takeRecords().map(r),n&&(e.isFinal=!0),s()}))},d=function(){return void 0===t&&(t="hidden"===document.visibilityState?0:1/0,c((function(n){var e=n.timeStamp;return t=e}),!0)),{get timeStamp(){return t}}},m=function(t){var n=i("FCP"),e=d(),r=a("paint",(function(t){"first-contentful-paint"===t.name&&t.startTime<e.timeStamp&&(n.value=t.startTime,n.isFinal=!0,n.entries.push(t),o())})),o=l(t,n,r)},v=function(t){var n=i("FID"),e=d(),r=function(t){t.startTime<e.timeStamp&&(n.value=t.processingStart-t.startTime,n.entries.push(t),n.isFinal=!0,s())},o=a("first-input",r),s=l(t,n,o);c((function(){o&&(o.takeRecords().map(r),o.disconnect())}),!0),o||window.perfMetrics&&window.perfMetrics.onFirstInputDelay&&window.perfMetrics.onFirstInputDelay((function(t,i){i.timeStamp<e.timeStamp&&(n.value=t,n.isFinal=!0,n.entries=[{entryType:"first-input",name:i.type,target:i.target,cancelable:i.cancelable,startTime:i.timeStamp,processingStart:i.timeStamp+t}],s())}))},f=function(){return n||(n=new Promise((function(t){return["scroll","keydown","pointerdown"].map((function(n){addEventListener(n,t,{once:!0,passive:!0,capture:!0})}))}))),n},g=function(t){var n=arguments.length>1&&void 0!==arguments[1]&&arguments[1],e=i("LCP"),r=d(),o=function(t){var n=t.startTime;n<r.timeStamp?(e.value=n,e.entries.push(t)):e.isFinal=!0,u()},s=a("largest-contentful-paint",o),u=l(t,e,s,n),p=function(){e.isFinal||(s&&s.takeRecords().map(o),e.isFinal=!0,u())};f().then(p),c(p,!0)},h=function(t){var n,e=i("TTFB");n=function(){try{var n=performance.getEntriesByType("navigation")[0]||function(){var t=performance.timing,n={entryType:"navigation",startTime:0};for(var e in t)"navigationStart"!==e&&"toJSON"!==e&&(n[e]=Math.max(t[e]-t.navigationStart,0));return n}();e.value=e.delta=n.responseStart,e.entries=[n],e.isFinal=!0,t(e)}catch(t){}},"complete"===document.readyState?setTimeout(n,0):addEventListener("pageshow",n)};


/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "dll-reference dll_a0ea8196e869b9b4425e":
/*!*******************************************!*\
  !*** external "dll_a0ea8196e869b9b4425e" ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = dll_a0ea8196e869b9b4425e;

/***/ })

},[["./node_modules/next/dist/client/next-dev.js","static/runtime/webpack.js"]]]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hcnJheUxpa2VUb0FycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2FycmF5V2l0aEhvbGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2FycmF5V2l0aG91dEhvbGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2Fzc2VydFRoaXNJbml0aWFsaXplZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2NvbnN0cnVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9leHRlbmRzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2dldFByb3RvdHlwZU9mLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2luaGVyaXRzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pdGVyYWJsZVRvQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaXRlcmFibGVUb0FycmF5TGltaXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvbm9uSXRlcmFibGVSZXN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL25vbkl0ZXJhYmxlU3ByZWFkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvc2V0UHJvdG90eXBlT2YuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvc2xpY2VkVG9BcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90b0NvbnN1bWFibGVBcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2YuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9saWIvY2xpZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9saWIvaW50ZXJuYWwvRXJyb3JCb3VuZGFyeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvbGliL2ludGVybmFsL1JlYWN0RGV2T3ZlcmxheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvbGliL2ludGVybmFsL2J1cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvbGliL2ludGVybmFsL2NvbXBvbmVudHMvQ29kZUZyYW1lL0NvZGVGcmFtZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvbGliL2ludGVybmFsL2NvbXBvbmVudHMvQ29kZUZyYW1lL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9saWIvaW50ZXJuYWwvY29tcG9uZW50cy9Db2RlRnJhbWUvc3R5bGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9saWIvaW50ZXJuYWwvY29tcG9uZW50cy9EaWFsb2cvRGlhbG9nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9saWIvaW50ZXJuYWwvY29tcG9uZW50cy9EaWFsb2cvRGlhbG9nQm9keS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvbGliL2ludGVybmFsL2NvbXBvbmVudHMvRGlhbG9nL0RpYWxvZ0NvbnRlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BuZXh0L3JlYWN0LWRldi1vdmVybGF5L2xpYi9pbnRlcm5hbC9jb21wb25lbnRzL0RpYWxvZy9EaWFsb2dIZWFkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BuZXh0L3JlYWN0LWRldi1vdmVybGF5L2xpYi9pbnRlcm5hbC9jb21wb25lbnRzL0RpYWxvZy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvbGliL2ludGVybmFsL2NvbXBvbmVudHMvRGlhbG9nL3N0eWxlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvbGliL2ludGVybmFsL2NvbXBvbmVudHMvTGVmdFJpZ2h0RGlhbG9nSGVhZGVyL0xlZnRSaWdodERpYWxvZ0hlYWRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvbGliL2ludGVybmFsL2NvbXBvbmVudHMvTGVmdFJpZ2h0RGlhbG9nSGVhZGVyL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9saWIvaW50ZXJuYWwvY29tcG9uZW50cy9MZWZ0UmlnaHREaWFsb2dIZWFkZXIvc3R5bGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9saWIvaW50ZXJuYWwvY29tcG9uZW50cy9PdmVybGF5L092ZXJsYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BuZXh0L3JlYWN0LWRldi1vdmVybGF5L2xpYi9pbnRlcm5hbC9jb21wb25lbnRzL092ZXJsYXkvYm9keS1sb2NrZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BuZXh0L3JlYWN0LWRldi1vdmVybGF5L2xpYi9pbnRlcm5hbC9jb21wb25lbnRzL092ZXJsYXkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BuZXh0L3JlYWN0LWRldi1vdmVybGF5L2xpYi9pbnRlcm5hbC9jb21wb25lbnRzL092ZXJsYXkvc3R5bGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9saWIvaW50ZXJuYWwvY29tcG9uZW50cy9TaGFkb3dQb3J0YWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BuZXh0L3JlYWN0LWRldi1vdmVybGF5L2xpYi9pbnRlcm5hbC9jb21wb25lbnRzL1Rlcm1pbmFsL1Rlcm1pbmFsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9saWIvaW50ZXJuYWwvY29tcG9uZW50cy9UZXJtaW5hbC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvbGliL2ludGVybmFsL2NvbXBvbmVudHMvVGVybWluYWwvc3R5bGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9saWIvaW50ZXJuYWwvY29tcG9uZW50cy9Ub2FzdC9Ub2FzdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvbGliL2ludGVybmFsL2NvbXBvbmVudHMvVG9hc3QvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BuZXh0L3JlYWN0LWRldi1vdmVybGF5L2xpYi9pbnRlcm5hbC9jb21wb25lbnRzL1RvYXN0L3N0eWxlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvbGliL2ludGVybmFsL2NvbnRhaW5lci9CdWlsZEVycm9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9saWIvaW50ZXJuYWwvY29udGFpbmVyL0Vycm9ycy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvbGliL2ludGVybmFsL2NvbnRhaW5lci9SdW50aW1lRXJyb3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BuZXh0L3JlYWN0LWRldi1vdmVybGF5L2xpYi9pbnRlcm5hbC9oZWxwZXJzL25vZGVTdGFja0ZyYW1lcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvbGliL2ludGVybmFsL2hlbHBlcnMvbm9vcC10ZW1wbGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvbGliL2ludGVybmFsL2hlbHBlcnMvcGFyc2VTdGFjay5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvbGliL2ludGVybmFsL2hlbHBlcnMvc3RhY2stZnJhbWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BuZXh0L3JlYWN0LWRldi1vdmVybGF5L2xpYi9pbnRlcm5hbC9ob29rcy91c2Utb24tY2xpY2stb3V0c2lkZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvbGliL2ludGVybmFsL3N0eWxlcy9CYXNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9saWIvaW50ZXJuYWwvc3R5bGVzL0NvbXBvbmVudFN0eWxlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvbGliL2ludGVybmFsL3N0eWxlcy9Dc3NSZXNldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9lbGVtZW50L2Rpc2FibGVkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL2VsZW1lbnQvZm9jdXMuc3ZnLWZvcmVpZ24tb2JqZWN0LWhhY2suanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvZ2V0L3BhcmVudHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvZ2V0L3NoYWRvdy1ob3N0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL2lzL2FjdGl2ZS1lbGVtZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL2lzL2Rpc2FibGVkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL2lzL2ZvY3VzLXJlbGV2YW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL2lzL2ZvY3VzYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9pcy9pcy51dGlsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL2lzL25hdGl2ZS1kaXNhYmxlZC1zdXBwb3J0ZWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvaXMvb25seS10YWJiYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9pcy90YWJiYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9pcy92YWxpZC1hcmVhLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL2lzL3ZhbGlkLXRhYmluZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL2lzL3Zpc2libGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvbWFpbnRhaW4vZGlzYWJsZWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvbWFpbnRhaW4vdGFiLWZvY3VzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL21hcC9rZXljb2RlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL29ic2VydmUvc2hhZG93LW11dGF0aW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9xdWVyeS9mb2N1c2FibGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvcXVlcnkvZm9jdXNhYmxlLnF1aWNrLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3F1ZXJ5L2ZvY3VzYWJsZS5zdHJpY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvcXVlcnkvc2hhZG93LWhvc3RzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3F1ZXJ5L3RhYmJhYmxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3F1ZXJ5L3RhYnNlcXVlbmNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3F1ZXJ5L3RhYnNlcXVlbmNlLnNvcnQtYXJlYS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9xdWVyeS90YWJzZXF1ZW5jZS5zb3J0LXNoYWRvd2VkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3F1ZXJ5L3RhYnNlcXVlbmNlLnNvcnQtdGFiaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvc2VsZWN0b3IvZm9jdXNhYmxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3N1cHBvcnRzL2Nzcy1zaGFkb3ctcGllcmNpbmctZGVlcC1jb21iaW5hdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3N1cHBvcnRzL2RldGVjdC1mb2N1cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9zdXBwb3J0cy9mb2N1cy1hcmVhLWltZy10YWJpbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9zdXBwb3J0cy9mb2N1cy1hcmVhLXRhYmluZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3N1cHBvcnRzL2ZvY3VzLWFyZWEtd2l0aG91dC1ocmVmLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3N1cHBvcnRzL2ZvY3VzLWF1ZGlvLXdpdGhvdXQtY29udHJvbHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvc3VwcG9ydHMvZm9jdXMtYnJva2VuLWltYWdlLW1hcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9zdXBwb3J0cy9mb2N1cy1jaGlsZHJlbi1vZi1mb2N1c2FibGUtZmxleGJveC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9zdXBwb3J0cy9mb2N1cy1maWVsZHNldC1kaXNhYmxlZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9zdXBwb3J0cy9mb2N1cy1maWVsZHNldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9zdXBwb3J0cy9mb2N1cy1mbGV4Ym94LWNvbnRhaW5lci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9zdXBwb3J0cy9mb2N1cy1mb3JtLWRpc2FibGVkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3N1cHBvcnRzL2ZvY3VzLWltZy1pc21hcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9zdXBwb3J0cy9mb2N1cy1pbWctdXNlbWFwLXRhYmluZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3N1cHBvcnRzL2ZvY3VzLWluLWhpZGRlbi1pZnJhbWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvc3VwcG9ydHMvZm9jdXMtaW4temVyby1kaW1lbnNpb24tb2JqZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3N1cHBvcnRzL2ZvY3VzLWludmFsaWQtdGFiaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvc3VwcG9ydHMvZm9jdXMtbGFiZWwtdGFiaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvc3VwcG9ydHMvZm9jdXMtb2JqZWN0LXN2Zy1oaWRkZW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvc3VwcG9ydHMvZm9jdXMtb2JqZWN0LXN2Zy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9zdXBwb3J0cy9mb2N1cy1vYmplY3Qtc3dmLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3N1cHBvcnRzL2ZvY3VzLXJlZGlyZWN0LWltZy11c2VtYXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvc3VwcG9ydHMvZm9jdXMtcmVkaXJlY3QtbGVnZW5kLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3N1cHBvcnRzL2ZvY3VzLXNjcm9sbC1ib2R5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3N1cHBvcnRzL2ZvY3VzLXNjcm9sbC1jb250YWluZXItd2l0aG91dC1vdmVyZmxvdy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9zdXBwb3J0cy9mb2N1cy1zY3JvbGwtY29udGFpbmVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3N1cHBvcnRzL2ZvY3VzLXN1bW1hcnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvc3VwcG9ydHMvZm9jdXMtc3ZnLWZvY3VzYWJsZS1hdHRyaWJ1dGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvc3VwcG9ydHMvZm9jdXMtc3ZnLWZvcmVpZ25vYmplY3QtdGFiaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvc3VwcG9ydHMvZm9jdXMtc3ZnLWluLWlmcmFtZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9zdXBwb3J0cy9mb2N1cy1zdmctbmVnYXRpdmUtdGFiaW5kZXgtYXR0cmlidXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3N1cHBvcnRzL2ZvY3VzLXN2Zy10YWJpbmRleC1hdHRyaWJ1dGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvc3VwcG9ydHMvZm9jdXMtc3ZnLXVzZS10YWJpbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9zdXBwb3J0cy9mb2N1cy1zdmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvc3VwcG9ydHMvZm9jdXMtdGFiaW5kZXgtdHJhaWxpbmctY2hhcmFjdGVycy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9zdXBwb3J0cy9mb2N1cy10YWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9zdXBwb3J0cy9mb2N1cy12aWRlby13aXRob3V0LWNvbnRyb2xzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3N1cHBvcnRzL2hlbHBlci9zdmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvc3VwcG9ydHMvbWVkaWEvZ2lmLmludmFsaWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvc3VwcG9ydHMvbWVkaWEvZ2lmLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3N1cHBvcnRzL21lZGlhL21wMy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9zdXBwb3J0cy9tZWRpYS9tcDQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvc3VwcG9ydHMvbWVkaWEvc3ZnLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3N1cHBvcnRzL3N1cHBvcnRzLWNhY2hlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3N1cHBvcnRzL3N1cHBvcnRzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3N1cHBvcnRzL3RhYnNlcXVlbmNlLWFyZWEtYXQtaW1nLXBvc2l0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3V0aWwvYXJyYXktZmluZC1pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy91dGlsL2NvbXBhcmUtcG9zaXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvdXRpbC9jb250ZXh0LXRvLWVsZW1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvdXRpbC9lbGVtZW50LW1hdGNoZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvdXRpbC9nZXQtY29udGVudC1kb2N1bWVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy91dGlsL2dldC1kb2N1bWVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy91dGlsL2dldC1mcmFtZS1lbGVtZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3V0aWwvZ2V0LXdpbmRvdy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy91dGlsL2ltYWdlLW1hcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy91dGlsL2xvZ2dlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy91dGlsL21lcmdlLWRvbS1vcmRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy91dGlsL25vZGUtYXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvdXRpbC9wbGF0Zm9ybS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy91dGlsL3NlbGVjdC1pbi1zaGFkb3dzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3V0aWwvc29ydC1kb20tb3JkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvdXRpbC90YWJpbmRleC12YWx1ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy91dGlsL3RvZ2dsZS1hdHRyaWJ1dGUtdmFsdWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvdXRpbC90b2dnbGUtYXR0cmlidXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3ZlcnNpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvd2hlbi9rZXkuYmluZGluZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy93aGVuL2tleS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYW5zZXIvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbnNpLXJlZ2V4L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jc3MuZXNjYXBlL2Nzcy5lc2NhcGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL25hdGl2ZS11cmwvZGlzdC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3BvbHlmaWxscy9maW5hbGx5LXBvbHlmaWxsLm1pbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3BvbHlmaWxscy91bmZldGNoLmpzIiwid2VicGFjazovLy8uLi8uLi8uLi9jbGllbnQvZGV2L2Rldi1idWlsZC13YXRjaGVyLmpzIiwid2VicGFjazovLy8uLi8uLi8uLi8uLi9jbGllbnQvZGV2L2Vycm9yLW92ZXJsYXkvZXZlbnRzb3VyY2UuanMiLCJ3ZWJwYWNrOi8vLy4uLy4uLy4uLy4uL2NsaWVudC9kZXYvZXJyb3Itb3ZlcmxheS9mb3JtYXQtd2VicGFjay1tZXNzYWdlcy5qcyIsIndlYnBhY2s6Ly8vLi4vLi4vLi4vLi4vY2xpZW50L2Rldi9lcnJvci1vdmVybGF5L2hvdC1kZXYtY2xpZW50LmpzIiwid2VicGFjazovLy8uLi8uLi8uLi9jbGllbnQvZGV2L2V2ZW50LXNvdXJjZS1wb2x5ZmlsbC5qcyIsIndlYnBhY2s6Ly8vLi4vLi4vLi4vY2xpZW50L2Rldi9mb3VjLmpzIiwid2VicGFjazovLy8uLi8uLi8uLi9jbGllbnQvZGV2L29uLWRlbWFuZC1lbnRyaWVzLWNsaWVudC5qcyIsIndlYnBhY2s6Ly8vLi4vLi4vLi4vY2xpZW50L2Rldi9vbi1kZW1hbmQtZW50cmllcy11dGlscy5qcyIsIndlYnBhY2s6Ly8vLi4vLi4vLi4vY2xpZW50L2Rldi9wcmVyZW5kZXItaW5kaWNhdG9yLmpzIiwid2VicGFjazovLy8uLi8uLi8uLi9jbGllbnQvZGV2L3dlYnBhY2staG90LW1pZGRsZXdhcmUtY2xpZW50LmpzIiwid2VicGFjazovLy8uLi8uLi9jbGllbnQvaGVhZC1tYW5hZ2VyLmpzIiwid2VicGFjazovLy8uLi8uLi9jbGllbnQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uLy4uL2NsaWVudC9uZXh0LWRldi5qcyIsIndlYnBhY2s6Ly8vLi4vLi4vY2xpZW50L3BhZ2UtbG9hZGVyLmpzIiwid2VicGFjazovLy8uLi8uLi9jbGllbnQvcGVyZm9ybWFuY2UtcmVsYXllci5qcyIsIndlYnBhY2s6Ly8vLi4vLi4vY2xpZW50L3JvdXRlci50cyIsIndlYnBhY2s6Ly8vLi4vLi4vY2xpZW50L3dpdGgtcm91dGVyLnRzeCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3N0cmlwLWFuc2kvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uLy4uLy4uL25leHQtc2VydmVyL2xpYi9oZWFkLW1hbmFnZXItY29udGV4dC50cyIsIndlYnBhY2s6Ly8vLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL21pdHQudHMiLCJ3ZWJwYWNrOi8vLy4uLy4uLy4uL25leHQtc2VydmVyL2xpYi9yb3V0ZXItY29udGV4dC50cyIsIndlYnBhY2s6Ly8vLi4vLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci9yb3V0ZXIudHMiLCJ3ZWJwYWNrOi8vLy4uLy4uLy4uLy4uLy4uL25leHQtc2VydmVyL2xpYi9yb3V0ZXIvdXRpbHMvaXMtZHluYW1pYy50cyIsIndlYnBhY2s6Ly8vLi4vLi4vLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci91dGlscy9yb3V0ZS1tYXRjaGVyLnRzIiwid2VicGFjazovLy8uLi8uLi8uLi8uLi8uLi9uZXh0LXNlcnZlci9saWIvcm91dGVyL3V0aWxzL3JvdXRlLXJlZ2V4LnRzIiwid2VicGFjazovLy8uLi8uLi8uLi9uZXh0LXNlcnZlci9saWIvcnVudGltZS1jb25maWcudHMiLCJ3ZWJwYWNrOi8vLy4uLy4uLy4uL25leHQtc2VydmVyL2xpYi91dGlscy50cyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGxhdGZvcm0vcGxhdGZvcm0uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2RlY29kZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2VuY29kZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2luZGV4LmpzIiwid2VicGFjazovLy9kZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2luZGV4LmpzIGZyb20gZGxsLXJlZmVyZW5jZSBkbGxfYTBlYTgxOTZlODY5YjliNDQyNWUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWlzL2Nqcy9yZWFjdC1pcy5kZXZlbG9wbWVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtaXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL2RlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9yZWFjdC9pbmRleC5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgZGxsX2EwZWE4MTk2ZTg2OWI5YjQ0MjVlIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3N0YWNrdHJhY2UtcGFyc2VyL2Rpc3Qvc3RhY2stdHJhY2UtcGFyc2VyLmVzbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3RyaXAtYW5zaS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvd2ViLXZpdGFscy9kaXN0L3dlYi12aXRhbHMuZXM1Lm1pbi5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiZGxsX2EwZWE4MTk2ZTg2OWI5YjQ0MjVlXCIiXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsIm9ubHlGaXJzdCIsInBhdHRlcm4iLCJqb2luIiwiUmVnRXhwIiwidW5kZWZpbmVkIiwic2hhZG93SG9zdCIsImRvY3VtZW50IiwicHJlZml4Iiwic2hhZG93Um9vdCIsIm1vZGUiLCJjb250YWluZXIiLCJjcmVhdGVDb250YWluZXIiLCJjc3MiLCJjcmVhdGVDc3MiLCJpc1Zpc2libGUiLCJpc0J1aWxkaW5nIiwidGltZW91dElkIiwiZXZ0U291cmNlIiwicGF0aCIsImV2ZW50IiwiaGFuZGxlTWVzc2FnZSIsIm9iaiIsIkpTT04iLCJjbGVhclRpbWVvdXQiLCJ1cGRhdGVDb250YWluZXIiLCJzZXRUaW1lb3V0IiwiZXZlbnRDYWxsYmFja3MiLCJsYXN0QWN0aXZpdHkiLCJsaXN0ZW5lcnMiLCJvcHRpb25zIiwiaW5pdCIsInRpbWVyIiwic2V0SW50ZXJ2YWwiLCJoYW5kbGVEaXNjb25uZWN0Iiwic291cmNlIiwid2luZG93IiwiY29uc29sZSIsImkiLCJjYiIsImNsZWFySW50ZXJ2YWwiLCJjbG9zZSIsImFkZE1lc3NhZ2VMaXN0ZW5lciIsIkV2ZW50U291cmNlV3JhcHBlciIsImZyaWVuZGx5U3ludGF4RXJyb3JMYWJlbCIsIm1lc3NhZ2UiLCJsaW5lcyIsImxpbmUiLCJwYXJzaW5nRXJyb3IiLCJlcnJvck1lc3NhZ2UiLCJlcnJvckxpbmUiLCJpbmRleCIsImFyciIsImZvcm1hdHRlZEVycm9ycyIsImpzb24iLCJmb3JtYXRNZXNzYWdlIiwiZm9ybWF0dGVkV2FybmluZ3MiLCJyZXN1bHQiLCJlcnJvcnMiLCJ3YXJuaW5ncyIsImhhZFJ1bnRpbWVFcnJvciIsIkRldk92ZXJsYXkiLCJwcm9jZXNzTWVzc2FnZSIsInN1YnNjcmliZVRvSG1yRXZlbnQiLCJjdXN0b21IbXJFdmVudEhhbmRsZXIiLCJvblVucmVjb3ZlcmFibGVFcnJvciIsImlzRmlyc3RDb21waWxhdGlvbiIsIm1vc3RSZWNlbnRDb21waWxhdGlvbkhhc2giLCJoYXNDb21waWxlRXJyb3JzIiwiY2xlYXJPdXRkYXRlZEVycm9ycyIsImlzSG90VXBkYXRlIiwidHJ5QXBwbHlVcGRhdGVzIiwib25GYXN0UmVmcmVzaCIsImZvcm1hdHRlZCIsInByaW50V2FybmluZ3MiLCJwcm9jZXNzIiwic2VsZiIsImUiLCJoYW5kbGVBdmFpbGFibGVIYXNoIiwiaGFzRXJyb3JzIiwiQm9vbGVhbiIsImhhbmRsZUVycm9ycyIsImhhc1dhcm5pbmdzIiwiaGFuZGxlV2FybmluZ3MiLCJoYW5kbGVTdWNjZXNzIiwiY2FuQXBwbHlVcGRhdGVzIiwiZm4iLCJzdGF0dXMiLCJpc1VwZGF0ZUF2YWlsYWJsZSIsImVyciIsImhhc1VwZGF0ZXMiLCJ1cGRhdGVkTW9kdWxlcyIsIm9uSG90VXBkYXRlU3VjY2VzcyIsImFmdGVyQXBwbHlVcGRhdGVzIiwiaGFuZGxlQXBwbHlVcGRhdGVzIiwiUmVzcG9uc2UiLCJUZXh0RGVjb2RlciIsIlRleHRFbmNvZGVyIiwiQWJvcnRDb250cm9sbGVyIiwiVGV4dERlY29kZXJQb2x5ZmlsbCIsIm9jdGV0c0NvdW50IiwiY29kZVBvaW50IiwiYml0c05lZWRlZCIsIlJFUExBQ0VSIiwic3RyaW5nIiwib2N0ZXRzIiwib2N0ZXQiLCJ2YWxpZCIsIlN0cmluZyIsInN1cHBvcnRzU3RyZWFtT3B0aW9uIiwic3RyZWFtIiwiayIsInRoYXQiLCJ4aHIiLCJzdGF0ZSIsInRpbWVvdXQiLCJvblN0YXJ0Iiwic3RhdHVzVGV4dCIsImNvbnRlbnRUeXBlIiwib25Qcm9ncmVzcyIsInJlc3BvbnNlVGV4dCIsIm9uRmluaXNoIiwib25SZWFkeVN0YXRlQ2hhbmdlIiwib25UaW1lb3V0IiwiWE1MSHR0cFJlcXVlc3QiLCJ1cmwiLCJYSFJXcmFwcGVyIiwibmFtZSIsImMiLCJtYXAiLCJPYmplY3QiLCJhcnJheSIsImFsbCIsInBhcnRzIiwidmFsdWUiLCJ0b0xvd2VyQ2FzZSIsIkhlYWRlcnNQb2x5ZmlsbCIsIlhIUlRyYW5zcG9ydCIsIm9mZnNldCIsImNodW5rIiwib25Qcm9ncmVzc0NhbGxiYWNrIiwiaGVhZGVycyIsIm9uU3RhcnRDYWxsYmFjayIsIm9uRmluaXNoQ2FsbGJhY2siLCJIZWFkZXJzV3JhcHBlciIsImNvbnRyb2xsZXIiLCJzaWduYWwiLCJ0ZXh0RGVjb2RlciIsImNyZWRlbnRpYWxzIiwid2l0aENyZWRlbnRpYWxzIiwiY2FjaGUiLCJyZWFkZXIiLCJyZXNwb25zZSIsInJlYWROZXh0Q2h1bmsiLCJyZXNvbHZlIiwicmVqZWN0IiwiUHJvbWlzZSIsIkV2ZW50VGFyZ2V0IiwidHlwZUxpc3RlbmVycyIsImxlbmd0aCIsImxpc3RlbmVyIiwidGhyb3dFcnJvciIsInR5cGUiLCJmb3VuZCIsImZpbHRlcmVkIiwiRXZlbnQiLCJNZXNzYWdlRXZlbnQiLCJDb25uZWN0aW9uRXZlbnQiLCJXQUlUSU5HIiwiQ09OTkVDVElORyIsIk9QRU4iLCJDTE9TRUQiLCJBRlRFUl9DUiIsIkZJRUxEX1NUQVJUIiwiRklFTEQiLCJWQUxVRV9TVEFSVCIsIlZBTFVFIiwiY29udGVudFR5cGVSZWdFeHAiLCJNSU5JTVVNX0RVUkFUSU9OIiwiTUFYSU1VTV9EVVJBVElPTiIsInBhcnNlRHVyYXRpb24iLCJuIiwicGFyc2VJbnQiLCJjbGFtcER1cmF0aW9uIiwiTWF0aCIsImZpcmUiLCJmIiwic3RhcnQiLCJpc0ZldGNoU3VwcG9ydGVkIiwiZmV0Y2giLCJpbml0aWFsUmV0cnkiLCJoZWFydGJlYXRUaW1lb3V0IiwibGFzdEV2ZW50SWQiLCJyZXRyeSIsIndhc0FjdGl2aXR5IiwiQ3VycmVudFRyYW5zcG9ydCIsInRyYW5zcG9ydCIsImNhbmNlbEZ1bmN0aW9uIiwiY3VycmVudFN0YXRlIiwiZGF0YUJ1ZmZlciIsImxhc3RFdmVudElkQnVmZmVyIiwiZXZlbnRUeXBlQnVmZmVyIiwidGV4dEJ1ZmZlciIsImZpZWxkU3RhcnQiLCJ2YWx1ZVN0YXJ0IiwiZXMiLCJ0ZXh0Q2h1bmsiLCJwb3NpdGlvbiIsImZpZWxkIiwiZGF0YSIsInJlcXVlc3RVUkwiLCJlbmNvZGVVUklDb21wb25lbnQiLCJyZXF1ZXN0SGVhZGVycyIsIkV2ZW50U291cmNlUG9seWZpbGwiLCJ4IiwiY2FsbGJhY2siLCJSb3V0ZXIiLCJzZXR1cFBpbmciLCJjdXJyZW50UGFnZSIsInBhdGhuYW1lIiwicGF0aG5hbWVGbiIsImNsb3NlUGluZyIsImFzc2V0UHJlZml4Iiwib25kZW1hbmQiLCJwYXlsb2FkIiwibG9jYXRpb24iLCJwYWdlUmVzIiwiZXhwYW5kRWwiLCJjbG9zZUVsIiwiZGlzbWlzc0tleSIsImRpc21pc3NVbnRpbCIsImRpc21pc3NlZCIsImV4cGFuZGVkQ2xhc3MiLCJ0b2dnbGVFeHBhbmQiLCJleHBhbmQiLCJ0b2dnbGVUaW1lb3V0Iiwib25lSG91ckF3YXkiLCJkZXZDbGllbnQiLCJwYWdlIiwiRE9NQXR0cmlidXRlTmFtZXMiLCJhY2NlcHRDaGFyc2V0IiwiY2xhc3NOYW1lIiwiaHRtbEZvciIsImh0dHBFcXVpdiIsImVsIiwicHJvcHMiLCJwIiwiYXR0ciIsImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MIiwiY2hpbGRyZW4iLCJoZWFkRWwiLCJoZWFkQ291bnRFbCIsImhlYWRDb3VudCIsIk51bWJlciIsIm9sZFRhZ3MiLCJqIiwibmV3VGFncyIsImNvbXBvbmVudHMiLCJuZXdUYWciLCJsZW4iLCJvbGRUYWciLCJ0IiwidXBkYXRlUHJvbWlzZSIsImhlYWQiLCJwcm9taXNlIiwidGFncyIsImgiLCJ0aXRsZUNvbXBvbmVudCIsInRpdGxlIiwidXBkYXRlRWxlbWVudHMiLCJyZXF1aXJlIiwidmVyc2lvbiIsIl9fTkVYVF9WRVJTSU9OIiwiZHluYW1pY0lkcyIsImlzRmFsbGJhY2siLCJfX3dlYnBhY2tfcHVibGljX3BhdGhfXyIsImVudkNvbmZpZyIsInNlcnZlclJ1bnRpbWVDb25maWciLCJwdWJsaWNSdW50aW1lQ29uZmlnIiwicnVudGltZUNvbmZpZyIsImFzUGF0aCIsInBhZ2VMb2FkZXIiLCJQYWdlTG9hZGVyIiwicmVnaXN0ZXIiLCJ1cGRhdGVIZWFkIiwiYXBwRWxlbWVudCIsImNvbXBvbmVudERpZE1vdW50Iiwicm91dGVyIiwiX2giLCJzaGFsbG93IiwiY29tcG9uZW50RGlkVXBkYXRlIiwic2Nyb2xsVG9IYXNoIiwiaGFzaCIsInJlbmRlciIsIlJlYWN0IiwiQ29tcG9uZW50IiwiZW1pdHRlciIsIndlYnBhY2tITVIiLCJBcHAiLCJtb2QiLCJvblBlcmZFbnRyeSIsInVuaXF1ZUlEIiwiRGF0ZSIsImVudHJpZXMiLCJwZXJmU3RhcnRFbnRyeSIsImlkIiwic3RhcnRUaW1lIiwibGFiZWwiLCJlbnRyeVR5cGUiLCJpbml0aWFsRXJyIiwiaXNWYWxpZEVsZW1lbnRUeXBlIiwiZXJyb3IiLCJub2RlIiwiZ2V0Tm9kZUVycm9yIiwiaW5pdGlhbFByb3BzIiwid3JhcEFwcCIsInN1YnNjcmlwdGlvbiIsInJlbmRlckN0eCIsInJlbmRlckVycm9yIiwiZG9SZW5kZXIiLCJBcHBUcmVlIiwiYXBwQ3R4IiwiY3R4IiwicXVlcnkiLCJpbml0UHJvcHMiLCJpc0luaXRpYWxSZW5kZXIiLCJSZWFjdERPTSIsInJlYWN0Um9vdCIsIlNUIiwicGVyZm9ybWFuY2UiLCJjbGVhck1hcmtzIiwibmF2U3RhcnRFbnRyaWVzIiwibWVhc3VyZSIsIm1hcmsiLCJhcHBQcm9wcyIsImxhc3RBcHBQcm9wcyIsInJlbmRlclByb21pc2UiLCJsYXN0UmVuZGVyUmVqZWN0IiwicmVzb2x2ZVByb21pc2UiLCJlbGVtIiwicmVuZGVyUmVhY3RFbGVtZW50IiwiX19SRVBMQUNFX05PT1BfSU1QT1JUX18iLCJfX05FWFRfREFUQV9fIiwibGluayIsInJlbFByZWZldGNoIiwiaGFzUmVsIiwiaGFzTm9Nb2R1bGUiLCJyb3V0ZSIsImNvbnN0cnVjdG9yIiwibWFuIiwiZW5jb2RlVVJJIiwiZ2V0SHJlZkZvclNsdWciLCJidWlsZElkIiwibm9ybWFsaXplUm91dGUiLCJpc0R5bmFtaWMiLCJkeW5hbWljUmVnZXgiLCJkeW5hbWljR3JvdXBzIiwiZHluYW1pY01hdGNoZXMiLCJpbnRlcnBvbGF0ZWRSb3V0ZSIsInBhcmFtIiwicmVwZWF0IiwiQXJyYXkiLCJzIiwiX2RhdGFIcmVmIiwiYXBwZW5kTGluayIsImxvYWRQYWdlIiwibG9hZFBhZ2VTY3JpcHQiLCJjYWNoZWRQYWdlIiwibG9hZFJvdXRlIiwic2NyaXB0Um91dGUiLCJsb2FkU2NyaXB0Iiwic2NyaXB0IiwicmVnRm4iLCJwYWdlRGF0YSIsImNoZWNrIiwiY24iLCJuYXZpZ2F0b3IiLCJzaW5nbGV0b25Sb3V0ZXIiLCJyZWFkeUNhbGxiYWNrcyIsInJlYWR5IiwidXJsUHJvcGVydHlGaWVsZHMiLCJyb3V0ZXJFdmVudHMiLCJjb3JlTWV0aG9kRmllbGRzIiwiZ2V0IiwiZ2V0Um91dGVyIiwiZXZlbnRGaWVsZCIsIl9zaW5nbGV0b25Sb3V0ZXIiLCJSb3V0ZXJDb250ZXh0IiwiY3JlYXRlUm91dGVyIiwiX3JvdXRlciIsImluc3RhbmNlIiwiQ29tcG9zZWRDb21wb25lbnQiLCJnZXRJbml0aWFsUHJvcHMiLCJXaXRoUm91dGVyV3JhcHBlciIsInIiLCJfX3dlYnBhY2tfcmVxdWlyZV9fIiwibCIsImNhbGwiLCJhYiIsIl9fZGlybmFtZSIsInN0YXJ0dXAiLCJyZXBsYWNlIiwiSGVhZE1hbmFnZXJDb250ZXh0Iiwib24iLCJvZmYiLCJlbWl0IiwiaGFuZGxlciIsImJhc2VQYXRoIiwicHJlcGFyZVJvdXRlIiwidG9Sb3V0ZSIsImF0dGVtcHRzIiwiaXNTZXJ2ZXJSZW5kZXIiLCJhZGRCYXNlUGF0aCIsImRlbEJhc2VQYXRoIiwicmVzIiwiZ2V0UmVzcG9uc2UiLCJzZGMiLCJzdWIiLCJjbGMiLCJfYnBzIiwiZXZlbnRzIiwiX3dyYXBBcHAiLCJpc1NzciIsImZldGNoTmV4dERhdGEiLCJfX05fU1NHIiwiX19OX1NTUCIsImFzIiwibmV3RGF0YSIsInJlbG9hZCIsImNoYW5nZSIsIm1ldGhvZCIsInJvdXRlUmVnZXgiLCJyb3V0ZU1hdGNoIiwibWlzc2luZ1BhcmFtcyIsImFzUGF0aG5hbWUiLCJyb3V0ZUluZm8iLCJhcHBDb21wIiwiY2hhbmdlU3RhdGUiLCJnZXRSb3V0ZUluZm8iLCJjYWNoZWRSb3V0ZUluZm8iLCJoYW5kbGVFcnJvciIsImdpcEVyciIsInNldCIsIm9ubHlBSGFzaENoYW5nZSIsIm5ld0hhc2giLCJvbGRVcmxOb0hhc2giLCJvbGRIYXNoIiwiaWRFbCIsIm5hbWVFbCIsInVybElzTmV3IiwiY2FuY2VsbGVkIiwiY2FuY2VsIiwiY29tcG9uZW50UmVzdWx0IiwiYWJvcnRDb21wb25lbnRMb2FkIiwibm90aWZ5IiwidXBkYXRlIiwiVEVTVF9ST1VURSIsInJlIiwiZGVjb2RlIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwicGFyYW1zIiwic2x1Z05hbWUiLCJnIiwiZ3JvdXBzIiwibSIsImVudHJ5Iiwic3RyIiwiZXNjYXBlZFJvdXRlIiwiZXNjYXBlUmVnZXgiLCJub3JtYWxpemVkUm91dGUiLCJncm91cEluZGV4IiwicGFyYW1ldGVyaXplZFJvdXRlIiwiaXNPcHRpb25hbCIsIiQxIiwiaXNDYXRjaEFsbCIsInBvcyIsIm5hbWVkUmVnZXgiLCJuYW1lZFBhcmFtZXRlcml6ZWRSb3V0ZSIsInVzZWQiLCJwcm90b2NvbCIsImhvc3RuYW1lIiwicG9ydCIsIm9yaWdpbiIsImdldExvY2F0aW9uT3JpZ2luIiwiaHJlZiIsImdldERpc3BsYXlOYW1lIiwibG9hZEdldEluaXRpYWxQcm9wcyIsInBhZ2VQcm9wcyIsImlzUmVzU2VudCIsInVybE9iamVjdEtleXMiLCJrZXkiLCJTUCIsImFuc2lSZWdleCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTs7QUFFQSx3Q0FBd0MsU0FBUztBQUNqRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsbUM7Ozs7Ozs7Ozs7O0FDVkE7QUFDQTtBQUNBOztBQUVBLGlDOzs7Ozs7Ozs7OztBQ0pBLHVCQUF1QixtQkFBTyxDQUFDLHFGQUFvQjs7QUFFbkQ7QUFDQTtBQUNBOztBQUVBLG9DOzs7Ozs7Ozs7OztBQ05BO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsd0M7Ozs7Ozs7Ozs7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEsbUM7Ozs7Ozs7Ozs7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBLHFDOzs7Ozs7Ozs7Ozs7QUNoTmE7O0FBRWI7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDBFQUEwRSxnQkFBZ0I7QUFDMUYsdURBQXVELGdCQUFnQjs7QUFFdkU7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBLG9DOzs7Ozs7Ozs7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O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxFQUFFO0FBQ2YsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEVBQUU7QUFDZixhQUFhLE9BQU87QUFDcEIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsR0FBRztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUZBQXlGO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7QUFDQSw4QkFBOEIsZUFBZTtBQUM3Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLE1BQU0sSUFBMEU7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJLG1DQUFPO0FBQ1g7QUFDQSxLQUFLO0FBQUEsb0dBQUM7QUFDTjtBQUNBO0FBQ0EsT0FBTyxFQVNKO0FBQ0gsQ0FBQzs7Ozs7Ozs7Ozs7OztBQ2pvQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVTs7Ozs7Ozs7Ozs7OztBQ3ZMdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZUFBZTtBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3BGYTs7QUFFYixpQ0FBaUMsbUJBQU8sQ0FBQywwREFBVTtBQUNuRCxxQ0FBcUMsbUJBQU8sQ0FBQywwREFBVTs7Ozs7Ozs7Ozs7O0FDSHZELG9LOzs7Ozs7Ozs7Ozs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOzs7O0FBSWIsSUFBSSxJQUFxQztBQUN6QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRTtBQUMxRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7O0FBRWhEO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDs7QUFFakQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7Ozs7Ozs7Ozs7Ozs7QUNwTGE7O0FBRWIsSUFBSSxLQUFxQyxFQUFFLEVBRTFDO0FBQ0QsbUJBQW1CLG1CQUFPLENBQUMsMEZBQStCO0FBQzFEOzs7Ozs7Ozs7Ozs7QUNOQSxnSzs7Ozs7Ozs7Ozs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsS0FBSztBQUNMLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBLHdDQUF3QyxXQUFXO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DLGNBQWM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDLGtCQUFrQjtBQUNuRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUEsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLDhDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLDhDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxLQUEwQixvQkFBb0IsU0FBRTtBQUNsRDs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Ozs7Ozs7Ozs7Ozs7QUNyQkEsMEMiLCJmaWxlIjoic3RhdGljL3J1bnRpbWUvbWFpbi5qcyIsInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XHJcbiAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XHJcblxyXG4gIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykge1xyXG4gICAgYXJyMltpXSA9IGFycltpXTtcclxuICB9XHJcblxyXG4gIHJldHVybiBhcnIyO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IF9hcnJheUxpa2VUb0FycmF5OyIsImZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHtcclxuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IF9hcnJheVdpdGhIb2xlczsiLCJ2YXIgYXJyYXlMaWtlVG9BcnJheSA9IHJlcXVpcmUoXCIuL2FycmF5TGlrZVRvQXJyYXlcIik7XHJcblxyXG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7XHJcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXkoYXJyKTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBfYXJyYXlXaXRob3V0SG9sZXM7IiwiZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XHJcbiAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xyXG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHNlbGY7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gX2Fzc2VydFRoaXNJbml0aWFsaXplZDsiLCJmdW5jdGlvbiBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIGtleSwgYXJnKSB7XHJcbiAgdHJ5IHtcclxuICAgIHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTtcclxuICAgIHZhciB2YWx1ZSA9IGluZm8udmFsdWU7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIHJlamVjdChlcnJvcik7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICBpZiAoaW5mby5kb25lKSB7XHJcbiAgICByZXNvbHZlKHZhbHVlKTtcclxuICB9IGVsc2Uge1xyXG4gICAgUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKF9uZXh0LCBfdGhyb3cpO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gX2FzeW5jVG9HZW5lcmF0b3IoZm4pIHtcclxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIHNlbGYgPSB0aGlzLFxyXG4gICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICB2YXIgZ2VuID0gZm4uYXBwbHkoc2VsZiwgYXJncyk7XHJcblxyXG4gICAgICBmdW5jdGlvbiBfbmV4dCh2YWx1ZSkge1xyXG4gICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJuZXh0XCIsIHZhbHVlKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZnVuY3Rpb24gX3Rocm93KGVycikge1xyXG4gICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJ0aHJvd1wiLCBlcnIpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBfbmV4dCh1bmRlZmluZWQpO1xyXG4gICAgfSk7XHJcbiAgfTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBfYXN5bmNUb0dlbmVyYXRvcjsiLCJmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XHJcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcclxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XHJcbiAgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IF9jbGFzc0NhbGxDaGVjazsiLCJ2YXIgc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKFwiLi9zZXRQcm90b3R5cGVPZlwiKTtcclxuXHJcbnZhciBpc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSByZXF1aXJlKFwiLi9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3RcIik7XHJcblxyXG5mdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHtcclxuICBpZiAoaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkpIHtcclxuICAgIG1vZHVsZS5leHBvcnRzID0gX2NvbnN0cnVjdCA9IFJlZmxlY3QuY29uc3RydWN0O1xyXG4gIH0gZWxzZSB7XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IF9jb25zdHJ1Y3QgPSBmdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHtcclxuICAgICAgdmFyIGEgPSBbbnVsbF07XHJcbiAgICAgIGEucHVzaC5hcHBseShhLCBhcmdzKTtcclxuICAgICAgdmFyIENvbnN0cnVjdG9yID0gRnVuY3Rpb24uYmluZC5hcHBseShQYXJlbnQsIGEpO1xyXG4gICAgICB2YXIgaW5zdGFuY2UgPSBuZXcgQ29uc3RydWN0b3IoKTtcclxuICAgICAgaWYgKENsYXNzKSBzZXRQcm90b3R5cGVPZihpbnN0YW5jZSwgQ2xhc3MucHJvdG90eXBlKTtcclxuICAgICAgcmV0dXJuIGluc3RhbmNlO1xyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIHJldHVybiBfY29uc3RydWN0LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gX2NvbnN0cnVjdDsiLCJmdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xyXG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcclxuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcclxuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcclxuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XHJcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XHJcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xyXG4gIHJldHVybiBDb25zdHJ1Y3RvcjtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBfY3JlYXRlQ2xhc3M7IiwiZnVuY3Rpb24gX2V4dGVuZHMoKSB7XHJcbiAgbW9kdWxlLmV4cG9ydHMgPSBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkge1xyXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcclxuXHJcbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcclxuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xyXG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGFyZ2V0O1xyXG4gIH07XHJcblxyXG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IF9leHRlbmRzOyIsImZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XHJcbiAgbW9kdWxlLmV4cG9ydHMgPSBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xyXG4gICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcclxuICB9O1xyXG4gIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gX2dldFByb3RvdHlwZU9mOyIsInZhciBzZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCIuL3NldFByb3RvdHlwZU9mXCIpO1xyXG5cclxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XHJcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xyXG4gIH1cclxuXHJcbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XHJcbiAgICBjb25zdHJ1Y3Rvcjoge1xyXG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXHJcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH1cclxuICB9KTtcclxuICBpZiAoc3VwZXJDbGFzcykgc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IF9pbmhlcml0czsiLCJmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xyXG4gIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7XHJcbiAgICBcImRlZmF1bHRcIjogb2JqXHJcbiAgfTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0OyIsInZhciBfdHlwZW9mID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvdHlwZW9mXCIpO1xyXG5cclxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkge1xyXG4gIGlmICh0eXBlb2YgV2Vha01hcCAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gbnVsbDtcclxuICB2YXIgY2FjaGUgPSBuZXcgV2Vha01hcCgpO1xyXG5cclxuICBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKSB7XHJcbiAgICByZXR1cm4gY2FjaGU7XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIGNhY2hlO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHtcclxuICBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7XHJcbiAgICByZXR1cm4gb2JqO1xyXG4gIH1cclxuXHJcbiAgaWYgKG9iaiA9PT0gbnVsbCB8fCBfdHlwZW9mKG9iaikgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iaiAhPT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBcImRlZmF1bHRcIjogb2JqXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgdmFyIGNhY2hlID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCk7XHJcblxyXG4gIGlmIChjYWNoZSAmJiBjYWNoZS5oYXMob2JqKSkge1xyXG4gICAgcmV0dXJuIGNhY2hlLmdldChvYmopO1xyXG4gIH1cclxuXHJcbiAgdmFyIG5ld09iaiA9IHt9O1xyXG4gIHZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcclxuXHJcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xyXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcclxuICAgICAgdmFyIGRlc2MgPSBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IG51bGw7XHJcblxyXG4gICAgICBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBuZXdPYmpba2V5XSA9IG9ialtrZXldO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBuZXdPYmpbXCJkZWZhdWx0XCJdID0gb2JqO1xyXG5cclxuICBpZiAoY2FjaGUpIHtcclxuICAgIGNhY2hlLnNldChvYmosIG5ld09iaik7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gbmV3T2JqO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkOyIsImZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7XHJcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlO1xyXG4gIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7XHJcbiAgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTtcclxuXHJcbiAgdHJ5IHtcclxuICAgIERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoRGF0ZSwgW10sIGZ1bmN0aW9uICgpIHt9KSk7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9IGNhdGNoIChlKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3Q7IiwiZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7XHJcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChpdGVyKSkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gX2l0ZXJhYmxlVG9BcnJheTsiLCJmdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7XHJcbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwidW5kZWZpbmVkXCIgfHwgIShTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGFycikpKSByZXR1cm47XHJcbiAgdmFyIF9hcnIgPSBbXTtcclxuICB2YXIgX24gPSB0cnVlO1xyXG4gIHZhciBfZCA9IGZhbHNlO1xyXG4gIHZhciBfZSA9IHVuZGVmaW5lZDtcclxuXHJcbiAgdHJ5IHtcclxuICAgIGZvciAodmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHtcclxuICAgICAgX2Fyci5wdXNoKF9zLnZhbHVlKTtcclxuXHJcbiAgICAgIGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhaztcclxuICAgIH1cclxuICB9IGNhdGNoIChlcnIpIHtcclxuICAgIF9kID0gdHJ1ZTtcclxuICAgIF9lID0gZXJyO1xyXG4gIH0gZmluYWxseSB7XHJcbiAgICB0cnkge1xyXG4gICAgICBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdICE9IG51bGwpIF9pW1wicmV0dXJuXCJdKCk7XHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICBpZiAoX2QpIHRocm93IF9lO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIF9hcnI7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gX2l0ZXJhYmxlVG9BcnJheUxpbWl0OyIsImZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7XHJcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBfbm9uSXRlcmFibGVSZXN0OyIsImZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHtcclxuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBfbm9uSXRlcmFibGVTcHJlYWQ7IiwidmFyIF90eXBlb2YgPSByZXF1aXJlKFwiLi4vaGVscGVycy90eXBlb2ZcIik7XHJcblxyXG52YXIgYXNzZXJ0VGhpc0luaXRpYWxpemVkID0gcmVxdWlyZShcIi4vYXNzZXJ0VGhpc0luaXRpYWxpemVkXCIpO1xyXG5cclxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xyXG4gIGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XHJcbiAgICByZXR1cm4gY2FsbDtcclxuICB9XHJcblxyXG4gIHJldHVybiBhc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm47IiwiZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcclxuICBtb2R1bGUuZXhwb3J0cyA9IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xyXG4gICAgby5fX3Byb3RvX18gPSBwO1xyXG4gICAgcmV0dXJuIG87XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBfc2V0UHJvdG90eXBlT2Y7IiwidmFyIGFycmF5V2l0aEhvbGVzID0gcmVxdWlyZShcIi4vYXJyYXlXaXRoSG9sZXNcIik7XHJcblxyXG52YXIgaXRlcmFibGVUb0FycmF5TGltaXQgPSByZXF1aXJlKFwiLi9pdGVyYWJsZVRvQXJyYXlMaW1pdFwiKTtcclxuXHJcbnZhciB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSA9IHJlcXVpcmUoXCIuL3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5XCIpO1xyXG5cclxudmFyIG5vbkl0ZXJhYmxlUmVzdCA9IHJlcXVpcmUoXCIuL25vbkl0ZXJhYmxlUmVzdFwiKTtcclxuXHJcbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkge1xyXG4gIHJldHVybiBhcnJheVdpdGhIb2xlcyhhcnIpIHx8IGl0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyLCBpKSB8fCBub25JdGVyYWJsZVJlc3QoKTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBfc2xpY2VkVG9BcnJheTsiLCJ2YXIgYXJyYXlXaXRob3V0SG9sZXMgPSByZXF1aXJlKFwiLi9hcnJheVdpdGhvdXRIb2xlc1wiKTtcclxuXHJcbnZhciBpdGVyYWJsZVRvQXJyYXkgPSByZXF1aXJlKFwiLi9pdGVyYWJsZVRvQXJyYXlcIik7XHJcblxyXG52YXIgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkgPSByZXF1aXJlKFwiLi91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheVwiKTtcclxuXHJcbnZhciBub25JdGVyYWJsZVNwcmVhZCA9IHJlcXVpcmUoXCIuL25vbkl0ZXJhYmxlU3ByZWFkXCIpO1xyXG5cclxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikge1xyXG4gIHJldHVybiBhcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IGl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IHVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgbm9uSXRlcmFibGVTcHJlYWQoKTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBfdG9Db25zdW1hYmxlQXJyYXk7IiwiZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcclxuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XHJcblxyXG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikge1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcclxuICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XHJcbiAgICB9O1xyXG4gIH0gZWxzZSB7XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xyXG4gICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICByZXR1cm4gX3R5cGVvZihvYmopO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IF90eXBlb2Y7IiwidmFyIGFycmF5TGlrZVRvQXJyYXkgPSByZXF1aXJlKFwiLi9hcnJheUxpa2VUb0FycmF5XCIpO1xyXG5cclxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikge1xyXG4gIGlmICghbykgcmV0dXJuO1xyXG4gIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcclxuICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XHJcbiAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcclxuICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTtcclxuICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXk7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwicmVnZW5lcmF0b3ItcnVudGltZVwiKTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcclxuICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XHJcbiAgICByZXN1bHRbXCJkZWZhdWx0XCJdID0gbW9kO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxudmFyIEJ1cyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9pbnRlcm5hbC9idXNcIikpO1xyXG52YXIgcGFyc2VTdGFja18xID0gcmVxdWlyZShcIi4vaW50ZXJuYWwvaGVscGVycy9wYXJzZVN0YWNrXCIpO1xyXG52YXIgaXNSZWdpc3RlcmVkID0gZmFsc2U7XHJcbnZhciBzdGFja1RyYWNlTGltaXQgPSB1bmRlZmluZWQ7XHJcbmZ1bmN0aW9uIG9uVW5oYW5kbGVkRXJyb3IoZXYpIHtcclxuICAgIHZhciBlcnJvciA9IGV2ID09PSBudWxsIHx8IGV2ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBldi5lcnJvcjtcclxuICAgIGlmICghZXJyb3IgfHwgIShlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB8fCB0eXBlb2YgZXJyb3Iuc3RhY2sgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgLy8gQSBub24tZXJyb3Igd2FzIHRocm93biwgd2UgZG9uJ3QgaGF2ZSBhbnl0aGluZyB0byBzaG93LiA6LShcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB2YXIgZSA9IGVycm9yO1xyXG4gICAgQnVzLmVtaXQoe1xyXG4gICAgICAgIHR5cGU6IEJ1cy5UWVBFX1VOSEFORExFRF9FUlJPUixcclxuICAgICAgICByZWFzb246IGVycm9yLFxyXG4gICAgICAgIGZyYW1lczogcGFyc2VTdGFja18xLnBhcnNlU3RhY2soZS5zdGFjaylcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIG9uVW5oYW5kbGVkUmVqZWN0aW9uKGV2KSB7XHJcbiAgICB2YXIgcmVhc29uID0gZXYgPT09IG51bGwgfHwgZXYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGV2LnJlYXNvbjtcclxuICAgIGlmICghcmVhc29uIHx8XHJcbiAgICAgICAgIShyZWFzb24gaW5zdGFuY2VvZiBFcnJvcikgfHxcclxuICAgICAgICB0eXBlb2YgcmVhc29uLnN0YWNrICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgIC8vIEEgbm9uLWVycm9yIHdhcyB0aHJvd24sIHdlIGRvbid0IGhhdmUgYW55dGhpbmcgdG8gc2hvdy4gOi0oXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdmFyIGUgPSByZWFzb247XHJcbiAgICBCdXMuZW1pdCh7XHJcbiAgICAgICAgdHlwZTogQnVzLlRZUEVfVU5IQU5ETEVEX1JFSkVDVElPTixcclxuICAgICAgICByZWFzb246IHJlYXNvbixcclxuICAgICAgICBmcmFtZXM6IHBhcnNlU3RhY2tfMS5wYXJzZVN0YWNrKGUuc3RhY2spXHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiByZWdpc3RlcigpIHtcclxuICAgIGlmIChpc1JlZ2lzdGVyZWQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpc1JlZ2lzdGVyZWQgPSB0cnVlO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB2YXIgbGltaXQgPSBFcnJvci5zdGFja1RyYWNlTGltaXQ7XHJcbiAgICAgICAgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ID0gNTA7XHJcbiAgICAgICAgc3RhY2tUcmFjZUxpbWl0ID0gbGltaXQ7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoX2EpIHsgfVxyXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgb25VbmhhbmRsZWRFcnJvcik7XHJcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndW5oYW5kbGVkcmVqZWN0aW9uJywgb25VbmhhbmRsZWRSZWplY3Rpb24pO1xyXG59XHJcbmV4cG9ydHMucmVnaXN0ZXIgPSByZWdpc3RlcjtcclxuZnVuY3Rpb24gdW5yZWdpc3RlcigpIHtcclxuICAgIGlmICghaXNSZWdpc3RlcmVkKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaXNSZWdpc3RlcmVkID0gZmFsc2U7XHJcbiAgICBpZiAoc3RhY2tUcmFjZUxpbWl0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBFcnJvci5zdGFja1RyYWNlTGltaXQgPSBzdGFja1RyYWNlTGltaXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChfYSkgeyB9XHJcbiAgICAgICAgc3RhY2tUcmFjZUxpbWl0ID0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgb25VbmhhbmRsZWRFcnJvcik7XHJcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndW5oYW5kbGVkcmVqZWN0aW9uJywgb25VbmhhbmRsZWRSZWplY3Rpb24pO1xyXG59XHJcbmV4cG9ydHMudW5yZWdpc3RlciA9IHVucmVnaXN0ZXI7XHJcbmZ1bmN0aW9uIG9uQnVpbGRPaygpIHtcclxuICAgIEJ1cy5lbWl0KHsgdHlwZTogQnVzLlRZUEVfQlVJTERfT0sgfSk7XHJcbn1cclxuZXhwb3J0cy5vbkJ1aWxkT2sgPSBvbkJ1aWxkT2s7XHJcbmZ1bmN0aW9uIG9uQnVpbGRFcnJvcihtZXNzYWdlKSB7XHJcbiAgICBCdXMuZW1pdCh7IHR5cGU6IEJ1cy5UWVBFX0JVSUxEX0VSUk9SLCBtZXNzYWdlOiBtZXNzYWdlIH0pO1xyXG59XHJcbmV4cG9ydHMub25CdWlsZEVycm9yID0gb25CdWlsZEVycm9yO1xyXG5mdW5jdGlvbiBvblJlZnJlc2goKSB7XHJcbiAgICBCdXMuZW1pdCh7IHR5cGU6IEJ1cy5UWVBFX1JFRkZSRVNIIH0pO1xyXG59XHJcbmV4cG9ydHMub25SZWZyZXNoID0gb25SZWZyZXNoO1xyXG52YXIgbm9kZVN0YWNrRnJhbWVzXzEgPSByZXF1aXJlKFwiLi9pbnRlcm5hbC9oZWxwZXJzL25vZGVTdGFja0ZyYW1lc1wiKTtcclxuZXhwb3J0cy5nZXROb2RlRXJyb3IgPSBub2RlU3RhY2tGcmFtZXNfMS5nZXROb2RlRXJyb3I7XHJcbnZhciBSZWFjdERldk92ZXJsYXlfMSA9IHJlcXVpcmUoXCIuL2ludGVybmFsL1JlYWN0RGV2T3ZlcmxheVwiKTtcclxuZXhwb3J0cy5SZWFjdERldk92ZXJsYXkgPSBSZWFjdERldk92ZXJsYXlfMVtcImRlZmF1bHRcIl07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxufSkoKTtcclxudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcclxufTtcclxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxudmFyIHJlYWN0XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInJlYWN0XCIpKTtcclxudmFyIEVycm9yQm91bmRhcnkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoRXJyb3JCb3VuZGFyeSwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEVycm9yQm91bmRhcnkoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuc3RhdGUgPSB7IGVycm9yOiBudWxsIH07XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgRXJyb3JCb3VuZGFyeS5wcm90b3R5cGUuY29tcG9uZW50RGlkQ2F0Y2ggPSBmdW5jdGlvbiAoZXJyb3IsIFxyXG4gICAgLy8gTG9vc2VseSB0eXBlZCBiZWNhdXNlIGl0IGRlcGVuZHMgb24gdGhlIFJlYWN0IHZlcnNpb24gYW5kIHdhc1xyXG4gICAgLy8gYWNjaWRlbnRhbGx5IGV4Y2x1ZGVkIGluIHNvbWUgdmVyc2lvbnMuXHJcbiAgICBlcnJvckluZm8pIHtcclxuICAgICAgICB0aGlzLnByb3BzLm9uRXJyb3IoZXJyb3IsIChlcnJvckluZm8gPT09IG51bGwgfHwgZXJyb3JJbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlcnJvckluZm8uY29tcG9uZW50U3RhY2spIHx8IG51bGwpO1xyXG4gICAgICAgIHRoaXMuc2V0U3RhdGUoeyBlcnJvcjogZXJyb3IgfSk7XHJcbiAgICB9O1xyXG4gICAgRXJyb3JCb3VuZGFyeS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmVycm9yXHJcbiAgICAgICAgICAgID8gLy8gVGhlIGNvbXBvbmVudCBoYXMgdG8gYmUgdW5tb3VudGVkIG9yIGVsc2UgaXQgd291bGQgY29udGludWUgdG8gZXJyb3JcclxuICAgICAgICAgICAgICAgIG51bGxcclxuICAgICAgICAgICAgOiB0aGlzLnByb3BzLmNoaWxkcmVuO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBFcnJvckJvdW5kYXJ5O1xyXG59KHJlYWN0XzFbXCJkZWZhdWx0XCJdLlB1cmVDb21wb25lbnQpKTtcclxuZXhwb3J0cy5FcnJvckJvdW5kYXJ5ID0gRXJyb3JCb3VuZGFyeTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcclxuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcclxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufTtcclxudmFyIF9fcmVhZCA9ICh0aGlzICYmIHRoaXMuX19yZWFkKSB8fCBmdW5jdGlvbiAobywgbikge1xyXG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xyXG4gICAgaWYgKCFtKSByZXR1cm4gbztcclxuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxyXG4gICAgZmluYWxseSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFyO1xyXG59O1xyXG52YXIgX19zcHJlYWQgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkKSB8fCBmdW5jdGlvbiAoKSB7XHJcbiAgICBmb3IgKHZhciBhciA9IFtdLCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgYXIgPSBhci5jb25jYXQoX19yZWFkKGFyZ3VtZW50c1tpXSkpO1xyXG4gICAgcmV0dXJuIGFyO1xyXG59O1xyXG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XHJcbiAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xyXG4gICAgcmVzdWx0W1wiZGVmYXVsdFwiXSA9IG1vZDtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn07XHJcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XHJcbnZhciBSZWFjdCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwicmVhY3RcIikpO1xyXG52YXIgQnVzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2J1c1wiKSk7XHJcbnZhciBTaGFkb3dQb3J0YWxfMSA9IHJlcXVpcmUoXCIuL2NvbXBvbmVudHMvU2hhZG93UG9ydGFsXCIpO1xyXG52YXIgRXJyb3JzXzEgPSByZXF1aXJlKFwiLi9jb250YWluZXIvRXJyb3JzXCIpO1xyXG52YXIgQnVpbGRFcnJvcl8xID0gcmVxdWlyZShcIi4vY29udGFpbmVyL0J1aWxkRXJyb3JcIik7XHJcbnZhciBFcnJvckJvdW5kYXJ5XzEgPSByZXF1aXJlKFwiLi9FcnJvckJvdW5kYXJ5XCIpO1xyXG52YXIgQmFzZV8xID0gcmVxdWlyZShcIi4vc3R5bGVzL0Jhc2VcIik7XHJcbnZhciBDb21wb25lbnRTdHlsZXNfMSA9IHJlcXVpcmUoXCIuL3N0eWxlcy9Db21wb25lbnRTdHlsZXNcIik7XHJcbnZhciBDc3NSZXNldF8xID0gcmVxdWlyZShcIi4vc3R5bGVzL0Nzc1Jlc2V0XCIpO1xyXG5mdW5jdGlvbiByZWR1Y2VyKHN0YXRlLCBldikge1xyXG4gICAgc3dpdGNoIChldi50eXBlKSB7XHJcbiAgICAgICAgY2FzZSBCdXMuVFlQRV9CVUlMRF9PSzoge1xyXG4gICAgICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIHN0YXRlKSwgeyBidWlsZEVycm9yOiBudWxsIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXNlIEJ1cy5UWVBFX0JVSUxEX0VSUk9SOiB7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgc3RhdGUpLCB7IGJ1aWxkRXJyb3I6IGV2Lm1lc3NhZ2UgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhc2UgQnVzLlRZUEVfUkVGRlJFU0g6IHtcclxuICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBzdGF0ZSksIHsgYnVpbGRFcnJvcjogbnVsbCwgZXJyb3JzOiBbXSB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FzZSBCdXMuVFlQRV9VTkhBTkRMRURfRVJST1I6XHJcbiAgICAgICAgY2FzZSBCdXMuVFlQRV9VTkhBTkRMRURfUkVKRUNUSU9OOiB7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgc3RhdGUpLCB7IG5leHRJZDogc3RhdGUubmV4dElkICsgMSwgZXJyb3JzOiBfX3NwcmVhZChzdGF0ZS5lcnJvcnMsIFt7IGlkOiBzdGF0ZS5uZXh0SWQsIGV2ZW50OiBldiB9XSkgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRlZmF1bHQ6IHtcclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xyXG4gICAgICAgICAgICB2YXIgXzEgPSBldjtcclxuICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBSZWFjdERldk92ZXJsYXkoX2EpIHtcclxuICAgIHZhciBjaGlsZHJlbiA9IF9hLmNoaWxkcmVuO1xyXG4gICAgdmFyIF9iID0gX19yZWFkKFJlYWN0LnVzZVJlZHVjZXIocmVkdWNlciwgeyBuZXh0SWQ6IDEsIGJ1aWxkRXJyb3I6IG51bGwsIGVycm9yczogW10gfSksIDIpLCBzdGF0ZSA9IF9iWzBdLCBkaXNwYXRjaCA9IF9iWzFdO1xyXG4gICAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBCdXMub24oZGlzcGF0Y2gpO1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIEJ1cy5vZmYoZGlzcGF0Y2gpO1xyXG4gICAgICAgIH07XHJcbiAgICB9LCBbZGlzcGF0Y2hdKTtcclxuICAgIHZhciBvbkNvbXBvbmVudEVycm9yID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKGVycm9yLCBjb21wb25lbnRTdGFjaykge1xyXG4gICAgICAgIC8vIFRPRE86IHNwZWNpYWwgaGFuZGxpbmdcclxuICAgIH0sIFtdKTtcclxuICAgIHZhciBoYXNCdWlsZEVycm9yID0gc3RhdGUuYnVpbGRFcnJvciAhPSBudWxsO1xyXG4gICAgdmFyIGhhc1J1bnRpbWVFcnJvcnMgPSBCb29sZWFuKHN0YXRlLmVycm9ycy5sZW5ndGgpO1xyXG4gICAgdmFyIGlzTW91bnRlZCA9IGhhc0J1aWxkRXJyb3IgfHwgaGFzUnVudGltZUVycm9ycztcclxuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCxcclxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KEVycm9yQm91bmRhcnlfMS5FcnJvckJvdW5kYXJ5LCB7IG9uRXJyb3I6IG9uQ29tcG9uZW50RXJyb3IgfSwgY2hpbGRyZW4gIT09IG51bGwgJiYgY2hpbGRyZW4gIT09IHZvaWQgMCA/IGNoaWxkcmVuIDogbnVsbCksXHJcbiAgICAgICAgaXNNb3VudGVkID8gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoU2hhZG93UG9ydGFsXzEuU2hhZG93UG9ydGFsLCBudWxsLFxyXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KENzc1Jlc2V0XzEuQ3NzUmVzZXQsIG51bGwpLFxyXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KEJhc2VfMS5CYXNlLCBudWxsKSxcclxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChDb21wb25lbnRTdHlsZXNfMS5Db21wb25lbnRTdHlsZXMsIG51bGwpLFxyXG4gICAgICAgICAgICBoYXNCdWlsZEVycm9yID8gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoQnVpbGRFcnJvcl8xLkJ1aWxkRXJyb3IsIHsgbWVzc2FnZTogc3RhdGUuYnVpbGRFcnJvciB9KSkgOiBoYXNSdW50aW1lRXJyb3JzID8gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoRXJyb3JzXzEuRXJyb3JzLCB7IGVycm9yczogc3RhdGUuZXJyb3JzIH0pKSA6IHVuZGVmaW5lZCkpIDogdW5kZWZpbmVkKSk7XHJcbn1cclxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBSZWFjdERldk92ZXJsYXk7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XHJcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xyXG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXHJcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn07XHJcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XHJcbmV4cG9ydHMuVFlQRV9CVUlMRF9PSyA9ICdidWlsZC1vayc7XHJcbmV4cG9ydHMuVFlQRV9CVUlMRF9FUlJPUiA9ICdidWlsZC1lcnJvcic7XHJcbmV4cG9ydHMuVFlQRV9SRUZGUkVTSCA9ICdmYXN0LXJlZnJlc2gnO1xyXG5leHBvcnRzLlRZUEVfVU5IQU5ETEVEX0VSUk9SID0gJ3VuaGFuZGxlZC1lcnJvcic7XHJcbmV4cG9ydHMuVFlQRV9VTkhBTkRMRURfUkVKRUNUSU9OID0gJ3VuaGFuZGxlZC1yZWplY3Rpb24nO1xyXG52YXIgaGFuZGxlcnMgPSBuZXcgU2V0KCk7XHJcbnZhciBxdWV1ZSA9IFtdO1xyXG5mdW5jdGlvbiBkcmFpbigpIHtcclxuICAgIC8vIERyYWluaW5nIHNob3VsZCBuZXZlciBoYXBwZW4gc3luY2hyb25vdXNseSBpbiBjYXNlIG11bHRpcGxlIGhhbmRsZXJzIGFyZVxyXG4gICAgLy8gcmVnaXN0ZXJlZC5cclxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgZXYgPSBxdWV1ZS5zaGlmdCgpO1xyXG4gICAgICAgICAgICBoYW5kbGVycy5mb3JFYWNoKGZ1bmN0aW9uIChoYW5kbGVyKSB7IHJldHVybiBoYW5kbGVyKGV2KTsgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB3aGlsZSAoXHJcbiAgICAgICAgLy8gVW50aWwgd2UgYXJlIG91dCBvZiBldmVudHM6XHJcbiAgICAgICAgQm9vbGVhbihxdWV1ZS5sZW5ndGgpICYmXHJcbiAgICAgICAgICAgIC8vIE9yLCBpZiBhbGwgaGFuZGxlcnMgcmVtb3ZlZCB0aGVtc2VsdmVzIGFzIGEgcmVzdWx0IG9mIGhhbmRsaW5nIHRoZVxyXG4gICAgICAgICAgICAvLyBldmVudChzKVxyXG4gICAgICAgICAgICBCb29sZWFuKGhhbmRsZXJzLnNpemUpKSB7XHJcbiAgICAgICAgICAgIF9sb29wXzEoKTtcclxuICAgICAgICB9XHJcbiAgICB9LCAxKTtcclxufVxyXG5mdW5jdGlvbiBlbWl0KGV2KSB7XHJcbiAgICBxdWV1ZS5wdXNoKE9iamVjdC5mcmVlemUoX19hc3NpZ24oe30sIGV2KSkpO1xyXG4gICAgZHJhaW4oKTtcclxufVxyXG5leHBvcnRzLmVtaXQgPSBlbWl0O1xyXG5mdW5jdGlvbiBvbihmbikge1xyXG4gICAgaWYgKGhhbmRsZXJzLmhhcyhmbikpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBoYW5kbGVycy5hZGQoZm4pO1xyXG4gICAgZHJhaW4oKTtcclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcbmV4cG9ydHMub24gPSBvbjtcclxuZnVuY3Rpb24gb2ZmKGZuKSB7XHJcbiAgICBpZiAoaGFuZGxlcnMuaGFzKGZuKSkge1xyXG4gICAgICAgIGhhbmRsZXJzW1wiZGVsZXRlXCJdKGZuKTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG5leHBvcnRzLm9mZiA9IG9mZjtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcclxuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcclxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufTtcclxudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcclxufTtcclxudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xyXG4gICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcclxuICAgIHJlc3VsdFtcImRlZmF1bHRcIl0gPSBtb2Q7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xyXG52YXIgYW5zZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiYW5zZXJcIikpO1xyXG52YXIgUmVhY3QgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcInJlYWN0XCIpKTtcclxudmFyIHN0cmlwX2Fuc2lfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwic3RyaXAtYW5zaVwiKSk7XHJcbnZhciBzdGFja19mcmFtZV8xID0gcmVxdWlyZShcIi4uLy4uL2hlbHBlcnMvc3RhY2stZnJhbWVcIik7XHJcbmV4cG9ydHMuQ29kZUZyYW1lID0gZnVuY3Rpb24gQ29kZUZyYW1lKF9hKSB7XHJcbiAgICB2YXIgc3RhY2tGcmFtZSA9IF9hLnN0YWNrRnJhbWUsIGNvZGVGcmFtZSA9IF9hLmNvZGVGcmFtZTtcclxuICAgIC8vIFN0cmlwIGxlYWRpbmcgc3BhY2VzIG91dCBvZiB0aGUgY29kZSBmcmFtZTpcclxuICAgIHZhciBmb3JtYXR0ZWRGcmFtZSA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBsaW5lcyA9IGNvZGVGcmFtZS5zcGxpdCgvXFxyP1xcbi9nKTtcclxuICAgICAgICB2YXIgcHJlZml4TGVuZ3RoID0gbGluZXNcclxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAobGluZSkgeyByZXR1cm4gL14+PyArXFxkKyArXFx8ICggKikvLmV4ZWMoc3RyaXBfYW5zaV8xW1wiZGVmYXVsdFwiXShsaW5lKSk7IH0pXHJcbiAgICAgICAgICAgIC5maWx0ZXIoQm9vbGVhbilcclxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAodikgeyByZXR1cm4gdi5wb3AoKTsgfSlcclxuICAgICAgICAgICAgLnJlZHVjZShmdW5jdGlvbiAoYywgbikgeyByZXR1cm4gKGlzTmFOKGMpID8gbi5sZW5ndGggOiBNYXRoLm1pbihjLCBuLmxlbmd0aCkpOyB9LCBOYU4pO1xyXG4gICAgICAgIGlmIChwcmVmaXhMZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgIHZhciBwXzEgPSAnICcucmVwZWF0KHByZWZpeExlbmd0aCk7XHJcbiAgICAgICAgICAgIHJldHVybiBsaW5lc1xyXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAobGluZSwgYSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIH4oYSA9IGxpbmUuaW5kZXhPZignfCcpKVxyXG4gICAgICAgICAgICAgICAgICAgID8gbGluZS5zdWJzdHJpbmcoMCwgYSkgKyBsaW5lLnN1YnN0cmluZyhhKS5yZXBsYWNlKHBfMSwgJycpXHJcbiAgICAgICAgICAgICAgICAgICAgOiBsaW5lO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLmpvaW4oJ1xcbicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbGluZXMuam9pbignXFxuJyk7XHJcbiAgICB9LCBbY29kZUZyYW1lXSk7XHJcbiAgICB2YXIgZGVjb2RlZCA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBhbnNlcl8xW1wiZGVmYXVsdFwiXS5hbnNpVG9Kc29uKGZvcm1hdHRlZEZyYW1lLCB7XHJcbiAgICAgICAgICAgIGpzb246IHRydWUsXHJcbiAgICAgICAgICAgIHVzZV9jbGFzc2VzOiB0cnVlLFxyXG4gICAgICAgICAgICByZW1vdmVfZW1wdHk6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgIH0sIFtmb3JtYXR0ZWRGcmFtZV0pO1xyXG4gICAgdmFyIG9wZW4gPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHZhciBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XHJcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHN0YWNrRnJhbWUpIHtcclxuICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChrZXksICgoX2EgPSBzdGFja0ZyYW1lW2tleV0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnKS50b1N0cmluZygpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2VsZi5mZXRjaChcIi9fX25leHRqc19sYXVuY2gtZWRpdG9yP1wiICsgcGFyYW1zLnRvU3RyaW5nKCkpLnRoZW4oZnVuY3Rpb24gKCkgeyB9LCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIC8vIFRPRE86IHJlcG9ydCBlcnJvclxyXG4gICAgICAgIH0pO1xyXG4gICAgfSwgW3N0YWNrRnJhbWVdKTtcclxuICAgIC8vIFRPRE86IG1ha2UgdGhlIGNhcmV0IGFic29sdXRlXHJcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBcImRhdGEtbmV4dGpzLWNvZGVmcmFtZVwiOiB0cnVlIH0sXHJcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInBcIiwgeyByb2xlOiBcImxpbmtcIiwgb25DbGljazogb3BlbiwgdGFiSW5kZXg6IDEsIHRpdGxlOiBcIkNsaWNrIHRvIG9wZW4gaW4geW91ciBlZGl0b3JcIiB9LFxyXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCBudWxsLFxyXG4gICAgICAgICAgICAgICAgc3RhY2tfZnJhbWVfMS5nZXRGcmFtZVNvdXJjZShzdGFja0ZyYW1lKSxcclxuICAgICAgICAgICAgICAgIFwiIEAgXCIsXHJcbiAgICAgICAgICAgICAgICBzdGFja0ZyYW1lLm1ldGhvZE5hbWUpLFxyXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3ZnXCIsIHsgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgdmlld0JveDogXCIwIDAgMjQgMjRcIiwgZmlsbDogXCJub25lXCIsIHN0cm9rZTogXCJjdXJyZW50Q29sb3JcIiwgc3Ryb2tlV2lkdGg6IFwiMlwiLCBzdHJva2VMaW5lY2FwOiBcInJvdW5kXCIsIHN0cm9rZUxpbmVqb2luOiBcInJvdW5kXCIgfSxcclxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHsgZDogXCJNMTggMTN2NmEyIDIgMCAwIDEtMiAySDVhMiAyIDAgMCAxLTItMlY4YTIgMiAwIDAgMSAyLTJoNlwiIH0pLFxyXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInBvbHlsaW5lXCIsIHsgcG9pbnRzOiBcIjE1IDMgMjEgMyAyMSA5XCIgfSksXHJcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwibGluZVwiLCB7IHgxOiBcIjEwXCIsIHkxOiBcIjE0XCIsIHgyOiBcIjIxXCIsIHkyOiBcIjNcIiB9KSkpLFxyXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJoclwiLCBudWxsKSxcclxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwicHJlXCIsIG51bGwsIGRlY29kZWQubWFwKGZ1bmN0aW9uIChlbnRyeSwgaW5kZXgpIHsgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7IGtleTogXCJmcmFtZS1cIiArIGluZGV4LCBzdHlsZTogX19hc3NpZ24oeyBjb2xvcjogZW50cnkuZmcgPyBcInZhcigtLWNvbG9yLVwiICsgZW50cnkuZmcgKyBcIilcIiA6IHVuZGVmaW5lZCB9LCAoZW50cnkuZGVjb3JhdGlvbiA9PT0gJ2JvbGQnXHJcbiAgICAgICAgICAgICAgICA/IHsgZm9udFdlaWdodDogODAwIH1cclxuICAgICAgICAgICAgICAgIDogZW50cnkuZGVjb3JhdGlvbiA9PT0gJ2l0YWxpYydcclxuICAgICAgICAgICAgICAgICAgICA/IHsgZm9udFN0eWxlOiAnaXRhbGljJyB9XHJcbiAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpKSB9LCBlbnRyeS5jb250ZW50KSk7IH0pKSkpO1xyXG59O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxudmFyIENvZGVGcmFtZV8xID0gcmVxdWlyZShcIi4vQ29kZUZyYW1lXCIpO1xyXG5leHBvcnRzLkNvZGVGcmFtZSA9IENvZGVGcmFtZV8xLkNvZGVGcmFtZTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX21ha2VUZW1wbGF0ZU9iamVjdCA9ICh0aGlzICYmIHRoaXMuX19tYWtlVGVtcGxhdGVPYmplY3QpIHx8IGZ1bmN0aW9uIChjb29rZWQsIHJhdykge1xyXG4gICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cclxuICAgIHJldHVybiBjb29rZWQ7XHJcbn07XHJcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XHJcbnZhciBub29wX3RlbXBsYXRlXzEgPSByZXF1aXJlKFwiLi4vLi4vaGVscGVycy9ub29wLXRlbXBsYXRlXCIpO1xyXG52YXIgc3R5bGVzID0gbm9vcF90ZW1wbGF0ZV8xLm5vb3AodGVtcGxhdGVPYmplY3RfMSB8fCAodGVtcGxhdGVPYmplY3RfMSA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcbiAgW2RhdGEtbmV4dGpzLWNvZGVmcmFtZV0ge1xcbiAgICBib3JkZXItcmFkaXVzOiB2YXIoLS1zaXplLWdhcC1oYWxmKTtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tY29sb3ItYW5zaS1iZyk7XFxuICAgIGNvbG9yOiB2YXIoLS1jb2xvci1hbnNpLWZnKTtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1jb2RlZnJhbWVdOjpzZWxlY3Rpb24sXFxuICBbZGF0YS1uZXh0anMtY29kZWZyYW1lXSAqOjpzZWxlY3Rpb24ge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1jb2xvci1hbnNpLXNlbGVjdGlvbik7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtY29kZWZyYW1lXSAqIHtcXG4gICAgY29sb3I6IGluaGVyaXQ7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgICBmb250LWZhbWlseTogdmFyKC0tZm9udC1zdGFjay1tb25vc3BhY2UpO1xcbiAgfVxcblxcbiAgW2RhdGEtbmV4dGpzLWNvZGVmcmFtZV0gPiAqIHtcXG4gICAgbWFyZ2luOiAwO1xcbiAgICBwYWRkaW5nOiBjYWxjKHZhcigtLXNpemUtZ2FwKSArIHZhcigtLXNpemUtZ2FwLWhhbGYpKVxcbiAgICAgIGNhbGModmFyKC0tc2l6ZS1nYXAtZG91YmxlKSArIHZhcigtLXNpemUtZ2FwLWhhbGYpKTtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1jb2RlZnJhbWVdID4gaHIge1xcbiAgICBtYXJnaW46IDA7XFxuICAgIHBhZGRpbmc6IDA7XFxuXFxuICAgIGJvcmRlcjogbm9uZTtcXG4gICAgYm9yZGVyLXN0eWxlOiBzb2xpZDtcXG4gICAgYm9yZGVyLXdpZHRoOiAwO1xcbiAgICBib3JkZXItYm90dG9tLXdpZHRoOiAxcHg7XFxuICAgIGJvcmRlci1jb2xvcjogdmFyKC0tY29sb3ItYW5zaS1icmlnaHQtYmxhY2spO1xcbiAgfVxcblxcbiAgW2RhdGEtbmV4dGpzLWNvZGVmcmFtZV0gPiBwIHtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtY29kZWZyYW1lXSA+IHA6aG92ZXIge1xcbiAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZSBkb3R0ZWQ7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtY29kZWZyYW1lXSA+IHAgPiBzdmcge1xcbiAgICB3aWR0aDogYXV0bztcXG4gICAgaGVpZ2h0OiAxZW07XFxuICAgIG1hcmdpbi1sZWZ0OiAwLjVyZW07XFxuICB9XFxuXCJdLCBbXCJcXG4gIFtkYXRhLW5leHRqcy1jb2RlZnJhbWVdIHtcXG4gICAgYm9yZGVyLXJhZGl1czogdmFyKC0tc2l6ZS1nYXAtaGFsZik7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWNvbG9yLWFuc2ktYmcpO1xcbiAgICBjb2xvcjogdmFyKC0tY29sb3ItYW5zaS1mZyk7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtY29kZWZyYW1lXTo6c2VsZWN0aW9uLFxcbiAgW2RhdGEtbmV4dGpzLWNvZGVmcmFtZV0gKjo6c2VsZWN0aW9uIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tY29sb3ItYW5zaS1zZWxlY3Rpb24pO1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWNvZGVmcmFtZV0gKiB7XFxuICAgIGNvbG9yOiBpbmhlcml0O1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gICAgZm9udC1mYW1pbHk6IHZhcigtLWZvbnQtc3RhY2stbW9ub3NwYWNlKTtcXG4gIH1cXG5cXG4gIFtkYXRhLW5leHRqcy1jb2RlZnJhbWVdID4gKiB7XFxuICAgIG1hcmdpbjogMDtcXG4gICAgcGFkZGluZzogY2FsYyh2YXIoLS1zaXplLWdhcCkgKyB2YXIoLS1zaXplLWdhcC1oYWxmKSlcXG4gICAgICBjYWxjKHZhcigtLXNpemUtZ2FwLWRvdWJsZSkgKyB2YXIoLS1zaXplLWdhcC1oYWxmKSk7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtY29kZWZyYW1lXSA+IGhyIHtcXG4gICAgbWFyZ2luOiAwO1xcbiAgICBwYWRkaW5nOiAwO1xcblxcbiAgICBib3JkZXI6IG5vbmU7XFxuICAgIGJvcmRlci1zdHlsZTogc29saWQ7XFxuICAgIGJvcmRlci13aWR0aDogMDtcXG4gICAgYm9yZGVyLWJvdHRvbS13aWR0aDogMXB4O1xcbiAgICBib3JkZXItY29sb3I6IHZhcigtLWNvbG9yLWFuc2ktYnJpZ2h0LWJsYWNrKTtcXG4gIH1cXG5cXG4gIFtkYXRhLW5leHRqcy1jb2RlZnJhbWVdID4gcCB7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcXG4gICAgY3Vyc29yOiBwb2ludGVyO1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWNvZGVmcmFtZV0gPiBwOmhvdmVyIHtcXG4gICAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmUgZG90dGVkO1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWNvZGVmcmFtZV0gPiBwID4gc3ZnIHtcXG4gICAgd2lkdGg6IGF1dG87XFxuICAgIGhlaWdodDogMWVtO1xcbiAgICBtYXJnaW4tbGVmdDogMC41cmVtO1xcbiAgfVxcblwiXSkpKTtcclxuZXhwb3J0cy5zdHlsZXMgPSBzdHlsZXM7XHJcbnZhciB0ZW1wbGF0ZU9iamVjdF8xO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fcmVzdCA9ICh0aGlzICYmIHRoaXMuX19yZXN0KSB8fCBmdW5jdGlvbiAocywgZSkge1xyXG4gICAgdmFyIHQgPSB7fTtcclxuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxyXG4gICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxyXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XHJcbiAgICAgICAgfVxyXG4gICAgcmV0dXJuIHQ7XHJcbn07XHJcbnZhciBfX3JlYWQgPSAodGhpcyAmJiB0aGlzLl9fcmVhZCkgfHwgZnVuY3Rpb24gKG8sIG4pIHtcclxuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcclxuICAgIGlmICghbSkgcmV0dXJuIG87XHJcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cclxuICAgIGZpbmFsbHkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cclxuICAgIH1cclxuICAgIHJldHVybiBhcjtcclxufTtcclxudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xyXG4gICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcclxuICAgIHJlc3VsdFtcImRlZmF1bHRcIl0gPSBtb2Q7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xyXG52YXIgUmVhY3QgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcInJlYWN0XCIpKTtcclxudmFyIHVzZV9vbl9jbGlja19vdXRzaWRlXzEgPSByZXF1aXJlKFwiLi4vLi4vaG9va3MvdXNlLW9uLWNsaWNrLW91dHNpZGVcIik7XHJcbnZhciBEaWFsb2cgPSBmdW5jdGlvbiBEaWFsb2coX2EpIHtcclxuICAgIHZhciBjaGlsZHJlbiA9IF9hLmNoaWxkcmVuLCB0eXBlID0gX2EudHlwZSwgb25DbG9zZSA9IF9hLm9uQ2xvc2UsIHByb3BzID0gX19yZXN0KF9hLCBbXCJjaGlsZHJlblwiLCBcInR5cGVcIiwgXCJvbkNsb3NlXCJdKTtcclxuICAgIHZhciBfYiA9IF9fcmVhZChSZWFjdC51c2VTdGF0ZShudWxsKSwgMiksIGRpYWxvZyA9IF9iWzBdLCBzZXREaWFsb2cgPSBfYlsxXTtcclxuICAgIHZhciBvbkRpYWxvZyA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgc2V0RGlhbG9nKG5vZGUpO1xyXG4gICAgfSwgW10pO1xyXG4gICAgdXNlX29uX2NsaWNrX291dHNpZGVfMS51c2VPbkNsaWNrT3V0c2lkZShkaWFsb2csIG9uQ2xvc2UpO1xyXG4gICAgLy8gTWFrZSBIVE1MRWxlbWVudHMgd2l0aCBgcm9sZT1saW5rYCBhY2Nlc3NpYmxlIHRvIGJlIHRyaWdnZXJlZCBieSB0aGVcclxuICAgIC8vIGtleWJvYXJkLCBpLmUuIFtFbnRlcl0uXHJcbiAgICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChkaWFsb2cgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciByb290ID0gZGlhbG9nLmdldFJvb3ROb2RlKCk7XHJcbiAgICAgICAgLy8gQWx3YXlzIHRydWUsIGJ1dCB3ZSBkbyB0aGlzIGZvciBUeXBlU2NyaXB0OlxyXG4gICAgICAgIGlmICghKHJvb3QgaW5zdGFuY2VvZiBTaGFkb3dSb290KSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBzaGFkb3dSb290ID0gcm9vdDtcclxuICAgICAgICBmdW5jdGlvbiBoYW5kbGVyKGUpIHtcclxuICAgICAgICAgICAgdmFyIGVsID0gc2hhZG93Um9vdC5hY3RpdmVFbGVtZW50O1xyXG4gICAgICAgICAgICBpZiAoZS5rZXkgPT09ICdFbnRlcicgJiZcclxuICAgICAgICAgICAgICAgIGVsIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgJiZcclxuICAgICAgICAgICAgICAgIGVsLmdldEF0dHJpYnV0ZSgncm9sZScpID09PSAnbGluaycpIHtcclxuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICBlbC5jbGljaygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNoYWRvd1Jvb3QuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGhhbmRsZXIpO1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBzaGFkb3dSb290LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBoYW5kbGVyKTsgfTtcclxuICAgIH0sIFtkaWFsb2ddKTtcclxuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHJlZjogb25EaWFsb2csIFwiZGF0YS1uZXh0anMtZGlhbG9nXCI6IHRydWUsIHRhYkluZGV4OiAtMSwgcm9sZTogXCJkaWFsb2dcIiwgXCJhcmlhLWxhYmVsbGVkYnlcIjogcHJvcHNbJ2FyaWEtbGFiZWxsZWRieSddLCBcImFyaWEtZGVzY3JpYmVkYnlcIjogcHJvcHNbJ2FyaWEtZGVzY3JpYmVkYnknXSwgXCJhcmlhLW1vZGFsXCI6IFwidHJ1ZVwiIH0sXHJcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IFwiZGF0YS1uZXh0anMtZGlhbG9nLWJhbm5lclwiOiB0cnVlLCBjbGFzc05hbWU6IFwiYmFubmVyLVwiICsgdHlwZSB9KSxcclxuICAgICAgICBjaGlsZHJlbikpO1xyXG59O1xyXG5leHBvcnRzLkRpYWxvZyA9IERpYWxvZztcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcclxuICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XHJcbiAgICByZXN1bHRbXCJkZWZhdWx0XCJdID0gbW9kO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxudmFyIFJlYWN0ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJyZWFjdFwiKSk7XHJcbnZhciBEaWFsb2dCb2R5ID0gZnVuY3Rpb24gRGlhbG9nQm9keShfYSkge1xyXG4gICAgdmFyIGNoaWxkcmVuID0gX2EuY2hpbGRyZW4sIGNsYXNzTmFtZSA9IF9hLmNsYXNzTmFtZTtcclxuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IFwiZGF0YS1uZXh0anMtZGlhbG9nLWJvZHlcIjogdHJ1ZSwgY2xhc3NOYW1lOiBjbGFzc05hbWUgfSwgY2hpbGRyZW4pKTtcclxufTtcclxuZXhwb3J0cy5EaWFsb2dCb2R5ID0gRGlhbG9nQm9keTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcclxuICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XHJcbiAgICByZXN1bHRbXCJkZWZhdWx0XCJdID0gbW9kO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxudmFyIFJlYWN0ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJyZWFjdFwiKSk7XHJcbnZhciBEaWFsb2dDb250ZW50ID0gZnVuY3Rpb24gRGlhbG9nQ29udGVudChfYSkge1xyXG4gICAgdmFyIGNoaWxkcmVuID0gX2EuY2hpbGRyZW4sIGNsYXNzTmFtZSA9IF9hLmNsYXNzTmFtZTtcclxuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IFwiZGF0YS1uZXh0anMtZGlhbG9nLWNvbnRlbnRcIjogdHJ1ZSwgY2xhc3NOYW1lOiBjbGFzc05hbWUgfSwgY2hpbGRyZW4pKTtcclxufTtcclxuZXhwb3J0cy5EaWFsb2dDb250ZW50ID0gRGlhbG9nQ29udGVudDtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcclxuICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XHJcbiAgICByZXN1bHRbXCJkZWZhdWx0XCJdID0gbW9kO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxudmFyIFJlYWN0ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJyZWFjdFwiKSk7XHJcbnZhciBEaWFsb2dIZWFkZXIgPSBmdW5jdGlvbiBEaWFsb2dIZWFkZXIoX2EpIHtcclxuICAgIHZhciBjaGlsZHJlbiA9IF9hLmNoaWxkcmVuLCBjbGFzc05hbWUgPSBfYS5jbGFzc05hbWU7XHJcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBcImRhdGEtbmV4dGpzLWRpYWxvZy1oZWFkZXJcIjogdHJ1ZSwgY2xhc3NOYW1lOiBjbGFzc05hbWUgfSwgY2hpbGRyZW4pKTtcclxufTtcclxuZXhwb3J0cy5EaWFsb2dIZWFkZXIgPSBEaWFsb2dIZWFkZXI7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xyXG52YXIgRGlhbG9nXzEgPSByZXF1aXJlKFwiLi9EaWFsb2dcIik7XHJcbmV4cG9ydHMuRGlhbG9nID0gRGlhbG9nXzEuRGlhbG9nO1xyXG52YXIgRGlhbG9nQm9keV8xID0gcmVxdWlyZShcIi4vRGlhbG9nQm9keVwiKTtcclxuZXhwb3J0cy5EaWFsb2dCb2R5ID0gRGlhbG9nQm9keV8xLkRpYWxvZ0JvZHk7XHJcbnZhciBEaWFsb2dDb250ZW50XzEgPSByZXF1aXJlKFwiLi9EaWFsb2dDb250ZW50XCIpO1xyXG5leHBvcnRzLkRpYWxvZ0NvbnRlbnQgPSBEaWFsb2dDb250ZW50XzEuRGlhbG9nQ29udGVudDtcclxudmFyIERpYWxvZ0hlYWRlcl8xID0gcmVxdWlyZShcIi4vRGlhbG9nSGVhZGVyXCIpO1xyXG5leHBvcnRzLkRpYWxvZ0hlYWRlciA9IERpYWxvZ0hlYWRlcl8xLkRpYWxvZ0hlYWRlcjtcclxudmFyIHN0eWxlc18xID0gcmVxdWlyZShcIi4vc3R5bGVzXCIpO1xyXG5leHBvcnRzLnN0eWxlcyA9IHN0eWxlc18xLnN0eWxlcztcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX21ha2VUZW1wbGF0ZU9iamVjdCA9ICh0aGlzICYmIHRoaXMuX19tYWtlVGVtcGxhdGVPYmplY3QpIHx8IGZ1bmN0aW9uIChjb29rZWQsIHJhdykge1xyXG4gICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cclxuICAgIHJldHVybiBjb29rZWQ7XHJcbn07XHJcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XHJcbnZhciBub29wX3RlbXBsYXRlXzEgPSByZXF1aXJlKFwiLi4vLi4vaGVscGVycy9ub29wLXRlbXBsYXRlXCIpO1xyXG52YXIgc3R5bGVzID0gbm9vcF90ZW1wbGF0ZV8xLm5vb3AodGVtcGxhdGVPYmplY3RfMSB8fCAodGVtcGxhdGVPYmplY3RfMSA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZ10ge1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbiAgICB3aWR0aDogMTAwJTtcXG4gICAgbWFyZ2luLXJpZ2h0OiBhdXRvO1xcbiAgICBtYXJnaW4tbGVmdDogYXV0bztcXG4gICAgb3V0bGluZTogbm9uZTtcXG4gICAgYmFja2dyb3VuZDogd2hpdGU7XFxuICAgIGJvcmRlci1yYWRpdXM6IHZhcigtLXNpemUtZ2FwKTtcXG4gICAgYm94LXNoYWRvdzogMCB2YXIoLS1zaXplLWdhcC1oYWxmKSB2YXIoLS1zaXplLWdhcC1kb3VibGUpXFxuICAgICAgcmdiYSgwLCAwLCAwLCAwLjI1KTtcXG4gICAgbWF4LWhlaWdodDogY2FsYygxMDAlIC0gMy41cmVtKTtcXG4gICAgb3ZlcmZsb3cteTogaGlkZGVuO1xcbiAgfVxcblxcbiAgQG1lZGlhIChtaW4td2lkdGg6IDU3NnB4KSB7XFxuICAgIFtkYXRhLW5leHRqcy1kaWFsb2ddIHtcXG4gICAgICBtYXgtd2lkdGg6IDU0MHB4O1xcbiAgICAgIGJveC1zaGFkb3c6IDAgdmFyKC0tc2l6ZS1nYXApIHZhcigtLXNpemUtZ2FwLXF1YWQpIHJnYmEoMCwgMCwgMCwgMC4yNSk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIEBtZWRpYSAobWluLXdpZHRoOiA3NjhweCkge1xcbiAgICBbZGF0YS1uZXh0anMtZGlhbG9nXSB7XFxuICAgICAgbWF4LXdpZHRoOiA3MjBweDtcXG4gICAgfVxcbiAgfVxcblxcbiAgQG1lZGlhIChtaW4td2lkdGg6IDk5MnB4KSB7XFxuICAgIFtkYXRhLW5leHRqcy1kaWFsb2ddIHtcXG4gICAgICBtYXgtd2lkdGg6IDk2MHB4O1xcbiAgICB9XFxuICB9XFxuXFxuICBbZGF0YS1uZXh0anMtZGlhbG9nLWJhbm5lcl0ge1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtZGlhbG9nLWJhbm5lcl0uYmFubmVyLXdhcm5pbmcge1xcbiAgICBib3JkZXItY29sb3I6IHZhcigtLWNvbG9yLWFuc2kteWVsbG93KTtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctYmFubmVyXS5iYW5uZXItZXJyb3Ige1xcbiAgICBib3JkZXItY29sb3I6IHZhcigtLWNvbG9yLWFuc2ktcmVkKTtcXG4gIH1cXG5cXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctYmFubmVyXTo6YWZ0ZXIge1xcbiAgICB6LWluZGV4OiAyO1xcbiAgICBjb250ZW50OiAnJztcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICB0b3A6IDA7XFxuICAgIHJpZ2h0OiAwO1xcbiAgICB3aWR0aDogMTAwJTtcXG4gICAgLyogYmFubmVyIHdpZHRoOiAqL1xcbiAgICBib3JkZXItdG9wLXdpZHRoOiB2YXIoLS1zaXplLWdhcC1oYWxmKTtcXG4gICAgYm9yZGVyLWJvdHRvbS13aWR0aDogMDtcXG4gICAgYm9yZGVyLXRvcC1zdHlsZTogc29saWQ7XFxuICAgIGJvcmRlci1ib3R0b20tc3R5bGU6IHNvbGlkO1xcbiAgICBib3JkZXItdG9wLWNvbG9yOiBpbmhlcml0O1xcbiAgICBib3JkZXItYm90dG9tLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gIH1cXG5cXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctY29udGVudF0ge1xcbiAgICBvdmVyZmxvdy15OiBhdXRvO1xcbiAgICBib3JkZXI6IG5vbmU7XFxuICAgIG1hcmdpbjogMDtcXG4gICAgLyogY2FsYyhwYWRkaW5nICsgYmFubmVyIHdpZHRoIG9mZnNldCkgKi9cXG4gICAgcGFkZGluZzogY2FsYyh2YXIoLS1zaXplLWdhcC1kb3VibGUpICsgdmFyKC0tc2l6ZS1nYXAtaGFsZikpXFxuICAgICAgdmFyKC0tc2l6ZS1nYXAtZG91YmxlKTtcXG4gICAgaGVpZ2h0OiAxMDAlO1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1jb250ZW50XSA+IFtkYXRhLW5leHRqcy1kaWFsb2ctaGVhZGVyXSB7XFxuICAgIGZsZXgtc2hyaW5rOiAwO1xcbiAgICBtYXJnaW4tYm90dG9tOiB2YXIoLS1zaXplLWdhcC1kb3VibGUpO1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1jb250ZW50XSA+IFtkYXRhLW5leHRqcy1kaWFsb2ctYm9keV0ge1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAgIGZsZXg6IDEgMSBhdXRvO1xcbiAgfVxcblwiXSwgW1wiXFxuICBbZGF0YS1uZXh0anMtZGlhbG9nXSB7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBtYXJnaW4tcmlnaHQ6IGF1dG87XFxuICAgIG1hcmdpbi1sZWZ0OiBhdXRvO1xcbiAgICBvdXRsaW5lOiBub25lO1xcbiAgICBiYWNrZ3JvdW5kOiB3aGl0ZTtcXG4gICAgYm9yZGVyLXJhZGl1czogdmFyKC0tc2l6ZS1nYXApO1xcbiAgICBib3gtc2hhZG93OiAwIHZhcigtLXNpemUtZ2FwLWhhbGYpIHZhcigtLXNpemUtZ2FwLWRvdWJsZSlcXG4gICAgICByZ2JhKDAsIDAsIDAsIDAuMjUpO1xcbiAgICBtYXgtaGVpZ2h0OiBjYWxjKDEwMCUgLSAzLjVyZW0pO1xcbiAgICBvdmVyZmxvdy15OiBoaWRkZW47XFxuICB9XFxuXFxuICBAbWVkaWEgKG1pbi13aWR0aDogNTc2cHgpIHtcXG4gICAgW2RhdGEtbmV4dGpzLWRpYWxvZ10ge1xcbiAgICAgIG1heC13aWR0aDogNTQwcHg7XFxuICAgICAgYm94LXNoYWRvdzogMCB2YXIoLS1zaXplLWdhcCkgdmFyKC0tc2l6ZS1nYXAtcXVhZCkgcmdiYSgwLCAwLCAwLCAwLjI1KTtcXG4gICAgfVxcbiAgfVxcblxcbiAgQG1lZGlhIChtaW4td2lkdGg6IDc2OHB4KSB7XFxuICAgIFtkYXRhLW5leHRqcy1kaWFsb2ddIHtcXG4gICAgICBtYXgtd2lkdGg6IDcyMHB4O1xcbiAgICB9XFxuICB9XFxuXFxuICBAbWVkaWEgKG1pbi13aWR0aDogOTkycHgpIHtcXG4gICAgW2RhdGEtbmV4dGpzLWRpYWxvZ10ge1xcbiAgICAgIG1heC13aWR0aDogOTYwcHg7XFxuICAgIH1cXG4gIH1cXG5cXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctYmFubmVyXSB7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctYmFubmVyXS5iYW5uZXItd2FybmluZyB7XFxuICAgIGJvcmRlci1jb2xvcjogdmFyKC0tY29sb3ItYW5zaS15ZWxsb3cpO1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1iYW5uZXJdLmJhbm5lci1lcnJvciB7XFxuICAgIGJvcmRlci1jb2xvcjogdmFyKC0tY29sb3ItYW5zaS1yZWQpO1xcbiAgfVxcblxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1iYW5uZXJdOjphZnRlciB7XFxuICAgIHotaW5kZXg6IDI7XFxuICAgIGNvbnRlbnQ6ICcnO1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIHRvcDogMDtcXG4gICAgcmlnaHQ6IDA7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICAvKiBiYW5uZXIgd2lkdGg6ICovXFxuICAgIGJvcmRlci10b3Atd2lkdGg6IHZhcigtLXNpemUtZ2FwLWhhbGYpO1xcbiAgICBib3JkZXItYm90dG9tLXdpZHRoOiAwO1xcbiAgICBib3JkZXItdG9wLXN0eWxlOiBzb2xpZDtcXG4gICAgYm9yZGVyLWJvdHRvbS1zdHlsZTogc29saWQ7XFxuICAgIGJvcmRlci10b3AtY29sb3I6IGluaGVyaXQ7XFxuICAgIGJvcmRlci1ib3R0b20tY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgfVxcblxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1jb250ZW50XSB7XFxuICAgIG92ZXJmbG93LXk6IGF1dG87XFxuICAgIGJvcmRlcjogbm9uZTtcXG4gICAgbWFyZ2luOiAwO1xcbiAgICAvKiBjYWxjKHBhZGRpbmcgKyBiYW5uZXIgd2lkdGggb2Zmc2V0KSAqL1xcbiAgICBwYWRkaW5nOiBjYWxjKHZhcigtLXNpemUtZ2FwLWRvdWJsZSkgKyB2YXIoLS1zaXplLWdhcC1oYWxmKSlcXG4gICAgICB2YXIoLS1zaXplLWdhcC1kb3VibGUpO1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICB9XFxuICBbZGF0YS1uZXh0anMtZGlhbG9nLWNvbnRlbnRdID4gW2RhdGEtbmV4dGpzLWRpYWxvZy1oZWFkZXJdIHtcXG4gICAgZmxleC1zaHJpbms6IDA7XFxuICAgIG1hcmdpbi1ib3R0b206IHZhcigtLXNpemUtZ2FwLWRvdWJsZSk7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtZGlhbG9nLWNvbnRlbnRdID4gW2RhdGEtbmV4dGpzLWRpYWxvZy1ib2R5XSB7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgZmxleDogMSAxIGF1dG87XFxuICB9XFxuXCJdKSkpO1xyXG5leHBvcnRzLnN0eWxlcyA9IHN0eWxlcztcclxudmFyIHRlbXBsYXRlT2JqZWN0XzE7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XHJcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XHJcbiAgICBpZiAoIW0pIHJldHVybiBvO1xyXG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XHJcbiAgICBmaW5hbGx5IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXI7XHJcbn07XHJcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcclxuICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XHJcbiAgICByZXN1bHRbXCJkZWZhdWx0XCJdID0gbW9kO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxudmFyIFJlYWN0ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJyZWFjdFwiKSk7XHJcbnZhciBMZWZ0UmlnaHREaWFsb2dIZWFkZXIgPSBmdW5jdGlvbiBMZWZ0UmlnaHREaWFsb2dIZWFkZXIoX2EpIHtcclxuICAgIHZhciBjaGlsZHJlbiA9IF9hLmNoaWxkcmVuLCBjbGFzc05hbWUgPSBfYS5jbGFzc05hbWUsIHByZXZpb3VzID0gX2EucHJldmlvdXMsIG5leHQgPSBfYS5uZXh0LCBjbG9zZSA9IF9hLmNsb3NlO1xyXG4gICAgdmFyIGJ1dHRvbkxlZnQgPSBSZWFjdC51c2VSZWYoKTtcclxuICAgIHZhciBidXR0b25SaWdodCA9IFJlYWN0LnVzZVJlZigpO1xyXG4gICAgdmFyIGJ1dHRvbkNsb3NlID0gUmVhY3QudXNlUmVmKCk7XHJcbiAgICB2YXIgX2IgPSBfX3JlYWQoUmVhY3QudXNlU3RhdGUobnVsbCksIDIpLCBuYXYgPSBfYlswXSwgc2V0TmF2ID0gX2JbMV07XHJcbiAgICB2YXIgb25OYXYgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoZWwpIHtcclxuICAgICAgICBzZXROYXYoZWwpO1xyXG4gICAgfSwgW10pO1xyXG4gICAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAobmF2ID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcm9vdCA9IG5hdi5nZXRSb290Tm9kZSgpO1xyXG4gICAgICAgIHZhciBkID0gc2VsZi5kb2N1bWVudDtcclxuICAgICAgICBmdW5jdGlvbiBoYW5kbGVyKGUpIHtcclxuICAgICAgICAgICAgaWYgKGUua2V5ID09PSAnQXJyb3dMZWZ0Jykge1xyXG4gICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAgICAgICAgIGlmIChidXR0b25MZWZ0LmN1cnJlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBidXR0b25MZWZ0LmN1cnJlbnQuZm9jdXMoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHByZXZpb3VzICYmIHByZXZpb3VzKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoZS5rZXkgPT09ICdBcnJvd1JpZ2h0Jykge1xyXG4gICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAgICAgICAgIGlmIChidXR0b25SaWdodC5jdXJyZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnV0dG9uUmlnaHQuY3VycmVudC5mb2N1cygpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbmV4dCAmJiBuZXh0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoZS5rZXkgPT09ICdFc2NhcGUnKSB7XHJcbiAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJvb3QgaW5zdGFuY2VvZiBTaGFkb3dSb290KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSByb290LmFjdGl2ZUVsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGEgJiYgYSAhPT0gYnV0dG9uQ2xvc2UuY3VycmVudCAmJiBhIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYS5ibHVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjbG9zZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJvb3QuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGhhbmRsZXIpO1xyXG4gICAgICAgIGlmIChyb290ICE9PSBkKSB7XHJcbiAgICAgICAgICAgIGQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGhhbmRsZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByb290LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBoYW5kbGVyKTtcclxuICAgICAgICAgICAgaWYgKHJvb3QgIT09IGQpIHtcclxuICAgICAgICAgICAgICAgIGQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGhhbmRsZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH0sIFtjbG9zZSwgbmF2LCBuZXh0LCBwcmV2aW91c10pO1xyXG4gICAgLy8gVW5sb2NrIGZvY3VzIGZvciBicm93c2VycyBsaWtlIEZpcmVmb3gsIHRoYXQgYnJlYWsgYWxsIHVzZXIgZm9jdXMgaWYgdGhlXHJcbiAgICAvLyBjdXJyZW50bHkgZm9jdXNlZCBpdGVtIGJlY29tZXMgZGlzYWJsZWQuXHJcbiAgICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChuYXYgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciByb290ID0gbmF2LmdldFJvb3ROb2RlKCk7XHJcbiAgICAgICAgLy8gQWx3YXlzIHRydWUsIGJ1dCB3ZSBkbyB0aGlzIGZvciBUeXBlU2NyaXB0OlxyXG4gICAgICAgIGlmIChyb290IGluc3RhbmNlb2YgU2hhZG93Um9vdCkge1xyXG4gICAgICAgICAgICB2YXIgYSA9IHJvb3QuYWN0aXZlRWxlbWVudDtcclxuICAgICAgICAgICAgaWYgKHByZXZpb3VzID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGlmIChhID09PSBidXR0b25MZWZ0LmN1cnJlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBidXR0b25MZWZ0LmN1cnJlbnQuYmx1cigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG5leHQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGEgPT09IGJ1dHRvblJpZ2h0LmN1cnJlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBidXR0b25SaWdodC5jdXJyZW50LmJsdXIoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sIFtuYXYsIG5leHQsIHByZXZpb3VzXSk7XHJcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBcImRhdGEtbmV4dGpzLWRpYWxvZy1sZWZ0LXJpZ2h0XCI6IHRydWUsIGNsYXNzTmFtZTogY2xhc3NOYW1lIH0sXHJcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcIm5hdlwiLCB7IHJlZjogb25OYXYgfSxcclxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLCB7IHJlZjogYnV0dG9uTGVmdCwgdHlwZTogXCJidXR0b25cIiwgZGlzYWJsZWQ6IHByZXZpb3VzID09IG51bGwgPyB0cnVlIDogdW5kZWZpbmVkLCBcImFyaWEtZGlzYWJsZWRcIjogcHJldmlvdXMgPT0gbnVsbCA/IHRydWUgOiB1bmRlZmluZWQsIG9uQ2xpY2s6IHByZXZpb3VzICE9PSBudWxsICYmIHByZXZpb3VzICE9PSB2b2lkIDAgPyBwcmV2aW91cyA6IHVuZGVmaW5lZCB9LFxyXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInN2Z1wiLCB7IHZpZXdCb3g6IFwiMCAwIDE0IDE0XCIsIGZpbGw6IFwibm9uZVwiLCB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInBhdGhcIiwgeyBkOiBcIk02Ljk5OTk2IDEuMTY2NjZMMS4xNjY2MyA2Ljk5OTk5TDYuOTk5OTYgMTIuODMzM00xMi44MzMzIDYuOTk5OTlIMS45OTk5NkgxMi44MzMzWlwiLCBzdHJva2U6IFwiY3VycmVudENvbG9yXCIsIHN0cm9rZVdpZHRoOiBcIjJcIiwgc3Ryb2tlTGluZWNhcDogXCJyb3VuZFwiLCBzdHJva2VMaW5lam9pbjogXCJyb3VuZFwiIH0pKSksXHJcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiwgeyByZWY6IGJ1dHRvblJpZ2h0LCB0eXBlOiBcImJ1dHRvblwiLCBkaXNhYmxlZDogbmV4dCA9PSBudWxsID8gdHJ1ZSA6IHVuZGVmaW5lZCwgXCJhcmlhLWRpc2FibGVkXCI6IG5leHQgPT0gbnVsbCA/IHRydWUgOiB1bmRlZmluZWQsIG9uQ2xpY2s6IG5leHQgIT09IG51bGwgJiYgbmV4dCAhPT0gdm9pZCAwID8gbmV4dCA6IHVuZGVmaW5lZCB9LFxyXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInN2Z1wiLCB7IHZpZXdCb3g6IFwiMCAwIDE0IDE0XCIsIGZpbGw6IFwibm9uZVwiLCB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInBhdGhcIiwgeyBkOiBcIk02Ljk5OTk2IDEuMTY2NjZMMTIuODMzMyA2Ljk5OTk5TDYuOTk5OTYgMTIuODMzM00xLjE2NjYzIDYuOTk5OTlIMTJIMS4xNjY2M1pcIiwgc3Ryb2tlOiBcImN1cnJlbnRDb2xvclwiLCBzdHJva2VXaWR0aDogXCIyXCIsIHN0cm9rZUxpbmVjYXA6IFwicm91bmRcIiwgc3Ryb2tlTGluZWpvaW46IFwicm91bmRcIiB9KSkpLFxyXG4gICAgICAgICAgICBcIlxcdTAwQTBcIixcclxuICAgICAgICAgICAgY2hpbGRyZW4pLFxyXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiwgeyByZWY6IGJ1dHRvbkNsb3NlLCB0eXBlOiBcImJ1dHRvblwiLCBvbkNsaWNrOiBjbG9zZSwgXCJhcmlhLWxhYmVsXCI6IFwiQ2xvc2VcIiB9LFxyXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7IFwiYXJpYS1oaWRkZW5cIjogXCJ0cnVlXCIgfSxcclxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdmdcIiwgeyB3aWR0aDogXCIyNFwiLCBoZWlnaHQ6IFwiMjRcIiwgdmlld0JveDogXCIwIDAgMjQgMjRcIiwgZmlsbDogXCJub25lXCIsIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgfSxcclxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7IGQ6IFwiTTE4IDZMNiAxOFwiLCBzdHJva2U6IFwiY3VycmVudENvbG9yXCIsIHN0cm9rZVdpZHRoOiBcIjJcIiwgc3Ryb2tlTGluZWNhcDogXCJyb3VuZFwiLCBzdHJva2VMaW5lam9pbjogXCJyb3VuZFwiIH0pLFxyXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHsgZDogXCJNNiA2TDE4IDE4XCIsIHN0cm9rZTogXCJjdXJyZW50Q29sb3JcIiwgc3Ryb2tlV2lkdGg6IFwiMlwiLCBzdHJva2VMaW5lY2FwOiBcInJvdW5kXCIsIHN0cm9rZUxpbmVqb2luOiBcInJvdW5kXCIgfSkpKSkpKTtcclxufTtcclxuZXhwb3J0cy5MZWZ0UmlnaHREaWFsb2dIZWFkZXIgPSBMZWZ0UmlnaHREaWFsb2dIZWFkZXI7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xyXG52YXIgTGVmdFJpZ2h0RGlhbG9nSGVhZGVyXzEgPSByZXF1aXJlKFwiLi9MZWZ0UmlnaHREaWFsb2dIZWFkZXJcIik7XHJcbmV4cG9ydHMuTGVmdFJpZ2h0RGlhbG9nSGVhZGVyID0gTGVmdFJpZ2h0RGlhbG9nSGVhZGVyXzEuTGVmdFJpZ2h0RGlhbG9nSGVhZGVyO1xyXG52YXIgc3R5bGVzXzEgPSByZXF1aXJlKFwiLi9zdHlsZXNcIik7XHJcbmV4cG9ydHMuc3R5bGVzID0gc3R5bGVzXzEuc3R5bGVzO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fbWFrZVRlbXBsYXRlT2JqZWN0ID0gKHRoaXMgJiYgdGhpcy5fX21ha2VUZW1wbGF0ZU9iamVjdCkgfHwgZnVuY3Rpb24gKGNvb2tlZCwgcmF3KSB7XHJcbiAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb29rZWQsIFwicmF3XCIsIHsgdmFsdWU6IHJhdyB9KTsgfSBlbHNlIHsgY29va2VkLnJhdyA9IHJhdzsgfVxyXG4gICAgcmV0dXJuIGNvb2tlZDtcclxufTtcclxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxudmFyIG5vb3BfdGVtcGxhdGVfMSA9IHJlcXVpcmUoXCIuLi8uLi9oZWxwZXJzL25vb3AtdGVtcGxhdGVcIik7XHJcbnZhciBzdHlsZXMgPSBub29wX3RlbXBsYXRlXzEubm9vcCh0ZW1wbGF0ZU9iamVjdF8xIHx8ICh0ZW1wbGF0ZU9iamVjdF8xID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuICBbZGF0YS1uZXh0anMtZGlhbG9nLWxlZnQtcmlnaHRdIHtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgZmxleC1kaXJlY3Rpb246IHJvdztcXG4gICAgYWxpZ24tY29udGVudDogY2VudGVyO1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XFxuICB9XFxuICBbZGF0YS1uZXh0anMtZGlhbG9nLWxlZnQtcmlnaHRdID4gbmF2ID4gYnV0dG9uIHtcXG4gICAgZGlzcGxheTogaW5saW5lLWZsZXg7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcblxcbiAgICB3aWR0aDogY2FsYyh2YXIoLS1zaXplLWdhcC1kb3VibGUpICsgdmFyKC0tc2l6ZS1nYXApKTtcXG4gICAgaGVpZ2h0OiBjYWxjKHZhcigtLXNpemUtZ2FwLWRvdWJsZSkgKyB2YXIoLS1zaXplLWdhcCkpO1xcbiAgICBmb250LXNpemU6IDA7XFxuICAgIGJvcmRlcjogbm9uZTtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNTUsIDg1LCA4NSwgMC4xKTtcXG4gICAgY29sb3I6IHZhcigtLWNvbG9yLWFuc2ktcmVkKTtcXG4gICAgY3Vyc29yOiBwb2ludGVyO1xcbiAgICB0cmFuc2l0aW9uOiBiYWNrZ3JvdW5kLWNvbG9yIDAuMjVzIGVhc2U7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtZGlhbG9nLWxlZnQtcmlnaHRdID4gbmF2ID4gYnV0dG9uID4gc3ZnIHtcXG4gICAgd2lkdGg6IGF1dG87XFxuICAgIGhlaWdodDogY2FsYyh2YXIoLS1zaXplLWdhcCkgKyB2YXIoLS1zaXplLWdhcC1oYWxmKSk7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtZGlhbG9nLWxlZnQtcmlnaHRdID4gbmF2ID4gYnV0dG9uOmhvdmVyIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNTUsIDg1LCA4NSwgMC4yKTtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctbGVmdC1yaWdodF0gPiBuYXYgPiBidXR0b246ZGlzYWJsZWQge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI1NSwgODUsIDg1LCAwLjEpO1xcbiAgICBjb2xvcjogcmdiYSgyNTUsIDg1LCA4NSwgMC40KTtcXG4gICAgY3Vyc29yOiBub3QtYWxsb3dlZDtcXG4gIH1cXG5cXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctbGVmdC1yaWdodF0gPiBuYXYgPiBidXR0b246Zmlyc3Qtb2YtdHlwZSB7XFxuICAgIGJvcmRlci1yYWRpdXM6IHZhcigtLXNpemUtZ2FwLWhhbGYpIDAgMCB2YXIoLS1zaXplLWdhcC1oYWxmKTtcXG4gICAgbWFyZ2luLXJpZ2h0OiAxcHg7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtZGlhbG9nLWxlZnQtcmlnaHRdID4gbmF2ID4gYnV0dG9uOmxhc3Qtb2YtdHlwZSB7XFxuICAgIGJvcmRlci1yYWRpdXM6IDAgdmFyKC0tc2l6ZS1nYXAtaGFsZikgdmFyKC0tc2l6ZS1nYXAtaGFsZikgMDtcXG4gIH1cXG5cXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctbGVmdC1yaWdodF0gPiBidXR0b246bGFzdC1vZi10eXBlIHtcXG4gICAgYm9yZGVyOiAwO1xcbiAgICBwYWRkaW5nOiAwO1xcblxcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gICAgYXBwZWFyYW5jZTogbm9uZTtcXG5cXG4gICAgb3BhY2l0eTogMC40O1xcbiAgICB0cmFuc2l0aW9uOiBvcGFjaXR5IDAuMjVzIGVhc2U7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtZGlhbG9nLWxlZnQtcmlnaHRdID4gYnV0dG9uOmxhc3Qtb2YtdHlwZTpob3ZlciB7XFxuICAgIG9wYWNpdHk6IDAuNztcXG4gIH1cXG5cIl0sIFtcIlxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1sZWZ0LXJpZ2h0XSB7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGZsZXgtZGlyZWN0aW9uOiByb3c7XFxuICAgIGFsaWduLWNvbnRlbnQ6IGNlbnRlcjtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1sZWZ0LXJpZ2h0XSA+IG5hdiA+IGJ1dHRvbiB7XFxuICAgIGRpc3BsYXk6IGlubGluZS1mbGV4O1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG5cXG4gICAgd2lkdGg6IGNhbGModmFyKC0tc2l6ZS1nYXAtZG91YmxlKSArIHZhcigtLXNpemUtZ2FwKSk7XFxuICAgIGhlaWdodDogY2FsYyh2YXIoLS1zaXplLWdhcC1kb3VibGUpICsgdmFyKC0tc2l6ZS1nYXApKTtcXG4gICAgZm9udC1zaXplOiAwO1xcbiAgICBib3JkZXI6IG5vbmU7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LCA4NSwgODUsIDAuMSk7XFxuICAgIGNvbG9yOiB2YXIoLS1jb2xvci1hbnNpLXJlZCk7XFxuICAgIGN1cnNvcjogcG9pbnRlcjtcXG4gICAgdHJhbnNpdGlvbjogYmFja2dyb3VuZC1jb2xvciAwLjI1cyBlYXNlO1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1sZWZ0LXJpZ2h0XSA+IG5hdiA+IGJ1dHRvbiA+IHN2ZyB7XFxuICAgIHdpZHRoOiBhdXRvO1xcbiAgICBoZWlnaHQ6IGNhbGModmFyKC0tc2l6ZS1nYXApICsgdmFyKC0tc2l6ZS1nYXAtaGFsZikpO1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1sZWZ0LXJpZ2h0XSA+IG5hdiA+IGJ1dHRvbjpob3ZlciB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LCA4NSwgODUsIDAuMik7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtZGlhbG9nLWxlZnQtcmlnaHRdID4gbmF2ID4gYnV0dG9uOmRpc2FibGVkIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNTUsIDg1LCA4NSwgMC4xKTtcXG4gICAgY29sb3I6IHJnYmEoMjU1LCA4NSwgODUsIDAuNCk7XFxuICAgIGN1cnNvcjogbm90LWFsbG93ZWQ7XFxuICB9XFxuXFxuICBbZGF0YS1uZXh0anMtZGlhbG9nLWxlZnQtcmlnaHRdID4gbmF2ID4gYnV0dG9uOmZpcnN0LW9mLXR5cGUge1xcbiAgICBib3JkZXItcmFkaXVzOiB2YXIoLS1zaXplLWdhcC1oYWxmKSAwIDAgdmFyKC0tc2l6ZS1nYXAtaGFsZik7XFxuICAgIG1hcmdpbi1yaWdodDogMXB4O1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1sZWZ0LXJpZ2h0XSA+IG5hdiA+IGJ1dHRvbjpsYXN0LW9mLXR5cGUge1xcbiAgICBib3JkZXItcmFkaXVzOiAwIHZhcigtLXNpemUtZ2FwLWhhbGYpIHZhcigtLXNpemUtZ2FwLWhhbGYpIDA7XFxuICB9XFxuXFxuICBbZGF0YS1uZXh0anMtZGlhbG9nLWxlZnQtcmlnaHRdID4gYnV0dG9uOmxhc3Qtb2YtdHlwZSB7XFxuICAgIGJvcmRlcjogMDtcXG4gICAgcGFkZGluZzogMDtcXG5cXG4gICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICAgIGFwcGVhcmFuY2U6IG5vbmU7XFxuXFxuICAgIG9wYWNpdHk6IDAuNDtcXG4gICAgdHJhbnNpdGlvbjogb3BhY2l0eSAwLjI1cyBlYXNlO1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1sZWZ0LXJpZ2h0XSA+IGJ1dHRvbjpsYXN0LW9mLXR5cGU6aG92ZXIge1xcbiAgICBvcGFjaXR5OiAwLjc7XFxuICB9XFxuXCJdKSkpO1xyXG5leHBvcnRzLnN0eWxlcyA9IHN0eWxlcztcclxudmFyIHRlbXBsYXRlT2JqZWN0XzE7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XHJcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XHJcbiAgICBpZiAoIW0pIHJldHVybiBvO1xyXG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XHJcbiAgICBmaW5hbGx5IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXI7XHJcbn07XHJcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XHJcbn07XHJcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcclxuICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XHJcbiAgICByZXN1bHRbXCJkZWZhdWx0XCJdID0gbW9kO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxudmFyIGRpc2FibGVkXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImFsbHkuanMvbWFpbnRhaW4vZGlzYWJsZWRcIikpO1xyXG52YXIgdGFiX2ZvY3VzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImFsbHkuanMvbWFpbnRhaW4vdGFiLWZvY3VzXCIpKTtcclxudmFyIFJlYWN0ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJyZWFjdFwiKSk7XHJcbnZhciBib2R5X2xvY2tlcl8xID0gcmVxdWlyZShcIi4vYm9keS1sb2NrZXJcIik7XHJcbnZhciBPdmVybGF5ID0gZnVuY3Rpb24gT3ZlcmxheShfYSkge1xyXG4gICAgdmFyIGNsYXNzTmFtZSA9IF9hLmNsYXNzTmFtZSwgY2hpbGRyZW4gPSBfYS5jaGlsZHJlbiwgZml4ZWQgPSBfYS5maXhlZDtcclxuICAgIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgYm9keV9sb2NrZXJfMS5sb2NrKCk7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgYm9keV9sb2NrZXJfMS51bmxvY2soKTtcclxuICAgICAgICB9O1xyXG4gICAgfSwgW10pO1xyXG4gICAgdmFyIF9iID0gX19yZWFkKFJlYWN0LnVzZVN0YXRlKG51bGwpLCAyKSwgb3ZlcmxheSA9IF9iWzBdLCBzZXRPdmVybGF5ID0gX2JbMV07XHJcbiAgICB2YXIgb25PdmVybGF5ID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKGVsKSB7XHJcbiAgICAgICAgc2V0T3ZlcmxheShlbCk7XHJcbiAgICB9LCBbXSk7XHJcbiAgICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChvdmVybGF5ID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgaGFuZGxlMSA9IGRpc2FibGVkXzFbXCJkZWZhdWx0XCJdKHsgZmlsdGVyOiBvdmVybGF5IH0pO1xyXG4gICAgICAgIHZhciBoYW5kbGUyID0gdGFiX2ZvY3VzXzFbXCJkZWZhdWx0XCJdKHsgY29udGV4dDogb3ZlcmxheSB9KTtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBoYW5kbGUxLmRpc2VuZ2FnZSgpO1xyXG4gICAgICAgICAgICBoYW5kbGUyLmRpc2VuZ2FnZSgpO1xyXG4gICAgICAgIH07XHJcbiAgICB9LCBbb3ZlcmxheV0pO1xyXG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgXCJkYXRhLW5leHRqcy1kaWFsb2ctb3ZlcmxheVwiOiB0cnVlLCBjbGFzc05hbWU6IGNsYXNzTmFtZSwgcmVmOiBvbk92ZXJsYXkgfSxcclxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgXCJkYXRhLW5leHRqcy1kaWFsb2ctYmFja2Ryb3BcIjogdHJ1ZSwgXCJkYXRhLW5leHRqcy1kaWFsb2ctYmFja2Ryb3AtZml4ZWRcIjogZml4ZWQgPyB0cnVlIDogdW5kZWZpbmVkIH0pLFxyXG4gICAgICAgIGNoaWxkcmVuKSk7XHJcbn07XHJcbmV4cG9ydHMuT3ZlcmxheSA9IE92ZXJsYXk7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xyXG52YXIgcHJldmlvdXNCb2R5UGFkZGluZ1JpZ2h0O1xyXG52YXIgcHJldmlvdXNCb2R5T3ZlcmZsb3dTZXR0aW5nO1xyXG52YXIgYWN0aXZlTG9ja3MgPSAwO1xyXG5mdW5jdGlvbiBsb2NrKCkge1xyXG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKGFjdGl2ZUxvY2tzKysgPiAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHNjcm9sbEJhckdhcCA9IHdpbmRvdy5pbm5lcldpZHRoIC0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoO1xyXG4gICAgICAgIGlmIChzY3JvbGxCYXJHYXAgPiAwKSB7XHJcbiAgICAgICAgICAgIHByZXZpb3VzQm9keVBhZGRpbmdSaWdodCA9IGRvY3VtZW50LmJvZHkuc3R5bGUucGFkZGluZ1JpZ2h0O1xyXG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLnBhZGRpbmdSaWdodCA9IHNjcm9sbEJhckdhcCArIFwicHhcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcHJldmlvdXNCb2R5T3ZlcmZsb3dTZXR0aW5nID0gZG9jdW1lbnQuYm9keS5zdHlsZS5vdmVyZmxvdztcclxuICAgICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XHJcbiAgICB9KTtcclxufVxyXG5leHBvcnRzLmxvY2sgPSBsb2NrO1xyXG5mdW5jdGlvbiB1bmxvY2soKSB7XHJcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoYWN0aXZlTG9ja3MgPT09IDAgfHwgLS1hY3RpdmVMb2NrcyAhPT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwcmV2aW91c0JvZHlQYWRkaW5nUmlnaHQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLnBhZGRpbmdSaWdodCA9IHByZXZpb3VzQm9keVBhZGRpbmdSaWdodDtcclxuICAgICAgICAgICAgcHJldmlvdXNCb2R5UGFkZGluZ1JpZ2h0ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocHJldmlvdXNCb2R5T3ZlcmZsb3dTZXR0aW5nICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5vdmVyZmxvdyA9IHByZXZpb3VzQm9keU92ZXJmbG93U2V0dGluZztcclxuICAgICAgICAgICAgcHJldmlvdXNCb2R5T3ZlcmZsb3dTZXR0aW5nID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcbmV4cG9ydHMudW5sb2NrID0gdW5sb2NrO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxudmFyIE92ZXJsYXlfMSA9IHJlcXVpcmUoXCIuL092ZXJsYXlcIik7XHJcbmV4cG9ydHMuT3ZlcmxheSA9IE92ZXJsYXlfMS5PdmVybGF5O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fbWFrZVRlbXBsYXRlT2JqZWN0ID0gKHRoaXMgJiYgdGhpcy5fX21ha2VUZW1wbGF0ZU9iamVjdCkgfHwgZnVuY3Rpb24gKGNvb2tlZCwgcmF3KSB7XHJcbiAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb29rZWQsIFwicmF3XCIsIHsgdmFsdWU6IHJhdyB9KTsgfSBlbHNlIHsgY29va2VkLnJhdyA9IHJhdzsgfVxyXG4gICAgcmV0dXJuIGNvb2tlZDtcclxufTtcclxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxudmFyIG5vb3BfdGVtcGxhdGVfMSA9IHJlcXVpcmUoXCIuLi8uLi9oZWxwZXJzL25vb3AtdGVtcGxhdGVcIik7XHJcbnZhciBzdHlsZXMgPSBub29wX3RlbXBsYXRlXzEubm9vcCh0ZW1wbGF0ZU9iamVjdF8xIHx8ICh0ZW1wbGF0ZU9iamVjdF8xID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuICBbZGF0YS1uZXh0anMtZGlhbG9nLW92ZXJsYXldIHtcXG4gICAgcG9zaXRpb246IGZpeGVkO1xcbiAgICB0b3A6IDA7XFxuICAgIHJpZ2h0OiAwO1xcbiAgICBib3R0b206IDA7XFxuICAgIGxlZnQ6IDA7XFxuICAgIG92ZXJmbG93OiBhdXRvO1xcbiAgICB6LWluZGV4OiA5MDAwO1xcblxcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBhbGlnbi1jb250ZW50OiBjZW50ZXI7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICAgIHBhZGRpbmc6IDEwdmggMTVweCAwO1xcbiAgfVxcblxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1iYWNrZHJvcF0ge1xcbiAgICBwb3NpdGlvbjogZml4ZWQ7XFxuICAgIHRvcDogMDtcXG4gICAgcmlnaHQ6IDA7XFxuICAgIGJvdHRvbTogMDtcXG4gICAgbGVmdDogMDtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgxNywgMTcsIDE3LCAwLjIpO1xcbiAgICBwb2ludGVyLWV2ZW50czogYWxsO1xcbiAgICB6LWluZGV4OiAtMTtcXG4gIH1cXG5cXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctYmFja2Ryb3AtZml4ZWRdIHtcXG4gICAgY3Vyc29yOiBub3QtYWxsb3dlZDtcXG4gICAgLXdlYmtpdC1iYWNrZHJvcC1maWx0ZXI6IGJsdXIoOHB4KTtcXG4gICAgYmFja2Ryb3AtZmlsdGVyOiBibHVyKDhweCk7XFxuICB9XFxuXCJdLCBbXCJcXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctb3ZlcmxheV0ge1xcbiAgICBwb3NpdGlvbjogZml4ZWQ7XFxuICAgIHRvcDogMDtcXG4gICAgcmlnaHQ6IDA7XFxuICAgIGJvdHRvbTogMDtcXG4gICAgbGVmdDogMDtcXG4gICAgb3ZlcmZsb3c6IGF1dG87XFxuICAgIHotaW5kZXg6IDkwMDA7XFxuXFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGFsaWduLWNvbnRlbnQ6IGNlbnRlcjtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gICAgcGFkZGluZzogMTB2aCAxNXB4IDA7XFxuICB9XFxuXFxuICBbZGF0YS1uZXh0anMtZGlhbG9nLWJhY2tkcm9wXSB7XFxuICAgIHBvc2l0aW9uOiBmaXhlZDtcXG4gICAgdG9wOiAwO1xcbiAgICByaWdodDogMDtcXG4gICAgYm90dG9tOiAwO1xcbiAgICBsZWZ0OiAwO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDE3LCAxNywgMTcsIDAuMik7XFxuICAgIHBvaW50ZXItZXZlbnRzOiBhbGw7XFxuICAgIHotaW5kZXg6IC0xO1xcbiAgfVxcblxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1iYWNrZHJvcC1maXhlZF0ge1xcbiAgICBjdXJzb3I6IG5vdC1hbGxvd2VkO1xcbiAgICAtd2Via2l0LWJhY2tkcm9wLWZpbHRlcjogYmx1cig4cHgpO1xcbiAgICBiYWNrZHJvcC1maWx0ZXI6IGJsdXIoOHB4KTtcXG4gIH1cXG5cIl0pKSk7XHJcbmV4cG9ydHMuc3R5bGVzID0gc3R5bGVzO1xyXG52YXIgdGVtcGxhdGVPYmplY3RfMTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX3JlYWQgPSAodGhpcyAmJiB0aGlzLl9fcmVhZCkgfHwgZnVuY3Rpb24gKG8sIG4pIHtcclxuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcclxuICAgIGlmICghbSkgcmV0dXJuIG87XHJcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cclxuICAgIGZpbmFsbHkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cclxuICAgIH1cclxuICAgIHJldHVybiBhcjtcclxufTtcclxudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xyXG4gICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcclxuICAgIHJlc3VsdFtcImRlZmF1bHRcIl0gPSBtb2Q7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xyXG52YXIgUmVhY3QgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcInJlYWN0XCIpKTtcclxudmFyIHJlYWN0X2RvbV8xID0gcmVxdWlyZShcInJlYWN0LWRvbVwiKTtcclxuZXhwb3J0cy5TaGFkb3dQb3J0YWwgPSBmdW5jdGlvbiBQb3J0YWwoX2EpIHtcclxuICAgIHZhciBjaGlsZHJlbiA9IF9hLmNoaWxkcmVuO1xyXG4gICAgdmFyIG1vdW50Tm9kZSA9IFJlYWN0LnVzZVJlZihudWxsKTtcclxuICAgIHZhciBwb3J0YWxOb2RlID0gUmVhY3QudXNlUmVmKG51bGwpO1xyXG4gICAgdmFyIHNoYWRvd05vZGUgPSBSZWFjdC51c2VSZWYobnVsbCk7XHJcbiAgICB2YXIgX2IgPSBfX3JlYWQoUmVhY3QudXNlU3RhdGUoKSwgMiksIGZvcmNlVXBkYXRlID0gX2JbMV07XHJcbiAgICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBvd25lckRvY3VtZW50ID0gbW91bnROb2RlLmN1cnJlbnQub3duZXJEb2N1bWVudDtcclxuICAgICAgICBwb3J0YWxOb2RlLmN1cnJlbnQgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ25leHRqcy1wb3J0YWwnKTtcclxuICAgICAgICBzaGFkb3dOb2RlLmN1cnJlbnQgPSBwb3J0YWxOb2RlLmN1cnJlbnQuYXR0YWNoU2hhZG93KHsgbW9kZTogJ29wZW4nIH0pO1xyXG4gICAgICAgIG93bmVyRG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChwb3J0YWxOb2RlLmN1cnJlbnQpO1xyXG4gICAgICAgIGZvcmNlVXBkYXRlKHt9KTtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAocG9ydGFsTm9kZS5jdXJyZW50ICYmIHBvcnRhbE5vZGUuY3VycmVudC5vd25lckRvY3VtZW50KSB7XHJcbiAgICAgICAgICAgICAgICBwb3J0YWxOb2RlLmN1cnJlbnQub3duZXJEb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHBvcnRhbE5vZGUuY3VycmVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfSwgW10pO1xyXG4gICAgcmV0dXJuIHNoYWRvd05vZGUuY3VycmVudCA/IChyZWFjdF9kb21fMS5jcmVhdGVQb3J0YWwoY2hpbGRyZW4sIHNoYWRvd05vZGUuY3VycmVudCkpIDogKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHsgcmVmOiBtb3VudE5vZGUgfSkpO1xyXG59O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xyXG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcclxuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxyXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59O1xyXG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xyXG59O1xyXG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XHJcbiAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xyXG4gICAgcmVzdWx0W1wiZGVmYXVsdFwiXSA9IG1vZDtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn07XHJcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XHJcbnZhciBhbnNlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJhbnNlclwiKSk7XHJcbnZhciBSZWFjdCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwicmVhY3RcIikpO1xyXG5leHBvcnRzLlRlcm1pbmFsID0gZnVuY3Rpb24gVGVybWluYWwoX2EpIHtcclxuICAgIHZhciBjb250ZW50ID0gX2EuY29udGVudDtcclxuICAgIHZhciBkZWNvZGVkID0gUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIGFuc2VyXzFbXCJkZWZhdWx0XCJdLmFuc2lUb0pzb24oY29udGVudCwge1xyXG4gICAgICAgICAgICBqc29uOiB0cnVlLFxyXG4gICAgICAgICAgICB1c2VfY2xhc3NlczogdHJ1ZSxcclxuICAgICAgICAgICAgcmVtb3ZlX2VtcHR5OiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICB9LCBbY29udGVudF0pO1xyXG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgXCJkYXRhLW5leHRqcy10ZXJtaW5hbFwiOiB0cnVlIH0sXHJcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInByZVwiLCBudWxsLCBkZWNvZGVkLm1hcChmdW5jdGlvbiAoZW50cnksIGluZGV4KSB7IHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgeyBrZXk6IFwidGVybWluYWwtZW50cnktXCIgKyBpbmRleCwgc3R5bGU6IF9fYXNzaWduKHsgY29sb3I6IGVudHJ5LmZnID8gXCJ2YXIoLS1jb2xvci1cIiArIGVudHJ5LmZnICsgXCIpXCIgOiB1bmRlZmluZWQgfSwgKGVudHJ5LmRlY29yYXRpb24gPT09ICdib2xkJ1xyXG4gICAgICAgICAgICAgICAgPyB7IGZvbnRXZWlnaHQ6IDgwMCB9XHJcbiAgICAgICAgICAgICAgICA6IGVudHJ5LmRlY29yYXRpb24gPT09ICdpdGFsaWMnXHJcbiAgICAgICAgICAgICAgICAgICAgPyB7IGZvbnRTdHlsZTogJ2l0YWxpYycgfVxyXG4gICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKSkgfSwgZW50cnkuY29udGVudCkpOyB9KSkpKTtcclxufTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XHJcbnZhciBUZXJtaW5hbF8xID0gcmVxdWlyZShcIi4vVGVybWluYWxcIik7XHJcbmV4cG9ydHMuVGVybWluYWwgPSBUZXJtaW5hbF8xLlRlcm1pbmFsO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fbWFrZVRlbXBsYXRlT2JqZWN0ID0gKHRoaXMgJiYgdGhpcy5fX21ha2VUZW1wbGF0ZU9iamVjdCkgfHwgZnVuY3Rpb24gKGNvb2tlZCwgcmF3KSB7XHJcbiAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb29rZWQsIFwicmF3XCIsIHsgdmFsdWU6IHJhdyB9KTsgfSBlbHNlIHsgY29va2VkLnJhdyA9IHJhdzsgfVxyXG4gICAgcmV0dXJuIGNvb2tlZDtcclxufTtcclxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxudmFyIG5vb3BfdGVtcGxhdGVfMSA9IHJlcXVpcmUoXCIuLi8uLi9oZWxwZXJzL25vb3AtdGVtcGxhdGVcIik7XHJcbnZhciBzdHlsZXMgPSBub29wX3RlbXBsYXRlXzEubm9vcCh0ZW1wbGF0ZU9iamVjdF8xIHx8ICh0ZW1wbGF0ZU9iamVjdF8xID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuICBbZGF0YS1uZXh0anMtdGVybWluYWxdIHtcXG4gICAgYm9yZGVyLXJhZGl1czogdmFyKC0tc2l6ZS1nYXAtaGFsZik7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWNvbG9yLWFuc2ktYmcpO1xcbiAgICBjb2xvcjogdmFyKC0tY29sb3ItYW5zaS1mZyk7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtdGVybWluYWxdOjpzZWxlY3Rpb24sXFxuICBbZGF0YS1uZXh0anMtdGVybWluYWxdICo6OnNlbGVjdGlvbiB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWNvbG9yLWFuc2ktc2VsZWN0aW9uKTtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy10ZXJtaW5hbF0gKiB7XFxuICAgIGNvbG9yOiBpbmhlcml0O1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gICAgZm9udC1mYW1pbHk6IHZhcigtLWZvbnQtc3RhY2stbW9ub3NwYWNlKTtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy10ZXJtaW5hbF0gPiAqIHtcXG4gICAgbWFyZ2luOiAwO1xcbiAgICBwYWRkaW5nOiBjYWxjKHZhcigtLXNpemUtZ2FwKSArIHZhcigtLXNpemUtZ2FwLWhhbGYpKVxcbiAgICAgIGNhbGModmFyKC0tc2l6ZS1nYXAtZG91YmxlKSArIHZhcigtLXNpemUtZ2FwLWhhbGYpKTtcXG4gIH1cXG5cXG4gIFtkYXRhLW5leHRqcy10ZXJtaW5hbF0gcHJlIHtcXG4gICAgd2hpdGUtc3BhY2U6IHByZS13cmFwO1xcbiAgICB3b3JkLWJyZWFrOiBicmVhay13b3JkO1xcbiAgfVxcblwiXSwgW1wiXFxuICBbZGF0YS1uZXh0anMtdGVybWluYWxdIHtcXG4gICAgYm9yZGVyLXJhZGl1czogdmFyKC0tc2l6ZS1nYXAtaGFsZik7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWNvbG9yLWFuc2ktYmcpO1xcbiAgICBjb2xvcjogdmFyKC0tY29sb3ItYW5zaS1mZyk7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtdGVybWluYWxdOjpzZWxlY3Rpb24sXFxuICBbZGF0YS1uZXh0anMtdGVybWluYWxdICo6OnNlbGVjdGlvbiB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWNvbG9yLWFuc2ktc2VsZWN0aW9uKTtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy10ZXJtaW5hbF0gKiB7XFxuICAgIGNvbG9yOiBpbmhlcml0O1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gICAgZm9udC1mYW1pbHk6IHZhcigtLWZvbnQtc3RhY2stbW9ub3NwYWNlKTtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy10ZXJtaW5hbF0gPiAqIHtcXG4gICAgbWFyZ2luOiAwO1xcbiAgICBwYWRkaW5nOiBjYWxjKHZhcigtLXNpemUtZ2FwKSArIHZhcigtLXNpemUtZ2FwLWhhbGYpKVxcbiAgICAgIGNhbGModmFyKC0tc2l6ZS1nYXAtZG91YmxlKSArIHZhcigtLXNpemUtZ2FwLWhhbGYpKTtcXG4gIH1cXG5cXG4gIFtkYXRhLW5leHRqcy10ZXJtaW5hbF0gcHJlIHtcXG4gICAgd2hpdGUtc3BhY2U6IHByZS13cmFwO1xcbiAgICB3b3JkLWJyZWFrOiBicmVhay13b3JkO1xcbiAgfVxcblwiXSkpKTtcclxuZXhwb3J0cy5zdHlsZXMgPSBzdHlsZXM7XHJcbnZhciB0ZW1wbGF0ZU9iamVjdF8xO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xyXG4gICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcclxuICAgIHJlc3VsdFtcImRlZmF1bHRcIl0gPSBtb2Q7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xyXG52YXIgUmVhY3QgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcInJlYWN0XCIpKTtcclxuZXhwb3J0cy5Ub2FzdCA9IGZ1bmN0aW9uIFRvYXN0KF9hKSB7XHJcbiAgICB2YXIgb25DbGljayA9IF9hLm9uQ2xpY2ssIGNoaWxkcmVuID0gX2EuY2hpbGRyZW4sIGNsYXNzTmFtZSA9IF9hLmNsYXNzTmFtZTtcclxuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IFwiZGF0YS1uZXh0anMtdG9hc3RcIjogdHJ1ZSwgb25DbGljazogb25DbGljaywgY2xhc3NOYW1lOiBjbGFzc05hbWUgfSxcclxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgXCJkYXRhLW5leHRqcy10b2FzdC13cmFwcGVyXCI6IHRydWUgfSwgY2hpbGRyZW4pKSk7XHJcbn07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xyXG52YXIgc3R5bGVzXzEgPSByZXF1aXJlKFwiLi9zdHlsZXNcIik7XHJcbmV4cG9ydHMuc3R5bGVzID0gc3R5bGVzXzEuc3R5bGVzO1xyXG52YXIgVG9hc3RfMSA9IHJlcXVpcmUoXCIuL1RvYXN0XCIpO1xyXG5leHBvcnRzLlRvYXN0ID0gVG9hc3RfMS5Ub2FzdDtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX21ha2VUZW1wbGF0ZU9iamVjdCA9ICh0aGlzICYmIHRoaXMuX19tYWtlVGVtcGxhdGVPYmplY3QpIHx8IGZ1bmN0aW9uIChjb29rZWQsIHJhdykge1xyXG4gICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cclxuICAgIHJldHVybiBjb29rZWQ7XHJcbn07XHJcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XHJcbnZhciBub29wX3RlbXBsYXRlXzEgPSByZXF1aXJlKFwiLi4vLi4vaGVscGVycy9ub29wLXRlbXBsYXRlXCIpO1xyXG52YXIgc3R5bGVzID0gbm9vcF90ZW1wbGF0ZV8xLm5vb3AodGVtcGxhdGVPYmplY3RfMSB8fCAodGVtcGxhdGVPYmplY3RfMSA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcbiAgW2RhdGEtbmV4dGpzLXRvYXN0XSB7XFxuICAgIHBvc2l0aW9uOiBmaXhlZDtcXG4gICAgYm90dG9tOiB2YXIoLS1zaXplLWdhcC1kb3VibGUpO1xcbiAgICBsZWZ0OiB2YXIoLS1zaXplLWdhcC1kb3VibGUpO1xcbiAgICBtYXgtd2lkdGg6IDQyMHB4O1xcbiAgICB6LWluZGV4OiA5MDAwO1xcbiAgfVxcblxcbiAgQG1lZGlhIChtYXgtd2lkdGg6IDQ0MHB4KSB7XFxuICAgIFtkYXRhLW5leHRqcy10b2FzdF0ge1xcbiAgICAgIG1heC13aWR0aDogOTB2dztcXG4gICAgICBsZWZ0OiA1dnc7XFxuICAgIH1cXG4gIH1cXG5cXG4gIFtkYXRhLW5leHRqcy10b2FzdC13cmFwcGVyXSB7XFxuICAgIHBhZGRpbmc6IDFyZW07XFxuICAgIGJvcmRlci1yYWRpdXM6IHZhcigtLXNpemUtZ2FwLWhhbGYpO1xcbiAgICBmb250LXdlaWdodDogNTAwO1xcbiAgICBjb2xvcjogdmFyKC0tY29sb3ItYW5zaS1icmlnaHQtd2hpdGUpO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1jb2xvci1hbnNpLXJlZCk7XFxuICAgIGJveC1zaGFkb3c6IDBweCB2YXIoLS1zaXplLWdhcC1kb3VibGUpIHZhcigtLXNpemUtZ2FwLXF1YWQpXFxuICAgICAgcmdiYSgwLCAwLCAwLCAwLjI1KTtcXG4gIH1cXG5cIl0sIFtcIlxcbiAgW2RhdGEtbmV4dGpzLXRvYXN0XSB7XFxuICAgIHBvc2l0aW9uOiBmaXhlZDtcXG4gICAgYm90dG9tOiB2YXIoLS1zaXplLWdhcC1kb3VibGUpO1xcbiAgICBsZWZ0OiB2YXIoLS1zaXplLWdhcC1kb3VibGUpO1xcbiAgICBtYXgtd2lkdGg6IDQyMHB4O1xcbiAgICB6LWluZGV4OiA5MDAwO1xcbiAgfVxcblxcbiAgQG1lZGlhIChtYXgtd2lkdGg6IDQ0MHB4KSB7XFxuICAgIFtkYXRhLW5leHRqcy10b2FzdF0ge1xcbiAgICAgIG1heC13aWR0aDogOTB2dztcXG4gICAgICBsZWZ0OiA1dnc7XFxuICAgIH1cXG4gIH1cXG5cXG4gIFtkYXRhLW5leHRqcy10b2FzdC13cmFwcGVyXSB7XFxuICAgIHBhZGRpbmc6IDFyZW07XFxuICAgIGJvcmRlci1yYWRpdXM6IHZhcigtLXNpemUtZ2FwLWhhbGYpO1xcbiAgICBmb250LXdlaWdodDogNTAwO1xcbiAgICBjb2xvcjogdmFyKC0tY29sb3ItYW5zaS1icmlnaHQtd2hpdGUpO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1jb2xvci1hbnNpLXJlZCk7XFxuICAgIGJveC1zaGFkb3c6IDBweCB2YXIoLS1zaXplLWdhcC1kb3VibGUpIHZhcigtLXNpemUtZ2FwLXF1YWQpXFxuICAgICAgcmdiYSgwLCAwLCAwLCAwLjI1KTtcXG4gIH1cXG5cIl0pKSk7XHJcbmV4cG9ydHMuc3R5bGVzID0gc3R5bGVzO1xyXG52YXIgdGVtcGxhdGVPYmplY3RfMTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX21ha2VUZW1wbGF0ZU9iamVjdCA9ICh0aGlzICYmIHRoaXMuX19tYWtlVGVtcGxhdGVPYmplY3QpIHx8IGZ1bmN0aW9uIChjb29rZWQsIHJhdykge1xyXG4gICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cclxuICAgIHJldHVybiBjb29rZWQ7XHJcbn07XHJcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcclxuICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XHJcbiAgICByZXN1bHRbXCJkZWZhdWx0XCJdID0gbW9kO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxudmFyIFJlYWN0ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJyZWFjdFwiKSk7XHJcbnZhciBEaWFsb2dfMSA9IHJlcXVpcmUoXCIuLi9jb21wb25lbnRzL0RpYWxvZ1wiKTtcclxudmFyIE92ZXJsYXlfMSA9IHJlcXVpcmUoXCIuLi9jb21wb25lbnRzL092ZXJsYXlcIik7XHJcbnZhciBUZXJtaW5hbF8xID0gcmVxdWlyZShcIi4uL2NvbXBvbmVudHMvVGVybWluYWxcIik7XHJcbnZhciBub29wX3RlbXBsYXRlXzEgPSByZXF1aXJlKFwiLi4vaGVscGVycy9ub29wLXRlbXBsYXRlXCIpO1xyXG5leHBvcnRzLkJ1aWxkRXJyb3IgPSBmdW5jdGlvbiBCdWlsZEVycm9yKF9hKSB7XHJcbiAgICB2YXIgbWVzc2FnZSA9IF9hLm1lc3NhZ2U7XHJcbiAgICB2YXIgbm9vcCA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHsgfSwgW10pO1xyXG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KE92ZXJsYXlfMS5PdmVybGF5LCB7IGZpeGVkOiB0cnVlIH0sXHJcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChEaWFsb2dfMS5EaWFsb2csIHsgdHlwZTogXCJlcnJvclwiLCBcImFyaWEtbGFiZWxsZWRieVwiOiBcIm5leHRqc19fY29udGFpbmVyX2J1aWxkX2Vycm9yX2xhYmVsXCIsIFwiYXJpYS1kZXNjcmliZWRieVwiOiBcIm5leHRqc19fY29udGFpbmVyX2J1aWxkX2Vycm9yX2Rlc2NcIiwgb25DbG9zZTogbm9vcCB9LFxyXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KERpYWxvZ18xLkRpYWxvZ0NvbnRlbnQsIG51bGwsXHJcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KERpYWxvZ18xLkRpYWxvZ0hlYWRlciwgeyBjbGFzc05hbWU6IFwibmV4dGpzLWNvbnRhaW5lci1idWlsZC1lcnJvci1oZWFkZXJcIiB9LFxyXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJoNFwiLCB7IGlkOiBcIm5leHRqc19fY29udGFpbmVyX2J1aWxkX2Vycm9yX2xhYmVsXCIgfSwgXCJGYWlsZWQgdG8gY29tcGlsZVwiKSksXHJcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KERpYWxvZ18xLkRpYWxvZ0JvZHksIHsgY2xhc3NOYW1lOiBcIm5leHRqcy1jb250YWluZXItYnVpbGQtZXJyb3ItYm9keVwiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChUZXJtaW5hbF8xLlRlcm1pbmFsLCB7IGNvbnRlbnQ6IG1lc3NhZ2UgfSksXHJcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImZvb3RlclwiLCBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwicFwiLCB7IGlkOiBcIm5leHRqc19fY29udGFpbmVyX2J1aWxkX2Vycm9yX2Rlc2NcIiB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInNtYWxsXCIsIG51bGwsIFwiVGhpcyBlcnJvciBvY2N1cmVkIGR1cmluZyB0aGUgYnVpbGQgcHJvY2VzcyBhbmQgY2FuIG9ubHkgYmUgZGlzbWlzc2VkIGJ5IGZpeGluZyB0aGUgZXJyb3IuXCIpKSkpKSkpKTtcclxufTtcclxuZXhwb3J0cy5zdHlsZXMgPSBub29wX3RlbXBsYXRlXzEubm9vcCh0ZW1wbGF0ZU9iamVjdF8xIHx8ICh0ZW1wbGF0ZU9iamVjdF8xID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuICAubmV4dGpzLWNvbnRhaW5lci1idWlsZC1lcnJvci1oZWFkZXIgPiBoNCB7XFxuICAgIGxpbmUtaGVpZ2h0OiAxLjU7XFxuICAgIG1hcmdpbjogMDtcXG4gICAgcGFkZGluZzogMDtcXG4gIH1cXG5cXG4gIC5uZXh0anMtY29udGFpbmVyLWJ1aWxkLWVycm9yLWJvZHkgZm9vdGVyIHtcXG4gICAgbWFyZ2luLXRvcDogdmFyKC0tc2l6ZS1nYXApO1xcbiAgfVxcbiAgLm5leHRqcy1jb250YWluZXItYnVpbGQtZXJyb3ItYm9keSBmb290ZXIgcCB7XFxuICAgIG1hcmdpbjogMDtcXG4gIH1cXG5cXG4gIC5uZXh0anMtY29udGFpbmVyLWJ1aWxkLWVycm9yLWJvZHkgc21hbGwge1xcbiAgICBjb2xvcjogIzc1NzU3NTtcXG4gIH1cXG5cIl0sIFtcIlxcbiAgLm5leHRqcy1jb250YWluZXItYnVpbGQtZXJyb3ItaGVhZGVyID4gaDQge1xcbiAgICBsaW5lLWhlaWdodDogMS41O1xcbiAgICBtYXJnaW46IDA7XFxuICAgIHBhZGRpbmc6IDA7XFxuICB9XFxuXFxuICAubmV4dGpzLWNvbnRhaW5lci1idWlsZC1lcnJvci1ib2R5IGZvb3RlciB7XFxuICAgIG1hcmdpbi10b3A6IHZhcigtLXNpemUtZ2FwKTtcXG4gIH1cXG4gIC5uZXh0anMtY29udGFpbmVyLWJ1aWxkLWVycm9yLWJvZHkgZm9vdGVyIHAge1xcbiAgICBtYXJnaW46IDA7XFxuICB9XFxuXFxuICAubmV4dGpzLWNvbnRhaW5lci1idWlsZC1lcnJvci1ib2R5IHNtYWxsIHtcXG4gICAgY29sb3I6ICM3NTc1NzU7XFxuICB9XFxuXCJdKSkpO1xyXG52YXIgdGVtcGxhdGVPYmplY3RfMTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX21ha2VUZW1wbGF0ZU9iamVjdCA9ICh0aGlzICYmIHRoaXMuX19tYWtlVGVtcGxhdGVPYmplY3QpIHx8IGZ1bmN0aW9uIChjb29rZWQsIHJhdykge1xyXG4gICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cclxuICAgIHJldHVybiBjb29rZWQ7XHJcbn07XHJcbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcclxuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcclxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufTtcclxudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59O1xyXG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xyXG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcclxuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XHJcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xyXG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xyXG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcclxuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XHJcbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XHJcbiAgICB9XHJcbn07XHJcbnZhciBfX3JlYWQgPSAodGhpcyAmJiB0aGlzLl9fcmVhZCkgfHwgZnVuY3Rpb24gKG8sIG4pIHtcclxuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcclxuICAgIGlmICghbSkgcmV0dXJuIG87XHJcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cclxuICAgIGZpbmFsbHkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cclxuICAgIH1cclxuICAgIHJldHVybiBhcjtcclxufTtcclxudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xyXG4gICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcclxuICAgIHJlc3VsdFtcImRlZmF1bHRcIl0gPSBtb2Q7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xyXG52YXIgUmVhY3QgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcInJlYWN0XCIpKTtcclxudmFyIGJ1c18xID0gcmVxdWlyZShcIi4uL2J1c1wiKTtcclxudmFyIERpYWxvZ18xID0gcmVxdWlyZShcIi4uL2NvbXBvbmVudHMvRGlhbG9nXCIpO1xyXG52YXIgTGVmdFJpZ2h0RGlhbG9nSGVhZGVyXzEgPSByZXF1aXJlKFwiLi4vY29tcG9uZW50cy9MZWZ0UmlnaHREaWFsb2dIZWFkZXJcIik7XHJcbnZhciBPdmVybGF5XzEgPSByZXF1aXJlKFwiLi4vY29tcG9uZW50cy9PdmVybGF5XCIpO1xyXG52YXIgVG9hc3RfMSA9IHJlcXVpcmUoXCIuLi9jb21wb25lbnRzL1RvYXN0XCIpO1xyXG52YXIgbm9kZVN0YWNrRnJhbWVzXzEgPSByZXF1aXJlKFwiLi4vaGVscGVycy9ub2RlU3RhY2tGcmFtZXNcIik7XHJcbnZhciBub29wX3RlbXBsYXRlXzEgPSByZXF1aXJlKFwiLi4vaGVscGVycy9ub29wLXRlbXBsYXRlXCIpO1xyXG52YXIgc3RhY2tfZnJhbWVfMSA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL3N0YWNrLWZyYW1lXCIpO1xyXG52YXIgUnVudGltZUVycm9yXzEgPSByZXF1aXJlKFwiLi9SdW50aW1lRXJyb3JcIik7XHJcbmZ1bmN0aW9uIGdldEVycm9yU2lnbmF0dXJlKGV2KSB7XHJcbiAgICB2YXIgZXZlbnQgPSBldi5ldmVudDtcclxuICAgIHN3aXRjaCAoZXZlbnQudHlwZSkge1xyXG4gICAgICAgIGNhc2UgYnVzXzEuVFlQRV9VTkhBTkRMRURfRVJST1I6XHJcbiAgICAgICAgY2FzZSBidXNfMS5UWVBFX1VOSEFORExFRF9SRUpFQ1RJT046IHtcclxuICAgICAgICAgICAgcmV0dXJuIGV2ZW50LnJlYXNvbi5uYW1lICsgXCI6OlwiICsgZXZlbnQucmVhc29uLm1lc3NhZ2UgKyBcIjo6XCIgKyBldmVudC5yZWFzb24uc3RhY2s7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRlZmF1bHQ6IHtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXHJcbiAgICB2YXIgXyA9IGV2ZW50O1xyXG4gICAgcmV0dXJuICcnO1xyXG59XHJcbmZ1bmN0aW9uIGdldEVycm9yQnlUeXBlKGV2KSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGlkLCBldmVudCwgX2EsIF9iLCBfO1xyXG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2MpIHtcclxuICAgICAgICAgICAgc3dpdGNoIChfYy5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgIGlkID0gZXYuaWQsIGV2ZW50ID0gZXYuZXZlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgX2EgPSBldmVudC50eXBlO1xyXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBidXNfMS5UWVBFX1VOSEFORExFRF9FUlJPUjogcmV0dXJuIFszIC8qYnJlYWsqLywgMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgYnVzXzEuVFlQRV9VTkhBTkRMRURfUkVKRUNUSU9OOiByZXR1cm4gWzMgLypicmVhayovLCAxXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgM107XHJcbiAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgX2IgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBpZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcnVudGltZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGV2ZW50LnJlYXNvblxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgc3RhY2tfZnJhbWVfMS5nZXRPcmlnaW5hbFN0YWNrRnJhbWVzKG5vZGVTdGFja0ZyYW1lc18xLmlzTm9kZUVycm9yKGV2ZW50LnJlYXNvbiksIGV2ZW50LmZyYW1lcyldO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gWzIgLypyZXR1cm4qLywgKF9iLmZyYW1lcyA9IF9jLnNlbnQoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2IpXTtcclxuICAgICAgICAgICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBfYy5sYWJlbCA9IDQ7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XHJcbiAgICAgICAgICAgICAgICAgICAgXyA9IGV2ZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndHlwZSBzeXN0ZW0gaW52YXJpYW50IHZpb2xhdGlvbicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxufVxyXG5leHBvcnRzLkVycm9ycyA9IGZ1bmN0aW9uIEVycm9ycyhfYSkge1xyXG4gICAgdmFyIGVycm9ycyA9IF9hLmVycm9ycztcclxuICAgIHZhciBfYiA9IF9fcmVhZChSZWFjdC51c2VTdGF0ZSh7fSksIDIpLCBsb29rdXBzID0gX2JbMF0sIHNldExvb2t1cHMgPSBfYlsxXTtcclxuICAgIHZhciBfYyA9IF9fcmVhZChSZWFjdC51c2VNZW1vKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcmVhZHkgPSBbXTtcclxuICAgICAgICB2YXIgbmV4dCA9IG51bGw7XHJcbiAgICAgICAgLy8gRW5zdXJlIGVycm9ycyBhcmUgZGlzcGxheWVkIGluIHRoZSBvcmRlciB0aGV5IG9jY3VycmVkIGluOlxyXG4gICAgICAgIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IGVycm9ycy5sZW5ndGg7ICsraWR4KSB7XHJcbiAgICAgICAgICAgIHZhciBlID0gZXJyb3JzW2lkeF07XHJcbiAgICAgICAgICAgIHZhciBpZCA9IGUuaWQ7XHJcbiAgICAgICAgICAgIGlmIChpZCBpbiBsb29rdXBzKSB7XHJcbiAgICAgICAgICAgICAgICByZWFkeS5wdXNoKGxvb2t1cHNbaWRdKTtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBkdXBsaWNhdGUgZXJyb3JzXHJcbiAgICAgICAgICAgIGlmIChpZHggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcHJldiA9IGVycm9yc1tpZHggLSAxXTtcclxuICAgICAgICAgICAgICAgIGlmIChnZXRFcnJvclNpZ25hdHVyZShwcmV2KSA9PT0gZ2V0RXJyb3JTaWduYXR1cmUoZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBuZXh0ID0gZTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBbcmVhZHksIG5leHRdO1xyXG4gICAgfSwgW2Vycm9ycywgbG9va3Vwc10pLCAyKSwgcmVhZHlFcnJvcnMgPSBfY1swXSwgbmV4dEVycm9yID0gX2NbMV07XHJcbiAgICB2YXIgaXNMb2FkaW5nID0gUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlYWR5RXJyb3JzLmxlbmd0aCA8IDEgJiYgQm9vbGVhbihlcnJvcnMubGVuZ3RoKTtcclxuICAgIH0sIFtlcnJvcnMubGVuZ3RoLCByZWFkeUVycm9ycy5sZW5ndGhdKTtcclxuICAgIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKG5leHRFcnJvciA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZ2V0RXJyb3JCeVR5cGUobmV4dEVycm9yKS50aGVuKGZ1bmN0aW9uIChyZXNvbHZlZCkge1xyXG4gICAgICAgICAgICAvLyBXZSBkb24ndCBjYXJlIGlmIHRoZSBkZXNpcmVkIGVycm9yIGNoYW5nZWQgd2hpbGUgd2Ugd2VyZSByZXNvbHZpbmcsXHJcbiAgICAgICAgICAgIC8vIHRodXMgd2UncmUgbm90IHRyYWNraW5nIGl0IHVzaW5nIGEgcmVmLiBPbmNlIHRoZSB3b3JrIGhhcyBiZWVuIGRvbmUsXHJcbiAgICAgICAgICAgIC8vIHdlJ2xsIHN0b3JlIGl0LlxyXG4gICAgICAgICAgICBzZXRMb29rdXBzKGZ1bmN0aW9uIChtKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKF9fYXNzaWduKF9fYXNzaWduKHt9LCBtKSwgKF9hID0ge30sIF9hW3Jlc29sdmVkLmlkXSA9IHJlc29sdmVkLCBfYSkpKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvLyBUT0RPOiBoYW5kbGUgdGhpcywgdGhvdWdoIGFuIGVkZ2UgY2FzZVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSwgW25leHRFcnJvcl0pO1xyXG4gICAgdmFyIF9kID0gX19yZWFkKFJlYWN0LnVzZVN0YXRlKGZhbHNlKSwgMiksIGlzTWluaW1pemVkID0gX2RbMF0sIHNldE1pbmltaXplZCA9IF9kWzFdO1xyXG4gICAgdmFyIF9lID0gX19yZWFkKFJlYWN0LnVzZVN0YXRlKDApLCAyKSwgYWN0aXZlSWR4ID0gX2VbMF0sIHNldEFjdGl2ZUluZGV4ID0gX2VbMV07XHJcbiAgICB2YXIgcHJldmlvdXMgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgIGUgPT09IG51bGwgfHwgZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIHNldEFjdGl2ZUluZGV4KGZ1bmN0aW9uICh2KSB7IHJldHVybiBNYXRoLm1heCgwLCB2IC0gMSk7IH0pO1xyXG4gICAgfSwgW10pO1xyXG4gICAgdmFyIG5leHQgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgIGUgPT09IG51bGwgfHwgZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIHNldEFjdGl2ZUluZGV4KGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1heCgwLCBNYXRoLm1pbihyZWFkeUVycm9ycy5sZW5ndGggLSAxLCB2ICsgMSkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSwgW3JlYWR5RXJyb3JzLmxlbmd0aF0pO1xyXG4gICAgdmFyIGFjdGl2ZUVycm9yID0gUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7IHZhciBfYTsgcmV0dXJuIChfYSA9IHJlYWR5RXJyb3JzW2FjdGl2ZUlkeF0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG51bGw7IH0sIFthY3RpdmVJZHgsIHJlYWR5RXJyb3JzXSk7XHJcbiAgICAvLyBSZXNldCBjb21wb25lbnQgc3RhdGUgd2hlbiB0aGVyZSBhcmUgbm8gZXJyb3JzIHRvIGJlIGRpc3BsYXllZC5cclxuICAgIC8vIFRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbiwgYnV0IGxldHMgaGFuZGxlIGl0LlxyXG4gICAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoZXJyb3JzLmxlbmd0aCA8IDEpIHtcclxuICAgICAgICAgICAgc2V0TG9va3Vwcyh7fSk7XHJcbiAgICAgICAgICAgIHNldE1pbmltaXplZChmYWxzZSk7XHJcbiAgICAgICAgICAgIHNldEFjdGl2ZUluZGV4KDApO1xyXG4gICAgICAgIH1cclxuICAgIH0sIFtlcnJvcnMubGVuZ3RoXSk7XHJcbiAgICB2YXIgbWluaW1pemUgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgIGUgPT09IG51bGwgfHwgZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIHNldE1pbmltaXplZCh0cnVlKTtcclxuICAgIH0sIFtdKTtcclxuICAgIHZhciByZW9wZW4gPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgIGUgPT09IG51bGwgfHwgZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIHNldE1pbmltaXplZChmYWxzZSk7XHJcbiAgICB9LCBbXSk7XHJcbiAgICAvLyBUaGlzIGNvbXBvbmVudCBzaG91bGRuJ3QgYmUgcmVuZGVyZWQgd2l0aCBubyBlcnJvcnMsIGJ1dCBpZiBpdCBpcywgbGV0J3NcclxuICAgIC8vIGhhbmRsZSBpdCBncmFjZWZ1bGx5IGJ5IHJlbmRlcmluZyBub3RoaW5nLlxyXG4gICAgaWYgKGVycm9ycy5sZW5ndGggPCAxKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNMb2FkaW5nKSB7XHJcbiAgICAgICAgLy8gVE9ETzogYmV0dGVyIGxvYWRpbmcgc3RhdGVcclxuICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChPdmVybGF5XzEuT3ZlcmxheSwgbnVsbCk7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNNaW5pbWl6ZWQpIHtcclxuICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoVG9hc3RfMS5Ub2FzdCwgeyBjbGFzc05hbWU6IFwibmV4dGpzLXRvYXN0LWVycm9ycy1wYXJlbnRcIiwgb25DbGljazogcmVvcGVuIH0sXHJcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwibmV4dGpzLXRvYXN0LWVycm9yc1wiIH0sXHJcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3ZnXCIsIHsgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgd2lkdGg6IFwiMjRcIiwgaGVpZ2h0OiBcIjI0XCIsIHZpZXdCb3g6IFwiMCAwIDI0IDI0XCIsIGZpbGw6IFwibm9uZVwiLCBzdHJva2U6IFwiY3VycmVudENvbG9yXCIsIHN0cm9rZVdpZHRoOiBcIjJcIiwgc3Ryb2tlTGluZWNhcDogXCJyb3VuZFwiLCBzdHJva2VMaW5lam9pbjogXCJyb3VuZFwiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImNpcmNsZVwiLCB7IGN4OiBcIjEyXCIsIGN5OiBcIjEyXCIsIHI6IFwiMTBcIiB9KSxcclxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwibGluZVwiLCB7IHgxOiBcIjEyXCIsIHkxOiBcIjhcIiwgeDI6IFwiMTJcIiwgeTI6IFwiMTJcIiB9KSxcclxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwibGluZVwiLCB7IHgxOiBcIjEyXCIsIHkxOiBcIjE2XCIsIHgyOiBcIjEyLjAxXCIsIHkyOiBcIjE2XCIgfSkpLFxyXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICByZWFkeUVycm9ycy5sZW5ndGgsXHJcbiAgICAgICAgICAgICAgICAgICAgXCIgZXJyb3JcIixcclxuICAgICAgICAgICAgICAgICAgICByZWFkeUVycm9ycy5sZW5ndGggPiAxID8gJ3MnIDogJycpKSkpO1xyXG4gICAgfVxyXG4gICAgdmFyIGlzU2VydmVyRXJyb3IgPSBub2RlU3RhY2tGcmFtZXNfMS5pc05vZGVFcnJvcihhY3RpdmVFcnJvci5lcnJvcik7XHJcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoT3ZlcmxheV8xLk92ZXJsYXksIG51bGwsXHJcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChEaWFsb2dfMS5EaWFsb2csIHsgdHlwZTogXCJlcnJvclwiLCBcImFyaWEtbGFiZWxsZWRieVwiOiBcIm5leHRqc19fY29udGFpbmVyX2Vycm9yc19sYWJlbFwiLCBcImFyaWEtZGVzY3JpYmVkYnlcIjogXCJuZXh0anNfX2NvbnRhaW5lcl9lcnJvcnNfZGVzY1wiLCBvbkNsb3NlOiBtaW5pbWl6ZSB9LFxyXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KERpYWxvZ18xLkRpYWxvZ0NvbnRlbnQsIG51bGwsXHJcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KERpYWxvZ18xLkRpYWxvZ0hlYWRlciwgeyBjbGFzc05hbWU6IFwibmV4dGpzLWNvbnRhaW5lci1lcnJvcnMtaGVhZGVyXCIgfSxcclxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KExlZnRSaWdodERpYWxvZ0hlYWRlcl8xLkxlZnRSaWdodERpYWxvZ0hlYWRlciwgeyBwcmV2aW91czogYWN0aXZlSWR4ID4gMCA/IHByZXZpb3VzIDogbnVsbCwgbmV4dDogYWN0aXZlSWR4IDwgcmVhZHlFcnJvcnMubGVuZ3RoIC0gMSA/IG5leHQgOiBudWxsLCBjbG9zZTogbWluaW1pemUgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInNtYWxsXCIsIG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCBudWxsLCBhY3RpdmVJZHggKyAxKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiIG9mXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnICcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCBudWxsLCByZWFkeUVycm9ycy5sZW5ndGgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgdW5oYW5kbGVkIGVycm9yXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkeUVycm9ycy5sZW5ndGggPCAyID8gJycgOiAncycpKSxcclxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiaDFcIiwgeyBpZDogXCJuZXh0anNfX2NvbnRhaW5lcl9lcnJvcnNfbGFiZWxcIiB9LCBpc1NlcnZlckVycm9yID8gJ1NlcnZlciBFcnJvcicgOiAnVW5oYW5kbGVkIFJ1bnRpbWUgRXJyb3InKSxcclxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwicFwiLCB7IGlkOiBcIm5leHRqc19fY29udGFpbmVyX2Vycm9yc19kZXNjXCIgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlRXJyb3IuZXJyb3IubmFtZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgXCI6IFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmVFcnJvci5lcnJvci5tZXNzYWdlKSxcclxuICAgICAgICAgICAgICAgICAgICBpc1NlcnZlckVycm9yID8gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInNtYWxsXCIsIG51bGwsIFwiVGhpcyBlcnJvciBoYXBwZW5lZCB3aGlsZSBnZW5lcmF0aW5nIHRoZSBwYWdlLiBBbnkgY29uc29sZSBsb2dzIHdpbGwgYmUgZGlzcGxheWVkIGluIHRoZSB0ZXJtaW5hbCB3aW5kb3cuXCIpKSkgOiB1bmRlZmluZWQpLFxyXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChEaWFsb2dfMS5EaWFsb2dCb2R5LCB7IGNsYXNzTmFtZTogXCJuZXh0anMtY29udGFpbmVyLWVycm9ycy1ib2R5XCIgfSxcclxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFJ1bnRpbWVFcnJvcl8xLlJ1bnRpbWVFcnJvciwgeyBrZXk6IGFjdGl2ZUVycm9yLmlkLnRvU3RyaW5nKCksIGVycm9yOiBhY3RpdmVFcnJvciB9KSkpKSkpO1xyXG59O1xyXG5leHBvcnRzLnN0eWxlcyA9IG5vb3BfdGVtcGxhdGVfMS5ub29wKHRlbXBsYXRlT2JqZWN0XzEgfHwgKHRlbXBsYXRlT2JqZWN0XzEgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG4gIC5uZXh0anMtY29udGFpbmVyLWVycm9ycy1oZWFkZXIgPiBoMSB7XFxuICAgIGZvbnQtc2l6ZTogdmFyKC0tc2l6ZS1mb250LWJpZyk7XFxuICAgIGxpbmUtaGVpZ2h0OiB2YXIoLS1zaXplLWZvbnQtYmlnZ2VyKTtcXG4gICAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxuICAgIG1hcmdpbjogMDtcXG4gICAgbWFyZ2luLXRvcDogY2FsYyh2YXIoLS1zaXplLWdhcC1kb3VibGUpICsgdmFyKC0tc2l6ZS1nYXAtaGFsZikpO1xcbiAgfVxcbiAgLm5leHRqcy1jb250YWluZXItZXJyb3JzLWhlYWRlciBzbWFsbCB7XFxuICAgIGZvbnQtc2l6ZTogdmFyKC0tc2l6ZS1mb250LXNtYWxsKTtcXG4gICAgY29sb3I6IHZhcigtLWNvbG9yLWFjY2VudHMtMSk7XFxuICAgIG1hcmdpbi1sZWZ0OiB2YXIoLS1zaXplLWdhcC1kb3VibGUpO1xcbiAgfVxcbiAgLm5leHRqcy1jb250YWluZXItZXJyb3JzLWhlYWRlciBzbWFsbCA+IHNwYW4ge1xcbiAgICBmb250LWZhbWlseTogdmFyKC0tZm9udC1zdGFjay1tb25vc3BhY2UpO1xcbiAgfVxcbiAgLm5leHRqcy1jb250YWluZXItZXJyb3JzLWhlYWRlciA+IHAge1xcbiAgICBmb250LWZhbWlseTogdmFyKC0tZm9udC1zdGFjay1tb25vc3BhY2UpO1xcbiAgICBmb250LXNpemU6IHZhcigtLXNpemUtZm9udC1zbWFsbCk7XFxuICAgIGxpbmUtaGVpZ2h0OiB2YXIoLS1zaXplLWZvbnQtYmlnKTtcXG4gICAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxuICAgIG1hcmdpbjogMDtcXG4gICAgbWFyZ2luLXRvcDogdmFyKC0tc2l6ZS1nYXAtaGFsZik7XFxuICAgIGNvbG9yOiB2YXIoLS1jb2xvci1hbnNpLXJlZCk7XFxuICAgIHdoaXRlLXNwYWNlOiBwcmUtd3JhcDtcXG4gIH1cXG4gIC5uZXh0anMtY29udGFpbmVyLWVycm9ycy1oZWFkZXIgPiBkaXYgPiBzbWFsbCB7XFxuICAgIG1hcmdpbjogMDtcXG4gICAgbWFyZ2luLXRvcDogdmFyKC0tc2l6ZS1nYXAtaGFsZik7XFxuICB9XFxuXFxuICAubmV4dGpzLWNvbnRhaW5lci1lcnJvcnMtYm9keSA+IGg1Om5vdCg6Zmlyc3QtY2hpbGQpIHtcXG4gICAgbWFyZ2luLXRvcDogY2FsYyh2YXIoLS1zaXplLWdhcC1kb3VibGUpICsgdmFyKC0tc2l6ZS1nYXApKTtcXG4gIH1cXG4gIC5uZXh0anMtY29udGFpbmVyLWVycm9ycy1ib2R5ID4gaDUge1xcbiAgICBtYXJnaW4tYm90dG9tOiB2YXIoLS1zaXplLWdhcCk7XFxuICB9XFxuXFxuICAubmV4dGpzLXRvYXN0LWVycm9ycy1wYXJlbnQge1xcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxuICAgIHRyYW5zaXRpb246IHRyYW5zZm9ybSAwLjJzIGVhc2U7XFxuICB9XFxuICAubmV4dGpzLXRvYXN0LWVycm9ycy1wYXJlbnQ6aG92ZXIge1xcbiAgICB0cmFuc2Zvcm06IHNjYWxlKDEuMSk7XFxuICB9XFxuICAubmV4dGpzLXRvYXN0LWVycm9ycyB7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgIGp1c3RpZnktY29udGVudDogZmxleC1zdGFydDtcXG4gIH1cXG4gIC5uZXh0anMtdG9hc3QtZXJyb3JzID4gc3ZnIHtcXG4gICAgbWFyZ2luLXJpZ2h0OiB2YXIoLS1zaXplLWdhcCk7XFxuICB9XFxuXCJdLCBbXCJcXG4gIC5uZXh0anMtY29udGFpbmVyLWVycm9ycy1oZWFkZXIgPiBoMSB7XFxuICAgIGZvbnQtc2l6ZTogdmFyKC0tc2l6ZS1mb250LWJpZyk7XFxuICAgIGxpbmUtaGVpZ2h0OiB2YXIoLS1zaXplLWZvbnQtYmlnZ2VyKTtcXG4gICAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxuICAgIG1hcmdpbjogMDtcXG4gICAgbWFyZ2luLXRvcDogY2FsYyh2YXIoLS1zaXplLWdhcC1kb3VibGUpICsgdmFyKC0tc2l6ZS1nYXAtaGFsZikpO1xcbiAgfVxcbiAgLm5leHRqcy1jb250YWluZXItZXJyb3JzLWhlYWRlciBzbWFsbCB7XFxuICAgIGZvbnQtc2l6ZTogdmFyKC0tc2l6ZS1mb250LXNtYWxsKTtcXG4gICAgY29sb3I6IHZhcigtLWNvbG9yLWFjY2VudHMtMSk7XFxuICAgIG1hcmdpbi1sZWZ0OiB2YXIoLS1zaXplLWdhcC1kb3VibGUpO1xcbiAgfVxcbiAgLm5leHRqcy1jb250YWluZXItZXJyb3JzLWhlYWRlciBzbWFsbCA+IHNwYW4ge1xcbiAgICBmb250LWZhbWlseTogdmFyKC0tZm9udC1zdGFjay1tb25vc3BhY2UpO1xcbiAgfVxcbiAgLm5leHRqcy1jb250YWluZXItZXJyb3JzLWhlYWRlciA+IHAge1xcbiAgICBmb250LWZhbWlseTogdmFyKC0tZm9udC1zdGFjay1tb25vc3BhY2UpO1xcbiAgICBmb250LXNpemU6IHZhcigtLXNpemUtZm9udC1zbWFsbCk7XFxuICAgIGxpbmUtaGVpZ2h0OiB2YXIoLS1zaXplLWZvbnQtYmlnKTtcXG4gICAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxuICAgIG1hcmdpbjogMDtcXG4gICAgbWFyZ2luLXRvcDogdmFyKC0tc2l6ZS1nYXAtaGFsZik7XFxuICAgIGNvbG9yOiB2YXIoLS1jb2xvci1hbnNpLXJlZCk7XFxuICAgIHdoaXRlLXNwYWNlOiBwcmUtd3JhcDtcXG4gIH1cXG4gIC5uZXh0anMtY29udGFpbmVyLWVycm9ycy1oZWFkZXIgPiBkaXYgPiBzbWFsbCB7XFxuICAgIG1hcmdpbjogMDtcXG4gICAgbWFyZ2luLXRvcDogdmFyKC0tc2l6ZS1nYXAtaGFsZik7XFxuICB9XFxuXFxuICAubmV4dGpzLWNvbnRhaW5lci1lcnJvcnMtYm9keSA+IGg1Om5vdCg6Zmlyc3QtY2hpbGQpIHtcXG4gICAgbWFyZ2luLXRvcDogY2FsYyh2YXIoLS1zaXplLWdhcC1kb3VibGUpICsgdmFyKC0tc2l6ZS1nYXApKTtcXG4gIH1cXG4gIC5uZXh0anMtY29udGFpbmVyLWVycm9ycy1ib2R5ID4gaDUge1xcbiAgICBtYXJnaW4tYm90dG9tOiB2YXIoLS1zaXplLWdhcCk7XFxuICB9XFxuXFxuICAubmV4dGpzLXRvYXN0LWVycm9ycy1wYXJlbnQge1xcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxuICAgIHRyYW5zaXRpb246IHRyYW5zZm9ybSAwLjJzIGVhc2U7XFxuICB9XFxuICAubmV4dGpzLXRvYXN0LWVycm9ycy1wYXJlbnQ6aG92ZXIge1xcbiAgICB0cmFuc2Zvcm06IHNjYWxlKDEuMSk7XFxuICB9XFxuICAubmV4dGpzLXRvYXN0LWVycm9ycyB7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgIGp1c3RpZnktY29udGVudDogZmxleC1zdGFydDtcXG4gIH1cXG4gIC5uZXh0anMtdG9hc3QtZXJyb3JzID4gc3ZnIHtcXG4gICAgbWFyZ2luLXJpZ2h0OiB2YXIoLS1zaXplLWdhcCk7XFxuICB9XFxuXCJdKSkpO1xyXG52YXIgdGVtcGxhdGVPYmplY3RfMTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX21ha2VUZW1wbGF0ZU9iamVjdCA9ICh0aGlzICYmIHRoaXMuX19tYWtlVGVtcGxhdGVPYmplY3QpIHx8IGZ1bmN0aW9uIChjb29rZWQsIHJhdykge1xyXG4gICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cclxuICAgIHJldHVybiBjb29rZWQ7XHJcbn07XHJcbnZhciBfX3JlYWQgPSAodGhpcyAmJiB0aGlzLl9fcmVhZCkgfHwgZnVuY3Rpb24gKG8sIG4pIHtcclxuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcclxuICAgIGlmICghbSkgcmV0dXJuIG87XHJcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cclxuICAgIGZpbmFsbHkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cclxuICAgIH1cclxuICAgIHJldHVybiBhcjtcclxufTtcclxudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xyXG4gICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcclxuICAgIHJlc3VsdFtcImRlZmF1bHRcIl0gPSBtb2Q7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xyXG52YXIgUmVhY3QgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcInJlYWN0XCIpKTtcclxudmFyIENvZGVGcmFtZV8xID0gcmVxdWlyZShcIi4uL2NvbXBvbmVudHMvQ29kZUZyYW1lXCIpO1xyXG52YXIgbm9vcF90ZW1wbGF0ZV8xID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvbm9vcC10ZW1wbGF0ZVwiKTtcclxudmFyIHN0YWNrX2ZyYW1lXzEgPSByZXF1aXJlKFwiLi4vaGVscGVycy9zdGFjay1mcmFtZVwiKTtcclxudmFyIENhbGxTdGFja0ZyYW1lID0gZnVuY3Rpb24gQ2FsbFN0YWNrRnJhbWUoX2EpIHtcclxuICAgIC8vIFRPRE86IGFiaWxpdHkgdG8gZXhwYW5kIHJlc29sdmVkIGZyYW1lc1xyXG4gICAgLy8gVE9ETzogcmVuZGVyIGVycm9yIG9yIGV4dGVybmFsIGluZGljYXRvclxyXG4gICAgdmFyIGZyYW1lID0gX2EuZnJhbWU7XHJcbiAgICB2YXIgX2I7XHJcbiAgICB2YXIgZiA9IChfYiA9IGZyYW1lLm9yaWdpbmFsU3RhY2tGcmFtZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZnJhbWUuc291cmNlU3RhY2tGcmFtZTtcclxuICAgIHZhciBoYXNTb3VyY2UgPSBCb29sZWFuKGZyYW1lLm9yaWdpbmFsQ29kZUZyYW1lKTtcclxuICAgIHZhciBvcGVuID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBpZiAoIWhhc1NvdXJjZSlcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIHZhciBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XHJcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGYpIHtcclxuICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChrZXksICgoX2EgPSBmW2tleV0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnKS50b1N0cmluZygpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2VsZi5mZXRjaChcIi9fX25leHRqc19sYXVuY2gtZWRpdG9yP1wiICsgcGFyYW1zLnRvU3RyaW5nKCkpLnRoZW4oZnVuY3Rpb24gKCkgeyB9LCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIC8vIFRPRE86IHJlcG9ydCBlcnJvclxyXG4gICAgICAgIH0pO1xyXG4gICAgfSwgW2hhc1NvdXJjZSwgZl0pO1xyXG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgXCJkYXRhLW5leHRqcy1jYWxsLXN0YWNrLWZyYW1lXCI6IHRydWUgfSxcclxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiaDZcIiwgeyBcImRhdGEtbmV4dGpzLWZyYW1lLWV4cGFuZGVkXCI6IEJvb2xlYW4oZnJhbWUuZXhwYW5kZWQpIH0sIGYubWV0aG9kTmFtZSksXHJcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IFwiZGF0YS1oYXMtc291cmNlXCI6IGhhc1NvdXJjZSA/ICd0cnVlJyA6IHVuZGVmaW5lZCwgdGFiSW5kZXg6IGhhc1NvdXJjZSA/IDEwIDogdW5kZWZpbmVkLCByb2xlOiBoYXNTb3VyY2UgPyAnbGluaycgOiB1bmRlZmluZWQsIG9uQ2xpY2s6IG9wZW4sIHRpdGxlOiBoYXNTb3VyY2UgPyAnQ2xpY2sgdG8gb3BlbiBpbiB5b3VyIGVkaXRvcicgOiB1bmRlZmluZWQgfSxcclxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgbnVsbCwgc3RhY2tfZnJhbWVfMS5nZXRGcmFtZVNvdXJjZShmKSksXHJcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdmdcIiwgeyB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCB2aWV3Qm94OiBcIjAgMCAyNCAyNFwiLCBmaWxsOiBcIm5vbmVcIiwgc3Ryb2tlOiBcImN1cnJlbnRDb2xvclwiLCBzdHJva2VXaWR0aDogXCIyXCIsIHN0cm9rZUxpbmVjYXA6IFwicm91bmRcIiwgc3Ryb2tlTGluZWpvaW46IFwicm91bmRcIiB9LFxyXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInBhdGhcIiwgeyBkOiBcIk0xOCAxM3Y2YTIgMiAwIDAgMS0yIDJINWEyIDIgMCAwIDEtMi0yVjhhMiAyIDAgMCAxIDItMmg2XCIgfSksXHJcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwicG9seWxpbmVcIiwgeyBwb2ludHM6IFwiMTUgMyAyMSAzIDIxIDlcIiB9KSxcclxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJsaW5lXCIsIHsgeDE6IFwiMTBcIiwgeTE6IFwiMTRcIiwgeDI6IFwiMjFcIiwgeTI6IFwiM1wiIH0pKSkpKTtcclxufTtcclxudmFyIFJ1bnRpbWVFcnJvciA9IGZ1bmN0aW9uIFJ1bnRpbWVFcnJvcihfYSkge1xyXG4gICAgdmFyIGVycm9yID0gX2EuZXJyb3I7XHJcbiAgICB2YXIgZmlyc3RGaXJzdFBhcnR5RnJhbWVJbmRleCA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBlcnJvci5mcmFtZXMuZmluZEluZGV4KGZ1bmN0aW9uIChlbnRyeSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZW50cnkuZXhwYW5kZWQgJiZcclxuICAgICAgICAgICAgICAgIEJvb2xlYW4oZW50cnkub3JpZ2luYWxDb2RlRnJhbWUpICYmXHJcbiAgICAgICAgICAgICAgICBCb29sZWFuKGVudHJ5Lm9yaWdpbmFsU3RhY2tGcmFtZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9LCBbZXJyb3IuZnJhbWVzXSk7XHJcbiAgICB2YXIgZmlyc3RGcmFtZSA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICByZXR1cm4gKF9hID0gZXJyb3IuZnJhbWVzW2ZpcnN0Rmlyc3RQYXJ0eUZyYW1lSW5kZXhdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBudWxsO1xyXG4gICAgfSwgW2Vycm9yLmZyYW1lcywgZmlyc3RGaXJzdFBhcnR5RnJhbWVJbmRleF0pO1xyXG4gICAgdmFyIGFsbExlYWRpbmdGcmFtZXMgPSBSZWFjdC51c2VNZW1vKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gZmlyc3RGaXJzdFBhcnR5RnJhbWVJbmRleCA8IDBcclxuICAgICAgICAgICAgPyBbXVxyXG4gICAgICAgICAgICA6IGVycm9yLmZyYW1lcy5zbGljZSgwLCBmaXJzdEZpcnN0UGFydHlGcmFtZUluZGV4KTtcclxuICAgIH0sIFtlcnJvci5mcmFtZXMsIGZpcnN0Rmlyc3RQYXJ0eUZyYW1lSW5kZXhdKTtcclxuICAgIHZhciBfYiA9IF9fcmVhZChSZWFjdC51c2VTdGF0ZShmaXJzdEZyYW1lID09IG51bGwpLCAyKSwgYWxsID0gX2JbMF0sIHNldEFsbCA9IF9iWzFdO1xyXG4gICAgdmFyIHRvZ2dsZUFsbCA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBzZXRBbGwoZnVuY3Rpb24gKHYpIHsgcmV0dXJuICF2OyB9KTtcclxuICAgIH0sIFtdKTtcclxuICAgIHZhciBsZWFkaW5nRnJhbWVzID0gUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7IHJldHVybiBhbGxMZWFkaW5nRnJhbWVzLmZpbHRlcihmdW5jdGlvbiAoZikgeyByZXR1cm4gZi5leHBhbmRlZCB8fCBhbGw7IH0pOyB9LCBbYWxsLCBhbGxMZWFkaW5nRnJhbWVzXSk7XHJcbiAgICB2YXIgYWxsQ2FsbFN0YWNrRnJhbWVzID0gUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7IHJldHVybiBlcnJvci5mcmFtZXMuc2xpY2UoZmlyc3RGaXJzdFBhcnR5RnJhbWVJbmRleCArIDEpOyB9LCBbZXJyb3IuZnJhbWVzLCBmaXJzdEZpcnN0UGFydHlGcmFtZUluZGV4XSk7XHJcbiAgICB2YXIgdmlzaWJsZUNhbGxTdGFja0ZyYW1lcyA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkgeyByZXR1cm4gYWxsQ2FsbFN0YWNrRnJhbWVzLmZpbHRlcihmdW5jdGlvbiAoZikgeyByZXR1cm4gZi5leHBhbmRlZCB8fCBhbGw7IH0pOyB9LCBbYWxsLCBhbGxDYWxsU3RhY2tGcmFtZXNdKTtcclxuICAgIHZhciBjYW5TaG93TW9yZSA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiAoYWxsQ2FsbFN0YWNrRnJhbWVzLmxlbmd0aCAhPT0gdmlzaWJsZUNhbGxTdGFja0ZyYW1lcy5sZW5ndGggfHxcclxuICAgICAgICAgICAgKGFsbCAmJiBmaXJzdEZyYW1lICE9IG51bGwpKTtcclxuICAgIH0sIFtcclxuICAgICAgICBhbGwsXHJcbiAgICAgICAgYWxsQ2FsbFN0YWNrRnJhbWVzLmxlbmd0aCxcclxuICAgICAgICBmaXJzdEZyYW1lLFxyXG4gICAgICAgIHZpc2libGVDYWxsU3RhY2tGcmFtZXMubGVuZ3RoLFxyXG4gICAgXSk7XHJcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsXHJcbiAgICAgICAgZmlyc3RGcmFtZSA/IChSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLFxyXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiaDVcIiwgbnVsbCwgXCJTb3VyY2VcIiksXHJcbiAgICAgICAgICAgIGxlYWRpbmdGcmFtZXMubWFwKGZ1bmN0aW9uIChmcmFtZSwgaW5kZXgpIHsgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KENhbGxTdGFja0ZyYW1lLCB7IGtleTogXCJsZWFkaW5nLWZyYW1lLVwiICsgaW5kZXggKyBcIi1cIiArIGFsbCwgZnJhbWU6IGZyYW1lIH0pKTsgfSksXHJcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29kZUZyYW1lXzEuQ29kZUZyYW1lLCB7IHN0YWNrRnJhbWU6IGZpcnN0RnJhbWUub3JpZ2luYWxTdGFja0ZyYW1lLCBjb2RlRnJhbWU6IGZpcnN0RnJhbWUub3JpZ2luYWxDb2RlRnJhbWUgfSkpKSA6IHVuZGVmaW5lZCxcclxuICAgICAgICB2aXNpYmxlQ2FsbFN0YWNrRnJhbWVzLmxlbmd0aCA/IChSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLFxyXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiaDVcIiwgbnVsbCwgXCJDYWxsIFN0YWNrXCIpLFxyXG4gICAgICAgICAgICB2aXNpYmxlQ2FsbFN0YWNrRnJhbWVzLm1hcChmdW5jdGlvbiAoZnJhbWUsIGluZGV4KSB7IHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChDYWxsU3RhY2tGcmFtZSwgeyBrZXk6IFwiY2FsbC1zdGFjay1cIiArIGluZGV4ICsgXCItXCIgKyBhbGwsIGZyYW1lOiBmcmFtZSB9KSk7IH0pKSkgOiB1bmRlZmluZWQsXHJcbiAgICAgICAgY2FuU2hvd01vcmUgPyAoUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCxcclxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLCB7IHRhYkluZGV4OiAxMCwgXCJkYXRhLW5leHRqcy1kYXRhLXJ1bnRpbWUtZXJyb3ItY29sbGFwc2VkLWFjdGlvblwiOiB0cnVlLCB0eXBlOiBcImJ1dHRvblwiLCBvbkNsaWNrOiB0b2dnbGVBbGwgfSxcclxuICAgICAgICAgICAgICAgIGFsbCA/ICdIaWRlJyA6ICdTaG93JyxcclxuICAgICAgICAgICAgICAgIFwiIGNvbGxhcHNlZCBmcmFtZXNcIikpKSA6IHVuZGVmaW5lZCkpO1xyXG59O1xyXG5leHBvcnRzLlJ1bnRpbWVFcnJvciA9IFJ1bnRpbWVFcnJvcjtcclxuZXhwb3J0cy5zdHlsZXMgPSBub29wX3RlbXBsYXRlXzEubm9vcCh0ZW1wbGF0ZU9iamVjdF8xIHx8ICh0ZW1wbGF0ZU9iamVjdF8xID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuICBidXR0b25bZGF0YS1uZXh0anMtZGF0YS1ydW50aW1lLWVycm9yLWNvbGxhcHNlZC1hY3Rpb25dIHtcXG4gICAgYmFja2dyb3VuZDogbm9uZTtcXG4gICAgYm9yZGVyOiBub25lO1xcbiAgICBwYWRkaW5nOiAwO1xcbiAgICBmb250LXNpemU6IHZhcigtLXNpemUtZm9udC1zbWFsbCk7XFxuICAgIGxpbmUtaGVpZ2h0OiB2YXIoLS1zaXplLWZvbnQtYmlnZ2VyKTtcXG4gICAgY29sb3I6IHZhcigtLWNvbG9yLWFjY2VudHMtMyk7XFxuICB9XFxuXFxuICBbZGF0YS1uZXh0anMtY2FsbC1zdGFjay1mcmFtZV06bm90KDpsYXN0LWNoaWxkKSB7XFxuICAgIG1hcmdpbi1ib3R0b206IHZhcigtLXNpemUtZ2FwLWRvdWJsZSk7XFxuICB9XFxuXFxuICBbZGF0YS1uZXh0anMtY2FsbC1zdGFjay1mcmFtZV0gPiBoNiB7XFxuICAgIG1hcmdpbi10b3A6IDA7XFxuICAgIG1hcmdpbi1ib3R0b206IHZhcigtLXNpemUtZ2FwKTtcXG4gICAgZm9udC1mYW1pbHk6IHZhcigtLWZvbnQtc3RhY2stbW9ub3NwYWNlKTtcXG4gICAgY29sb3I6ICMyMjI7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtY2FsbC1zdGFjay1mcmFtZV0gPiBoNltkYXRhLW5leHRqcy1mcmFtZS1leHBhbmRlZD0nZmFsc2UnXSB7XFxuICAgIGNvbG9yOiAjNjY2O1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWNhbGwtc3RhY2stZnJhbWVdID4gZGl2IHtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAgcGFkZGluZy1sZWZ0OiBjYWxjKHZhcigtLXNpemUtZ2FwKSArIHZhcigtLXNpemUtZ2FwLWhhbGYpKTtcXG4gICAgZm9udC1zaXplOiB2YXIoLS1zaXplLWZvbnQtc21hbGwpO1xcbiAgICBjb2xvcjogIzk5OTtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1jYWxsLXN0YWNrLWZyYW1lXSA+IGRpdiA+IHN2ZyB7XFxuICAgIHdpZHRoOiBhdXRvO1xcbiAgICBoZWlnaHQ6IHZhcigtLXNpemUtZm9udC1zbWFsbCk7XFxuICAgIG1hcmdpbi1sZWZ0OiB2YXIoLS1zaXplLWdhcCk7XFxuXFxuICAgIGRpc3BsYXk6IG5vbmU7XFxuICB9XFxuXFxuICBbZGF0YS1uZXh0anMtY2FsbC1zdGFjay1mcmFtZV0gPiBkaXZbZGF0YS1oYXMtc291cmNlXSB7XFxuICAgIGN1cnNvcjogcG9pbnRlcjtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1jYWxsLXN0YWNrLWZyYW1lXSA+IGRpdltkYXRhLWhhcy1zb3VyY2VdOmhvdmVyIHtcXG4gICAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmUgZG90dGVkO1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWNhbGwtc3RhY2stZnJhbWVdID4gZGl2W2RhdGEtaGFzLXNvdXJjZV0gPiBzdmcge1xcbiAgICBkaXNwbGF5OiB1bnNldDtcXG4gIH1cXG5cIl0sIFtcIlxcbiAgYnV0dG9uW2RhdGEtbmV4dGpzLWRhdGEtcnVudGltZS1lcnJvci1jb2xsYXBzZWQtYWN0aW9uXSB7XFxuICAgIGJhY2tncm91bmQ6IG5vbmU7XFxuICAgIGJvcmRlcjogbm9uZTtcXG4gICAgcGFkZGluZzogMDtcXG4gICAgZm9udC1zaXplOiB2YXIoLS1zaXplLWZvbnQtc21hbGwpO1xcbiAgICBsaW5lLWhlaWdodDogdmFyKC0tc2l6ZS1mb250LWJpZ2dlcik7XFxuICAgIGNvbG9yOiB2YXIoLS1jb2xvci1hY2NlbnRzLTMpO1xcbiAgfVxcblxcbiAgW2RhdGEtbmV4dGpzLWNhbGwtc3RhY2stZnJhbWVdOm5vdCg6bGFzdC1jaGlsZCkge1xcbiAgICBtYXJnaW4tYm90dG9tOiB2YXIoLS1zaXplLWdhcC1kb3VibGUpO1xcbiAgfVxcblxcbiAgW2RhdGEtbmV4dGpzLWNhbGwtc3RhY2stZnJhbWVdID4gaDYge1xcbiAgICBtYXJnaW4tdG9wOiAwO1xcbiAgICBtYXJnaW4tYm90dG9tOiB2YXIoLS1zaXplLWdhcCk7XFxuICAgIGZvbnQtZmFtaWx5OiB2YXIoLS1mb250LXN0YWNrLW1vbm9zcGFjZSk7XFxuICAgIGNvbG9yOiAjMjIyO1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWNhbGwtc3RhY2stZnJhbWVdID4gaDZbZGF0YS1uZXh0anMtZnJhbWUtZXhwYW5kZWQ9J2ZhbHNlJ10ge1xcbiAgICBjb2xvcjogIzY2NjtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1jYWxsLXN0YWNrLWZyYW1lXSA+IGRpdiB7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgIHBhZGRpbmctbGVmdDogY2FsYyh2YXIoLS1zaXplLWdhcCkgKyB2YXIoLS1zaXplLWdhcC1oYWxmKSk7XFxuICAgIGZvbnQtc2l6ZTogdmFyKC0tc2l6ZS1mb250LXNtYWxsKTtcXG4gICAgY29sb3I6ICM5OTk7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtY2FsbC1zdGFjay1mcmFtZV0gPiBkaXYgPiBzdmcge1xcbiAgICB3aWR0aDogYXV0bztcXG4gICAgaGVpZ2h0OiB2YXIoLS1zaXplLWZvbnQtc21hbGwpO1xcbiAgICBtYXJnaW4tbGVmdDogdmFyKC0tc2l6ZS1nYXApO1xcblxcbiAgICBkaXNwbGF5OiBub25lO1xcbiAgfVxcblxcbiAgW2RhdGEtbmV4dGpzLWNhbGwtc3RhY2stZnJhbWVdID4gZGl2W2RhdGEtaGFzLXNvdXJjZV0ge1xcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtY2FsbC1zdGFjay1mcmFtZV0gPiBkaXZbZGF0YS1oYXMtc291cmNlXTpob3ZlciB7XFxuICAgIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lIGRvdHRlZDtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1jYWxsLXN0YWNrLWZyYW1lXSA+IGRpdltkYXRhLWhhcy1zb3VyY2VdID4gc3ZnIHtcXG4gICAgZGlzcGxheTogdW5zZXQ7XFxuICB9XFxuXCJdKSkpO1xyXG52YXIgdGVtcGxhdGVPYmplY3RfMTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcclxuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcclxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufTtcclxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxudmFyIHN0YWNrdHJhY2VfcGFyc2VyXzEgPSByZXF1aXJlKFwic3RhY2t0cmFjZS1wYXJzZXJcIik7XHJcbmZ1bmN0aW9uIGdldEZpbGVzeXN0ZW1GcmFtZShmcmFtZSkge1xyXG4gICAgdmFyIGYgPSBfX2Fzc2lnbih7fSwgZnJhbWUpO1xyXG4gICAgaWYgKHR5cGVvZiBmLmZpbGUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgaWYgKFxyXG4gICAgICAgIC8vIFBvc2l4OlxyXG4gICAgICAgIGYuZmlsZS5zdGFydHNXaXRoKCcvJykgfHxcclxuICAgICAgICAgICAgLy8gV2luMzI6XHJcbiAgICAgICAgICAgIC9eW2Etel06XFxcXC9pLnRlc3QoZi5maWxlKSB8fFxyXG4gICAgICAgICAgICAvLyBXaW4zMiBVTkM6XHJcbiAgICAgICAgICAgIGYuZmlsZS5zdGFydHNXaXRoKCdcXFxcXFxcXCcpKSB7XHJcbiAgICAgICAgICAgIGYuZmlsZSA9IFwiZmlsZTovL1wiICsgZi5maWxlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBmO1xyXG59XHJcbmV4cG9ydHMuZ2V0RmlsZXN5c3RlbUZyYW1lID0gZ2V0RmlsZXN5c3RlbUZyYW1lO1xyXG52YXIgc3ltYm9sTm9kZUVycm9yID0gU3ltYm9sKCdOZXh0anNOb2RlRXJyb3InKTtcclxuZnVuY3Rpb24gaXNOb2RlRXJyb3IoZXJyb3IpIHtcclxuICAgIHJldHVybiBzeW1ib2xOb2RlRXJyb3IgaW4gZXJyb3I7XHJcbn1cclxuZXhwb3J0cy5pc05vZGVFcnJvciA9IGlzTm9kZUVycm9yO1xyXG5mdW5jdGlvbiBnZXROb2RlRXJyb3IoZXJyb3IpIHtcclxuICAgIHZhciBuO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3IubWVzc2FnZSk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgIG4gPSBlO1xyXG4gICAgfVxyXG4gICAgbi5uYW1lID0gZXJyb3IubmFtZTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgbi5zdGFjayA9IHN0YWNrdHJhY2VfcGFyc2VyXzEucGFyc2UoZXJyb3Iuc3RhY2spXHJcbiAgICAgICAgICAgIC5tYXAoZ2V0RmlsZXN5c3RlbUZyYW1lKVxyXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChmKSB7XHJcbiAgICAgICAgICAgIHZhciBzdHIgPSBcIiAgICBhdCBcIiArIGYubWV0aG9kTmFtZTtcclxuICAgICAgICAgICAgaWYgKGYuZmlsZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGxvYyA9IGYuZmlsZTtcclxuICAgICAgICAgICAgICAgIGlmIChmLmxpbmVOdW1iZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBsb2MgKz0gXCI6XCIgKyBmLmxpbmVOdW1iZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGYuY29sdW1uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvYyArPSBcIjpcIiArIGYuY29sdW1uO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHN0ciArPSBcIiAoXCIgKyBsb2MgKyBcIilcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gc3RyO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5qb2luKCdcXG4nKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChfYSkge1xyXG4gICAgICAgIG4uc3RhY2sgPSBlcnJvci5zdGFjaztcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBzeW1ib2xOb2RlRXJyb3IsIHtcclxuICAgICAgICB3cml0YWJsZTogZmFsc2UsXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gbjtcclxufVxyXG5leHBvcnRzLmdldE5vZGVFcnJvciA9IGdldE5vZGVFcnJvcjtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XHJcbmZ1bmN0aW9uIG5vb3Aoc3RyaW5ncykge1xyXG4gICAgdmFyIGtleXMgPSBbXTtcclxuICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAga2V5c1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcclxuICAgIH1cclxuICAgIHZhciBsYXN0SW5kZXggPSBzdHJpbmdzLmxlbmd0aCAtIDE7XHJcbiAgICByZXR1cm4gKHN0cmluZ3Muc2xpY2UoMCwgbGFzdEluZGV4KS5yZWR1Y2UoZnVuY3Rpb24gKHAsIHMsIGkpIHsgcmV0dXJuIHAgKyBzICsga2V5c1tpXTsgfSwgJycpICtcclxuICAgICAgICBzdHJpbmdzW2xhc3RJbmRleF0pO1xyXG59XHJcbmV4cG9ydHMubm9vcCA9IG5vb3A7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xyXG52YXIgc3RhY2t0cmFjZV9wYXJzZXJfMSA9IHJlcXVpcmUoXCJzdGFja3RyYWNlLXBhcnNlclwiKTtcclxudmFyIHJlZ2V4TmV4dFN0YXRpYyA9IC9cXC9fbmV4dChcXC9zdGF0aWNcXC8uKykvZztcclxuZnVuY3Rpb24gcGFyc2VTdGFjayhzdGFjaykge1xyXG4gICAgdmFyIGZyYW1lcyA9IHN0YWNrdHJhY2VfcGFyc2VyXzEucGFyc2Uoc3RhY2spO1xyXG4gICAgcmV0dXJuIGZyYW1lcy5tYXAoZnVuY3Rpb24gKGZyYW1lKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICB2YXIgdXJsID0gbmV3IFVSTChmcmFtZS5maWxlKTtcclxuICAgICAgICAgICAgdmFyIHJlcyA9IHJlZ2V4TmV4dFN0YXRpYy5leGVjKHVybC5wYXRobmFtZSk7XHJcbiAgICAgICAgICAgIGlmIChyZXMpIHtcclxuICAgICAgICAgICAgICAgIHZhciBkaXN0RGlyID0gKF9iID0gKF9hID0gcHJvY2Vzcy5lbnYuX19ORVhUX0RJU1RfRElSKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVwbGFjZSgvXFxcXC9nLCAnLycpKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IucmVwbGFjZSgvXFwvJC8sICcnKTtcclxuICAgICAgICAgICAgICAgIGlmIChkaXN0RGlyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZnJhbWUuZmlsZSA9ICdmaWxlOi8vJyArIGRpc3REaXIuY29uY2F0KHJlcy5wb3AoKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKF9jKSB7IH1cclxuICAgICAgICByZXR1cm4gZnJhbWU7XHJcbiAgICB9KTtcclxufVxyXG5leHBvcnRzLnBhcnNlU3RhY2sgPSBwYXJzZVN0YWNrO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59O1xyXG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xyXG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcclxuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XHJcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xyXG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xyXG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcclxuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XHJcbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XHJcbiAgICB9XHJcbn07XHJcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XHJcbmZ1bmN0aW9uIGdldE9yaWdpbmFsU3RhY2tGcmFtZXMoaXNTZXJ2ZXJTaWRlLCBmcmFtZXMpIHtcclxuICAgIHJldHVybiBQcm9taXNlLmFsbChmcmFtZXMubWFwKGZ1bmN0aW9uIChmcmFtZSkgeyByZXR1cm4gZ2V0T3JpZ2luYWxTdGFja0ZyYW1lKGlzU2VydmVyU2lkZSwgZnJhbWUpOyB9KSk7XHJcbn1cclxuZXhwb3J0cy5nZXRPcmlnaW5hbFN0YWNrRnJhbWVzID0gZ2V0T3JpZ2luYWxTdGFja0ZyYW1lcztcclxuZnVuY3Rpb24gZ2V0T3JpZ2luYWxTdGFja0ZyYW1lKGlzU2VydmVyU2lkZSwgc291cmNlKSB7XHJcbiAgICB2YXIgX2EsIF9iO1xyXG4gICAgZnVuY3Rpb24gX2dldE9yaWdpbmFsU3RhY2tGcmFtZSgpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHBhcmFtcywga2V5LCBjb250cm9sbGVyLCB0bSwgcmVzLCBfYywgX2QsIF9lLCBib2R5O1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9mKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9mLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoJ2lzU2VydmVyU2lkZScsIFN0cmluZyhpc1NlcnZlclNpZGUpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChrZXkgaW4gc291cmNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMuYXBwZW5kKGtleSwgKChfYSA9IHNvdXJjZVtrZXldKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJykudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG0gPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbnRyb2xsZXIuYWJvcnQoKTsgfSwgMzAwMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHNlbGZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmV0Y2goXCIvX19uZXh0anNfb3JpZ2luYWwtc3RhY2stZnJhbWU/XCIgKyBwYXJhbXMudG9TdHJpbmcoKSwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hbDogY29udHJvbGxlci5zaWduYWxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pW1wiZmluYWxseVwiXShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRtKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcyA9IF9mLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoIXJlcy5vayB8fCByZXMuc3RhdHVzID09PSAyMDQpKSByZXR1cm4gWzMgLypicmVhayovLCAzXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2QgPSAoX2MgPSBQcm9taXNlKS5yZWplY3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9lID0gRXJyb3IuYmluZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgcmVzLnRleHQoKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2QuYXBwbHkoX2MsIFtuZXcgKF9lLmFwcGx5KEVycm9yLCBbdm9pZCAwLCBfZi5zZW50KCldKSkoKV0pXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6IHJldHVybiBbNCAvKnlpZWxkKi8sIHJlcy5qc29uKCldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keSA9IF9mLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhc29uOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVybmFsOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBhbmRlZDogKChfYiA9IGJvZHkub3JpZ2luYWxTdGFja0ZyYW1lKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZmlsZSkgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIWJvZHkub3JpZ2luYWxTdGFja0ZyYW1lLmZpbGUuaW5jbHVkZXMoJ25vZGVfbW9kdWxlcycpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZVN0YWNrRnJhbWU6IHNvdXJjZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbFN0YWNrRnJhbWU6IGJvZHkub3JpZ2luYWxTdGFja0ZyYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsQ29kZUZyYW1lOiBib2R5Lm9yaWdpbmFsQ29kZUZyYW1lIHx8IG51bGxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1dO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGlmICghKCgoX2EgPSBzb3VyY2UuZmlsZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnN0YXJ0c1dpdGgoJ3dlYnBhY2staW50ZXJuYWw6JykpIHx8ICgoX2IgPSBzb3VyY2UuZmlsZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnN0YXJ0c1dpdGgoJ2ZpbGU6JykpKSkge1xyXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xyXG4gICAgICAgICAgICBlcnJvcjogZmFsc2UsXHJcbiAgICAgICAgICAgIHJlYXNvbjogbnVsbCxcclxuICAgICAgICAgICAgZXh0ZXJuYWw6IHRydWUsXHJcbiAgICAgICAgICAgIGV4cGFuZGVkOiBmYWxzZSxcclxuICAgICAgICAgICAgc291cmNlU3RhY2tGcmFtZTogc291cmNlLFxyXG4gICAgICAgICAgICBvcmlnaW5hbFN0YWNrRnJhbWU6IG51bGwsXHJcbiAgICAgICAgICAgIG9yaWdpbmFsQ29kZUZyYW1lOiBudWxsXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gX2dldE9yaWdpbmFsU3RhY2tGcmFtZSgpW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgcmV0dXJuICh7XHJcbiAgICAgICAgICAgIGVycm9yOiB0cnVlLFxyXG4gICAgICAgICAgICByZWFzb246IChfYiA9IChfYSA9IGVyciA9PT0gbnVsbCB8fCBlcnIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVyci5tZXNzYWdlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBlcnIgPT09IG51bGwgfHwgZXJyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlcnIudG9TdHJpbmcoKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJ1Vua25vd24gRXJyb3InLFxyXG4gICAgICAgICAgICBleHRlcm5hbDogZmFsc2UsXHJcbiAgICAgICAgICAgIGV4cGFuZGVkOiBmYWxzZSxcclxuICAgICAgICAgICAgc291cmNlU3RhY2tGcmFtZTogc291cmNlLFxyXG4gICAgICAgICAgICBvcmlnaW5hbFN0YWNrRnJhbWU6IG51bGwsXHJcbiAgICAgICAgICAgIG9yaWdpbmFsQ29kZUZyYW1lOiBudWxsXHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxufVxyXG5leHBvcnRzLmdldE9yaWdpbmFsU3RhY2tGcmFtZSA9IGdldE9yaWdpbmFsU3RhY2tGcmFtZTtcclxuZnVuY3Rpb24gZ2V0RnJhbWVTb3VyY2UoZnJhbWUpIHtcclxuICAgIHZhciBfYTtcclxuICAgIHZhciBzdHIgPSAnJztcclxuICAgIHRyeSB7XHJcbiAgICAgICAgdmFyIHUgPSBuZXcgVVJMKGZyYW1lLmZpbGUpO1xyXG4gICAgICAgIC8vIFN0cmlwIHRoZSBvcmlnaW4gZm9yIHNhbWUtb3JpZ2luIHNjcmlwdHMuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyAmJlxyXG4gICAgICAgICAgICAoKF9hID0gZ2xvYmFsVGhpcy5sb2NhdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm9yaWdpbikgIT09IHUub3JpZ2luKSB7XHJcbiAgICAgICAgICAgIC8vIFVSTHMgY2FuIGJlIHZhbGlkIHdpdGhvdXQgYW4gYG9yaWdpbmAsIHNvIGxvbmcgYXMgdGhleSBoYXZlIGFcclxuICAgICAgICAgICAgLy8gYHByb3RvY29sYC4gSG93ZXZlciwgYG9yaWdpbmAgaXMgcHJlZmVycmVkLlxyXG4gICAgICAgICAgICBpZiAodS5vcmlnaW4gPT09ICdudWxsJykge1xyXG4gICAgICAgICAgICAgICAgc3RyICs9IHUucHJvdG9jb2w7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzdHIgKz0gdS5vcmlnaW47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gU3RyaXAgcXVlcnkgc3RyaW5nIGluZm9ybWF0aW9uIGFzIGl0J3MgdHlwaWNhbGx5IHRvbyB2ZXJib3NlIHRvIGJlXHJcbiAgICAgICAgLy8gbWVhbmluZ2Z1bC5cclxuICAgICAgICBzdHIgKz0gdS5wYXRobmFtZTtcclxuICAgICAgICBzdHIgKz0gJyAnO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKF9iKSB7XHJcbiAgICAgICAgc3RyICs9IChmcmFtZS5maWxlIHx8ICcodW5rbm93biknKSArICcgJztcclxuICAgIH1cclxuICAgIGlmIChmcmFtZS5saW5lTnVtYmVyICE9IG51bGwpIHtcclxuICAgICAgICBpZiAoZnJhbWUuY29sdW1uICE9IG51bGwpIHtcclxuICAgICAgICAgICAgc3RyICs9IFwiKFwiICsgZnJhbWUubGluZU51bWJlciArIFwiOlwiICsgZnJhbWUuY29sdW1uICsgXCIpIFwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgc3RyICs9IFwiKFwiICsgZnJhbWUubGluZU51bWJlciArIFwiKSBcIjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc3RyLnNsaWNlKDAsIC0xKTtcclxufVxyXG5leHBvcnRzLmdldEZyYW1lU291cmNlID0gZ2V0RnJhbWVTb3VyY2U7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XHJcbiAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xyXG4gICAgcmVzdWx0W1wiZGVmYXVsdFwiXSA9IG1vZDtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn07XHJcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XHJcbnZhciBSZWFjdCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwicmVhY3RcIikpO1xyXG5mdW5jdGlvbiB1c2VPbkNsaWNrT3V0c2lkZShlbCwgaGFuZGxlcikge1xyXG4gICAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoZWwgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgIC8vIERvIG5vdGhpbmcgaWYgY2xpY2tpbmcgcmVmJ3MgZWxlbWVudCBvciBkZXNjZW5kZW50IGVsZW1lbnRzXHJcbiAgICAgICAgICAgIGlmICghZWwgfHwgZWwuY29udGFpbnMoZS50YXJnZXQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaGFuZGxlcihlKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciByb290ID0gZWwuZ2V0Um9vdE5vZGUoKTtcclxuICAgICAgICByb290LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGxpc3RlbmVyKTtcclxuICAgICAgICByb290LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBsaXN0ZW5lcik7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcm9vdC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBsaXN0ZW5lcik7XHJcbiAgICAgICAgICAgIHJvb3QucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIGxpc3RlbmVyKTtcclxuICAgICAgICB9O1xyXG4gICAgfSwgW2hhbmRsZXIsIGVsXSk7XHJcbn1cclxuZXhwb3J0cy51c2VPbkNsaWNrT3V0c2lkZSA9IHVzZU9uQ2xpY2tPdXRzaWRlO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fbWFrZVRlbXBsYXRlT2JqZWN0ID0gKHRoaXMgJiYgdGhpcy5fX21ha2VUZW1wbGF0ZU9iamVjdCkgfHwgZnVuY3Rpb24gKGNvb2tlZCwgcmF3KSB7XHJcbiAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb29rZWQsIFwicmF3XCIsIHsgdmFsdWU6IHJhdyB9KTsgfSBlbHNlIHsgY29va2VkLnJhdyA9IHJhdzsgfVxyXG4gICAgcmV0dXJuIGNvb2tlZDtcclxufTtcclxudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xyXG4gICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcclxuICAgIHJlc3VsdFtcImRlZmF1bHRcIl0gPSBtb2Q7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xyXG52YXIgUmVhY3QgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcInJlYWN0XCIpKTtcclxudmFyIG5vb3BfdGVtcGxhdGVfMSA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL25vb3AtdGVtcGxhdGVcIik7XHJcbmZ1bmN0aW9uIEJhc2UoKSB7XHJcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiLCB7IGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiB7XHJcbiAgICAgICAgICAgIF9faHRtbDogbm9vcF90ZW1wbGF0ZV8xLm5vb3AodGVtcGxhdGVPYmplY3RfMSB8fCAodGVtcGxhdGVPYmplY3RfMSA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcbiAgICAgICAgICA6aG9zdCB7XFxuICAgICAgICAgICAgLS1zaXplLWdhcC1oYWxmOiAwLjI1cmVtOyAvKiA0cHggKi9cXG4gICAgICAgICAgICAtLXNpemUtZ2FwOiAwLjVyZW07IC8qIDhweCAqL1xcbiAgICAgICAgICAgIC0tc2l6ZS1nYXAtZG91YmxlOiAxcmVtOyAvKiAxNnB4ICovXFxuICAgICAgICAgICAgLS1zaXplLWdhcC1xdWFkOiAycmVtOyAvKiAzMnB4ICovXFxuXFxuICAgICAgICAgICAgLS1zaXplLWZvbnQtc21hbGw6IDAuODc1cmVtOyAvKiAxNHB4ICovXFxuICAgICAgICAgICAgLS1zaXplLWZvbnQ6IDFyZW07IC8qIDE2cHggKi9cXG4gICAgICAgICAgICAtLXNpemUtZm9udC1iaWc6IDEuMjVyZW07IC8qIDIwcHggKi9cXG4gICAgICAgICAgICAtLXNpemUtZm9udC1iaWdnZXI6IDEuNXJlbTsgLyogMjRweCAqL1xcblxcbiAgICAgICAgICAgIC0tY29sb3ItYWNjZW50cy0xOiAjODA4MDgwO1xcbiAgICAgICAgICAgIC0tY29sb3ItYWNjZW50cy0yOiAjMjIyMjIyO1xcbiAgICAgICAgICAgIC0tY29sb3ItYWNjZW50cy0zOiAjNDA0MDQwO1xcblxcbiAgICAgICAgICAgIC0tZm9udC1zdGFjay1tb25vc3BhY2U6ICdTRk1vbm8tUmVndWxhcicsIENvbnNvbGFzLFxcbiAgICAgICAgICAgICAgJ0xpYmVyYXRpb24gTW9ubycsIE1lbmxvLCBDb3VyaWVyLCBtb25vc3BhY2U7XFxuXFxuICAgICAgICAgICAgLS1jb2xvci1hbnNpLXNlbGVjdGlvbjogcmdiYSg5NSwgMTI2LCAxNTEsIDAuNDgpO1xcbiAgICAgICAgICAgIC0tY29sb3ItYW5zaS1iZzogIzExMTExMTtcXG4gICAgICAgICAgICAtLWNvbG9yLWFuc2ktZmc6ICNjY2NjY2M7XFxuXFxuICAgICAgICAgICAgLS1jb2xvci1hbnNpLXdoaXRlOiAjNzc3Nzc3O1xcbiAgICAgICAgICAgIC0tY29sb3ItYW5zaS1ibGFjazogIzE0MTQxNDtcXG4gICAgICAgICAgICAtLWNvbG9yLWFuc2ktYmx1ZTogIzAwYWFmZjtcXG4gICAgICAgICAgICAtLWNvbG9yLWFuc2ktY3lhbjogIzg4ZGRmZjtcXG4gICAgICAgICAgICAtLWNvbG9yLWFuc2ktZ3JlZW46ICM5OGVjNjU7XFxuICAgICAgICAgICAgLS1jb2xvci1hbnNpLW1hZ2VudGE6ICNhYTg4ZmY7XFxuICAgICAgICAgICAgLS1jb2xvci1hbnNpLXJlZDogI2ZmNTU1NTtcXG4gICAgICAgICAgICAtLWNvbG9yLWFuc2kteWVsbG93OiAjZmZjYzMzO1xcbiAgICAgICAgICAgIC0tY29sb3ItYW5zaS1icmlnaHQtd2hpdGU6ICNmZmZmZmY7XFxuICAgICAgICAgICAgLS1jb2xvci1hbnNpLWJyaWdodC1ibGFjazogIzc3Nzc3NztcXG4gICAgICAgICAgICAtLWNvbG9yLWFuc2ktYnJpZ2h0LWJsdWU6ICMzM2JiZmY7XFxuICAgICAgICAgICAgLS1jb2xvci1hbnNpLWJyaWdodC1jeWFuOiAjYmJlY2ZmO1xcbiAgICAgICAgICAgIC0tY29sb3ItYW5zaS1icmlnaHQtZ3JlZW46ICNiNmYyOTI7XFxuICAgICAgICAgICAgLS1jb2xvci1hbnNpLWJyaWdodC1tYWdlbnRhOiAjY2ViYmZmO1xcbiAgICAgICAgICAgIC0tY29sb3ItYW5zaS1icmlnaHQtcmVkOiAjZmY4ODg4O1xcbiAgICAgICAgICAgIC0tY29sb3ItYW5zaS1icmlnaHQteWVsbG93OiAjZmZkOTY2O1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIC5tb25vIHtcXG4gICAgICAgICAgICBmb250LWZhbWlseTogdmFyKC0tZm9udC1zdGFjay1tb25vc3BhY2UpO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGgxLFxcbiAgICAgICAgICBoMixcXG4gICAgICAgICAgaDMsXFxuICAgICAgICAgIGg0LFxcbiAgICAgICAgICBoNSxcXG4gICAgICAgICAgaDYge1xcbiAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IHZhcigtLXNpemUtZ2FwKTtcXG4gICAgICAgICAgICBmb250LXdlaWdodDogNTAwO1xcbiAgICAgICAgICAgIGxpbmUtaGVpZ2h0OiAxLjU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgaDEge1xcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogMi41cmVtO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGgyIHtcXG4gICAgICAgICAgICBmb250LXNpemU6IDJyZW07XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgaDMge1xcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogMS43NXJlbTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBoNCB7XFxuICAgICAgICAgICAgZm9udC1zaXplOiAxLjVyZW07XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgaDUge1xcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogMS4yNXJlbTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBoNiB7XFxuICAgICAgICAgICAgZm9udC1zaXplOiAxcmVtO1xcbiAgICAgICAgICB9XFxuICAgICAgICBcIl0sIFtcIlxcbiAgICAgICAgICA6aG9zdCB7XFxuICAgICAgICAgICAgLS1zaXplLWdhcC1oYWxmOiAwLjI1cmVtOyAvKiA0cHggKi9cXG4gICAgICAgICAgICAtLXNpemUtZ2FwOiAwLjVyZW07IC8qIDhweCAqL1xcbiAgICAgICAgICAgIC0tc2l6ZS1nYXAtZG91YmxlOiAxcmVtOyAvKiAxNnB4ICovXFxuICAgICAgICAgICAgLS1zaXplLWdhcC1xdWFkOiAycmVtOyAvKiAzMnB4ICovXFxuXFxuICAgICAgICAgICAgLS1zaXplLWZvbnQtc21hbGw6IDAuODc1cmVtOyAvKiAxNHB4ICovXFxuICAgICAgICAgICAgLS1zaXplLWZvbnQ6IDFyZW07IC8qIDE2cHggKi9cXG4gICAgICAgICAgICAtLXNpemUtZm9udC1iaWc6IDEuMjVyZW07IC8qIDIwcHggKi9cXG4gICAgICAgICAgICAtLXNpemUtZm9udC1iaWdnZXI6IDEuNXJlbTsgLyogMjRweCAqL1xcblxcbiAgICAgICAgICAgIC0tY29sb3ItYWNjZW50cy0xOiAjODA4MDgwO1xcbiAgICAgICAgICAgIC0tY29sb3ItYWNjZW50cy0yOiAjMjIyMjIyO1xcbiAgICAgICAgICAgIC0tY29sb3ItYWNjZW50cy0zOiAjNDA0MDQwO1xcblxcbiAgICAgICAgICAgIC0tZm9udC1zdGFjay1tb25vc3BhY2U6ICdTRk1vbm8tUmVndWxhcicsIENvbnNvbGFzLFxcbiAgICAgICAgICAgICAgJ0xpYmVyYXRpb24gTW9ubycsIE1lbmxvLCBDb3VyaWVyLCBtb25vc3BhY2U7XFxuXFxuICAgICAgICAgICAgLS1jb2xvci1hbnNpLXNlbGVjdGlvbjogcmdiYSg5NSwgMTI2LCAxNTEsIDAuNDgpO1xcbiAgICAgICAgICAgIC0tY29sb3ItYW5zaS1iZzogIzExMTExMTtcXG4gICAgICAgICAgICAtLWNvbG9yLWFuc2ktZmc6ICNjY2NjY2M7XFxuXFxuICAgICAgICAgICAgLS1jb2xvci1hbnNpLXdoaXRlOiAjNzc3Nzc3O1xcbiAgICAgICAgICAgIC0tY29sb3ItYW5zaS1ibGFjazogIzE0MTQxNDtcXG4gICAgICAgICAgICAtLWNvbG9yLWFuc2ktYmx1ZTogIzAwYWFmZjtcXG4gICAgICAgICAgICAtLWNvbG9yLWFuc2ktY3lhbjogIzg4ZGRmZjtcXG4gICAgICAgICAgICAtLWNvbG9yLWFuc2ktZ3JlZW46ICM5OGVjNjU7XFxuICAgICAgICAgICAgLS1jb2xvci1hbnNpLW1hZ2VudGE6ICNhYTg4ZmY7XFxuICAgICAgICAgICAgLS1jb2xvci1hbnNpLXJlZDogI2ZmNTU1NTtcXG4gICAgICAgICAgICAtLWNvbG9yLWFuc2kteWVsbG93OiAjZmZjYzMzO1xcbiAgICAgICAgICAgIC0tY29sb3ItYW5zaS1icmlnaHQtd2hpdGU6ICNmZmZmZmY7XFxuICAgICAgICAgICAgLS1jb2xvci1hbnNpLWJyaWdodC1ibGFjazogIzc3Nzc3NztcXG4gICAgICAgICAgICAtLWNvbG9yLWFuc2ktYnJpZ2h0LWJsdWU6ICMzM2JiZmY7XFxuICAgICAgICAgICAgLS1jb2xvci1hbnNpLWJyaWdodC1jeWFuOiAjYmJlY2ZmO1xcbiAgICAgICAgICAgIC0tY29sb3ItYW5zaS1icmlnaHQtZ3JlZW46ICNiNmYyOTI7XFxuICAgICAgICAgICAgLS1jb2xvci1hbnNpLWJyaWdodC1tYWdlbnRhOiAjY2ViYmZmO1xcbiAgICAgICAgICAgIC0tY29sb3ItYW5zaS1icmlnaHQtcmVkOiAjZmY4ODg4O1xcbiAgICAgICAgICAgIC0tY29sb3ItYW5zaS1icmlnaHQteWVsbG93OiAjZmZkOTY2O1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIC5tb25vIHtcXG4gICAgICAgICAgICBmb250LWZhbWlseTogdmFyKC0tZm9udC1zdGFjay1tb25vc3BhY2UpO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGgxLFxcbiAgICAgICAgICBoMixcXG4gICAgICAgICAgaDMsXFxuICAgICAgICAgIGg0LFxcbiAgICAgICAgICBoNSxcXG4gICAgICAgICAgaDYge1xcbiAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IHZhcigtLXNpemUtZ2FwKTtcXG4gICAgICAgICAgICBmb250LXdlaWdodDogNTAwO1xcbiAgICAgICAgICAgIGxpbmUtaGVpZ2h0OiAxLjU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgaDEge1xcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogMi41cmVtO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGgyIHtcXG4gICAgICAgICAgICBmb250LXNpemU6IDJyZW07XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgaDMge1xcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogMS43NXJlbTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBoNCB7XFxuICAgICAgICAgICAgZm9udC1zaXplOiAxLjVyZW07XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgaDUge1xcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogMS4yNXJlbTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBoNiB7XFxuICAgICAgICAgICAgZm9udC1zaXplOiAxcmVtO1xcbiAgICAgICAgICB9XFxuICAgICAgICBcIl0pKSlcclxuICAgICAgICB9IH0pKTtcclxufVxyXG5leHBvcnRzLkJhc2UgPSBCYXNlO1xyXG52YXIgdGVtcGxhdGVPYmplY3RfMTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX21ha2VUZW1wbGF0ZU9iamVjdCA9ICh0aGlzICYmIHRoaXMuX19tYWtlVGVtcGxhdGVPYmplY3QpIHx8IGZ1bmN0aW9uIChjb29rZWQsIHJhdykge1xyXG4gICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cclxuICAgIHJldHVybiBjb29rZWQ7XHJcbn07XHJcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcclxuICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XHJcbiAgICByZXN1bHRbXCJkZWZhdWx0XCJdID0gbW9kO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxudmFyIFJlYWN0ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJyZWFjdFwiKSk7XHJcbnZhciBzdHlsZXNfMSA9IHJlcXVpcmUoXCIuLi9jb21wb25lbnRzL0NvZGVGcmFtZS9zdHlsZXNcIik7XHJcbnZhciBEaWFsb2dfMSA9IHJlcXVpcmUoXCIuLi9jb21wb25lbnRzL0RpYWxvZ1wiKTtcclxudmFyIHN0eWxlc18yID0gcmVxdWlyZShcIi4uL2NvbXBvbmVudHMvTGVmdFJpZ2h0RGlhbG9nSGVhZGVyL3N0eWxlc1wiKTtcclxudmFyIHN0eWxlc18zID0gcmVxdWlyZShcIi4uL2NvbXBvbmVudHMvT3ZlcmxheS9zdHlsZXNcIik7XHJcbnZhciBzdHlsZXNfNCA9IHJlcXVpcmUoXCIuLi9jb21wb25lbnRzL1Rlcm1pbmFsL3N0eWxlc1wiKTtcclxudmFyIFRvYXN0XzEgPSByZXF1aXJlKFwiLi4vY29tcG9uZW50cy9Ub2FzdFwiKTtcclxudmFyIEJ1aWxkRXJyb3JfMSA9IHJlcXVpcmUoXCIuLi9jb250YWluZXIvQnVpbGRFcnJvclwiKTtcclxudmFyIEVycm9yc18xID0gcmVxdWlyZShcIi4uL2NvbnRhaW5lci9FcnJvcnNcIik7XHJcbnZhciBSdW50aW1lRXJyb3JfMSA9IHJlcXVpcmUoXCIuLi9jb250YWluZXIvUnVudGltZUVycm9yXCIpO1xyXG52YXIgbm9vcF90ZW1wbGF0ZV8xID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvbm9vcC10ZW1wbGF0ZVwiKTtcclxuZnVuY3Rpb24gQ29tcG9uZW50U3R5bGVzKCkge1xyXG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIiwgeyBkYW5nZXJvdXNseVNldElubmVySFRNTDoge1xyXG4gICAgICAgICAgICBfX2h0bWw6IG5vb3BfdGVtcGxhdGVfMS5ub29wKHRlbXBsYXRlT2JqZWN0XzEgfHwgKHRlbXBsYXRlT2JqZWN0XzEgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG4gICAgICAgICAgXCIsIFwiXFxuICAgICAgICAgIFwiLCBcIlxcbiAgICAgICAgICBcIiwgXCJcXG4gICAgICAgICAgXCIsIFwiXFxuICAgICAgICAgIFwiLCBcIlxcbiAgICAgICAgICBcIiwgXCJcXG5cXG4gICAgICAgICAgXCIsIFwiXFxuICAgICAgICAgIFwiLCBcIlxcbiAgICAgICAgICBcIiwgXCJcXG4gICAgICAgIFwiXSwgW1wiXFxuICAgICAgICAgIFwiLCBcIlxcbiAgICAgICAgICBcIiwgXCJcXG4gICAgICAgICAgXCIsIFwiXFxuICAgICAgICAgIFwiLCBcIlxcbiAgICAgICAgICBcIiwgXCJcXG4gICAgICAgICAgXCIsIFwiXFxuXFxuICAgICAgICAgIFwiLCBcIlxcbiAgICAgICAgICBcIiwgXCJcXG4gICAgICAgICAgXCIsIFwiXFxuICAgICAgICBcIl0pKSwgc3R5bGVzXzMuc3R5bGVzLCBUb2FzdF8xLnN0eWxlcywgRGlhbG9nXzEuc3R5bGVzLCBzdHlsZXNfMi5zdHlsZXMsIHN0eWxlc18xLnN0eWxlcywgc3R5bGVzXzQuc3R5bGVzLCBCdWlsZEVycm9yXzEuc3R5bGVzLCBFcnJvcnNfMS5zdHlsZXMsIFJ1bnRpbWVFcnJvcl8xLnN0eWxlcylcclxuICAgICAgICB9IH0pKTtcclxufVxyXG5leHBvcnRzLkNvbXBvbmVudFN0eWxlcyA9IENvbXBvbmVudFN0eWxlcztcclxudmFyIHRlbXBsYXRlT2JqZWN0XzE7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19tYWtlVGVtcGxhdGVPYmplY3QgPSAodGhpcyAmJiB0aGlzLl9fbWFrZVRlbXBsYXRlT2JqZWN0KSB8fCBmdW5jdGlvbiAoY29va2VkLCByYXcpIHtcclxuICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvb2tlZCwgXCJyYXdcIiwgeyB2YWx1ZTogcmF3IH0pOyB9IGVsc2UgeyBjb29rZWQucmF3ID0gcmF3OyB9XHJcbiAgICByZXR1cm4gY29va2VkO1xyXG59O1xyXG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XHJcbiAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xyXG4gICAgcmVzdWx0W1wiZGVmYXVsdFwiXSA9IG1vZDtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn07XHJcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XHJcbnZhciBSZWFjdCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwicmVhY3RcIikpO1xyXG52YXIgbm9vcF90ZW1wbGF0ZV8xID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvbm9vcC10ZW1wbGF0ZVwiKTtcclxuZnVuY3Rpb24gQ3NzUmVzZXQoKSB7XHJcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiLCB7IGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiB7XHJcbiAgICAgICAgICAgIF9faHRtbDogbm9vcF90ZW1wbGF0ZV8xLm5vb3AodGVtcGxhdGVPYmplY3RfMSB8fCAodGVtcGxhdGVPYmplY3RfMSA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcbiAgICAgICAgICA6aG9zdCB7XFxuICAgICAgICAgICAgYWxsOiBpbml0aWFsO1xcblxcbiAgICAgICAgICAgIC8qIHRoZSBkaXJlY3Rpb24gcHJvcGVydHkgaXMgbm90IHJlc2V0IGJ5ICdhbGwnICovXFxuICAgICAgICAgICAgZGlyZWN0aW9uOiBsdHI7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgLyohXFxuICAgICAgICAgICAqIEJvb3RzdHJhcCBSZWJvb3QgdjQuNC4xIChodHRwczovL2dldGJvb3RzdHJhcC5jb20vKVxcbiAgICAgICAgICAgKiBDb3B5cmlnaHQgMjAxMS0yMDE5IFRoZSBCb290c3RyYXAgQXV0aG9yc1xcbiAgICAgICAgICAgKiBDb3B5cmlnaHQgMjAxMS0yMDE5IFR3aXR0ZXIsIEluYy5cXG4gICAgICAgICAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYXN0ZXIvTElDRU5TRSlcXG4gICAgICAgICAgICogRm9ya2VkIGZyb20gTm9ybWFsaXplLmNzcywgbGljZW5zZWQgTUlUIChodHRwczovL2dpdGh1Yi5jb20vbmVjb2xhcy9ub3JtYWxpemUuY3NzL2Jsb2IvbWFzdGVyL0xJQ0VOU0UubWQpXFxuICAgICAgICAgICAqL1xcbiAgICAgICAgICAqLFxcbiAgICAgICAgICAqOjpiZWZvcmUsXFxuICAgICAgICAgICo6OmFmdGVyIHtcXG4gICAgICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIDpob3N0IHtcXG4gICAgICAgICAgICBmb250LWZhbWlseTogc2Fucy1zZXJpZjtcXG4gICAgICAgICAgICBsaW5lLWhlaWdodDogMS4xNTtcXG4gICAgICAgICAgICAtd2Via2l0LXRleHQtc2l6ZS1hZGp1c3Q6IDEwMCU7XFxuICAgICAgICAgICAgLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yOiByZ2JhKDAsIDAsIDAsIDApO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGFydGljbGUsXFxuICAgICAgICAgIGFzaWRlLFxcbiAgICAgICAgICBmaWdjYXB0aW9uLFxcbiAgICAgICAgICBmaWd1cmUsXFxuICAgICAgICAgIGZvb3RlcixcXG4gICAgICAgICAgaGVhZGVyLFxcbiAgICAgICAgICBoZ3JvdXAsXFxuICAgICAgICAgIG1haW4sXFxuICAgICAgICAgIG5hdixcXG4gICAgICAgICAgc2VjdGlvbiB7XFxuICAgICAgICAgICAgZGlzcGxheTogYmxvY2s7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgOmhvc3Qge1xcbiAgICAgICAgICAgIG1hcmdpbjogMDtcXG4gICAgICAgICAgICBmb250LWZhbWlseTogLWFwcGxlLXN5c3RlbSwgQmxpbmtNYWNTeXN0ZW1Gb250LCAnU2Vnb2UgVUknLCBSb2JvdG8sXFxuICAgICAgICAgICAgICAnSGVsdmV0aWNhIE5ldWUnLCBBcmlhbCwgJ05vdG8gU2FucycsIHNhbnMtc2VyaWYsXFxuICAgICAgICAgICAgICAnQXBwbGUgQ29sb3IgRW1vamknLCAnU2Vnb2UgVUkgRW1vamknLCAnU2Vnb2UgVUkgU3ltYm9sJyxcXG4gICAgICAgICAgICAgICdOb3RvIENvbG9yIEVtb2ppJztcXG4gICAgICAgICAgICBmb250LXNpemU6IDFyZW07XFxuICAgICAgICAgICAgZm9udC13ZWlnaHQ6IDQwMDtcXG4gICAgICAgICAgICBsaW5lLWhlaWdodDogMS41O1xcbiAgICAgICAgICAgIGNvbG9yOiAjMjEyNTI5O1xcbiAgICAgICAgICAgIHRleHQtYWxpZ246IGxlZnQ7XFxuICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZjtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBbdGFiaW5kZXg9Jy0xJ106Zm9jdXM6bm90KDpmb2N1cy12aXNpYmxlKSB7XFxuICAgICAgICAgICAgb3V0bGluZTogMCAhaW1wb3J0YW50O1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGhyIHtcXG4gICAgICAgICAgICBib3gtc2l6aW5nOiBjb250ZW50LWJveDtcXG4gICAgICAgICAgICBoZWlnaHQ6IDA7XFxuICAgICAgICAgICAgb3ZlcmZsb3c6IHZpc2libGU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgaDEsXFxuICAgICAgICAgIGgyLFxcbiAgICAgICAgICBoMyxcXG4gICAgICAgICAgaDQsXFxuICAgICAgICAgIGg1LFxcbiAgICAgICAgICBoNiB7XFxuICAgICAgICAgICAgbWFyZ2luLXRvcDogMDtcXG4gICAgICAgICAgICBtYXJnaW4tYm90dG9tOiAwLjVyZW07XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgcCB7XFxuICAgICAgICAgICAgbWFyZ2luLXRvcDogMDtcXG4gICAgICAgICAgICBtYXJnaW4tYm90dG9tOiAxcmVtO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGFiYnJbdGl0bGVdLFxcbiAgICAgICAgICBhYmJyW2RhdGEtb3JpZ2luYWwtdGl0bGVdIHtcXG4gICAgICAgICAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcXG4gICAgICAgICAgICAtd2Via2l0LXRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lIGRvdHRlZDtcXG4gICAgICAgICAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZSBkb3R0ZWQ7XFxuICAgICAgICAgICAgY3Vyc29yOiBoZWxwO1xcbiAgICAgICAgICAgIGJvcmRlci1ib3R0b206IDA7XFxuICAgICAgICAgICAgLXdlYmtpdC10ZXh0LWRlY29yYXRpb24tc2tpcC1pbms6IG5vbmU7XFxuICAgICAgICAgICAgdGV4dC1kZWNvcmF0aW9uLXNraXAtaW5rOiBub25lO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGFkZHJlc3Mge1xcbiAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IDFyZW07XFxuICAgICAgICAgICAgZm9udC1zdHlsZTogbm9ybWFsO1xcbiAgICAgICAgICAgIGxpbmUtaGVpZ2h0OiBpbmhlcml0O1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIG9sLFxcbiAgICAgICAgICB1bCxcXG4gICAgICAgICAgZGwge1xcbiAgICAgICAgICAgIG1hcmdpbi10b3A6IDA7XFxuICAgICAgICAgICAgbWFyZ2luLWJvdHRvbTogMXJlbTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBvbCBvbCxcXG4gICAgICAgICAgdWwgdWwsXFxuICAgICAgICAgIG9sIHVsLFxcbiAgICAgICAgICB1bCBvbCB7XFxuICAgICAgICAgICAgbWFyZ2luLWJvdHRvbTogMDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBkdCB7XFxuICAgICAgICAgICAgZm9udC13ZWlnaHQ6IDcwMDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBkZCB7XFxuICAgICAgICAgICAgbWFyZ2luLWJvdHRvbTogMC41cmVtO1xcbiAgICAgICAgICAgIG1hcmdpbi1sZWZ0OiAwO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGJsb2NrcXVvdGUge1xcbiAgICAgICAgICAgIG1hcmdpbjogMCAwIDFyZW07XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgYixcXG4gICAgICAgICAgc3Ryb25nIHtcXG4gICAgICAgICAgICBmb250LXdlaWdodDogYm9sZGVyO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHNtYWxsIHtcXG4gICAgICAgICAgICBmb250LXNpemU6IDgwJTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBzdWIsXFxuICAgICAgICAgIHN1cCB7XFxuICAgICAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogNzUlO1xcbiAgICAgICAgICAgIGxpbmUtaGVpZ2h0OiAwO1xcbiAgICAgICAgICAgIHZlcnRpY2FsLWFsaWduOiBiYXNlbGluZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBzdWIge1xcbiAgICAgICAgICAgIGJvdHRvbTogLTAuMjVlbTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBzdXAge1xcbiAgICAgICAgICAgIHRvcDogLTAuNWVtO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGEge1xcbiAgICAgICAgICAgIGNvbG9yOiAjMDA3YmZmO1xcbiAgICAgICAgICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXG4gICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBhOmhvdmVyIHtcXG4gICAgICAgICAgICBjb2xvcjogIzAwNTZiMztcXG4gICAgICAgICAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBhOm5vdChbaHJlZl0pIHtcXG4gICAgICAgICAgICBjb2xvcjogaW5oZXJpdDtcXG4gICAgICAgICAgICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgYTpub3QoW2hyZWZdKTpob3ZlciB7XFxuICAgICAgICAgICAgY29sb3I6IGluaGVyaXQ7XFxuICAgICAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHByZSxcXG4gICAgICAgICAgY29kZSxcXG4gICAgICAgICAga2JkLFxcbiAgICAgICAgICBzYW1wIHtcXG4gICAgICAgICAgICBmb250LWZhbWlseTogU0ZNb25vLVJlZ3VsYXIsIE1lbmxvLCBNb25hY28sIENvbnNvbGFzLFxcbiAgICAgICAgICAgICAgJ0xpYmVyYXRpb24gTW9ubycsICdDb3VyaWVyIE5ldycsIG1vbm9zcGFjZTtcXG4gICAgICAgICAgICBmb250LXNpemU6IDFlbTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBwcmUge1xcbiAgICAgICAgICAgIG1hcmdpbi10b3A6IDA7XFxuICAgICAgICAgICAgbWFyZ2luLWJvdHRvbTogMXJlbTtcXG4gICAgICAgICAgICBvdmVyZmxvdzogYXV0bztcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBmaWd1cmUge1xcbiAgICAgICAgICAgIG1hcmdpbjogMCAwIDFyZW07XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgaW1nIHtcXG4gICAgICAgICAgICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xcbiAgICAgICAgICAgIGJvcmRlci1zdHlsZTogbm9uZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBzdmcge1xcbiAgICAgICAgICAgIG92ZXJmbG93OiBoaWRkZW47XFxuICAgICAgICAgICAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICB0YWJsZSB7XFxuICAgICAgICAgICAgYm9yZGVyLWNvbGxhcHNlOiBjb2xsYXBzZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBjYXB0aW9uIHtcXG4gICAgICAgICAgICBwYWRkaW5nLXRvcDogMC43NXJlbTtcXG4gICAgICAgICAgICBwYWRkaW5nLWJvdHRvbTogMC43NXJlbTtcXG4gICAgICAgICAgICBjb2xvcjogIzZjNzU3ZDtcXG4gICAgICAgICAgICB0ZXh0LWFsaWduOiBsZWZ0O1xcbiAgICAgICAgICAgIGNhcHRpb24tc2lkZTogYm90dG9tO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHRoIHtcXG4gICAgICAgICAgICB0ZXh0LWFsaWduOiBpbmhlcml0O1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGxhYmVsIHtcXG4gICAgICAgICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICAgICAgICAgICAgbWFyZ2luLWJvdHRvbTogMC41cmVtO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGJ1dHRvbiB7XFxuICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogMDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBidXR0b246Zm9jdXMge1xcbiAgICAgICAgICAgIG91dGxpbmU6IDFweCBkb3R0ZWQ7XFxuICAgICAgICAgICAgb3V0bGluZTogNXB4IGF1dG8gLXdlYmtpdC1mb2N1cy1yaW5nLWNvbG9yO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGlucHV0LFxcbiAgICAgICAgICBidXR0b24sXFxuICAgICAgICAgIHNlbGVjdCxcXG4gICAgICAgICAgb3B0Z3JvdXAsXFxuICAgICAgICAgIHRleHRhcmVhIHtcXG4gICAgICAgICAgICBtYXJnaW46IDA7XFxuICAgICAgICAgICAgZm9udC1mYW1pbHk6IGluaGVyaXQ7XFxuICAgICAgICAgICAgZm9udC1zaXplOiBpbmhlcml0O1xcbiAgICAgICAgICAgIGxpbmUtaGVpZ2h0OiBpbmhlcml0O1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGJ1dHRvbixcXG4gICAgICAgICAgaW5wdXQge1xcbiAgICAgICAgICAgIG92ZXJmbG93OiB2aXNpYmxlO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGJ1dHRvbixcXG4gICAgICAgICAgc2VsZWN0IHtcXG4gICAgICAgICAgICB0ZXh0LXRyYW5zZm9ybTogbm9uZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBzZWxlY3Qge1xcbiAgICAgICAgICAgIHdvcmQtd3JhcDogbm9ybWFsO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGJ1dHRvbixcXG4gICAgICAgICAgW3R5cGU9J2J1dHRvbiddLFxcbiAgICAgICAgICBbdHlwZT0ncmVzZXQnXSxcXG4gICAgICAgICAgW3R5cGU9J3N1Ym1pdCddIHtcXG4gICAgICAgICAgICAtd2Via2l0LWFwcGVhcmFuY2U6IGJ1dHRvbjtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBidXR0b246bm90KDpkaXNhYmxlZCksXFxuICAgICAgICAgIFt0eXBlPSdidXR0b24nXTpub3QoOmRpc2FibGVkKSxcXG4gICAgICAgICAgW3R5cGU9J3Jlc2V0J106bm90KDpkaXNhYmxlZCksXFxuICAgICAgICAgIFt0eXBlPSdzdWJtaXQnXTpub3QoOmRpc2FibGVkKSB7XFxuICAgICAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGJ1dHRvbjo6LW1vei1mb2N1cy1pbm5lcixcXG4gICAgICAgICAgW3R5cGU9J2J1dHRvbiddOjotbW96LWZvY3VzLWlubmVyLFxcbiAgICAgICAgICBbdHlwZT0ncmVzZXQnXTo6LW1vei1mb2N1cy1pbm5lcixcXG4gICAgICAgICAgW3R5cGU9J3N1Ym1pdCddOjotbW96LWZvY3VzLWlubmVyIHtcXG4gICAgICAgICAgICBwYWRkaW5nOiAwO1xcbiAgICAgICAgICAgIGJvcmRlci1zdHlsZTogbm9uZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBpbnB1dFt0eXBlPSdyYWRpbyddLFxcbiAgICAgICAgICBpbnB1dFt0eXBlPSdjaGVja2JveCddIHtcXG4gICAgICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgICAgICAgICAgIHBhZGRpbmc6IDA7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgaW5wdXRbdHlwZT0nZGF0ZSddLFxcbiAgICAgICAgICBpbnB1dFt0eXBlPSd0aW1lJ10sXFxuICAgICAgICAgIGlucHV0W3R5cGU9J2RhdGV0aW1lLWxvY2FsJ10sXFxuICAgICAgICAgIGlucHV0W3R5cGU9J21vbnRoJ10ge1xcbiAgICAgICAgICAgIC13ZWJraXQtYXBwZWFyYW5jZTogbGlzdGJveDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICB0ZXh0YXJlYSB7XFxuICAgICAgICAgICAgb3ZlcmZsb3c6IGF1dG87XFxuICAgICAgICAgICAgcmVzaXplOiB2ZXJ0aWNhbDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBmaWVsZHNldCB7XFxuICAgICAgICAgICAgbWluLXdpZHRoOiAwO1xcbiAgICAgICAgICAgIHBhZGRpbmc6IDA7XFxuICAgICAgICAgICAgbWFyZ2luOiAwO1xcbiAgICAgICAgICAgIGJvcmRlcjogMDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBsZWdlbmQge1xcbiAgICAgICAgICAgIGRpc3BsYXk6IGJsb2NrO1xcbiAgICAgICAgICAgIHdpZHRoOiAxMDAlO1xcbiAgICAgICAgICAgIG1heC13aWR0aDogMTAwJTtcXG4gICAgICAgICAgICBwYWRkaW5nOiAwO1xcbiAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IDAuNXJlbTtcXG4gICAgICAgICAgICBmb250LXNpemU6IDEuNXJlbTtcXG4gICAgICAgICAgICBsaW5lLWhlaWdodDogaW5oZXJpdDtcXG4gICAgICAgICAgICBjb2xvcjogaW5oZXJpdDtcXG4gICAgICAgICAgICB3aGl0ZS1zcGFjZTogbm9ybWFsO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHByb2dyZXNzIHtcXG4gICAgICAgICAgICB2ZXJ0aWNhbC1hbGlnbjogYmFzZWxpbmU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgW3R5cGU9J251bWJlciddOjotd2Via2l0LWlubmVyLXNwaW4tYnV0dG9uLFxcbiAgICAgICAgICBbdHlwZT0nbnVtYmVyJ106Oi13ZWJraXQtb3V0ZXItc3Bpbi1idXR0b24ge1xcbiAgICAgICAgICAgIGhlaWdodDogYXV0bztcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBbdHlwZT0nc2VhcmNoJ10ge1xcbiAgICAgICAgICAgIG91dGxpbmUtb2Zmc2V0OiAtMnB4O1xcbiAgICAgICAgICAgIC13ZWJraXQtYXBwZWFyYW5jZTogbm9uZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBbdHlwZT0nc2VhcmNoJ106Oi13ZWJraXQtc2VhcmNoLWRlY29yYXRpb24ge1xcbiAgICAgICAgICAgIC13ZWJraXQtYXBwZWFyYW5jZTogbm9uZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICA6Oi13ZWJraXQtZmlsZS11cGxvYWQtYnV0dG9uIHtcXG4gICAgICAgICAgICBmb250OiBpbmhlcml0O1xcbiAgICAgICAgICAgIC13ZWJraXQtYXBwZWFyYW5jZTogYnV0dG9uO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIG91dHB1dCB7XFxuICAgICAgICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHN1bW1hcnkge1xcbiAgICAgICAgICAgIGRpc3BsYXk6IGxpc3QtaXRlbTtcXG4gICAgICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgdGVtcGxhdGUge1xcbiAgICAgICAgICAgIGRpc3BsYXk6IG5vbmU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgW2hpZGRlbl0ge1xcbiAgICAgICAgICAgIGRpc3BsYXk6IG5vbmUgIWltcG9ydGFudDtcXG4gICAgICAgICAgfVxcbiAgICAgICAgXCJdLCBbXCJcXG4gICAgICAgICAgOmhvc3Qge1xcbiAgICAgICAgICAgIGFsbDogaW5pdGlhbDtcXG5cXG4gICAgICAgICAgICAvKiB0aGUgZGlyZWN0aW9uIHByb3BlcnR5IGlzIG5vdCByZXNldCBieSAnYWxsJyAqL1xcbiAgICAgICAgICAgIGRpcmVjdGlvbjogbHRyO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIC8qIVxcbiAgICAgICAgICAgKiBCb290c3RyYXAgUmVib290IHY0LjQuMSAoaHR0cHM6Ly9nZXRib290c3RyYXAuY29tLylcXG4gICAgICAgICAgICogQ29weXJpZ2h0IDIwMTEtMjAxOSBUaGUgQm9vdHN0cmFwIEF1dGhvcnNcXG4gICAgICAgICAgICogQ29weXJpZ2h0IDIwMTEtMjAxOSBUd2l0dGVyLCBJbmMuXFxuICAgICAgICAgICAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXFxuICAgICAgICAgICAqIEZvcmtlZCBmcm9tIE5vcm1hbGl6ZS5jc3MsIGxpY2Vuc2VkIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL25lY29sYXMvbm9ybWFsaXplLmNzcy9ibG9iL21hc3Rlci9MSUNFTlNFLm1kKVxcbiAgICAgICAgICAgKi9cXG4gICAgICAgICAgKixcXG4gICAgICAgICAgKjo6YmVmb3JlLFxcbiAgICAgICAgICAqOjphZnRlciB7XFxuICAgICAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICA6aG9zdCB7XFxuICAgICAgICAgICAgZm9udC1mYW1pbHk6IHNhbnMtc2VyaWY7XFxuICAgICAgICAgICAgbGluZS1oZWlnaHQ6IDEuMTU7XFxuICAgICAgICAgICAgLXdlYmtpdC10ZXh0LXNpemUtYWRqdXN0OiAxMDAlO1xcbiAgICAgICAgICAgIC13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvcjogcmdiYSgwLCAwLCAwLCAwKTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBhcnRpY2xlLFxcbiAgICAgICAgICBhc2lkZSxcXG4gICAgICAgICAgZmlnY2FwdGlvbixcXG4gICAgICAgICAgZmlndXJlLFxcbiAgICAgICAgICBmb290ZXIsXFxuICAgICAgICAgIGhlYWRlcixcXG4gICAgICAgICAgaGdyb3VwLFxcbiAgICAgICAgICBtYWluLFxcbiAgICAgICAgICBuYXYsXFxuICAgICAgICAgIHNlY3Rpb24ge1xcbiAgICAgICAgICAgIGRpc3BsYXk6IGJsb2NrO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIDpob3N0IHtcXG4gICAgICAgICAgICBtYXJnaW46IDA7XFxuICAgICAgICAgICAgZm9udC1mYW1pbHk6IC1hcHBsZS1zeXN0ZW0sIEJsaW5rTWFjU3lzdGVtRm9udCwgJ1NlZ29lIFVJJywgUm9ib3RvLFxcbiAgICAgICAgICAgICAgJ0hlbHZldGljYSBOZXVlJywgQXJpYWwsICdOb3RvIFNhbnMnLCBzYW5zLXNlcmlmLFxcbiAgICAgICAgICAgICAgJ0FwcGxlIENvbG9yIEVtb2ppJywgJ1NlZ29lIFVJIEVtb2ppJywgJ1NlZ29lIFVJIFN5bWJvbCcsXFxuICAgICAgICAgICAgICAnTm90byBDb2xvciBFbW9qaSc7XFxuICAgICAgICAgICAgZm9udC1zaXplOiAxcmVtO1xcbiAgICAgICAgICAgIGZvbnQtd2VpZ2h0OiA0MDA7XFxuICAgICAgICAgICAgbGluZS1oZWlnaHQ6IDEuNTtcXG4gICAgICAgICAgICBjb2xvcjogIzIxMjUyOTtcXG4gICAgICAgICAgICB0ZXh0LWFsaWduOiBsZWZ0O1xcbiAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6ICNmZmY7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgW3RhYmluZGV4PSctMSddOmZvY3VzOm5vdCg6Zm9jdXMtdmlzaWJsZSkge1xcbiAgICAgICAgICAgIG91dGxpbmU6IDAgIWltcG9ydGFudDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBociB7XFxuICAgICAgICAgICAgYm94LXNpemluZzogY29udGVudC1ib3g7XFxuICAgICAgICAgICAgaGVpZ2h0OiAwO1xcbiAgICAgICAgICAgIG92ZXJmbG93OiB2aXNpYmxlO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGgxLFxcbiAgICAgICAgICBoMixcXG4gICAgICAgICAgaDMsXFxuICAgICAgICAgIGg0LFxcbiAgICAgICAgICBoNSxcXG4gICAgICAgICAgaDYge1xcbiAgICAgICAgICAgIG1hcmdpbi10b3A6IDA7XFxuICAgICAgICAgICAgbWFyZ2luLWJvdHRvbTogMC41cmVtO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHAge1xcbiAgICAgICAgICAgIG1hcmdpbi10b3A6IDA7XFxuICAgICAgICAgICAgbWFyZ2luLWJvdHRvbTogMXJlbTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBhYmJyW3RpdGxlXSxcXG4gICAgICAgICAgYWJicltkYXRhLW9yaWdpbmFsLXRpdGxlXSB7XFxuICAgICAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7XFxuICAgICAgICAgICAgLXdlYmtpdC10ZXh0LWRlY29yYXRpb246IHVuZGVybGluZSBkb3R0ZWQ7XFxuICAgICAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmUgZG90dGVkO1xcbiAgICAgICAgICAgIGN1cnNvcjogaGVscDtcXG4gICAgICAgICAgICBib3JkZXItYm90dG9tOiAwO1xcbiAgICAgICAgICAgIC13ZWJraXQtdGV4dC1kZWNvcmF0aW9uLXNraXAtaW5rOiBub25lO1xcbiAgICAgICAgICAgIHRleHQtZGVjb3JhdGlvbi1za2lwLWluazogbm9uZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBhZGRyZXNzIHtcXG4gICAgICAgICAgICBtYXJnaW4tYm90dG9tOiAxcmVtO1xcbiAgICAgICAgICAgIGZvbnQtc3R5bGU6IG5vcm1hbDtcXG4gICAgICAgICAgICBsaW5lLWhlaWdodDogaW5oZXJpdDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBvbCxcXG4gICAgICAgICAgdWwsXFxuICAgICAgICAgIGRsIHtcXG4gICAgICAgICAgICBtYXJnaW4tdG9wOiAwO1xcbiAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IDFyZW07XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgb2wgb2wsXFxuICAgICAgICAgIHVsIHVsLFxcbiAgICAgICAgICBvbCB1bCxcXG4gICAgICAgICAgdWwgb2wge1xcbiAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IDA7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgZHQge1xcbiAgICAgICAgICAgIGZvbnQtd2VpZ2h0OiA3MDA7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgZGQge1xcbiAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IDAuNXJlbTtcXG4gICAgICAgICAgICBtYXJnaW4tbGVmdDogMDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBibG9ja3F1b3RlIHtcXG4gICAgICAgICAgICBtYXJnaW46IDAgMCAxcmVtO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGIsXFxuICAgICAgICAgIHN0cm9uZyB7XFxuICAgICAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGRlcjtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBzbWFsbCB7XFxuICAgICAgICAgICAgZm9udC1zaXplOiA4MCU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgc3ViLFxcbiAgICAgICAgICBzdXAge1xcbiAgICAgICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgICAgICAgICBmb250LXNpemU6IDc1JTtcXG4gICAgICAgICAgICBsaW5lLWhlaWdodDogMDtcXG4gICAgICAgICAgICB2ZXJ0aWNhbC1hbGlnbjogYmFzZWxpbmU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgc3ViIHtcXG4gICAgICAgICAgICBib3R0b206IC0wLjI1ZW07XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgc3VwIHtcXG4gICAgICAgICAgICB0b3A6IC0wLjVlbTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBhIHtcXG4gICAgICAgICAgICBjb2xvcjogIzAwN2JmZjtcXG4gICAgICAgICAgICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XFxuICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgYTpob3ZlciB7XFxuICAgICAgICAgICAgY29sb3I6ICMwMDU2YjM7XFxuICAgICAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgYTpub3QoW2hyZWZdKSB7XFxuICAgICAgICAgICAgY29sb3I6IGluaGVyaXQ7XFxuICAgICAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGE6bm90KFtocmVmXSk6aG92ZXIge1xcbiAgICAgICAgICAgIGNvbG9yOiBpbmhlcml0O1xcbiAgICAgICAgICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBwcmUsXFxuICAgICAgICAgIGNvZGUsXFxuICAgICAgICAgIGtiZCxcXG4gICAgICAgICAgc2FtcCB7XFxuICAgICAgICAgICAgZm9udC1mYW1pbHk6IFNGTW9uby1SZWd1bGFyLCBNZW5sbywgTW9uYWNvLCBDb25zb2xhcyxcXG4gICAgICAgICAgICAgICdMaWJlcmF0aW9uIE1vbm8nLCAnQ291cmllciBOZXcnLCBtb25vc3BhY2U7XFxuICAgICAgICAgICAgZm9udC1zaXplOiAxZW07XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgcHJlIHtcXG4gICAgICAgICAgICBtYXJnaW4tdG9wOiAwO1xcbiAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IDFyZW07XFxuICAgICAgICAgICAgb3ZlcmZsb3c6IGF1dG87XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgZmlndXJlIHtcXG4gICAgICAgICAgICBtYXJnaW46IDAgMCAxcmVtO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGltZyB7XFxuICAgICAgICAgICAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcXG4gICAgICAgICAgICBib3JkZXItc3R5bGU6IG5vbmU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgc3ZnIHtcXG4gICAgICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgICAgICAgICAgIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgdGFibGUge1xcbiAgICAgICAgICAgIGJvcmRlci1jb2xsYXBzZTogY29sbGFwc2U7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgY2FwdGlvbiB7XFxuICAgICAgICAgICAgcGFkZGluZy10b3A6IDAuNzVyZW07XFxuICAgICAgICAgICAgcGFkZGluZy1ib3R0b206IDAuNzVyZW07XFxuICAgICAgICAgICAgY29sb3I6ICM2Yzc1N2Q7XFxuICAgICAgICAgICAgdGV4dC1hbGlnbjogbGVmdDtcXG4gICAgICAgICAgICBjYXB0aW9uLXNpZGU6IGJvdHRvbTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICB0aCB7XFxuICAgICAgICAgICAgdGV4dC1hbGlnbjogaW5oZXJpdDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBsYWJlbCB7XFxuICAgICAgICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IDAuNXJlbTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBidXR0b24ge1xcbiAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDA7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgYnV0dG9uOmZvY3VzIHtcXG4gICAgICAgICAgICBvdXRsaW5lOiAxcHggZG90dGVkO1xcbiAgICAgICAgICAgIG91dGxpbmU6IDVweCBhdXRvIC13ZWJraXQtZm9jdXMtcmluZy1jb2xvcjtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBpbnB1dCxcXG4gICAgICAgICAgYnV0dG9uLFxcbiAgICAgICAgICBzZWxlY3QsXFxuICAgICAgICAgIG9wdGdyb3VwLFxcbiAgICAgICAgICB0ZXh0YXJlYSB7XFxuICAgICAgICAgICAgbWFyZ2luOiAwO1xcbiAgICAgICAgICAgIGZvbnQtZmFtaWx5OiBpbmhlcml0O1xcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogaW5oZXJpdDtcXG4gICAgICAgICAgICBsaW5lLWhlaWdodDogaW5oZXJpdDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBidXR0b24sXFxuICAgICAgICAgIGlucHV0IHtcXG4gICAgICAgICAgICBvdmVyZmxvdzogdmlzaWJsZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBidXR0b24sXFxuICAgICAgICAgIHNlbGVjdCB7XFxuICAgICAgICAgICAgdGV4dC10cmFuc2Zvcm06IG5vbmU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgc2VsZWN0IHtcXG4gICAgICAgICAgICB3b3JkLXdyYXA6IG5vcm1hbDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBidXR0b24sXFxuICAgICAgICAgIFt0eXBlPSdidXR0b24nXSxcXG4gICAgICAgICAgW3R5cGU9J3Jlc2V0J10sXFxuICAgICAgICAgIFt0eXBlPSdzdWJtaXQnXSB7XFxuICAgICAgICAgICAgLXdlYmtpdC1hcHBlYXJhbmNlOiBidXR0b247XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgYnV0dG9uOm5vdCg6ZGlzYWJsZWQpLFxcbiAgICAgICAgICBbdHlwZT0nYnV0dG9uJ106bm90KDpkaXNhYmxlZCksXFxuICAgICAgICAgIFt0eXBlPSdyZXNldCddOm5vdCg6ZGlzYWJsZWQpLFxcbiAgICAgICAgICBbdHlwZT0nc3VibWl0J106bm90KDpkaXNhYmxlZCkge1xcbiAgICAgICAgICAgIGN1cnNvcjogcG9pbnRlcjtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBidXR0b246Oi1tb3otZm9jdXMtaW5uZXIsXFxuICAgICAgICAgIFt0eXBlPSdidXR0b24nXTo6LW1vei1mb2N1cy1pbm5lcixcXG4gICAgICAgICAgW3R5cGU9J3Jlc2V0J106Oi1tb3otZm9jdXMtaW5uZXIsXFxuICAgICAgICAgIFt0eXBlPSdzdWJtaXQnXTo6LW1vei1mb2N1cy1pbm5lciB7XFxuICAgICAgICAgICAgcGFkZGluZzogMDtcXG4gICAgICAgICAgICBib3JkZXItc3R5bGU6IG5vbmU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgaW5wdXRbdHlwZT0ncmFkaW8nXSxcXG4gICAgICAgICAgaW5wdXRbdHlwZT0nY2hlY2tib3gnXSB7XFxuICAgICAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gICAgICAgICAgICBwYWRkaW5nOiAwO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGlucHV0W3R5cGU9J2RhdGUnXSxcXG4gICAgICAgICAgaW5wdXRbdHlwZT0ndGltZSddLFxcbiAgICAgICAgICBpbnB1dFt0eXBlPSdkYXRldGltZS1sb2NhbCddLFxcbiAgICAgICAgICBpbnB1dFt0eXBlPSdtb250aCddIHtcXG4gICAgICAgICAgICAtd2Via2l0LWFwcGVhcmFuY2U6IGxpc3Rib3g7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgdGV4dGFyZWEge1xcbiAgICAgICAgICAgIG92ZXJmbG93OiBhdXRvO1xcbiAgICAgICAgICAgIHJlc2l6ZTogdmVydGljYWw7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgZmllbGRzZXQge1xcbiAgICAgICAgICAgIG1pbi13aWR0aDogMDtcXG4gICAgICAgICAgICBwYWRkaW5nOiAwO1xcbiAgICAgICAgICAgIG1hcmdpbjogMDtcXG4gICAgICAgICAgICBib3JkZXI6IDA7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgbGVnZW5kIHtcXG4gICAgICAgICAgICBkaXNwbGF5OiBibG9jaztcXG4gICAgICAgICAgICB3aWR0aDogMTAwJTtcXG4gICAgICAgICAgICBtYXgtd2lkdGg6IDEwMCU7XFxuICAgICAgICAgICAgcGFkZGluZzogMDtcXG4gICAgICAgICAgICBtYXJnaW4tYm90dG9tOiAwLjVyZW07XFxuICAgICAgICAgICAgZm9udC1zaXplOiAxLjVyZW07XFxuICAgICAgICAgICAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7XFxuICAgICAgICAgICAgY29sb3I6IGluaGVyaXQ7XFxuICAgICAgICAgICAgd2hpdGUtc3BhY2U6IG5vcm1hbDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBwcm9ncmVzcyB7XFxuICAgICAgICAgICAgdmVydGljYWwtYWxpZ246IGJhc2VsaW5lO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIFt0eXBlPSdudW1iZXInXTo6LXdlYmtpdC1pbm5lci1zcGluLWJ1dHRvbixcXG4gICAgICAgICAgW3R5cGU9J251bWJlciddOjotd2Via2l0LW91dGVyLXNwaW4tYnV0dG9uIHtcXG4gICAgICAgICAgICBoZWlnaHQ6IGF1dG87XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgW3R5cGU9J3NlYXJjaCddIHtcXG4gICAgICAgICAgICBvdXRsaW5lLW9mZnNldDogLTJweDtcXG4gICAgICAgICAgICAtd2Via2l0LWFwcGVhcmFuY2U6IG5vbmU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgW3R5cGU9J3NlYXJjaCddOjotd2Via2l0LXNlYXJjaC1kZWNvcmF0aW9uIHtcXG4gICAgICAgICAgICAtd2Via2l0LWFwcGVhcmFuY2U6IG5vbmU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgOjotd2Via2l0LWZpbGUtdXBsb2FkLWJ1dHRvbiB7XFxuICAgICAgICAgICAgZm9udDogaW5oZXJpdDtcXG4gICAgICAgICAgICAtd2Via2l0LWFwcGVhcmFuY2U6IGJ1dHRvbjtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBvdXRwdXQge1xcbiAgICAgICAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBzdW1tYXJ5IHtcXG4gICAgICAgICAgICBkaXNwbGF5OiBsaXN0LWl0ZW07XFxuICAgICAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHRlbXBsYXRlIHtcXG4gICAgICAgICAgICBkaXNwbGF5OiBub25lO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIFtoaWRkZW5dIHtcXG4gICAgICAgICAgICBkaXNwbGF5OiBub25lICFpbXBvcnRhbnQ7XFxuICAgICAgICAgIH1cXG4gICAgICAgIFwiXSkpKVxyXG4gICAgICAgIH0gfSkpO1xyXG59XHJcbmV4cG9ydHMuQ3NzUmVzZXQgPSBDc3NSZXNldDtcclxudmFyIHRlbXBsYXRlT2JqZWN0XzE7XHJcbiIsIid1c2Ugc3RyaWN0JztcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKGNvbnRleHQsIGRpc2FibGVkU3RhdGUpIHtcclxuICBpZiAoIXN1cHBvcnRzKSB7XHJcbiAgICBzdXBwb3J0cyA9ICgwLCBfc3VwcG9ydHMzLmRlZmF1bHQpKCk7XHJcbiAgfVxyXG5cclxuICB2YXIgZWxlbWVudCA9ICgwLCBfY29udGV4dFRvRWxlbWVudDIuZGVmYXVsdCkoe1xyXG4gICAgbGFiZWw6ICdlbGVtZW50L2Rpc2FibGVkJyxcclxuICAgIGNvbnRleHQ6IGNvbnRleHRcclxuICB9KTtcclxuXHJcbiAgLy8gYWNjZXB0IHRydXRoeS9mYWxzeSB2YWx1ZXNcclxuICBkaXNhYmxlZFN0YXRlID0gQm9vbGVhbihkaXNhYmxlZFN0YXRlKTtcclxuICB2YXIgY3VycmVudFN0YXRlID0gZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2RhdGEtYWxseS1kaXNhYmxlZCcpO1xyXG4gIC8vIGlmIHRoZXJlJ3Mgbm8gdmFsdWUgdG8gc2V0LCB3ZSdyZSBydW5uaW5nIGFzIGEgZ2V0dGVyXHJcbiAgdmFyIHJ1bm5pbmdBc0dldHRlciA9IGFyZ3VtZW50cy5sZW5ndGggPT09IDE7XHJcblxyXG4gIGlmICgoMCwgX25hdGl2ZURpc2FibGVkU3VwcG9ydGVkMi5kZWZhdWx0KShlbGVtZW50KSkge1xyXG4gICAgaWYgKHJ1bm5pbmdBc0dldHRlcikge1xyXG4gICAgICByZXR1cm4gZWxlbWVudC5kaXNhYmxlZDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBmb3JtIGVsZW1lbnRzIGtub3cgdGhlIGRpc2FibGVkIGF0dHJpYnV0ZSwgd2hpY2ggd2Ugc2hhbGwgdXNlIGluc3RlYWQgb2Ygb3VyIHBvb3IgbWFuJ3MgY29weSBvZiBpdFxyXG4gICAgZWxlbWVudC5kaXNhYmxlZCA9IGRpc2FibGVkU3RhdGU7XHJcbiAgICByZXR1cm4gZWxlbWVudDtcclxuICB9XHJcblxyXG4gIGlmIChydW5uaW5nQXNHZXR0ZXIpIHtcclxuICAgIHJldHVybiBjdXJyZW50U3RhdGU7XHJcbiAgfVxyXG5cclxuICBpZiAoY3VycmVudFN0YXRlID09PSBkaXNhYmxlZFN0YXRlKSB7XHJcbiAgICAvLyBubyB1cGRhdGUgbmVjZXNzYXJ5XHJcbiAgICByZXR1cm4gZWxlbWVudDtcclxuICB9XHJcblxyXG4gIHNldEVsZW1lbnREaXNhYmxlZChlbGVtZW50LCBkaXNhYmxlZFN0YXRlKTtcclxuICByZXR1cm4gZWxlbWVudDtcclxufTtcclxuXHJcbnZhciBfY29udGV4dFRvRWxlbWVudCA9IHJlcXVpcmUoJy4uL3V0aWwvY29udGV4dC10by1lbGVtZW50Jyk7XHJcblxyXG52YXIgX2NvbnRleHRUb0VsZW1lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29udGV4dFRvRWxlbWVudCk7XHJcblxyXG52YXIgX3RhYmluZGV4VmFsdWUgPSByZXF1aXJlKCcuLi91dGlsL3RhYmluZGV4LXZhbHVlJyk7XHJcblxyXG52YXIgX3RhYmluZGV4VmFsdWUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdGFiaW5kZXhWYWx1ZSk7XHJcblxyXG52YXIgX25hdGl2ZURpc2FibGVkU3VwcG9ydGVkID0gcmVxdWlyZSgnLi4vaXMvbmF0aXZlLWRpc2FibGVkLXN1cHBvcnRlZCcpO1xyXG5cclxudmFyIF9uYXRpdmVEaXNhYmxlZFN1cHBvcnRlZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9uYXRpdmVEaXNhYmxlZFN1cHBvcnRlZCk7XHJcblxyXG52YXIgX3RvZ2dsZUF0dHJpYnV0ZSA9IHJlcXVpcmUoJy4uL3V0aWwvdG9nZ2xlLWF0dHJpYnV0ZScpO1xyXG5cclxudmFyIF90b2dnbGVBdHRyaWJ1dGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdG9nZ2xlQXR0cmlidXRlKTtcclxuXHJcbnZhciBfdG9nZ2xlQXR0cmlidXRlVmFsdWUgPSByZXF1aXJlKCcuLi91dGlsL3RvZ2dsZS1hdHRyaWJ1dGUtdmFsdWUnKTtcclxuXHJcbnZhciBfdG9nZ2xlQXR0cmlidXRlVmFsdWUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdG9nZ2xlQXR0cmlidXRlVmFsdWUpO1xyXG5cclxudmFyIF9sb2dnZXIgPSByZXF1aXJlKCcuLi91dGlsL2xvZ2dlcicpO1xyXG5cclxudmFyIF9sb2dnZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbG9nZ2VyKTtcclxuXHJcbnZhciBfc3VwcG9ydHMyID0gcmVxdWlyZSgnLi4vc3VwcG9ydHMvc3VwcG9ydHMnKTtcclxuXHJcbnZhciBfc3VwcG9ydHMzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3VwcG9ydHMyKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG52YXIgc3VwcG9ydHMgPSB2b2lkIDA7XHJcbi8qXHJcbiAgVXRpbGl0eSB0byBtYWtlIGFueSBlbGVtZW50IGluZXJ0IChkaXNhYmxlZCkuIEluZXJ0IG1lYW5zIHRoZSBlbGVtZW50cyBjYW5ub3QgYmUgaW50ZXJhY3RlZFxyXG4gIHdpdGggYW5kIHRoZXkgY2Fubm90IGJlIGZvY3VzZWQgdmlhIHNjcmlwdCwgcG9pbnRlciBvciBrZXlib2FyZCAtIGFuZCB0aHVzIG5vdCByZWNlaXZlIGZvY3VzLlxyXG5cclxuICBFbGVtZW50cyBtYWRlIGluZXJ0IChkaXNhYmxlZCkgYnkgdGhpcyB1dGlsaXR5IGFyZSBnaXZlbiB0aGUgYXR0cmlidXRlIFtkYXRhLWFsbHktZGlzYWJsZWQ9XCJ0cnVlXCJdLlxyXG5cclxuICAtLS0tLS0tLS0tLS0tLS1cclxuXHJcbiAgaW5lcnQgYXR0cmlidXRlIHdhcyBbcmVtb3ZlZF0oaHR0cHM6Ly9odG1sNS5vcmcvci84NTM2KSBbdHdlZXQgYnkgc3RldmVdKGh0dHBzOi8vdHdpdHRlci5jb20vc3RldmVmYXVsa25lci9zdGF0dXMvNDQzMDc1OTAwMjAxMjU5MDA4KVxyXG4gIGJ1dCBkZWZpbml0aW9uIG9mIFtpbmVydCBzdWJ0cmVlc10oaHR0cHM6Ly93d3cudzMub3JnL2h0bWwvd2cvZHJhZnRzL2h0bWwvbWFzdGVyL2VkaXRpbmcuaHRtbCNpbmVydC1zdWJ0cmVlcykgcmVtYWlucy5cclxuXHJcbiAgW2ltcGxlbWVudGF0aW9uIGlkZWEgYnkgVmFzaWxpc10oaHR0cHM6Ly9jb2RlcGVuLmlvL3Zhc2lsaXN2Zy9wZW4vc2Nvd0kpXHJcbiAgW2luZXJ0IGF0dHJpYnV0ZSBwb2x5ZmlsbCBieSBHb29nbGVDaHJvbWVdKGh0dHBzOi8vZ2l0aHViLmNvbS9Hb29nbGVDaHJvbWUvaW5lcnQtcG9seWZpbGwpXHJcblxyXG4gIFtHZWNrbyBCdWc6IEluZXJ0IEF0dHJpYnV0ZV0oaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9OTIxNTA0KVxyXG4gIFtDaHJvbWl1bSBCdWc6IEluZXJ0IEF0dHJpYnV0ZV0oaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTI2OTg0NilcclxuICBbQ2hyb21pdW0gQnVnOiBJbmVydCBTdWJ0cmVlXShodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MjQxNjk5KVxyXG4gIFtXZWJLaXQgQnVnOiBJbmVydCBTdWJ0cmVlXShodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTEwOTUyKVxyXG4qL1xyXG5cclxuZnVuY3Rpb24gZGlzYWJsZWRGb2N1cygpIHtcclxuICBfbG9nZ2VyMi5kZWZhdWx0Lndhcm4oJ3RyeWluZyB0byBmb2N1cyBpbmVydCBlbGVtZW50JywgdGhpcyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRpc2FibGVUYWJpbmRleChlbGVtZW50LCBkaXNhYmxlZFN0YXRlKSB7XHJcbiAgaWYgKGRpc2FibGVkU3RhdGUpIHtcclxuICAgIHZhciB0YWJJbmRleCA9ICgwLCBfdGFiaW5kZXhWYWx1ZTIuZGVmYXVsdCkoZWxlbWVudCk7XHJcbiAgICAoMCwgX3RvZ2dsZUF0dHJpYnV0ZVZhbHVlMi5kZWZhdWx0KSh7XHJcbiAgICAgIGVsZW1lbnQ6IGVsZW1lbnQsXHJcbiAgICAgIGF0dHJpYnV0ZTogJ3RhYmluZGV4JyxcclxuICAgICAgdGVtcG9yYXJ5VmFsdWU6ICctMScsXHJcbiAgICAgIHNhdmVWYWx1ZTogdGFiSW5kZXggIT09IG51bGwgPyB0YWJJbmRleCA6ICcnXHJcbiAgICB9KTtcclxuICB9IGVsc2Uge1xyXG4gICAgKDAsIF90b2dnbGVBdHRyaWJ1dGVWYWx1ZTIuZGVmYXVsdCkoe1xyXG4gICAgICBlbGVtZW50OiBlbGVtZW50LFxyXG4gICAgICBhdHRyaWJ1dGU6ICd0YWJpbmRleCdcclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZGlzYWJsZVZpZGVvQ29udHJvbHMoZWxlbWVudCwgZGlzYWJsZWRTdGF0ZSkge1xyXG4gICgwLCBfdG9nZ2xlQXR0cmlidXRlMi5kZWZhdWx0KSh7XHJcbiAgICBlbGVtZW50OiBlbGVtZW50LFxyXG4gICAgYXR0cmlidXRlOiAnY29udHJvbHMnLFxyXG4gICAgcmVtb3ZlOiBkaXNhYmxlZFN0YXRlXHJcbiAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRpc2FibGVTdmdGb2N1c2FibGUoZWxlbWVudCwgZGlzYWJsZWRTdGF0ZSkge1xyXG4gICgwLCBfdG9nZ2xlQXR0cmlidXRlVmFsdWUyLmRlZmF1bHQpKHtcclxuICAgIGVsZW1lbnQ6IGVsZW1lbnQsXHJcbiAgICBhdHRyaWJ1dGU6ICdmb2N1c2FibGUnLFxyXG4gICAgdGVtcG9yYXJ5VmFsdWU6IGRpc2FibGVkU3RhdGUgPyAnZmFsc2UnIDogdW5kZWZpbmVkXHJcbiAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRpc2FibGVTdmdMaW5rKGVsZW1lbnQsIGRpc2FibGVkU3RhdGUpIHtcclxuICAoMCwgX3RvZ2dsZUF0dHJpYnV0ZTIuZGVmYXVsdCkoe1xyXG4gICAgZWxlbWVudDogZWxlbWVudCxcclxuICAgIGF0dHJpYnV0ZTogJ3hsaW5rOmhyZWYnLFxyXG4gICAgcmVtb3ZlOiBkaXNhYmxlZFN0YXRlXHJcbiAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNldEFyaWFEaXNhYmxlZChlbGVtZW50LCBkaXNhYmxlZFN0YXRlKSB7XHJcbiAgKDAsIF90b2dnbGVBdHRyaWJ1dGVWYWx1ZTIuZGVmYXVsdCkoe1xyXG4gICAgZWxlbWVudDogZWxlbWVudCxcclxuICAgIGF0dHJpYnV0ZTogJ2FyaWEtZGlzYWJsZWQnLFxyXG4gICAgdGVtcG9yYXJ5VmFsdWU6IGRpc2FibGVkU3RhdGUgPyAndHJ1ZScgOiB1bmRlZmluZWRcclxuICB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gZGlzYWJsZVNjcmlwdEZvY3VzKGVsZW1lbnQsIGRpc2FibGVkU3RhdGUpIHtcclxuICBpZiAoZGlzYWJsZWRTdGF0ZSkge1xyXG4gICAgLy8gbWFrZSBzdXJlIG5vIHNjcmlwdCBjYW4gZm9jdXMgdGhlIGVsZW1lbnRcclxuICAgIGVsZW1lbnQuZm9jdXMgPSBkaXNhYmxlZEZvY3VzO1xyXG4gIH0gZWxzZSB7XHJcbiAgICAvLyByZXN0b3JlIG9yaWdpbmFsIGZvY3VzIGZ1bmN0aW9uIGZyb20gcHJvdG90eXBlXHJcbiAgICBkZWxldGUgZWxlbWVudC5mb2N1cztcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRpc2FibGVQb2ludGVyRXZlbnRzKGVsZW1lbnQsIGRpc2FibGVkU3RhdGUpIHtcclxuICBpZiAoZGlzYWJsZWRTdGF0ZSkge1xyXG4gICAgLy8gcmVtZW1iZXIgcHJldmlvdXMgcG9pbnRlciBldmVudHMgc3RhdHVzIHNvIHdlIGNhbiByZXN0b3JlIGl0XHJcbiAgICB2YXIgcG9pbnRlckV2ZW50cyA9IGVsZW1lbnQuc3R5bGUucG9pbnRlckV2ZW50cyB8fCAnJztcclxuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdkYXRhLWluZXJ0LXBvaW50ZXItZXZlbnRzJywgcG9pbnRlckV2ZW50cyk7XHJcbiAgICAvLyBtYWtlIHN1cmUgbm8gcG9pbnRlciBpbnRlcmFjdGlvbiBjYW4gYWNjZXNzIHRoZSBlbGVtZW50XHJcbiAgICBlbGVtZW50LnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XHJcbiAgfSBlbHNlIHtcclxuICAgIC8vIHJlc3RvcmUgdG8gcHJldmlvdXMgcG9pbnRlciBpbnRlcmFjdGlvbiBzdGF0dXNcclxuICAgIHZhciBfcG9pbnRlckV2ZW50cyA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWluZXJ0LXBvaW50ZXItZXZlbnRzJyk7XHJcbiAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1pbmVydC1wb2ludGVyLWV2ZW50cycpO1xyXG4gICAgZWxlbWVudC5zdHlsZS5wb2ludGVyRXZlbnRzID0gX3BvaW50ZXJFdmVudHM7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBzZXRFbGVtZW50RGlzYWJsZWQoZWxlbWVudCwgZGlzYWJsZWRTdGF0ZSkge1xyXG4gIHNldEFyaWFEaXNhYmxlZChlbGVtZW50LCBkaXNhYmxlZFN0YXRlKTtcclxuICBkaXNhYmxlVGFiaW5kZXgoZWxlbWVudCwgZGlzYWJsZWRTdGF0ZSk7XHJcbiAgZGlzYWJsZVNjcmlwdEZvY3VzKGVsZW1lbnQsIGRpc2FibGVkU3RhdGUpO1xyXG4gIGRpc2FibGVQb2ludGVyRXZlbnRzKGVsZW1lbnQsIGRpc2FibGVkU3RhdGUpO1xyXG5cclxuICB2YXIgbm9kZU5hbWUgPSBlbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XHJcbiAgaWYgKG5vZGVOYW1lID09PSAndmlkZW8nIHx8IG5vZGVOYW1lID09PSAnYXVkaW8nKSB7XHJcbiAgICAvLyBCbGluayBhbmQgR2Vja28gbGVhdmUgPHZpZGVvIGNvbnRyb2xzIHRhYmluZGV4PVwiLTFcIj4gaW4gZG9jdW1lbnQgZm9jdXMgbmF2aWdhdGlvbiBzZXF1ZW5jZVxyXG4gICAgLy8gQmxpbmsgbGVhdmVzIDxhdWRpbyBjb250cm9scyB0YWJpbmRleD1cIi0xXCI+IGluIGRvY3VtZW50IGZvY3VzIG5hdmlnYXRpb24gc2VxdWVuY2VcclxuICAgIGRpc2FibGVWaWRlb0NvbnRyb2xzKGVsZW1lbnQsIGRpc2FibGVkU3RhdGUpO1xyXG4gIH1cclxuXHJcbiAgaWYgKG5vZGVOYW1lID09PSAnc3ZnJyB8fCBlbGVtZW50Lm93bmVyU1ZHRWxlbWVudCkge1xyXG4gICAgaWYgKHN1cHBvcnRzLmZvY3VzU3ZnRm9jdXNhYmxlQXR0cmlidXRlKSB7XHJcbiAgICAgIC8vIEludGVybmV0IEV4cGxvcmVyIGtub3dzIGZvY3VzYWJsZT1cImZhbHNlXCIgaW5zdGVhZCBvZiB0YWJpbmRleD1cIi0xXCJcclxuICAgICAgZGlzYWJsZVN2Z0ZvY3VzYWJsZShlbGVtZW50LCBkaXNhYmxlZFN0YXRlKTtcclxuICAgIH0gZWxzZSBpZiAoIXN1cHBvcnRzLmZvY3VzU3ZnVGFiaW5kZXhBdHRyaWJ1dGUgJiYgbm9kZU5hbWUgPT09ICdhJykge1xyXG4gICAgICAvLyBGaXJlZm94IG5laXRoZXIga25vd3MgZm9jdXNhYmxlPVwiZmFsc2VcIiBub3IgdGFiaW5kZXg9XCItMVwiXHJcbiAgICAgIGRpc2FibGVTdmdMaW5rKGVsZW1lbnQsIGRpc2FibGVkU3RhdGUpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaWYgKGRpc2FibGVkU3RhdGUpIHtcclxuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdkYXRhLWFsbHktZGlzYWJsZWQnLCAndHJ1ZScpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1hbGx5LWRpc2FibGVkJyk7XHJcbiAgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGlzYWJsZWQuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xyXG4gIC8vIEVkZ2UxMywgRWRnZTE0OiBmb3JlaWduT2JqZWN0IGZvY3VzIGhhY2tcclxuICAvLyBodHRwczovL2pzYmluLmNvbS9rdW5laGludWdpL2VkaXQ/aHRtbCxqcyxvdXRwdXRcclxuICAvLyBodHRwczovL2pzYmluLmNvbS9mYWphZ2kvMy9lZGl0P2h0bWwsanMsb3V0cHV0XHJcbiAgdmFyIGlzU3ZnRWxlbWVudCA9IGVsZW1lbnQub3duZXJTVkdFbGVtZW50IHx8IGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3N2Zyc7XHJcbiAgaWYgKCFpc1N2Z0VsZW1lbnQpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIC8vIGluamVjdCBhbmQgZm9jdXMgYW4gPGlucHV0PiBlbGVtZW50IGludG8gdGhlIFNWRyBlbGVtZW50IHRvIHJlY2VpdmUgZm9jdXNcclxuICB2YXIgZm9yZWlnbk9iamVjdCA9IG1ha2VGb2N1c2FibGVGb3JlaWduT2JqZWN0KCk7XHJcbiAgZWxlbWVudC5hcHBlbmRDaGlsZChmb3JlaWduT2JqZWN0KTtcclxuICB2YXIgaW5wdXQgPSBmb3JlaWduT2JqZWN0LnF1ZXJ5U2VsZWN0b3IoJ2lucHV0Jyk7XHJcbiAgaW5wdXQuZm9jdXMoKTtcclxuXHJcbiAgLy8gdXBvbiBkaXNhYmxpbmcgdGhlIGFjdGl2ZUVsZW1lbnQsIElFIGFuZCBFZGdlXHJcbiAgLy8gd2lsbCBub3Qgc2hpZnQgZm9jdXMgdG8gPGJvZHk+IGxpa2UgYWxsIHRoZSBvdGhlclxyXG4gIC8vIGJyb3dzZXJzLCBidXQgaW5zdGVhZCBmaW5kIHRoZSBmaXJzdCBmb2N1c2FibGVcclxuICAvLyBhbmNlc3RvciBhbmQgc2hpZnQgZm9jdXMgdG8gdGhhdFxyXG4gIGlucHV0LmRpc2FibGVkID0gdHJ1ZTtcclxuXHJcbiAgLy8gY2xlYW4gdXBcclxuICBlbGVtZW50LnJlbW92ZUNoaWxkKGZvcmVpZ25PYmplY3QpO1xyXG4gIHJldHVybiB0cnVlO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gbWFrZUZvY3VzYWJsZUZvcmVpZ25PYmplY3QoKSB7XHJcbiAgdmFyIGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgZnJhZ21lbnQuaW5uZXJIVE1MID0gJzxzdmc+PGZvcmVpZ25PYmplY3Qgd2lkdGg9XCIzMFwiIGhlaWdodD1cIjMwXCI+XFxuICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIvPlxcbiAgPC9mb3JlaWduT2JqZWN0Pjwvc3ZnPic7XHJcblxyXG4gIHJldHVybiBmcmFnbWVudC5maXJzdENoaWxkLmZpcnN0Q2hpbGQ7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb2N1cy5zdmctZm9yZWlnbi1vYmplY3QtaGFjay5qcy5tYXAiLCIndXNlIHN0cmljdCc7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sXHJcbiAgICAgIGNvbnRleHQgPSBfcmVmLmNvbnRleHQ7XHJcblxyXG4gIHZhciBsaXN0ID0gW107XHJcbiAgdmFyIGVsZW1lbnQgPSAoMCwgX2NvbnRleHRUb0VsZW1lbnQyLmRlZmF1bHQpKHtcclxuICAgIGxhYmVsOiAnZ2V0L3BhcmVudHMnLFxyXG4gICAgY29udGV4dDogY29udGV4dFxyXG4gIH0pO1xyXG5cclxuICB3aGlsZSAoZWxlbWVudCkge1xyXG4gICAgbGlzdC5wdXNoKGVsZW1lbnQpO1xyXG4gICAgLy8gSUUgZG9lcyBrbm93IHN1cHBvcnQgcGFyZW50RWxlbWVudCBvbiBTVkdFbGVtZW50XHJcbiAgICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xyXG4gICAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudC5ub2RlVHlwZSAhPT0gTm9kZS5FTEVNRU5UX05PREUpIHtcclxuICAgICAgZWxlbWVudCA9IG51bGw7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gbGlzdDtcclxufTtcclxuXHJcbnZhciBfY29udGV4dFRvRWxlbWVudCA9IHJlcXVpcmUoJy4uL3V0aWwvY29udGV4dC10by1lbGVtZW50Jyk7XHJcblxyXG52YXIgX2NvbnRleHRUb0VsZW1lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29udGV4dFRvRWxlbWVudCk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XHJcblxyXG4vLyBbZWxlbSwgZWxlbS5wYXJlbnQsIGVsZW0ucGFyZW50LnBhcmVudCwg4oCmLCBodG1sXVxyXG4vLyB3aWxsIG5vdCBjb250YWluIHRoZSBzaGFkb3dSb290IChET0NVTUVOVF9GUkFHTUVOVF9OT0RFKSBhbmQgc2hhZG93SG9zdFxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJlbnRzLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcclxuICAgICAgY29udGV4dCA9IF9yZWYuY29udGV4dDtcclxuXHJcbiAgdmFyIGVsZW1lbnQgPSAoMCwgX2NvbnRleHRUb0VsZW1lbnQyLmRlZmF1bHQpKHtcclxuICAgIGxhYmVsOiAnZ2V0L3NoYWRvdy1ob3N0JyxcclxuICAgIGNvbnRleHQ6IGNvbnRleHRcclxuICB9KTtcclxuXHJcbiAgLy8gd2FsayB1cCB0byB0aGUgcm9vdFxyXG4gIHZhciBjb250YWluZXIgPSBudWxsO1xyXG5cclxuICB3aGlsZSAoZWxlbWVudCkge1xyXG4gICAgY29udGFpbmVyID0gZWxlbWVudDtcclxuICAgIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XHJcbiAgfVxyXG5cclxuICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTm9kZS5ub2RlVHlwZVxyXG4gIC8vIE5PVEU6IEZpcmVmb3ggMzQgZG9lcyBub3QgZXhwb3NlIFNoYWRvd1Jvb3QuaG9zdCAoYnV0IDM3IGRvZXMpXHJcbiAgaWYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gY29udGFpbmVyLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREUgJiYgY29udGFpbmVyLmhvc3QpIHtcclxuICAgIC8vIHRoZSByb290IGlzIGF0dGFjaGVkIHRvIGEgZnJhZ21lbnQgbm9kZSB0aGF0IGhhcyBhIGhvc3RcclxuICAgIHJldHVybiBjb250YWluZXIuaG9zdDtcclxuICB9XHJcblxyXG4gIHJldHVybiBudWxsO1xyXG59O1xyXG5cclxudmFyIF9jb250ZXh0VG9FbGVtZW50ID0gcmVxdWlyZSgnLi4vdXRpbC9jb250ZXh0LXRvLWVsZW1lbnQnKTtcclxuXHJcbnZhciBfY29udGV4dFRvRWxlbWVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb250ZXh0VG9FbGVtZW50KTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hhZG93LWhvc3QuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoY29udGV4dCkge1xyXG4gIHZhciBlbGVtZW50ID0gKDAsIF9jb250ZXh0VG9FbGVtZW50Mi5kZWZhdWx0KSh7XHJcbiAgICBsYWJlbDogJ2lzL2FjdGl2ZS1lbGVtZW50JyxcclxuICAgIHJlc29sdmVEb2N1bWVudDogdHJ1ZSxcclxuICAgIGNvbnRleHQ6IGNvbnRleHRcclxuICB9KTtcclxuXHJcbiAgdmFyIF9kb2N1bWVudCA9ICgwLCBfZ2V0RG9jdW1lbnQyLmRlZmF1bHQpKGVsZW1lbnQpO1xyXG4gIGlmIChfZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gZWxlbWVudCkge1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICB2YXIgc2hhZG93SG9zdCA9ICgwLCBfc2hhZG93SG9zdDIuZGVmYXVsdCkoeyBjb250ZXh0OiBlbGVtZW50IH0pO1xyXG4gIGlmIChzaGFkb3dIb3N0ICYmIHNoYWRvd0hvc3Quc2hhZG93Um9vdC5hY3RpdmVFbGVtZW50ID09PSBlbGVtZW50KSB7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIHJldHVybiBmYWxzZTtcclxufTtcclxuXHJcbnZhciBfY29udGV4dFRvRWxlbWVudCA9IHJlcXVpcmUoJy4uL3V0aWwvY29udGV4dC10by1lbGVtZW50Jyk7XHJcblxyXG52YXIgX2NvbnRleHRUb0VsZW1lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29udGV4dFRvRWxlbWVudCk7XHJcblxyXG52YXIgX3NoYWRvd0hvc3QgPSByZXF1aXJlKCcuLi9nZXQvc2hhZG93LWhvc3QnKTtcclxuXHJcbnZhciBfc2hhZG93SG9zdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zaGFkb3dIb3N0KTtcclxuXHJcbnZhciBfZ2V0RG9jdW1lbnQgPSByZXF1aXJlKCcuLi91dGlsL2dldC1kb2N1bWVudCcpO1xyXG5cclxudmFyIF9nZXREb2N1bWVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXREb2N1bWVudCk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuLy8gRGV0ZXJtaW5lcyBpZiBhbiBlbGVtZW50IGlzIHRoZSBhY3RpdmVFbGVtZW50IHdpdGhpbiBpdHMgY29udGV4dCwgaS5lLiBpdHMgZG9jdW1lbnQgaUZyYW1lIG9yIFNoYWRvd0hvc3RcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hY3RpdmUtZWxlbWVudC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XHJcbiAgaWYgKCFzdXBwb3J0cykge1xyXG4gICAgc3VwcG9ydHMgPSAoMCwgX3N1cHBvcnRzMy5kZWZhdWx0KSgpO1xyXG4gIH1cclxuXHJcbiAgdmFyIGVsZW1lbnQgPSAoMCwgX2NvbnRleHRUb0VsZW1lbnQyLmRlZmF1bHQpKHtcclxuICAgIGxhYmVsOiAnaXMvZGlzYWJsZWQnLFxyXG4gICAgY29udGV4dDogY29udGV4dFxyXG4gIH0pO1xyXG5cclxuICBpZiAoZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2RhdGEtYWxseS1kaXNhYmxlZCcpKSB7XHJcbiAgICAvLyB0cmVhdCBhbGx5J3MgZWxlbWVudC9kaXNhYmxlZCBsaWtlIHRoZSBET00gbmF0aXZlIGVsZW1lbnQuZGlzYWJsZWRcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuXHJcbiAgaWYgKCEoMCwgX25hdGl2ZURpc2FibGVkU3VwcG9ydGVkMi5kZWZhdWx0KShlbGVtZW50KSkge1xyXG4gICAgLy8gbm9uLWZvcm0gZWxlbWVudHMgZG8gbm90IHN1cHBvcnQgdGhlIGRpc2FibGVkIGF0dHJpYnV0ZVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgaWYgKGVsZW1lbnQuZGlzYWJsZWQpIHtcclxuICAgIC8vIHRoZSBlbGVtZW50IGl0c2VsZiBpcyBkaXNhYmxlZFxyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICB2YXIgcGFyZW50cyA9ICgwLCBfcGFyZW50czIuZGVmYXVsdCkoeyBjb250ZXh0OiBlbGVtZW50IH0pO1xyXG4gIGlmIChwYXJlbnRzLnNvbWUoaXNEaXNhYmxlZEZpZWxkc2V0KSkge1xyXG4gICAgLy8gYSBwYXJlbnRhbCA8ZmllbGRzZXQ+IGlzIGRpc2FibGQgYW5kIGluaGVyaXRzIHRoZSBzdGF0ZSBvbnRvIHRoaXMgZWxlbWVudFxyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICBpZiAoIXN1cHBvcnRzLmZvY3VzRm9ybURpc2FibGVkICYmIHBhcmVudHMuc29tZShpc0Rpc2FibGVkRm9ybSkpIHtcclxuICAgIC8vIGEgcGFyZW50YWwgPGZvcm0+IGlzIGRpc2FibGQgYW5kIGluaGVyaXRzIHRoZSBzdGF0ZSBvbnRvIHRoaXMgZWxlbWVudFxyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gZmFsc2U7XHJcbn07XHJcblxyXG52YXIgX2NvbnRleHRUb0VsZW1lbnQgPSByZXF1aXJlKCcuLi91dGlsL2NvbnRleHQtdG8tZWxlbWVudCcpO1xyXG5cclxudmFyIF9jb250ZXh0VG9FbGVtZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvbnRleHRUb0VsZW1lbnQpO1xyXG5cclxudmFyIF9wYXJlbnRzID0gcmVxdWlyZSgnLi4vZ2V0L3BhcmVudHMnKTtcclxuXHJcbnZhciBfcGFyZW50czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wYXJlbnRzKTtcclxuXHJcbnZhciBfbmF0aXZlRGlzYWJsZWRTdXBwb3J0ZWQgPSByZXF1aXJlKCcuL25hdGl2ZS1kaXNhYmxlZC1zdXBwb3J0ZWQnKTtcclxuXHJcbnZhciBfbmF0aXZlRGlzYWJsZWRTdXBwb3J0ZWQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbmF0aXZlRGlzYWJsZWRTdXBwb3J0ZWQpO1xyXG5cclxudmFyIF9zdXBwb3J0czIgPSByZXF1aXJlKCcuLi9zdXBwb3J0cy9zdXBwb3J0cycpO1xyXG5cclxudmFyIF9zdXBwb3J0czMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zdXBwb3J0czIpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbi8vIERldGVybWluZSBpZiBhbiBlbGVtZW50IGlzIGRpc2FibGVkIChpLmUuIG5vdCBlZGl0YWJsZSlcclxuXHJcbnZhciBzdXBwb3J0cyA9IHZvaWQgMDtcclxuXHJcbmZ1bmN0aW9uIGlzRGlzYWJsZWRGaWVsZHNldChlbGVtZW50KSB7XHJcbiAgdmFyIG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xyXG4gIHJldHVybiBub2RlTmFtZSA9PT0gJ2ZpZWxkc2V0JyAmJiBlbGVtZW50LmRpc2FibGVkO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc0Rpc2FibGVkRm9ybShlbGVtZW50KSB7XHJcbiAgdmFyIG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xyXG4gIHJldHVybiBub2RlTmFtZSA9PT0gJ2Zvcm0nICYmIGVsZW1lbnQuZGlzYWJsZWQ7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kaXNhYmxlZC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfcGFyZW50cyA9IHJlcXVpcmUoJy4uL2dldC9wYXJlbnRzJyk7XHJcblxyXG52YXIgX3BhcmVudHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcGFyZW50cyk7XHJcblxyXG52YXIgX2NvbnRleHRUb0VsZW1lbnQgPSByZXF1aXJlKCcuLi91dGlsL2NvbnRleHQtdG8tZWxlbWVudCcpO1xyXG5cclxudmFyIF9jb250ZXh0VG9FbGVtZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvbnRleHRUb0VsZW1lbnQpO1xyXG5cclxudmFyIF9lbGVtZW50TWF0Y2hlcyA9IHJlcXVpcmUoJy4uL3V0aWwvZWxlbWVudC1tYXRjaGVzJyk7XHJcblxyXG52YXIgX2VsZW1lbnRNYXRjaGVzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2VsZW1lbnRNYXRjaGVzKTtcclxuXHJcbnZhciBfdGFiaW5kZXhWYWx1ZSA9IHJlcXVpcmUoJy4uL3V0aWwvdGFiaW5kZXgtdmFsdWUnKTtcclxuXHJcbnZhciBfdGFiaW5kZXhWYWx1ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90YWJpbmRleFZhbHVlKTtcclxuXHJcbnZhciBfdmFsaWRUYWJpbmRleCA9IHJlcXVpcmUoJy4vdmFsaWQtdGFiaW5kZXgnKTtcclxuXHJcbnZhciBfdmFsaWRUYWJpbmRleDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF92YWxpZFRhYmluZGV4KTtcclxuXHJcbnZhciBfaXMgPSByZXF1aXJlKCcuL2lzLnV0aWwnKTtcclxuXHJcbnZhciBfc3VwcG9ydHMyID0gcmVxdWlyZSgnLi4vc3VwcG9ydHMvc3VwcG9ydHMnKTtcclxuXHJcbnZhciBfc3VwcG9ydHMzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3VwcG9ydHMyKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG52YXIgc3VwcG9ydHMgPSB2b2lkIDA7XHJcbi8vIGRldGVybWluZSBpZiBhbiBlbGVtZW50IHN1cHBvcnRzLmNhbiBiZSBmb2N1c2VkIGJ5IHNjcmlwdCByZWdhcmRsZXNzXHJcbi8vIG9mIHRoZSBlbGVtZW50IGFjdHVhbGx5IGJlaW5nIGZvY3VzYWJsZSBhdCB0aGUgdGltZSBvZiBleGVjdXRpb25cclxuLy8gaS5lLiA8aW5wdXQgZGlzYWJsZWQ+IGlzIGNvbmlzZGVyZWQgZm9jdXMtcmVsZXZhbnQsIGJ1dCBub3QgZm9jdXNhYmxlXHJcblxyXG5mdW5jdGlvbiBpc0ZvY3VzUmVsZXZhbnRSdWxlcygpIHtcclxuICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sXHJcbiAgICAgIGNvbnRleHQgPSBfcmVmLmNvbnRleHQsXHJcbiAgICAgIF9yZWYkZXhjZXB0ID0gX3JlZi5leGNlcHQsXHJcbiAgICAgIGV4Y2VwdCA9IF9yZWYkZXhjZXB0ID09PSB1bmRlZmluZWQgPyB7XHJcbiAgICBmbGV4Ym94OiBmYWxzZSxcclxuICAgIHNjcm9sbGFibGU6IGZhbHNlLFxyXG4gICAgc2hhZG93OiBmYWxzZVxyXG4gIH0gOiBfcmVmJGV4Y2VwdDtcclxuXHJcbiAgaWYgKCFzdXBwb3J0cykge1xyXG4gICAgc3VwcG9ydHMgPSAoMCwgX3N1cHBvcnRzMy5kZWZhdWx0KSgpO1xyXG4gIH1cclxuXHJcbiAgdmFyIGVsZW1lbnQgPSAoMCwgX2NvbnRleHRUb0VsZW1lbnQyLmRlZmF1bHQpKHtcclxuICAgIGxhYmVsOiAnaXMvZm9jdXMtcmVsZXZhbnQnLFxyXG4gICAgcmVzb2x2ZURvY3VtZW50OiB0cnVlLFxyXG4gICAgY29udGV4dDogY29udGV4dFxyXG4gIH0pO1xyXG5cclxuICBpZiAoIWV4Y2VwdC5zaGFkb3cgJiYgZWxlbWVudC5zaGFkb3dSb290KSB7XHJcbiAgICAvLyBhIFNoYWRvd0RPTSBob3N0IHJlY2VpdmVzIGZvY3VzIHdoZW4gdGhlIGZvY3VzIG1vdmVzIHRvIGl0cyBjb250ZW50XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIHZhciBub2RlTmFtZSA9IGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcclxuXHJcbiAgaWYgKG5vZGVOYW1lID09PSAnaW5wdXQnICYmIGVsZW1lbnQudHlwZSA9PT0gJ2hpZGRlbicpIHtcclxuICAgIC8vIGlucHV0W3R5cGU9XCJoaWRkZW5cIl0gc3VwcG9ydHMuY2Fubm90IGJlIGZvY3VzZWRcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIGlmIChub2RlTmFtZSA9PT0gJ2lucHV0JyB8fCBub2RlTmFtZSA9PT0gJ3NlbGVjdCcgfHwgbm9kZU5hbWUgPT09ICdidXR0b24nIHx8IG5vZGVOYW1lID09PSAndGV4dGFyZWEnKSB7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIGlmIChub2RlTmFtZSA9PT0gJ2xlZ2VuZCcgJiYgc3VwcG9ydHMuZm9jdXNSZWRpcmVjdExlZ2VuZCkge1xyXG4gICAgLy8gc3BlY2lmaWNzIGZpbHRlcmVkIGluIGlzL2ZvY3VzYWJsZVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICBpZiAobm9kZU5hbWUgPT09ICdsYWJlbCcpIHtcclxuICAgIC8vIHNwZWNpZmljcyBmaWx0ZXJlZCBpbiBpcy9mb2N1c2FibGVcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuXHJcbiAgaWYgKG5vZGVOYW1lID09PSAnYXJlYScpIHtcclxuICAgIC8vIHNwZWNpZmljcyBmaWx0ZXJlZCBpbiBpcy9mb2N1c2FibGVcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuXHJcbiAgaWYgKG5vZGVOYW1lID09PSAnYScgJiYgZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2hyZWYnKSkge1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICBpZiAobm9kZU5hbWUgPT09ICdvYmplY3QnICYmIGVsZW1lbnQuaGFzQXR0cmlidXRlKCd1c2VtYXAnKSkge1xyXG4gICAgLy8gb2JqZWN0W3VzZW1hcF0gaXMgbm90IGZvY3VzYWJsZSBpbiBhbnkgYnJvd3NlclxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgaWYgKG5vZGVOYW1lID09PSAnb2JqZWN0Jykge1xyXG4gICAgdmFyIHN2Z1R5cGUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgndHlwZScpO1xyXG4gICAgaWYgKCFzdXBwb3J0cy5mb2N1c09iamVjdFN2ZyAmJiBzdmdUeXBlID09PSAnaW1hZ2Uvc3ZnK3htbCcpIHtcclxuICAgICAgLy8gb2JqZWN0W3R5cGU9XCJpbWFnZS9zdmcreG1sXCJdIGlzIG5vdCBmb2N1c2FibGUgaW4gSW50ZXJuZXQgRXhwbG9yZXJcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfSBlbHNlIGlmICghc3VwcG9ydHMuZm9jdXNPYmplY3RTd2YgJiYgc3ZnVHlwZSA9PT0gJ2FwcGxpY2F0aW9uL3gtc2hvY2t3YXZlLWZsYXNoJykge1xyXG4gICAgICAvLyBvYmplY3RbdHlwZT1cImFwcGxpY2F0aW9uL3gtc2hvY2t3YXZlLWZsYXNoXCJdIGlzIG5vdCBmb2N1c2FibGUgaW4gSW50ZXJuZXQgRXhwbG9yZXIgOVxyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBpZiAobm9kZU5hbWUgPT09ICdpZnJhbWUnIHx8IG5vZGVOYW1lID09PSAnb2JqZWN0Jykge1xyXG4gICAgLy8gYnJvd3NpbmcgY29udGV4dCBjb250YWluZXJzXHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIGlmIChub2RlTmFtZSA9PT0gJ2VtYmVkJyB8fCBub2RlTmFtZSA9PT0gJ2tleWdlbicpIHtcclxuICAgIC8vIGVtYmVkIGlzIGNvbnNpZGVyZWQgZm9jdXMtcmVsZXZhbnQgYnV0IG5vdCBmb2N1c2FibGVcclxuICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbWVkaWFsaXplL2FsbHkuanMvaXNzdWVzLzgyXHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIGlmIChlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnY29udGVudGVkaXRhYmxlJykpIHtcclxuICAgIC8vIGFsc28gc2VlIENTUyBwcm9wZXJ0eSB1c2VyLW1vZGlmeSBiZWxvd1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICBpZiAobm9kZU5hbWUgPT09ICdhdWRpbycgJiYgKHN1cHBvcnRzLmZvY3VzQXVkaW9XaXRob3V0Q29udHJvbHMgfHwgZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2NvbnRyb2xzJykpKSB7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIGlmIChub2RlTmFtZSA9PT0gJ3ZpZGVvJyAmJiAoc3VwcG9ydHMuZm9jdXNWaWRlb1dpdGhvdXRDb250cm9scyB8fCBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnY29udHJvbHMnKSkpIHtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuXHJcbiAgaWYgKHN1cHBvcnRzLmZvY3VzU3VtbWFyeSAmJiBub2RlTmFtZSA9PT0gJ3N1bW1hcnknKSB7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIHZhciB2YWxpZFRhYmluZGV4ID0gKDAsIF92YWxpZFRhYmluZGV4Mi5kZWZhdWx0KShlbGVtZW50KTtcclxuXHJcbiAgaWYgKG5vZGVOYW1lID09PSAnaW1nJyAmJiBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgndXNlbWFwJykpIHtcclxuICAgIC8vIEdlY2tvLCBUcmlkZW50IGFuZCBFZGdlIGRvIG5vdCBhbGxvdyBhbiBpbWFnZSB3aXRoIGFuIGltYWdlIG1hcCBhbmQgdGFiaW5kZXggdG8gYmUgZm9jdXNlZCxcclxuICAgIC8vIGl0IGFwcGVhcnMgdGhlIHRhYmluZGV4IGlzIG92ZXJydWxlZCBzbyBmb2N1cyBpcyBzdGlsbCBmb3J3YXJkZWQgdG8gdGhlIDxtYXA+XHJcbiAgICByZXR1cm4gdmFsaWRUYWJpbmRleCAmJiBzdXBwb3J0cy5mb2N1c0ltZ1VzZW1hcFRhYmluZGV4IHx8IHN1cHBvcnRzLmZvY3VzUmVkaXJlY3RJbWdVc2VtYXA7XHJcbiAgfVxyXG5cclxuICBpZiAoc3VwcG9ydHMuZm9jdXNUYWJsZSAmJiAobm9kZU5hbWUgPT09ICd0YWJsZScgfHwgbm9kZU5hbWUgPT09ICd0ZCcpKSB7XHJcbiAgICAvLyBJRTEwLTExIHN1cHBvcnRzLmNhbiBmb2N1cyA8dGFibGU+IGFuZCA8dGQ+XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIGlmIChzdXBwb3J0cy5mb2N1c0ZpZWxkc2V0ICYmIG5vZGVOYW1lID09PSAnZmllbGRzZXQnKSB7XHJcbiAgICAvLyBJRTEwLTExIHN1cHBvcnRzLmNhbiBmb2N1cyA8ZmllbGRzZXQ+XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIHZhciBpc1N2Z0VsZW1lbnQgPSBub2RlTmFtZSA9PT0gJ3N2Zyc7XHJcbiAgdmFyIGlzU3ZnQ29udGVudCA9IGVsZW1lbnQub3duZXJTVkdFbGVtZW50O1xyXG4gIHZhciBmb2N1c2FibGVBdHRyaWJ1dGUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZm9jdXNhYmxlJyk7XHJcbiAgdmFyIHRhYmluZGV4ID0gKDAsIF90YWJpbmRleFZhbHVlMi5kZWZhdWx0KShlbGVtZW50KTtcclxuXHJcbiAgaWYgKG5vZGVOYW1lID09PSAndXNlJyAmJiB0YWJpbmRleCAhPT0gbnVsbCAmJiAhc3VwcG9ydHMuZm9jdXNTdmdVc2VUYWJpbmRleCkge1xyXG4gICAgLy8gPHVzZT4gY2Fubm90IGJlIG1hZGUgZm9jdXNhYmxlIGJ5IGFkZGluZyBhIHRhYmluZGV4IGF0dHJpYnV0ZSBhbnl3aGVyZSBidXQgQmxpbmsgYW5kIFdlYktpdFxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgaWYgKG5vZGVOYW1lID09PSAnZm9yZWlnbm9iamVjdCcpIHtcclxuICAgIC8vIDx1c2U+IGNhbiBvbmx5IGJlIG1hZGUgZm9jdXNhYmxlIGluIEJsaW5rIGFuZCBXZWJLaXRcclxuICAgIHJldHVybiB0YWJpbmRleCAhPT0gbnVsbCAmJiBzdXBwb3J0cy5mb2N1c1N2Z0ZvcmVpZ25vYmplY3RUYWJpbmRleDtcclxuICB9XHJcblxyXG4gIGlmICgoMCwgX2VsZW1lbnRNYXRjaGVzMi5kZWZhdWx0KShlbGVtZW50LCAnc3ZnIGEnKSAmJiBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgneGxpbms6aHJlZicpKSB7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIGlmICgoaXNTdmdFbGVtZW50IHx8IGlzU3ZnQ29udGVudCkgJiYgZWxlbWVudC5mb2N1cyAmJiAhc3VwcG9ydHMuZm9jdXNTdmdOZWdhdGl2ZVRhYmluZGV4QXR0cmlidXRlICYmIHRhYmluZGV4IDwgMCkge1xyXG4gICAgLy8gRmlyZWZveCA1MSBhbmQgNTIgdHJlYXQgYW55IG5hdGl2ZWx5IHRhYmJhYmxlIFNWRyBlbGVtZW50IHdpdGhcclxuICAgIC8vIHRhYmluZGV4PVwiLTFcIiBhcyB0YWJiYWJsZSBhbmQgZXZlcnl0aGluZyBlbHNlIGFzIGluZXJ0XHJcbiAgICAvLyBzZWUgaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTMwMjM0MFxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgaWYgKGlzU3ZnRWxlbWVudCkge1xyXG4gICAgcmV0dXJuIHZhbGlkVGFiaW5kZXggfHwgc3VwcG9ydHMuZm9jdXNTdmcgfHwgc3VwcG9ydHMuZm9jdXNTdmdJbklmcmFtZVxyXG4gICAgLy8gSW50ZXJuZXQgRXhwbG9yZXIgdW5kZXJzdGFuZHMgdGhlIGZvY3VzYWJsZSBhdHRyaWJ1dGUgaW50cm9kdWNlZCBpbiBTVkcgVGlueSAxLjJcclxuICAgIHx8IEJvb2xlYW4oc3VwcG9ydHMuZm9jdXNTdmdGb2N1c2FibGVBdHRyaWJ1dGUgJiYgZm9jdXNhYmxlQXR0cmlidXRlICYmIGZvY3VzYWJsZUF0dHJpYnV0ZSA9PT0gJ3RydWUnKTtcclxuICB9XHJcblxyXG4gIGlmIChpc1N2Z0NvbnRlbnQpIHtcclxuICAgIGlmIChzdXBwb3J0cy5mb2N1c1N2Z1RhYmluZGV4QXR0cmlidXRlICYmIHZhbGlkVGFiaW5kZXgpIHtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHN1cHBvcnRzLmZvY3VzU3ZnRm9jdXNhYmxlQXR0cmlidXRlKSB7XHJcbiAgICAgIC8vIEludGVybmV0IEV4cGxvcmVyIHVuZGVyc3RhbmRzIHRoZSBmb2N1c2FibGUgYXR0cmlidXRlIGludHJvZHVjZWQgaW4gU1ZHIFRpbnkgMS4yXHJcbiAgICAgIHJldHVybiBmb2N1c2FibGVBdHRyaWJ1dGUgPT09ICd0cnVlJztcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lZGl0aW5nLmh0bWwjc2VxdWVudGlhbC1mb2N1cy1uYXZpZ2F0aW9uLWFuZC10aGUtdGFiaW5kZXgtYXR0cmlidXRlXHJcbiAgaWYgKHZhbGlkVGFiaW5kZXgpIHtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuXHJcbiAgdmFyIHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCwgbnVsbCk7XHJcbiAgaWYgKCgwLCBfaXMuaXNVc2VyTW9kaWZ5V3JpdGFibGUpKHN0eWxlKSkge1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICBpZiAoc3VwcG9ydHMuZm9jdXNJbWdJc21hcCAmJiBub2RlTmFtZSA9PT0gJ2ltZycgJiYgZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2lzbWFwJykpIHtcclxuICAgIC8vIElFMTAtMTEgY29uc2lkZXJzIHRoZSA8aW1nPiBpbiA8YSBocmVmPjxpbWcgaXNtYXA+IGZvY3VzYWJsZVxyXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21lZGlhbGl6ZS9hbGx5LmpzL2lzc3Vlcy8yMFxyXG4gICAgdmFyIGhhc0xpbmtQYXJlbnQgPSAoMCwgX3BhcmVudHMyLmRlZmF1bHQpKHsgY29udGV4dDogZWxlbWVudCB9KS5zb21lKGZ1bmN0aW9uIChwYXJlbnQpIHtcclxuICAgICAgcmV0dXJuIHBhcmVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnYScgJiYgcGFyZW50Lmhhc0F0dHJpYnV0ZSgnaHJlZicpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaWYgKGhhc0xpbmtQYXJlbnQpIHtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vbWVkaWFsaXplL2FsbHkuanMvaXNzdWVzLzIxXHJcbiAgaWYgKCFleGNlcHQuc2Nyb2xsYWJsZSAmJiBzdXBwb3J0cy5mb2N1c1Njcm9sbENvbnRhaW5lcikge1xyXG4gICAgaWYgKHN1cHBvcnRzLmZvY3VzU2Nyb2xsQ29udGFpbmVyV2l0aG91dE92ZXJmbG93KSB7XHJcbiAgICAgIC8vIEludGVybmV0IEV4cGxvcmVyIGRvZXMgd2lsbCBjb25zaWRlciB0aGUgc2Nyb2xsYWJsZSBhcmVhIGZvY3VzYWJsZVxyXG4gICAgICAvLyBpZiB0aGUgZWxlbWVudCBpcyBhIDxkaXY+IG9yIGEgPHNwYW4+IGFuZCBpdCBpcyBpbiBmYWN0IHNjcm9sbGFibGUsXHJcbiAgICAgIC8vIHJlZ2FyZGxlc3Mgb2YgdGhlIENTUyBvdmVyZmxvdyBwcm9wZXJ0eVxyXG4gICAgICBpZiAoKDAsIF9pcy5pc1Njcm9sbGFibGVDb250YWluZXIpKGVsZW1lbnQsIG5vZGVOYW1lKSkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKCgwLCBfaXMuaGFzQ3NzT3ZlcmZsb3dTY3JvbGwpKHN0eWxlKSkge1xyXG4gICAgICAvLyBGaXJlZm94IHJlcXVpcmVzIHByb3BlciBvdmVyZmxvdyBzZXR0aW5nLCBJRSBkb2VzIG5vdCBuZWNlc3NhcmlseVxyXG4gICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1Mvb3ZlcmZsb3dcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBpZiAoIWV4Y2VwdC5mbGV4Ym94ICYmIHN1cHBvcnRzLmZvY3VzRmxleGJveENvbnRhaW5lciAmJiAoMCwgX2lzLmhhc0Nzc0Rpc3BsYXlGbGV4KShzdHlsZSkpIHtcclxuICAgIC8vIGVsZW1lbnRzIHdpdGggZGlzcGxheTpmbGV4IGFyZSBmb2N1c2FibGUgaW4gSUUxMC0xMVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICB2YXIgcGFyZW50ID0gZWxlbWVudC5wYXJlbnRFbGVtZW50O1xyXG4gIGlmICghZXhjZXB0LnNjcm9sbGFibGUgJiYgcGFyZW50KSB7XHJcbiAgICB2YXIgcGFyZW50Tm9kZU5hbWUgPSBwYXJlbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcclxuICAgIHZhciBwYXJlbnRTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHBhcmVudCwgbnVsbCk7XHJcbiAgICBpZiAoc3VwcG9ydHMuZm9jdXNTY3JvbGxCb2R5ICYmICgwLCBfaXMuaXNTY3JvbGxhYmxlQ29udGFpbmVyKShwYXJlbnQsIG5vZGVOYW1lLCBwYXJlbnROb2RlTmFtZSwgcGFyZW50U3R5bGUpKSB7XHJcbiAgICAgIC8vIHNjcm9sbGFibGUgYm9kaWVzIGFyZSBmb2N1c2FibGUgSW50ZXJuZXQgRXhwbG9yZXJcclxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21lZGlhbGl6ZS9hbGx5LmpzL2lzc3Vlcy8yMVxyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBDaGlsZHJlbiBvZiBmb2N1c2FibGUgZWxlbWVudHMgd2l0aCBkaXNwbGF5OmZsZXggYXJlIGZvY3VzYWJsZSBpbiBJRTEwLTExXHJcbiAgICBpZiAoc3VwcG9ydHMuZm9jdXNDaGlsZHJlbk9mRm9jdXNhYmxlRmxleGJveCkge1xyXG4gICAgICBpZiAoKDAsIF9pcy5oYXNDc3NEaXNwbGF5RmxleCkocGFyZW50U3R5bGUpKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIE5PVEU6IGVsZW1lbnRzIG1hcmtlZCBhcyBpbmVydCBhcmUgbm90IGZvY3VzYWJsZSxcclxuICAvLyBidXQgdGhhdCBwcm9wZXJ0eSBpcyBub3QgZXhwb3NlZCB0byB0aGUgRE9NXHJcbiAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VkaXRpbmcuaHRtbCNpbmVydFxyXG5cclxuICByZXR1cm4gZmFsc2U7XHJcbn1cclxuXHJcbi8vIGJpbmQgZXhjZXB0aW9ucyB0byBhbiBpdGVyYXRvciBjYWxsYmFja1xyXG5pc0ZvY3VzUmVsZXZhbnRSdWxlcy5leGNlcHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIGV4Y2VwdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XHJcblxyXG4gIHZhciBpc0ZvY3VzUmVsZXZhbnQgPSBmdW5jdGlvbiBpc0ZvY3VzUmVsZXZhbnQoY29udGV4dCkge1xyXG4gICAgcmV0dXJuIGlzRm9jdXNSZWxldmFudFJ1bGVzKHtcclxuICAgICAgY29udGV4dDogY29udGV4dCxcclxuICAgICAgZXhjZXB0OiBleGNlcHRcclxuICAgIH0pO1xyXG4gIH07XHJcblxyXG4gIGlzRm9jdXNSZWxldmFudC5ydWxlcyA9IGlzRm9jdXNSZWxldmFudFJ1bGVzO1xyXG4gIHJldHVybiBpc0ZvY3VzUmVsZXZhbnQ7XHJcbn07XHJcblxyXG4vLyBwcm92aWRlIGlzRm9jdXNSZWxldmFudChjb250ZXh0KSBhcyBkZWZhdWx0IGl0ZXJhdG9yIGNhbGxiYWNrXHJcbnZhciBpc0ZvY3VzUmVsZXZhbnQgPSBpc0ZvY3VzUmVsZXZhbnRSdWxlcy5leGNlcHQoe30pO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBpc0ZvY3VzUmVsZXZhbnQ7XHJcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb2N1cy1yZWxldmFudC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfZm9jdXNSZWxldmFudCA9IHJlcXVpcmUoJy4vZm9jdXMtcmVsZXZhbnQnKTtcclxuXHJcbnZhciBfZm9jdXNSZWxldmFudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mb2N1c1JlbGV2YW50KTtcclxuXHJcbnZhciBfdmFsaWRBcmVhID0gcmVxdWlyZSgnLi92YWxpZC1hcmVhJyk7XHJcblxyXG52YXIgX3ZhbGlkQXJlYTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF92YWxpZEFyZWEpO1xyXG5cclxudmFyIF92aXNpYmxlID0gcmVxdWlyZSgnLi92aXNpYmxlJyk7XHJcblxyXG52YXIgX3Zpc2libGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdmlzaWJsZSk7XHJcblxyXG52YXIgX2Rpc2FibGVkID0gcmVxdWlyZSgnLi9kaXNhYmxlZCcpO1xyXG5cclxudmFyIF9kaXNhYmxlZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kaXNhYmxlZCk7XHJcblxyXG52YXIgX29ubHlUYWJiYWJsZSA9IHJlcXVpcmUoJy4vb25seS10YWJiYWJsZScpO1xyXG5cclxudmFyIF9vbmx5VGFiYmFibGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfb25seVRhYmJhYmxlKTtcclxuXHJcbnZhciBfY29udGV4dFRvRWxlbWVudCA9IHJlcXVpcmUoJy4uL3V0aWwvY29udGV4dC10by1lbGVtZW50Jyk7XHJcblxyXG52YXIgX2NvbnRleHRUb0VsZW1lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29udGV4dFRvRWxlbWVudCk7XHJcblxyXG52YXIgX2dldEZyYW1lRWxlbWVudCA9IHJlcXVpcmUoJy4uL3V0aWwvZ2V0LWZyYW1lLWVsZW1lbnQnKTtcclxuXHJcbnZhciBfZ2V0RnJhbWVFbGVtZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldEZyYW1lRWxlbWVudCk7XHJcblxyXG52YXIgX3RhYmluZGV4VmFsdWUgPSByZXF1aXJlKCcuLi91dGlsL3RhYmluZGV4LXZhbHVlJyk7XHJcblxyXG52YXIgX3RhYmluZGV4VmFsdWUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdGFiaW5kZXhWYWx1ZSk7XHJcblxyXG52YXIgX3N1cHBvcnRzMiA9IHJlcXVpcmUoJy4uL3N1cHBvcnRzL3N1cHBvcnRzJyk7XHJcblxyXG52YXIgX3N1cHBvcnRzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3N1cHBvcnRzMik7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxudmFyIHN1cHBvcnRzID0gdm9pZCAwO1xyXG4vLyBkZXRlcm1pbmUgaWYgYW4gZWxlbWVudCBjYW4gYmUgZm9jdXNlZFxyXG5cclxuLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VkaXRpbmcuaHRtbCNmb2N1cy1tYW5hZ2VtZW50XHJcblxyXG4vLyBOT1RFOiBUaGUgZm9sbG93aW5nIGtub3duIGlzc3VlcyBleGlzdDpcclxuLy8gICBHZWNrbzogYHN2ZyBhW3hsaW5rfGhyZWZdYCBpcyBub3QgaWRlbnRpZmllZCBhcyBmb2N1c2FibGUgKGJlY2F1c2UgU1ZHRWxlbWVudC5wcm90b3R5cGUuZm9jdXMgaXMgbWlzc2luZylcclxuLy8gICBCbGluaywgV2ViS2l0OiBTVkdFbGVtZW50cyB0aGF0IGhhdmUgYmVlbiBtYWRlIGZvY3VzYWJsZSBieSBhZGRpbmcgYSBmb2N1cyBldmVudCBsaXN0ZW5lciBhcmUgbm90IGlkZW50aWZpZWQgYXMgZm9jdXNhYmxlXHJcblxyXG5mdW5jdGlvbiBpc09ubHlGb2N1c1JlbGV2YW50KGVsZW1lbnQpIHtcclxuICB2YXIgbm9kZU5hbWUgPSBlbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XHJcbiAgaWYgKG5vZGVOYW1lID09PSAnZW1iZWQnIHx8IG5vZGVOYW1lID09PSAna2V5Z2VuJykge1xyXG4gICAgLy8gZW1iZWQgaXMgY29uc2lkZXJlZCBmb2N1cy1yZWxldmFudCBidXQgbm90IGZvY3VzYWJsZVxyXG4gICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tZWRpYWxpemUvYWxseS5qcy9pc3N1ZXMvODJcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuXHJcbiAgdmFyIF90YWJpbmRleCA9ICgwLCBfdGFiaW5kZXhWYWx1ZTIuZGVmYXVsdCkoZWxlbWVudCk7XHJcbiAgaWYgKGVsZW1lbnQuc2hhZG93Um9vdCAmJiBfdGFiaW5kZXggPT09IG51bGwpIHtcclxuICAgIC8vIFNoYWRvd0RPTSBob3N0IGVsZW1lbnRzICptYXkqIHJlY2VpdmUgZm9jdXNcclxuICAgIC8vIGV2ZW4gdGhvdWdoIHRoZXkgYXJlIG5vdCBjb25zaWRlcmVkIGZvY3VhYmxlXHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIGlmIChub2RlTmFtZSA9PT0gJ2xhYmVsJykge1xyXG4gICAgLy8gPGxhYmVsIHRhYmluZGV4PVwiMFwiPiBpcyBvbmx5IHRhYmJhYmxlIGluIEZpcmVmb3gsIG5vdCBzY3JpcHQtZm9jdXNhYmxlXHJcbiAgICAvLyB0aGVyZSdzIG5vIHdheSB0byBtYWtlIGFuIGVsZW1lbnQgZm9jdXNhYmxlIG90aGVyIHRoYW4gYnkgYWRkaW5nIGEgdGFiaW5kZXgsXHJcbiAgICAvLyBhbmQgZm9jdXMgYmVoYXZpb3Igb2YgdGhlIGxhYmVsIGVsZW1lbnQgc2VlbXMgaGFyZC13aXJlZCB0byBpZ25vcmUgdGFiaW5kZXhcclxuICAgIC8vIGluIHNvbWUgYnJvd3NlcnMgKGxpa2UgR2Vja28sIEJsaW5rIGFuZCBXZWJLaXQpXHJcbiAgICByZXR1cm4gIXN1cHBvcnRzLmZvY3VzTGFiZWxUYWJpbmRleCB8fCBfdGFiaW5kZXggPT09IG51bGw7XHJcbiAgfVxyXG5cclxuICBpZiAobm9kZU5hbWUgPT09ICdsZWdlbmQnKSB7XHJcbiAgICByZXR1cm4gX3RhYmluZGV4ID09PSBudWxsO1xyXG4gIH1cclxuXHJcbiAgaWYgKHN1cHBvcnRzLmZvY3VzU3ZnRm9jdXNhYmxlQXR0cmlidXRlICYmIChlbGVtZW50Lm93bmVyU1ZHRWxlbWVudCB8fCBub2RlTmFtZSA9PT0gJ3N2ZycpKSB7XHJcbiAgICAvLyBJbnRlcm5ldCBFeHBsb3JlciB1bmRlcnN0YW5kcyB0aGUgZm9jdXNhYmxlIGF0dHJpYnV0ZSBpbnRyb2R1Y2VkIGluIFNWRyBUaW55IDEuMlxyXG4gICAgdmFyIGZvY3VzYWJsZUF0dHJpYnV0ZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdmb2N1c2FibGUnKTtcclxuICAgIHJldHVybiBmb2N1c2FibGVBdHRyaWJ1dGUgJiYgZm9jdXNhYmxlQXR0cmlidXRlID09PSAnZmFsc2UnO1xyXG4gIH1cclxuXHJcbiAgaWYgKG5vZGVOYW1lID09PSAnaW1nJyAmJiBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgndXNlbWFwJykpIHtcclxuICAgIC8vIEdlY2tvLCBUcmlkZW50IGFuZCBFZGdlIGRvIG5vdCBhbGxvdyBhbiBpbWFnZSB3aXRoIGFuIGltYWdlIG1hcCBhbmQgdGFiaW5kZXggdG8gYmUgZm9jdXNlZCxcclxuICAgIC8vIGl0IGFwcGVhcnMgdGhlIHRhYmluZGV4IGlzIG92ZXJydWxlZCBzbyBmb2N1cyBpcyBzdGlsbCBmb3J3YXJkZWQgdG8gdGhlIDxtYXA+XHJcbiAgICByZXR1cm4gX3RhYmluZGV4ID09PSBudWxsIHx8ICFzdXBwb3J0cy5mb2N1c0ltZ1VzZW1hcFRhYmluZGV4O1xyXG4gIH1cclxuXHJcbiAgaWYgKG5vZGVOYW1lID09PSAnYXJlYScpIHtcclxuICAgIC8vIGFsbCA8YXJlYT5zIGFyZSBjb25zaWRlcmVkIHJlbGV2YW50LFxyXG4gICAgLy8gYnV0IG9ubHkgdGhlIHZhbGlkIDxhcmVhPnMgYXJlIGZvY3VzYWJsZVxyXG4gICAgcmV0dXJuICEoMCwgX3ZhbGlkQXJlYTIuZGVmYXVsdCkoZWxlbWVudCk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gZmFsc2U7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzRm9jdXNhYmxlUnVsZXMoKSB7XHJcbiAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxyXG4gICAgICBjb250ZXh0ID0gX3JlZi5jb250ZXh0LFxyXG4gICAgICBfcmVmJGV4Y2VwdCA9IF9yZWYuZXhjZXB0LFxyXG4gICAgICBleGNlcHQgPSBfcmVmJGV4Y2VwdCA9PT0gdW5kZWZpbmVkID8ge1xyXG4gICAgZGlzYWJsZWQ6IGZhbHNlLFxyXG4gICAgdmlzaWJsZTogZmFsc2UsXHJcbiAgICBvbmx5VGFiYmFibGU6IGZhbHNlXHJcbiAgfSA6IF9yZWYkZXhjZXB0O1xyXG5cclxuICBpZiAoIXN1cHBvcnRzKSB7XHJcbiAgICBzdXBwb3J0cyA9ICgwLCBfc3VwcG9ydHMzLmRlZmF1bHQpKCk7XHJcbiAgfVxyXG5cclxuICB2YXIgX2lzT25seVRhYmJhYmxlID0gX29ubHlUYWJiYWJsZTIuZGVmYXVsdC5ydWxlcy5leGNlcHQoe1xyXG4gICAgb25seUZvY3VzYWJsZUJyb3dzaW5nQ29udGV4dDogdHJ1ZSxcclxuICAgIHZpc2libGU6IGV4Y2VwdC52aXNpYmxlXHJcbiAgfSk7XHJcblxyXG4gIHZhciBlbGVtZW50ID0gKDAsIF9jb250ZXh0VG9FbGVtZW50Mi5kZWZhdWx0KSh7XHJcbiAgICBsYWJlbDogJ2lzL2ZvY3VzYWJsZScsXHJcbiAgICByZXNvbHZlRG9jdW1lbnQ6IHRydWUsXHJcbiAgICBjb250ZXh0OiBjb250ZXh0XHJcbiAgfSk7XHJcblxyXG4gIHZhciBmb2N1c1JlbGV2YW50ID0gX2ZvY3VzUmVsZXZhbnQyLmRlZmF1bHQucnVsZXMoe1xyXG4gICAgY29udGV4dDogZWxlbWVudCxcclxuICAgIGV4Y2VwdDogZXhjZXB0XHJcbiAgfSk7XHJcblxyXG4gIGlmICghZm9jdXNSZWxldmFudCB8fCBpc09ubHlGb2N1c1JlbGV2YW50KGVsZW1lbnQpKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICBpZiAoIWV4Y2VwdC5kaXNhYmxlZCAmJiAoMCwgX2Rpc2FibGVkMi5kZWZhdWx0KShlbGVtZW50KSkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgaWYgKCFleGNlcHQub25seVRhYmJhYmxlICYmIF9pc09ubHlUYWJiYWJsZShlbGVtZW50KSkge1xyXG4gICAgLy8gc29tZSBlbGVtZW50cyBtYXkgYmUga2V5Ym9hcmQgZm9jdXNhYmxlLCBidXQgbm90IHNjcmlwdCBmb2N1c2FibGVcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIC8vIGVsZW1lbnRzIHRoYXQgYXJlIG5vdCByZW5kZXJlZCwgY2Fubm90IGJlIGZvY3VzZWRcclxuICBpZiAoIWV4Y2VwdC52aXNpYmxlKSB7XHJcbiAgICB2YXIgdmlzaWJpbGl0eU9wdGlvbnMgPSB7XHJcbiAgICAgIGNvbnRleHQ6IGVsZW1lbnQsXHJcbiAgICAgIGV4Y2VwdDoge31cclxuICAgIH07XHJcblxyXG4gICAgaWYgKHN1cHBvcnRzLmZvY3VzSW5IaWRkZW5JZnJhbWUpIHtcclxuICAgICAgLy8gV2ViS2l0IGFuZCBCbGluayBjYW4gZm9jdXMgY29udGVudCBpbiBoaWRkZW4gPGlmcmFtZT4gYW5kIDxvYmplY3Q+XHJcbiAgICAgIHZpc2liaWxpdHlPcHRpb25zLmV4Y2VwdC5icm93c2luZ0NvbnRleHQgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChzdXBwb3J0cy5mb2N1c09iamVjdFN2Z0hpZGRlbikge1xyXG4gICAgICAvLyBCbGluayBhbGxvd3MgZm9jdXNpbmcgdGhlIG9iamVjdCBlbGVtZW50LCBldmVuIGlmIGl0IGhhcyB2aXNpYmlsaXR5OiBoaWRkZW47XHJcbiAgICAgIC8vIEBicm93c2VyLWlzc3VlIEJsaW5rIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD01ODYxOTFcclxuICAgICAgdmFyIF9ub2RlTmFtZTIgPSBlbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgIGlmIChfbm9kZU5hbWUyID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIHZpc2liaWxpdHlPcHRpb25zLmV4Y2VwdC5jc3NWaXNpYmlsaXR5ID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmICghX3Zpc2libGUyLmRlZmF1bHQucnVsZXModmlzaWJpbGl0eU9wdGlvbnMpKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHZhciBmcmFtZUVsZW1lbnQgPSAoMCwgX2dldEZyYW1lRWxlbWVudDIuZGVmYXVsdCkoZWxlbWVudCk7XHJcbiAgaWYgKGZyYW1lRWxlbWVudCkge1xyXG4gICAgdmFyIF9ub2RlTmFtZSA9IGZyYW1lRWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgaWYgKF9ub2RlTmFtZSA9PT0gJ29iamVjdCcgJiYgIXN1cHBvcnRzLmZvY3VzSW5aZXJvRGltZW5zaW9uT2JqZWN0KSB7XHJcbiAgICAgIGlmICghZnJhbWVFbGVtZW50Lm9mZnNldFdpZHRoIHx8ICFmcmFtZUVsZW1lbnQub2Zmc2V0SGVpZ2h0KSB7XHJcbiAgICAgICAgLy8gV2ViS2l0IGNhbiBub3QgZm9jdXMgY29udGVudCBpbiA8b2JqZWN0PiBpZiBpdCBkb2Vzbid0IGhhdmUgZGltZW5zaW9uc1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgdmFyIG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xyXG4gIGlmIChub2RlTmFtZSA9PT0gJ3N2ZycgJiYgc3VwcG9ydHMuZm9jdXNTdmdJbklmcmFtZSAmJiAhZnJhbWVFbGVtZW50ICYmIGVsZW1lbnQuZ2V0QXR0cmlidXRlKCd0YWJpbmRleCcpID09PSBudWxsKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdHJ1ZTtcclxufVxyXG5cclxuLy8gYmluZCBleGNlcHRpb25zIHRvIGFuIGl0ZXJhdG9yIGNhbGxiYWNrXHJcbmlzRm9jdXNhYmxlUnVsZXMuZXhjZXB0ID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciBleGNlcHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xyXG5cclxuICB2YXIgaXNGb2N1c2FibGUgPSBmdW5jdGlvbiBpc0ZvY3VzYWJsZShjb250ZXh0KSB7XHJcbiAgICByZXR1cm4gaXNGb2N1c2FibGVSdWxlcyh7XHJcbiAgICAgIGNvbnRleHQ6IGNvbnRleHQsXHJcbiAgICAgIGV4Y2VwdDogZXhjZXB0XHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICBpc0ZvY3VzYWJsZS5ydWxlcyA9IGlzRm9jdXNhYmxlUnVsZXM7XHJcbiAgcmV0dXJuIGlzRm9jdXNhYmxlO1xyXG59O1xyXG5cclxuLy8gcHJvdmlkZSBpc0ZvY3VzUmVsZXZhbnQoY29udGV4dCkgYXMgZGVmYXVsdCBpdGVyYXRvciBjYWxsYmFja1xyXG52YXIgaXNGb2N1c2FibGUgPSBpc0ZvY3VzYWJsZVJ1bGVzLmV4Y2VwdCh7fSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IGlzRm9jdXNhYmxlO1xyXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9jdXNhYmxlLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLmlzVXNlck1vZGlmeVdyaXRhYmxlID0gaXNVc2VyTW9kaWZ5V3JpdGFibGU7XHJcbmV4cG9ydHMuaGFzQ3NzT3ZlcmZsb3dTY3JvbGwgPSBoYXNDc3NPdmVyZmxvd1Njcm9sbDtcclxuZXhwb3J0cy5oYXNDc3NEaXNwbGF5RmxleCA9IGhhc0Nzc0Rpc3BsYXlGbGV4O1xyXG5leHBvcnRzLmlzU2Nyb2xsYWJsZUNvbnRhaW5lciA9IGlzU2Nyb2xsYWJsZUNvbnRhaW5lcjtcclxuXHJcbi8vIHRoaXMgaXMgYSBzaGFyZWQgdXRpbGl0eSBmaWxlIGZvciBmb2N1cy1yZWxldmFudC5qcyBhbmQgdGFiYmFibGUuanNcclxuLy8gc2VwYXJhdGUgdGVzdGluZyBvZiB0aGlzIGZpbGUncyBmdW5jdGlvbnMgaXMgbm90IG5lY2Vzc2FyeSxcclxuLy8gYXMgdGhleSdyZSBpbXBsaWNpdGx5IHRlc3RlZCBieSB3YXkgb2YgdGhlIGNvbnN1bWVyc1xyXG5cclxuZnVuY3Rpb24gaXNVc2VyTW9kaWZ5V3JpdGFibGUoc3R5bGUpIHtcclxuICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvMTk5OS9XRC1jc3MzLXVzZXJpbnQtMTk5OTA5MTYjdXNlci1tb2RpZnlcclxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vbWVkaWFsaXplL2FsbHkuanMvaXNzdWVzLzE3XHJcbiAgdmFyIHVzZXJNb2RpZnkgPSBzdHlsZS53ZWJraXRVc2VyTW9kaWZ5IHx8ICcnO1xyXG4gIHJldHVybiBCb29sZWFuKHVzZXJNb2RpZnkgJiYgdXNlck1vZGlmeS5pbmRleE9mKCd3cml0ZScpICE9PSAtMSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGhhc0Nzc092ZXJmbG93U2Nyb2xsKHN0eWxlKSB7XHJcbiAgcmV0dXJuIFtzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCdvdmVyZmxvdycpLCBzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCdvdmVyZmxvdy14JyksIHN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ292ZXJmbG93LXknKV0uc29tZShmdW5jdGlvbiAob3ZlcmZsb3cpIHtcclxuICAgIHJldHVybiBvdmVyZmxvdyA9PT0gJ2F1dG8nIHx8IG92ZXJmbG93ID09PSAnc2Nyb2xsJztcclxuICB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gaGFzQ3NzRGlzcGxheUZsZXgoc3R5bGUpIHtcclxuICByZXR1cm4gc3R5bGUuZGlzcGxheS5pbmRleE9mKCdmbGV4JykgPiAtMTtcclxufVxyXG5cclxuZnVuY3Rpb24gaXNTY3JvbGxhYmxlQ29udGFpbmVyKGVsZW1lbnQsIG5vZGVOYW1lLCBwYXJlbnROb2RlTmFtZSwgcGFyZW50U3R5bGUpIHtcclxuICBpZiAobm9kZU5hbWUgIT09ICdkaXYnICYmIG5vZGVOYW1lICE9PSAnc3BhbicpIHtcclxuICAgIC8vIEludGVybmV0IEV4cGxvcmVyIGFkdmFuY2VzIHNjcm9sbGFibGUgY29udGFpbmVycyBhbmQgYm9kaWVzIHRvIGZvY3VzYWJsZVxyXG4gICAgLy8gb25seSBpZiB0aGUgc2Nyb2xsYWJsZSBjb250YWluZXIgaXMgPGRpdj4gb3IgPHNwYW4+IC0gdGhpcyBkb2VzICpub3QqXHJcbiAgICAvLyBoYXBwZW4gZm9yIDxzZWN0aW9uPiwgPGFydGljbGU+LCDigKZcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIGlmIChwYXJlbnROb2RlTmFtZSAmJiBwYXJlbnROb2RlTmFtZSAhPT0gJ2RpdicgJiYgcGFyZW50Tm9kZU5hbWUgIT09ICdzcGFuJyAmJiAhaGFzQ3NzT3ZlcmZsb3dTY3JvbGwocGFyZW50U3R5bGUpKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gZWxlbWVudC5vZmZzZXRIZWlnaHQgPCBlbGVtZW50LnNjcm9sbEhlaWdodCB8fCBlbGVtZW50Lm9mZnNldFdpZHRoIDwgZWxlbWVudC5zY3JvbGxXaWR0aDtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pcy51dGlsLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcclxuICBpZiAoIXN1cHBvcnRzKSB7XHJcbiAgICBzdXBwb3J0cyA9ICgwLCBfc3VwcG9ydHMzLmRlZmF1bHQpKCk7XHJcblxyXG4gICAgaWYgKHN1cHBvcnRzLmZvY3VzRmllbGRzZXREaXNhYmxlZCkge1xyXG4gICAgICBkZWxldGUgZGlzYWJsZWRFbGVtZW50cy5maWVsZHNldDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoc3VwcG9ydHMuZm9jdXNGb3JtRGlzYWJsZWQpIHtcclxuICAgICAgZGVsZXRlIGRpc2FibGVkRWxlbWVudHMuZm9ybTtcclxuICAgIH1cclxuXHJcbiAgICBkaXNhYmxlZEVsZW1lbnRzUGF0dGVybiA9IG5ldyBSZWdFeHAoJ14oJyArIE9iamVjdC5rZXlzKGRpc2FibGVkRWxlbWVudHMpLmpvaW4oJ3wnKSArICcpJCcpO1xyXG4gIH1cclxuXHJcbiAgdmFyIGVsZW1lbnQgPSAoMCwgX2NvbnRleHRUb0VsZW1lbnQyLmRlZmF1bHQpKHtcclxuICAgIGxhYmVsOiAnaXMvbmF0aXZlLWRpc2FibGVkLXN1cHBvcnRlZCcsXHJcbiAgICBjb250ZXh0OiBjb250ZXh0XHJcbiAgfSk7XHJcblxyXG4gIHZhciBub2RlTmFtZSA9IGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcclxuICByZXR1cm4gQm9vbGVhbihkaXNhYmxlZEVsZW1lbnRzUGF0dGVybi50ZXN0KG5vZGVOYW1lKSk7XHJcbn07XHJcblxyXG52YXIgX2NvbnRleHRUb0VsZW1lbnQgPSByZXF1aXJlKCcuLi91dGlsL2NvbnRleHQtdG8tZWxlbWVudCcpO1xyXG5cclxudmFyIF9jb250ZXh0VG9FbGVtZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvbnRleHRUb0VsZW1lbnQpO1xyXG5cclxudmFyIF9zdXBwb3J0czIgPSByZXF1aXJlKCcuLi9zdXBwb3J0cy9zdXBwb3J0cycpO1xyXG5cclxudmFyIF9zdXBwb3J0czMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zdXBwb3J0czIpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbi8vIERldGVybWluZSBpZiBhbiBlbGVtZW50IHN1cHBvcnRzIHRoZSBkaXNhYmxlZCBhdHRyaWJ1dGVcclxuXHJcbnZhciBzdXBwb3J0cyA9IHZvaWQgMDtcclxuXHJcbi8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9kaXNhYmxlZC1lbGVtZW50cy5odG1sI2NvbmNlcHQtZWxlbWVudC1kaXNhYmxlZFxyXG52YXIgZGlzYWJsZWRFbGVtZW50c1BhdHRlcm4gPSB2b2lkIDA7XHJcbnZhciBkaXNhYmxlZEVsZW1lbnRzID0ge1xyXG4gIGlucHV0OiB0cnVlLFxyXG4gIHNlbGVjdDogdHJ1ZSxcclxuICB0ZXh0YXJlYTogdHJ1ZSxcclxuICBidXR0b246IHRydWUsXHJcbiAgZmllbGRzZXQ6IHRydWUsXHJcbiAgZm9ybTogdHJ1ZVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5hdGl2ZS1kaXNhYmxlZC1zdXBwb3J0ZWQuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX3Zpc2libGUgPSByZXF1aXJlKCcuL3Zpc2libGUnKTtcclxuXHJcbnZhciBfdmlzaWJsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF92aXNpYmxlKTtcclxuXHJcbnZhciBfY29udGV4dFRvRWxlbWVudCA9IHJlcXVpcmUoJy4uL3V0aWwvY29udGV4dC10by1lbGVtZW50Jyk7XHJcblxyXG52YXIgX2NvbnRleHRUb0VsZW1lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29udGV4dFRvRWxlbWVudCk7XHJcblxyXG52YXIgX2dldEZyYW1lRWxlbWVudCA9IHJlcXVpcmUoJy4uL3V0aWwvZ2V0LWZyYW1lLWVsZW1lbnQnKTtcclxuXHJcbnZhciBfZ2V0RnJhbWVFbGVtZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldEZyYW1lRWxlbWVudCk7XHJcblxyXG52YXIgX3RhYmluZGV4VmFsdWUgPSByZXF1aXJlKCcuLi91dGlsL3RhYmluZGV4LXZhbHVlJyk7XHJcblxyXG52YXIgX3RhYmluZGV4VmFsdWUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdGFiaW5kZXhWYWx1ZSk7XHJcblxyXG52YXIgX3BsYXRmb3JtID0gcmVxdWlyZSgnLi4vdXRpbC9wbGF0Zm9ybScpO1xyXG5cclxudmFyIF9wbGF0Zm9ybTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wbGF0Zm9ybSk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuZnVuY3Rpb24gaXNPbmx5VGFiYmFibGVSdWxlcygpIHtcclxuICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sXHJcbiAgICAgIGNvbnRleHQgPSBfcmVmLmNvbnRleHQsXHJcbiAgICAgIF9yZWYkZXhjZXB0ID0gX3JlZi5leGNlcHQsXHJcbiAgICAgIGV4Y2VwdCA9IF9yZWYkZXhjZXB0ID09PSB1bmRlZmluZWQgPyB7XHJcbiAgICBvbmx5Rm9jdXNhYmxlQnJvd3NpbmdDb250ZXh0OiBmYWxzZSxcclxuICAgIHZpc2libGU6IGZhbHNlXHJcbiAgfSA6IF9yZWYkZXhjZXB0O1xyXG5cclxuICB2YXIgZWxlbWVudCA9ICgwLCBfY29udGV4dFRvRWxlbWVudDIuZGVmYXVsdCkoe1xyXG4gICAgbGFiZWw6ICdpcy9vbmx5LXRhYmJhYmxlJyxcclxuICAgIHJlc29sdmVEb2N1bWVudDogdHJ1ZSxcclxuICAgIGNvbnRleHQ6IGNvbnRleHRcclxuICB9KTtcclxuXHJcbiAgaWYgKCFleGNlcHQudmlzaWJsZSAmJiAhKDAsIF92aXNpYmxlMi5kZWZhdWx0KShlbGVtZW50KSkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgaWYgKCFleGNlcHQub25seUZvY3VzYWJsZUJyb3dzaW5nQ29udGV4dCAmJiAoX3BsYXRmb3JtMi5kZWZhdWx0LmlzLkdFQ0tPIHx8IF9wbGF0Zm9ybTIuZGVmYXVsdC5pcy5UUklERU5UIHx8IF9wbGF0Zm9ybTIuZGVmYXVsdC5pcy5FREdFKSkge1xyXG4gICAgdmFyIGZyYW1lRWxlbWVudCA9ICgwLCBfZ2V0RnJhbWVFbGVtZW50Mi5kZWZhdWx0KShlbGVtZW50KTtcclxuICAgIGlmIChmcmFtZUVsZW1lbnQpIHtcclxuICAgICAgaWYgKCgwLCBfdGFiaW5kZXhWYWx1ZTIuZGVmYXVsdCkoZnJhbWVFbGVtZW50KSA8IDApIHtcclxuICAgICAgICAvLyBpZnJhbWVbdGFiaW5kZXg9XCItMVwiXSBhbmQgb2JqZWN0W3RhYmluZGV4PVwiLTFcIl0gaW5oZXJpdCB0aGVcclxuICAgICAgICAvLyB0YWJiYWJsZSBkZW1vdGlvbiBvbnRvIGVsZW1lbnRzIG9mIHRoZWlyIGJyb3dzaW5nIGNvbnRleHRzXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICB2YXIgbm9kZU5hbWUgPSBlbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XHJcbiAgdmFyIHRhYmluZGV4ID0gKDAsIF90YWJpbmRleFZhbHVlMi5kZWZhdWx0KShlbGVtZW50KTtcclxuXHJcbiAgaWYgKG5vZGVOYW1lID09PSAnbGFiZWwnICYmIF9wbGF0Zm9ybTIuZGVmYXVsdC5pcy5HRUNLTykge1xyXG4gICAgLy8gRmlyZWZveCBjYW5ub3QgZm9jdXMsIGJ1dCB0YWIgdG86IGxhYmVsW3RhYmluZGV4PTBdXHJcbiAgICByZXR1cm4gdGFiaW5kZXggIT09IG51bGwgJiYgdGFiaW5kZXggPj0gMDtcclxuICB9XHJcblxyXG4gIC8vIFNWRyBFbGVtZW50cyB3ZXJlIGtleWJvYXJkIGZvY3VzYWJsZSBidXQgbm90IHNjcmlwdCBmb2N1c2FibGUgYmVmb3JlIEZpcmVmb3ggNTEuXHJcbiAgLy8gRmlyZWZveCA1MSBhZGRlZCB0aGUgZm9jdXMgbWFuYWdlbWVudCBET00gQVBJICguZm9jdXMgYW5kIC5ibHVyKSB0byBTVkdFbGVtZW50LFxyXG4gIC8vIHNlZSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD03Nzg2NTRcclxuICBpZiAoX3BsYXRmb3JtMi5kZWZhdWx0LmlzLkdFQ0tPICYmIGVsZW1lbnQub3duZXJTVkdFbGVtZW50ICYmICFlbGVtZW50LmZvY3VzKSB7XHJcbiAgICBpZiAobm9kZU5hbWUgPT09ICdhJyAmJiBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgneGxpbms6aHJlZicpKSB7XHJcbiAgICAgIC8vIGFueSBmb2N1c2FibGUgY2hpbGQgb2YgPHN2Zz4gY2Fubm90IGJlIGZvY3VzZWQsIGJ1dCB0YWJiZWQgdG9cclxuICAgICAgaWYgKF9wbGF0Zm9ybTIuZGVmYXVsdC5pcy5HRUNLTykge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gZmFsc2U7XHJcbn1cclxuXHJcbi8vIGJpbmQgZXhjZXB0aW9ucyB0byBhbiBpdGVyYXRvciBjYWxsYmFja1xyXG5pc09ubHlUYWJiYWJsZVJ1bGVzLmV4Y2VwdCA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgZXhjZXB0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcclxuXHJcbiAgdmFyIGlzT25seVRhYmJhYmxlID0gZnVuY3Rpb24gaXNPbmx5VGFiYmFibGUoY29udGV4dCkge1xyXG4gICAgcmV0dXJuIGlzT25seVRhYmJhYmxlUnVsZXMoe1xyXG4gICAgICBjb250ZXh0OiBjb250ZXh0LFxyXG4gICAgICBleGNlcHQ6IGV4Y2VwdFxyXG4gICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgaXNPbmx5VGFiYmFibGUucnVsZXMgPSBpc09ubHlUYWJiYWJsZVJ1bGVzO1xyXG4gIHJldHVybiBpc09ubHlUYWJiYWJsZTtcclxufTtcclxuXHJcbi8vIHByb3ZpZGUgaXNPbmx5VGFiYmFibGUoY29udGV4dCkgYXMgZGVmYXVsdCBpdGVyYXRvciBjYWxsYmFja1xyXG52YXIgaXNPbmx5VGFiYmFibGUgPSBpc09ubHlUYWJiYWJsZVJ1bGVzLmV4Y2VwdCh7fSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IGlzT25seVRhYmJhYmxlO1xyXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b25seS10YWJiYWJsZS5qcy5tYXAiLCIndXNlIHN0cmljdCc7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfdmlzaWJsZSA9IHJlcXVpcmUoJy4vdmlzaWJsZScpO1xyXG5cclxudmFyIF92aXNpYmxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Zpc2libGUpO1xyXG5cclxudmFyIF9jb250ZXh0VG9FbGVtZW50ID0gcmVxdWlyZSgnLi4vdXRpbC9jb250ZXh0LXRvLWVsZW1lbnQnKTtcclxuXHJcbnZhciBfY29udGV4dFRvRWxlbWVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb250ZXh0VG9FbGVtZW50KTtcclxuXHJcbnZhciBfZWxlbWVudE1hdGNoZXMgPSByZXF1aXJlKCcuLi91dGlsL2VsZW1lbnQtbWF0Y2hlcycpO1xyXG5cclxudmFyIF9lbGVtZW50TWF0Y2hlczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9lbGVtZW50TWF0Y2hlcyk7XHJcblxyXG52YXIgX3RhYmluZGV4VmFsdWUgPSByZXF1aXJlKCcuLi91dGlsL3RhYmluZGV4LXZhbHVlJyk7XHJcblxyXG52YXIgX3RhYmluZGV4VmFsdWUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdGFiaW5kZXhWYWx1ZSk7XHJcblxyXG52YXIgX2ZvY3VzUmVsZXZhbnQgPSByZXF1aXJlKCcuL2ZvY3VzLXJlbGV2YW50Jyk7XHJcblxyXG52YXIgX2ZvY3VzUmVsZXZhbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZm9jdXNSZWxldmFudCk7XHJcblxyXG52YXIgX2dldEZyYW1lRWxlbWVudCA9IHJlcXVpcmUoJy4uL3V0aWwvZ2V0LWZyYW1lLWVsZW1lbnQnKTtcclxuXHJcbnZhciBfZ2V0RnJhbWVFbGVtZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldEZyYW1lRWxlbWVudCk7XHJcblxyXG52YXIgX3BsYXRmb3JtID0gcmVxdWlyZSgnLi4vdXRpbC9wbGF0Zm9ybScpO1xyXG5cclxudmFyIF9wbGF0Zm9ybTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wbGF0Zm9ybSk7XHJcblxyXG52YXIgX2ltYWdlTWFwID0gcmVxdWlyZSgnLi4vdXRpbC9pbWFnZS1tYXAnKTtcclxuXHJcbnZhciBfaXMgPSByZXF1aXJlKCcuL2lzLnV0aWwnKTtcclxuXHJcbnZhciBfc3VwcG9ydHMyID0gcmVxdWlyZSgnLi4vc3VwcG9ydHMvc3VwcG9ydHMnKTtcclxuXHJcbnZhciBfc3VwcG9ydHMzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3VwcG9ydHMyKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG4vLyBkZXRlcm1pbmUgaWYgYW4gZWxlbWVudCBjYW4gYmUgZm9jdXNlZCBieSBrZXlib2FyZCAoaS5lLiBpcyBwYXJ0IG9mIHRoZSBkb2N1bWVudCdzIHNlcXVlbnRpYWwgZm9jdXMgbmF2aWdhdGlvbiBvcmRlcilcclxuXHJcbnZhciBzdXBwb3J0cyA9IHZvaWQgMDtcclxuXHJcbi8vIEludGVybmV0IEV4cGxvcmVyIDExIGNvbnNpZGVycyBmaWVsZHNldCwgdGFibGUsIHRkIGZvY3VzYWJsZSwgYnV0IG5vdCB0YWJiYWJsZVxyXG4vLyBJbnRlcm5ldCBFeHBsb3JlciAxMSBjb25zaWRlcnMgYm9keSB0byBoYXZlIFt0YWJpbmRleD0wXSwgYnV0IGRvZXMgbm90IGFsbG93IHRhYmJpbmcgdG8gaXRcclxudmFyIGZvY3VzYWJsZUVsZW1lbnRzUGF0dGVybiA9IC9eKGZpZWxkc2V0fHRhYmxlfHRkfGJvZHkpJC87XHJcblxyXG5mdW5jdGlvbiBpc1RhYmJhYmxlUnVsZXMoKSB7XHJcbiAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxyXG4gICAgICBjb250ZXh0ID0gX3JlZi5jb250ZXh0LFxyXG4gICAgICBfcmVmJGV4Y2VwdCA9IF9yZWYuZXhjZXB0LFxyXG4gICAgICBleGNlcHQgPSBfcmVmJGV4Y2VwdCA9PT0gdW5kZWZpbmVkID8ge1xyXG4gICAgZmxleGJveDogZmFsc2UsXHJcbiAgICBzY3JvbGxhYmxlOiBmYWxzZSxcclxuICAgIHNoYWRvdzogZmFsc2UsXHJcbiAgICB2aXNpYmxlOiBmYWxzZSxcclxuICAgIG9ubHlUYWJiYWJsZTogZmFsc2VcclxuICB9IDogX3JlZiRleGNlcHQ7XHJcblxyXG4gIGlmICghc3VwcG9ydHMpIHtcclxuICAgIHN1cHBvcnRzID0gKDAsIF9zdXBwb3J0czMuZGVmYXVsdCkoKTtcclxuICB9XHJcblxyXG4gIHZhciBlbGVtZW50ID0gKDAsIF9jb250ZXh0VG9FbGVtZW50Mi5kZWZhdWx0KSh7XHJcbiAgICBsYWJlbDogJ2lzL3RhYmJhYmxlJyxcclxuICAgIHJlc29sdmVEb2N1bWVudDogdHJ1ZSxcclxuICAgIGNvbnRleHQ6IGNvbnRleHRcclxuICB9KTtcclxuXHJcbiAgaWYgKF9wbGF0Zm9ybTIuZGVmYXVsdC5pcy5CTElOSyAmJiBfcGxhdGZvcm0yLmRlZmF1bHQuaXMuQU5EUk9JRCAmJiBfcGxhdGZvcm0yLmRlZmF1bHQubWFqb3JWZXJzaW9uID4gNDIpIHtcclxuICAgIC8vIEV4dGVybmFsIGtleWJvYXJkIHN1cHBvcnQgd29ya2VkIGZpbmUgaW4gQ0hyb21lIDQyLCBidXQgc3RvcHBlZCB3b3JraW5nIGluIENocm9tZSA0NS5cclxuICAgIC8vIFRoZSBvbi1zY3JlZW4ga2V5Ym9hcmQgZG9lcyBub3QgcHJvdmlkZSBhIHdheSB0byBmb2N1cyB0aGUgbmV4dCBpbnB1dCBlbGVtZW50IChsaWtlIGlPUyBkb2VzKS5cclxuICAgIC8vIFRoYXQgbGVhdmVzIHVzIHdpdGggbm8gb3B0aW9uIHRvIGFkdmFuY2UgZm9jdXMgYnkga2V5Ym9hcmQsIGVyZ28gbm90aGluZyBpcyB0YWJiYWJsZSAoa2V5Ym9hcmQgZm9jdXNhYmxlKS5cclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIHZhciBmcmFtZUVsZW1lbnQgPSAoMCwgX2dldEZyYW1lRWxlbWVudDIuZGVmYXVsdCkoZWxlbWVudCk7XHJcbiAgaWYgKGZyYW1lRWxlbWVudCkge1xyXG4gICAgaWYgKF9wbGF0Zm9ybTIuZGVmYXVsdC5pcy5XRUJLSVQgJiYgX3BsYXRmb3JtMi5kZWZhdWx0LmlzLklPUykge1xyXG4gICAgICAvLyBpT1Mgb25seSBkb2VzIG5vdCBjb25zaWRlciBhbnl0aGluZyBmcm9tIGFub3RoZXIgYnJvd3NpbmcgY29udGV4dCBrZXlib2FyZCBmb2N1c2FibGVcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGlmcmFtZVt0YWJpbmRleD1cIi0xXCJdIGFuZCBvYmplY3RbdGFiaW5kZXg9XCItMVwiXSBpbmhlcml0IHRoZVxyXG4gICAgLy8gdGFiYmFibGUgZGVtb3Rpb24gb250byBlbGVtZW50cyBvZiB0aGVpciBicm93c2luZyBjb250ZXh0c1xyXG4gICAgaWYgKCgwLCBfdGFiaW5kZXhWYWx1ZTIuZGVmYXVsdCkoZnJhbWVFbGVtZW50KSA8IDApIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghZXhjZXB0LnZpc2libGUgJiYgKF9wbGF0Zm9ybTIuZGVmYXVsdC5pcy5CTElOSyB8fCBfcGxhdGZvcm0yLmRlZmF1bHQuaXMuV0VCS0lUKSAmJiAhKDAsIF92aXNpYmxlMi5kZWZhdWx0KShmcmFtZUVsZW1lbnQpKSB7XHJcbiAgICAgIC8vIEJsaW5rIGFuZCBXZWJLaXQgY29uc2lkZXIgZWxlbWVudHMgaW4gaGlkZGVuIGJyb3dzaW5nIGNvbnRleHRzIGZvY3VzYWJsZSwgYnV0IG5vdCB0YWJiYWJsZVxyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gV2Via2l0IGFuZCBCbGluayBkb24ndCBjb25zaWRlciBhbnl0aGluZyBpbiA8b2JqZWN0PiB0YWJiYWJsZVxyXG4gICAgLy8gQmxpbmsgZml4ZWQgdGhhdCBmaXhlZCBpbiBDaHJvbWUgNTQsIE9wZXJhIDQxXHJcbiAgICB2YXIgZnJhbWVOb2RlTmFtZSA9IGZyYW1lRWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgaWYgKGZyYW1lTm9kZU5hbWUgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgIHZhciBpc0ZpeGVkQmxpbmsgPSBfcGxhdGZvcm0yLmRlZmF1bHQubmFtZSA9PT0gJ0Nocm9tZScgJiYgX3BsYXRmb3JtMi5kZWZhdWx0Lm1ham9yVmVyc2lvbiA+PSA1NCB8fCBfcGxhdGZvcm0yLmRlZmF1bHQubmFtZSA9PT0gJ09wZXJhJyAmJiBfcGxhdGZvcm0yLmRlZmF1bHQubWFqb3JWZXJzaW9uID49IDQxO1xyXG5cclxuICAgICAgaWYgKF9wbGF0Zm9ybTIuZGVmYXVsdC5pcy5XRUJLSVQgfHwgX3BsYXRmb3JtMi5kZWZhdWx0LmlzLkJMSU5LICYmICFpc0ZpeGVkQmxpbmspIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIHZhciBub2RlTmFtZSA9IGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcclxuICB2YXIgX3RhYmluZGV4ID0gKDAsIF90YWJpbmRleFZhbHVlMi5kZWZhdWx0KShlbGVtZW50KTtcclxuICB2YXIgdGFiaW5kZXggPSBfdGFiaW5kZXggPT09IG51bGwgPyBudWxsIDogX3RhYmluZGV4ID49IDA7XHJcblxyXG4gIGlmIChfcGxhdGZvcm0yLmRlZmF1bHQuaXMuRURHRSAmJiBfcGxhdGZvcm0yLmRlZmF1bHQubWFqb3JWZXJzaW9uID49IDE0ICYmIGZyYW1lRWxlbWVudCAmJiBlbGVtZW50Lm93bmVyU1ZHRWxlbWVudCAmJiBfdGFiaW5kZXggPCAwKSB7XHJcbiAgICAvLyBFZGdlIDE0KyBjb25zaWRlcnMgPGEgeGxpbms6aHJlZj1cIuKAplwiIHRhYmluZGV4PVwiLTFcIj4ga2V5Ym9hcmQgZm9jdXNhYmxlXHJcbiAgICAvLyBpZiB0aGUgZWxlbWVudCBpcyBpbiBhIG5lc3RlZCBicm93c2luZyBjb250ZXh0XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIHZhciBoYXNUYWJiYWJsZVRhYmluZGV4T3JOb25lID0gdGFiaW5kZXggIT09IGZhbHNlO1xyXG4gIHZhciBoYXNUYWJiYWJsZVRhYmluZGV4ID0gX3RhYmluZGV4ICE9PSBudWxsICYmIF90YWJpbmRleCA+PSAwO1xyXG5cclxuICAvLyBOT1RFOiBGaXJlZm94IDMxIGNvbnNpZGVycyBbY29udGVudGVkaXRhYmxlXSB0byBoYXZlIFt0YWJpbmRleD0tMV0sIGJ1dCBhbGxvd3MgdGFiYmluZyB0byBpdFxyXG4gIC8vIGZpeGVkIGluIEZpcmVmb3ggNDAgdGhlIGxhdGVzdCAtIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTExODU2NTdcclxuICBpZiAoZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScpKSB7XHJcbiAgICAvLyB0YWJiaW5nIGNhbiBzdGlsbCBiZSBkaXNhYmxlZCBieSBleHBsaWNpdGx5IHByb3ZpZGluZyBbdGFiaW5kZXg9XCItMVwiXVxyXG4gICAgcmV0dXJuIGhhc1RhYmJhYmxlVGFiaW5kZXhPck5vbmU7XHJcbiAgfVxyXG5cclxuICBpZiAoZm9jdXNhYmxlRWxlbWVudHNQYXR0ZXJuLnRlc3Qobm9kZU5hbWUpICYmIHRhYmluZGV4ICE9PSB0cnVlKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICBpZiAoX3BsYXRmb3JtMi5kZWZhdWx0LmlzLldFQktJVCAmJiBfcGxhdGZvcm0yLmRlZmF1bHQuaXMuSU9TKSB7XHJcbiAgICAvLyBpT1Mgb25seSBjb25zaWRlcnMgYSBoYW5kIGZ1bGwgb2YgZWxlbWVudHMgdGFiYmFibGUgKGtleWJvYXJkIGZvY3VzYWJsZSlcclxuICAgIC8vIHRoaXMgaG9sZHMgdHJ1ZSBldmVuIHdpdGggZXh0ZXJuYWwga2V5Ym9hcmRzXHJcbiAgICB2YXIgcG90ZW50aWFsbHlUYWJiYWJsZSA9IG5vZGVOYW1lID09PSAnaW5wdXQnICYmIGVsZW1lbnQudHlwZSA9PT0gJ3RleHQnIHx8IGVsZW1lbnQudHlwZSA9PT0gJ3Bhc3N3b3JkJyB8fCBub2RlTmFtZSA9PT0gJ3NlbGVjdCcgfHwgbm9kZU5hbWUgPT09ICd0ZXh0YXJlYScgfHwgZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScpO1xyXG5cclxuICAgIGlmICghcG90ZW50aWFsbHlUYWJiYWJsZSkge1xyXG4gICAgICB2YXIgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50LCBudWxsKTtcclxuICAgICAgcG90ZW50aWFsbHlUYWJiYWJsZSA9ICgwLCBfaXMuaXNVc2VyTW9kaWZ5V3JpdGFibGUpKHN0eWxlKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXBvdGVudGlhbGx5VGFiYmFibGUpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaWYgKG5vZGVOYW1lID09PSAndXNlJyAmJiBfdGFiaW5kZXggIT09IG51bGwpIHtcclxuICAgIGlmIChfcGxhdGZvcm0yLmRlZmF1bHQuaXMuQkxJTksgfHwgX3BsYXRmb3JtMi5kZWZhdWx0LmlzLldFQktJVCAmJiBfcGxhdGZvcm0yLmRlZmF1bHQubWFqb3JWZXJzaW9uID09PSA5KSB7XHJcbiAgICAgIC8vIEluIENocm9tZSBhbmQgU2FmYXJpIDkgdGhlIDx1c2U+IGVsZW1lbnQgaXMga2V5Ym9hcmQgZm9jdXNhYmxlIGV2ZW4gZm9yIHRhYmluZGV4PVwiLTFcIlxyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlmICgoMCwgX2VsZW1lbnRNYXRjaGVzMi5kZWZhdWx0KShlbGVtZW50LCAnc3ZnIGEnKSAmJiBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgneGxpbms6aHJlZicpKSB7XHJcbiAgICBpZiAoaGFzVGFiYmFibGVUYWJpbmRleE9yTm9uZSkge1xyXG4gICAgICAvLyBpbiBUcmlkZW50IGFuZCBHZWNrbyBTVkdFbGVtZW50IGRvZXMgbm90IGhhbmRsZSB0aGUgdGFiSW5kZXggcHJvcGVydHkgcHJvcGVybHlcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGVsZW1lbnQuZm9jdXMgJiYgIXN1cHBvcnRzLmZvY3VzU3ZnTmVnYXRpdmVUYWJpbmRleEF0dHJpYnV0ZSkge1xyXG4gICAgICAvLyBGaXJlZm94IDUxIGFuZCA1MiB0cmVhdCBhbnkgbmF0aXZlbHkgdGFiYmFibGUgU1ZHIGVsZW1lbnQgd2l0aFxyXG4gICAgICAvLyB0YWJpbmRleD1cIi0xXCIgYXMgdGFiYmFibGUgYW5kIGV2ZXJ5dGhpbmcgZWxzZSBhcyBpbmVydFxyXG4gICAgICAvLyBzZWUgaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTMwMjM0MFxyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlmIChub2RlTmFtZSA9PT0gJ3N2ZycgJiYgc3VwcG9ydHMuZm9jdXNTdmdJbklmcmFtZSAmJiBoYXNUYWJiYWJsZVRhYmluZGV4T3JOb25lKSB7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIGlmIChfcGxhdGZvcm0yLmRlZmF1bHQuaXMuVFJJREVOVCB8fCBfcGxhdGZvcm0yLmRlZmF1bHQuaXMuRURHRSkge1xyXG4gICAgaWYgKG5vZGVOYW1lID09PSAnc3ZnJykge1xyXG4gICAgICBpZiAoc3VwcG9ydHMuZm9jdXNTdmcpIHtcclxuICAgICAgICAvLyBvbGRlciBJbnRlcm5ldCBFeHBsb3JlcnMgY29uc2lkZXIgPHN2Zz4ga2V5Ym9hcmQgZm9jdXNhYmxlXHJcbiAgICAgICAgLy8gdW5sZXNzIHRoZXkgaGF2ZSBmb2NzYWJsZT1cImZhbHNlXCIsIGJ1dCB0aGVuIHRoZXkgd291bGRuJ3RcclxuICAgICAgICAvLyBiZSBmb2N1c2FibGUgYW5kIHRodXMgbm90IGV2ZW4gcmVhY2ggdGhpcyBmaWx0ZXJcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gZWxlbWVudHMgdGhhdCBoYXZlIFtmb2N1c2FibGVdIGFyZSBhdXRvbWF0aWNhbGx5IGtleWJvYXJkIGZvY3VzYWJsZSByZWdhcmRsZXNzIG9mIHRoZSBhdHRyaWJ1dGUncyB2YWx1ZVxyXG4gICAgICByZXR1cm4gZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2ZvY3VzYWJsZScpIHx8IGhhc1RhYmJhYmxlVGFiaW5kZXg7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGVsZW1lbnQub3duZXJTVkdFbGVtZW50KSB7XHJcbiAgICAgIGlmIChzdXBwb3J0cy5mb2N1c1N2Z1RhYmluZGV4QXR0cmlidXRlICYmIGhhc1RhYmJhYmxlVGFiaW5kZXgpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gZWxlbWVudHMgdGhhdCBoYXZlIFtmb2N1c2FibGVdIGFyZSBhdXRvbWF0aWNhbGx5IGtleWJvYXJkIGZvY3VzYWJsZSByZWdhcmRsZXNzIG9mIHRoZSBhdHRyaWJ1dGUncyB2YWx1ZVxyXG4gICAgICByZXR1cm4gZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2ZvY3VzYWJsZScpO1xyXG4gICAgfVxyXG4gIH1cclxuICBpZiAoZWxlbWVudC50YWJJbmRleCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICByZXR1cm4gQm9vbGVhbihleGNlcHQub25seVRhYmJhYmxlKTtcclxuICB9XHJcblxyXG4gIGlmIChub2RlTmFtZSA9PT0gJ2F1ZGlvJykge1xyXG4gICAgaWYgKCFlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnY29udHJvbHMnKSkge1xyXG4gICAgICAvLyBJbiBJbnRlcm5ldCBFeHBsb3JlciB0aGUgPGF1ZGlvPiBlbGVtZW50IGlzIGZvY3VzYWJsZSwgYnV0IG5vdCB0YWJiYWJsZSwgYW5kIHRhYkluZGV4IHByb3BlcnR5IGlzIHdyb25nXHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH0gZWxzZSBpZiAoX3BsYXRmb3JtMi5kZWZhdWx0LmlzLkJMSU5LKSB7XHJcbiAgICAgIC8vIEluIENocm9tZSA8YXVkaW8gY29udHJvbHMgdGFiaW5kZXg9XCItMVwiPiByZW1haW5zIGtleWJvYXJkIGZvY3VzYWJsZVxyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlmIChub2RlTmFtZSA9PT0gJ3ZpZGVvJykge1xyXG4gICAgaWYgKCFlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnY29udHJvbHMnKSkge1xyXG4gICAgICBpZiAoX3BsYXRmb3JtMi5kZWZhdWx0LmlzLlRSSURFTlQgfHwgX3BsYXRmb3JtMi5kZWZhdWx0LmlzLkVER0UpIHtcclxuICAgICAgICAvLyBJbiBJbnRlcm5ldCBFeHBsb3JlciBhbmQgRWRnZSB0aGUgPHZpZGVvPiBlbGVtZW50IGlzIGZvY3VzYWJsZSwgYnV0IG5vdCB0YWJiYWJsZSwgYW5kIHRhYkluZGV4IHByb3BlcnR5IGlzIHdyb25nXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKF9wbGF0Zm9ybTIuZGVmYXVsdC5pcy5CTElOSyB8fCBfcGxhdGZvcm0yLmRlZmF1bHQuaXMuR0VDS08pIHtcclxuICAgICAgLy8gSW4gQ2hyb21lIGFuZCBGaXJlZm94IDx2aWRlbyBjb250cm9scyB0YWJpbmRleD1cIi0xXCI+IHJlbWFpbnMga2V5Ym9hcmQgZm9jdXNhYmxlXHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaWYgKG5vZGVOYW1lID09PSAnb2JqZWN0Jykge1xyXG4gICAgaWYgKF9wbGF0Zm9ybTIuZGVmYXVsdC5pcy5CTElOSyB8fCBfcGxhdGZvcm0yLmRlZmF1bHQuaXMuV0VCS0lUKSB7XHJcbiAgICAgIC8vIEluIGFsbCBCbGluayBhbmQgV2ViS2l0IGJhc2VkIGJyb3dzZXJzIDxlbWJlZD4gYW5kIDxvYmplY3Q+IGFyZSBuZXZlciBrZXlib2FyZCBmb2N1c2FibGUsIGV2ZW4gd2l0aCB0YWJpbmRleD1cIjBcIiBzZXRcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaWYgKG5vZGVOYW1lID09PSAnaWZyYW1lJykge1xyXG4gICAgLy8gSW4gSW50ZXJuZXQgRXhwbG9yZXIgYWxsIGlmcmFtZXMgYXJlIG9ubHkgZm9jdXNhYmxlXHJcbiAgICAvLyBJbiBXZWJLaXQsIEJsaW5rIGFuZCBHZWNrbyBpZnJhbWVzIG1heSBiZSB0YWJiYWJsZSBkZXBlbmRpbmcgb24gY29udGVudC5cclxuICAgIC8vIFNpbmNlIHdlIGNhbid0IHJlbGlhYmx5IGludmVzdGlnYXRlIGlmcmFtZSBkb2N1bWVudHMgYmVjYXVzZSBvZiB0aGVcclxuICAgIC8vIFNhbWVPcmlnaW5Qb2xpY3ksIHdlJ3JlIGRlY2xhcmluZyBldmVyeXRoaW5nIG9ubHkgZm9jdXNhYmxlLlxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgaWYgKCFleGNlcHQuc2Nyb2xsYWJsZSAmJiBfcGxhdGZvcm0yLmRlZmF1bHQuaXMuR0VDS08pIHtcclxuICAgIC8vIEZpcmVmb3ggY29uc2lkZXJzIHNjcm9sbGFibGUgY29udGFpbmVycyBrZXlib2FyZCBmb2N1c2FibGUsXHJcbiAgICAvLyBldmVuIHRob3VnaCB0aGVpciB0YWJJbmRleCBwcm9wZXJ0eSBpcyAtMVxyXG4gICAgdmFyIF9zdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQsIG51bGwpO1xyXG4gICAgaWYgKCgwLCBfaXMuaGFzQ3NzT3ZlcmZsb3dTY3JvbGwpKF9zdHlsZSkpIHtcclxuICAgICAgcmV0dXJuIGhhc1RhYmJhYmxlVGFiaW5kZXhPck5vbmU7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBpZiAoX3BsYXRmb3JtMi5kZWZhdWx0LmlzLlRSSURFTlQgfHwgX3BsYXRmb3JtMi5kZWZhdWx0LmlzLkVER0UpIHtcclxuICAgIC8vIElFIGFuZCBFZGdlIGRlZ3JhZGUgPGFyZWE+IHRvIHNjcmlwdCBmb2N1c2FibGUsIGlmIHRoZSBpbWFnZVxyXG4gICAgLy8gdXNpbmcgdGhlIDxtYXA+IGhhcyBiZWVuIGdpdmVuIHRhYmluZGV4PVwiLTFcIlxyXG4gICAgaWYgKG5vZGVOYW1lID09PSAnYXJlYScpIHtcclxuICAgICAgdmFyIGltZyA9ICgwLCBfaW1hZ2VNYXAuZ2V0SW1hZ2VPZkFyZWEpKGVsZW1lbnQpO1xyXG4gICAgICBpZiAoaW1nICYmICgwLCBfdGFiaW5kZXhWYWx1ZTIuZGVmYXVsdCkoaW1nKSA8IDApIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB2YXIgX3N0eWxlMiA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQsIG51bGwpO1xyXG4gICAgaWYgKCgwLCBfaXMuaXNVc2VyTW9kaWZ5V3JpdGFibGUpKF9zdHlsZTIpKSB7XHJcbiAgICAgIC8vIHByZXZlbnQgYmVpbmcgc3dhbGxvd2VkIGJ5IHRoZSBvdmVyemVhbG91cyBpc1Njcm9sbGFibGVDb250YWluZXIoKSBiZWxvd1xyXG4gICAgICByZXR1cm4gZWxlbWVudC50YWJJbmRleCA+PSAwO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghZXhjZXB0LmZsZXhib3ggJiYgKDAsIF9pcy5oYXNDc3NEaXNwbGF5RmxleCkoX3N0eWxlMikpIHtcclxuICAgICAgaWYgKF90YWJpbmRleCAhPT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBoYXNUYWJiYWJsZVRhYmluZGV4O1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gaXNGb2N1c1JlbGV2YW50V2l0aG91dEZsZXhib3goZWxlbWVudCkgJiYgaXNUYWJiYWJsZVdpdGhvdXRGbGV4Ym94KGVsZW1lbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIElFIGNvbnNpZGVycyBzY3JvbGxhYmxlIGNvbnRhaW5lcnMgc2NyaXB0IGZvY3VzYWJsZSBvbmx5LFxyXG4gICAgLy8gZXZlbiB0aG91Z2ggdGhlaXIgdGFiSW5kZXggcHJvcGVydHkgaXMgMFxyXG4gICAgaWYgKCgwLCBfaXMuaXNTY3JvbGxhYmxlQ29udGFpbmVyKShlbGVtZW50LCBub2RlTmFtZSkpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBwYXJlbnQgPSBlbGVtZW50LnBhcmVudEVsZW1lbnQ7XHJcbiAgICBpZiAocGFyZW50KSB7XHJcbiAgICAgIHZhciBwYXJlbnROb2RlTmFtZSA9IHBhcmVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICB2YXIgcGFyZW50U3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShwYXJlbnQsIG51bGwpO1xyXG4gICAgICAvLyBJRSBjb25zaWRlcnMgc2Nyb2xsYWJsZSBib2RpZXMgc2NyaXB0IGZvY3VzYWJsZSBvbmx5LFxyXG4gICAgICBpZiAoKDAsIF9pcy5pc1Njcm9sbGFibGVDb250YWluZXIpKHBhcmVudCwgbm9kZU5hbWUsIHBhcmVudE5vZGVOYW1lLCBwYXJlbnRTdHlsZSkpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIENoaWxkcmVuIG9mIGZvY3VzYWJsZSBlbGVtZW50cyB3aXRoIGRpc3BsYXk6ZmxleCBhcmUgZm9jdXNhYmxlIGluIElFMTAtMTEsXHJcbiAgICAgIC8vIGV2ZW4gdGhvdWdoIHRoZWlyIHRhYkluZGV4IHByb3BlcnR5IHN1Z2dlc3RzIG90aGVyd2lzZVxyXG4gICAgICBpZiAoKDAsIF9pcy5oYXNDc3NEaXNwbGF5RmxleCkocGFyZW50U3R5bGUpKSB7XHJcbiAgICAgICAgLy8gdmFsdWUgb2YgdGFiaW5kZXggdGFrZXMgcHJlY2VkZW5jZVxyXG4gICAgICAgIHJldHVybiBoYXNUYWJiYWJsZVRhYmluZGV4O1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBodHRwczovL3d3dy53My5vcmcvV0FJL1BGL2FyaWEtcHJhY3RpY2VzLyNmb2N1c190YWJpbmRleFxyXG4gIHJldHVybiBlbGVtZW50LnRhYkluZGV4ID49IDA7XHJcbn1cclxuXHJcbi8vIGJpbmQgZXhjZXB0aW9ucyB0byBhbiBpdGVyYXRvciBjYWxsYmFja1xyXG5pc1RhYmJhYmxlUnVsZXMuZXhjZXB0ID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciBleGNlcHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xyXG5cclxuICB2YXIgaXNUYWJiYWJsZSA9IGZ1bmN0aW9uIGlzVGFiYmFibGUoY29udGV4dCkge1xyXG4gICAgcmV0dXJuIGlzVGFiYmFibGVSdWxlcyh7XHJcbiAgICAgIGNvbnRleHQ6IGNvbnRleHQsXHJcbiAgICAgIGV4Y2VwdDogZXhjZXB0XHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICBpc1RhYmJhYmxlLnJ1bGVzID0gaXNUYWJiYWJsZVJ1bGVzO1xyXG4gIHJldHVybiBpc1RhYmJhYmxlO1xyXG59O1xyXG5cclxudmFyIGlzRm9jdXNSZWxldmFudFdpdGhvdXRGbGV4Ym94ID0gX2ZvY3VzUmVsZXZhbnQyLmRlZmF1bHQucnVsZXMuZXhjZXB0KHsgZmxleGJveDogdHJ1ZSB9KTtcclxudmFyIGlzVGFiYmFibGVXaXRob3V0RmxleGJveCA9IGlzVGFiYmFibGVSdWxlcy5leGNlcHQoeyBmbGV4Ym94OiB0cnVlIH0pO1xyXG5cclxuLy8gcHJvdmlkZSBpc1RhYmJhYmxlKGNvbnRleHQpIGFzIGRlZmF1bHQgaXRlcmF0b3IgY2FsbGJhY2tcclxudmFyIGlzVGFiYmFibGUgPSBpc1RhYmJhYmxlUnVsZXMuZXhjZXB0KHt9KTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gaXNUYWJiYWJsZTtcclxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRhYmJhYmxlLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcclxuICBpZiAoIXN1cHBvcnRzKSB7XHJcbiAgICBzdXBwb3J0cyA9ICgwLCBfc3VwcG9ydHMzLmRlZmF1bHQpKCk7XHJcbiAgfVxyXG5cclxuICB2YXIgZWxlbWVudCA9ICgwLCBfY29udGV4dFRvRWxlbWVudDIuZGVmYXVsdCkoe1xyXG4gICAgbGFiZWw6ICdpcy92YWxpZC1hcmVhJyxcclxuICAgIGNvbnRleHQ6IGNvbnRleHRcclxuICB9KTtcclxuXHJcbiAgdmFyIG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xyXG4gIGlmIChub2RlTmFtZSAhPT0gJ2FyZWEnKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICB2YXIgaGFzVGFiaW5kZXggPSBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgndGFiaW5kZXgnKTtcclxuICBpZiAoIXN1cHBvcnRzLmZvY3VzQXJlYVRhYmluZGV4ICYmIGhhc1RhYmluZGV4KSB7XHJcbiAgICAvLyBCbGluayBhbmQgV2ViS2l0IGRvIG5vdCBjb25zaWRlciA8YXJlYSB0YWJpbmRleD1cIi0xXCIgaHJlZj1cIiN2b2lkXCI+IGZvY3VzYWJsZVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgdmFyIGltZyA9ICgwLCBfaW1hZ2VNYXAuZ2V0SW1hZ2VPZkFyZWEpKGVsZW1lbnQpO1xyXG4gIGlmICghaW1nIHx8ICEoMCwgX3Zpc2libGUyLmRlZmF1bHQpKGltZykpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIC8vIEZpcmVmb3ggb25seSBhbGxvd3MgZnVsbHkgbG9hZGVkIGltYWdlcyB0byByZWZlcmVuY2UgaW1hZ2UgbWFwc1xyXG4gIC8vIGh0dHBzOi8vc3RlcmVvY2hyby5tZS9pZGVhcy9kZXRlY3RpbmctYnJva2VuLWltYWdlcy1qc1xyXG4gIGlmICghc3VwcG9ydHMuZm9jdXNCcm9rZW5JbWFnZU1hcCAmJiAoIWltZy5jb21wbGV0ZSB8fCAhaW1nLm5hdHVyYWxIZWlnaHQgfHwgaW1nLm9mZnNldFdpZHRoIDw9IDAgfHwgaW1nLm9mZnNldEhlaWdodCA8PSAwKSkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgLy8gRmlyZWZveCBzdXBwb3J0cy5jYW4gZm9jdXMgYXJlYSBlbGVtZW50cyBldmVuIGlmIHRoZXkgZG9uJ3QgaGF2ZSBhbiBocmVmIGF0dHJpYnV0ZVxyXG4gIGlmICghc3VwcG9ydHMuZm9jdXNBcmVhV2l0aG91dEhyZWYgJiYgIWVsZW1lbnQuaHJlZikge1xyXG4gICAgLy8gSW50ZXJuZXQgZXhwbG9yZXIgc3VwcG9ydHMuY2FuIGZvY3VzIGFyZWEgZWxlbWVudHMgd2l0aG91dCBocmVmIGlmIGVpdGhlclxyXG4gICAgLy8gdGhlIGFyZWEgZWxlbWVudCBvciB0aGUgaW1hZ2UgZWxlbWVudCBoYXMgYSB0YWJpbmRleCBhdHRyaWJ1dGVcclxuICAgIHJldHVybiBzdXBwb3J0cy5mb2N1c0FyZWFUYWJpbmRleCAmJiBoYXNUYWJpbmRleCB8fCBzdXBwb3J0cy5mb2N1c0FyZWFJbWdUYWJpbmRleCAmJiBpbWcuaGFzQXR0cmlidXRlKCd0YWJpbmRleCcpO1xyXG4gIH1cclxuXHJcbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9FbGVtZW50L2ltZyNhdHRyLXVzZW1hcFxyXG4gIHZhciBjaGlsZE9mSW50ZXJhY3RpdmUgPSAoMCwgX3BhcmVudHMyLmRlZmF1bHQpKHsgY29udGV4dDogaW1nIH0pLnNsaWNlKDEpLnNvbWUoZnVuY3Rpb24gKF9lbGVtZW50KSB7XHJcbiAgICB2YXIgbmFtZSA9IF9lbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XHJcbiAgICByZXR1cm4gbmFtZSA9PT0gJ2J1dHRvbicgfHwgbmFtZSA9PT0gJ2EnO1xyXG4gIH0pO1xyXG5cclxuICBpZiAoY2hpbGRPZkludGVyYWN0aXZlKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdHJ1ZTtcclxufTtcclxuXHJcbnZhciBfY29udGV4dFRvRWxlbWVudCA9IHJlcXVpcmUoJy4uL3V0aWwvY29udGV4dC10by1lbGVtZW50Jyk7XHJcblxyXG52YXIgX2NvbnRleHRUb0VsZW1lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29udGV4dFRvRWxlbWVudCk7XHJcblxyXG52YXIgX3Zpc2libGUgPSByZXF1aXJlKCcuL3Zpc2libGUnKTtcclxuXHJcbnZhciBfdmlzaWJsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF92aXNpYmxlKTtcclxuXHJcbnZhciBfcGFyZW50cyA9IHJlcXVpcmUoJy4uL2dldC9wYXJlbnRzJyk7XHJcblxyXG52YXIgX3BhcmVudHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcGFyZW50cyk7XHJcblxyXG52YXIgX2ltYWdlTWFwID0gcmVxdWlyZSgnLi4vdXRpbC9pbWFnZS1tYXAnKTtcclxuXHJcbnZhciBfc3VwcG9ydHMyID0gcmVxdWlyZSgnLi4vc3VwcG9ydHMvc3VwcG9ydHMnKTtcclxuXHJcbnZhciBfc3VwcG9ydHMzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3VwcG9ydHMyKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG52YXIgc3VwcG9ydHMgPSB2b2lkIDA7XHJcblxyXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0VsZW1lbnQvbWFwXHJcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvRWxlbWVudC9pbWcjYXR0ci11c2VtYXBcclxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9qcXVlcnktdWkvYmxvYi9tYXN0ZXIvdWkvY29yZS5qcyNMODgtTDEwN1xyXG5cclxuLy8gZGV0ZXJtaW5lIGlmIGFuIDxhcmVhPiBlbGVtZW50IGlzIGJlaW5nIHByb3Blcmx5IHVzZWQgYnkgYW5kIDxpbWc+IHZpYSBhIDxtYXA+XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmFsaWQtYXJlYS5qcy5tYXAiLCIndXNlIHN0cmljdCc7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XHJcbiAgaWYgKCFzdXBwb3J0cykge1xyXG4gICAgc3VwcG9ydHMgPSAoMCwgX3N1cHBvcnRzMy5kZWZhdWx0KSgpO1xyXG4gIH1cclxuXHJcbiAgdmFyIHZhbGlkSW50ZWdlclBhdHRlcm4gPSBzdXBwb3J0cy5mb2N1c1RhYmluZGV4VHJhaWxpbmdDaGFyYWN0ZXJzID8gdmFsaWRJbnRlZ2VyUGF0dGVybldpdGhUcmFpbGluZyA6IHZhbGlkSW50ZWdlclBhdHRlcm5Ob1RyYWlsaW5nO1xyXG5cclxuICB2YXIgZWxlbWVudCA9ICgwLCBfY29udGV4dFRvRWxlbWVudDIuZGVmYXVsdCkoe1xyXG4gICAgbGFiZWw6ICdpcy92YWxpZC10YWJpbmRleCcsXHJcbiAgICByZXNvbHZlRG9jdW1lbnQ6IHRydWUsXHJcbiAgICBjb250ZXh0OiBjb250ZXh0XHJcbiAgfSk7XHJcblxyXG4gIC8vIEVkZ2UgMTQgaGFzIGEgY2FwaXRhbGl6YXRpb24gcHJvYmxlbSBvbiBTVkcgZWxlbWVudHMsXHJcbiAgLy8gc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1pY3Jvc29mdC5jb20vZW4tdXMvbWljcm9zb2Z0LWVkZ2UvcGxhdGZvcm0vaXNzdWVzLzkyODIwNTgvXHJcbiAgdmFyIGhhc1RhYmluZGV4ID0gZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ3RhYmluZGV4Jyk7XHJcbiAgdmFyIGhhc1RhYkluZGV4ID0gZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ3RhYkluZGV4Jyk7XHJcblxyXG4gIGlmICghaGFzVGFiaW5kZXggJiYgIWhhc1RhYkluZGV4KSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICAvLyBvbGRlciBGaXJlZm94IGFuZCBJbnRlcm5ldCBFeHBsb3JlciBkb24ndCBzdXBwb3J0IHRhYmluZGV4IG9uIFNWRyBlbGVtZW50c1xyXG4gIHZhciBpc1N2Z0VsZW1lbnQgPSBlbGVtZW50Lm93bmVyU1ZHRWxlbWVudCB8fCBlbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdzdmcnO1xyXG4gIGlmIChpc1N2Z0VsZW1lbnQgJiYgIXN1cHBvcnRzLmZvY3VzU3ZnVGFiaW5kZXhBdHRyaWJ1dGUpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIC8vIEBicm93c2VyLWlzc3VlIEdlY2tvIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTExMjgwNTRcclxuICBpZiAoc3VwcG9ydHMuZm9jdXNJbnZhbGlkVGFiaW5kZXgpIHtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuXHJcbiAgLy8gYW4gZWxlbWVudCBtYXRjaGVzIHRoZSB0YWJpbmRleCBzZWxlY3RvciBldmVuIGlmIGl0cyB2YWx1ZSBpcyBpbnZhbGlkXHJcbiAgdmFyIHRhYmluZGV4ID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoaGFzVGFiaW5kZXggPyAndGFiaW5kZXgnIDogJ3RhYkluZGV4Jyk7XHJcbiAgLy8gSUUxMSBwYXJzZXMgdGFiaW5kZXg9XCJcIiBhcyB0aGUgdmFsdWUgXCItMzI3NjhcIlxyXG4gIC8vIEBicm93c2VyLWlzc3VlIFRyaWRlbnQgaHR0cHM6Ly9jb25uZWN0Lm1pY3Jvc29mdC5jb20vSUUvZmVlZGJhY2svZGV0YWlscy8xMDcyOTY1XHJcbiAgaWYgKHRhYmluZGV4ID09PSAnLTMyNzY4Jykge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIEJvb2xlYW4odGFiaW5kZXggJiYgdmFsaWRJbnRlZ2VyUGF0dGVybi50ZXN0KHRhYmluZGV4KSk7XHJcbn07XHJcblxyXG52YXIgX2NvbnRleHRUb0VsZW1lbnQgPSByZXF1aXJlKCcuLi91dGlsL2NvbnRleHQtdG8tZWxlbWVudCcpO1xyXG5cclxudmFyIF9jb250ZXh0VG9FbGVtZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvbnRleHRUb0VsZW1lbnQpO1xyXG5cclxudmFyIF9zdXBwb3J0czIgPSByZXF1aXJlKCcuLi9zdXBwb3J0cy9zdXBwb3J0cycpO1xyXG5cclxudmFyIF9zdXBwb3J0czMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zdXBwb3J0czIpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbi8vIGRldGVybWluZSBpZiBhbiBlbGVtZW50J3MgdGFiaW5kZXggYXR0cmlidXRlIGhhcyBhIHZhbGlkIHZhbHVlXHJcblxyXG52YXIgc3VwcG9ydHMgPSB2b2lkIDA7XHJcblxyXG4vLyBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvaW5mcmFzdHJ1Y3R1cmUuaHRtbCNydWxlcy1mb3ItcGFyc2luZy1pbnRlZ2Vyc1xyXG4vLyBOT1RFOiBhbGwgYnJvd3NlcnMgYWdyZWUgdG8gYWxsb3cgdHJhaWxpbmcgc3BhY2VzIGFzIHdlbGxcclxudmFyIHZhbGlkSW50ZWdlclBhdHRlcm5Ob1RyYWlsaW5nID0gL15cXHMqKC18XFwrKT9bMC05XStcXHMqJC87XHJcbnZhciB2YWxpZEludGVnZXJQYXR0ZXJuV2l0aFRyYWlsaW5nID0gL15cXHMqKC18XFwrKT9bMC05XSsuKiQvO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZhbGlkLXRhYmluZGV4LmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9hcnJheUZpbmRJbmRleCA9IHJlcXVpcmUoJy4uL3V0aWwvYXJyYXktZmluZC1pbmRleCcpO1xyXG5cclxudmFyIF9hcnJheUZpbmRJbmRleDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hcnJheUZpbmRJbmRleCk7XHJcblxyXG52YXIgX3BhcmVudHMgPSByZXF1aXJlKCcuLi9nZXQvcGFyZW50cycpO1xyXG5cclxudmFyIF9wYXJlbnRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BhcmVudHMpO1xyXG5cclxudmFyIF9jb250ZXh0VG9FbGVtZW50ID0gcmVxdWlyZSgnLi4vdXRpbC9jb250ZXh0LXRvLWVsZW1lbnQnKTtcclxuXHJcbnZhciBfY29udGV4dFRvRWxlbWVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb250ZXh0VG9FbGVtZW50KTtcclxuXHJcbnZhciBfZ2V0RnJhbWVFbGVtZW50ID0gcmVxdWlyZSgnLi4vdXRpbC9nZXQtZnJhbWUtZWxlbWVudCcpO1xyXG5cclxudmFyIF9nZXRGcmFtZUVsZW1lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0RnJhbWVFbGVtZW50KTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG4vLyBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvcmVuZGVyaW5nLmh0bWwjYmVpbmctcmVuZGVyZWRcclxuLy8gPGFyZWE+IGlzIG5vdCByZW5kZXJlZCwgYnV0IHdlICpjb25zaWRlciogaXQgdmlzaWJsZSB0byBzaW1wbGZpeSB0aGlzIGZ1bmN0aW9uJ3MgdXNhZ2VcclxuXHJcbi8vIGRldGVybWluZSBpZiBhbiBlbGVtZW50IGlzIHJlbmRlcmVkXHJcbi8vIE5PVEU6IHRoYXQgZG9lcyBub3QgbWVhbiBhbiBlbGVtZW50IGlzIHZpc2libGUgaW4gdGhlIHZpZXdwb3J0LCBzZWUgdXRpbC92aXNpYmxlLWFyZWFcclxuXHJcbnZhciBub3RSZW5kZXJlZEVsZW1lbnRzUGF0dGVybiA9IC9eKGFyZWEpJC87XHJcblxyXG5mdW5jdGlvbiBjb21wdXRlZFN0eWxlKGVsZW1lbnQsIHByb3BlcnR5KSB7XHJcbiAgcmV0dXJuIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQsIG51bGwpLmdldFByb3BlcnR5VmFsdWUocHJvcGVydHkpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBub3REaXNwbGF5ZWQoX3BhdGgpIHtcclxuICByZXR1cm4gX3BhdGguc29tZShmdW5jdGlvbiAoZWxlbWVudCkge1xyXG4gICAgLy8gZGlzcGxheTpub25lIGlzIG5vdCB2aXNpYmxlIChvcHRpbWl6ZWQgYXdheSBhdCBsYXlvdXQpXHJcbiAgICByZXR1cm4gY29tcHV0ZWRTdHlsZShlbGVtZW50LCAnZGlzcGxheScpID09PSAnbm9uZSc7XHJcbiAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG5vdFZpc2libGUoX3BhdGgpIHtcclxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS11aS9ibG9iL21hc3Rlci91aS9jb3JlLmpzI0wxMDktTDExNFxyXG4gIC8vIE5PVEU6IGEgbmVzdGVkIGVsZW1lbnQgY2FuIHJldmVyc2UgdmlzaWJpbGl0eTpoaWRkZW58Y29sbGFwc2UgYnkgZXhwbGljaXRseSBzZXR0aW5nIHZpc2liaWxpdHk6dmlzaWJsZVxyXG4gIC8vIE5PVEU6IHZpc2liaWxpdHkgY2FuIGJlIFtcIlwiLCBcInZpc2libGVcIiwgXCJoaWRkZW5cIiwgXCJjb2xsYXBzZVwiXVxyXG4gIHZhciBoaWRkZW4gPSAoMCwgX2FycmF5RmluZEluZGV4Mi5kZWZhdWx0KShfcGF0aCwgZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuICAgIHZhciB2aXNpYmlsaXR5ID0gY29tcHV0ZWRTdHlsZShlbGVtZW50LCAndmlzaWJpbGl0eScpO1xyXG4gICAgcmV0dXJuIHZpc2liaWxpdHkgPT09ICdoaWRkZW4nIHx8IHZpc2liaWxpdHkgPT09ICdjb2xsYXBzZSc7XHJcbiAgfSk7XHJcblxyXG4gIGlmIChoaWRkZW4gPT09IC0xKSB7XHJcbiAgICAvLyB0aGVyZSBpcyBubyBoaWRkZW4gZWxlbWVudFxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgdmFyIHZpc2libGUgPSAoMCwgX2FycmF5RmluZEluZGV4Mi5kZWZhdWx0KShfcGF0aCwgZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuICAgIHJldHVybiBjb21wdXRlZFN0eWxlKGVsZW1lbnQsICd2aXNpYmlsaXR5JykgPT09ICd2aXNpYmxlJztcclxuICB9KTtcclxuXHJcbiAgaWYgKHZpc2libGUgPT09IC0xKSB7XHJcbiAgICAvLyB0aGVyZSBpcyBubyB2aXNpYmxlIGVsZW1lbnQgKGJ1dCBhIGhpZGRlbiBlbGVtZW50KVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICBpZiAoaGlkZGVuIDwgdmlzaWJsZSkge1xyXG4gICAgLy8gdGhlcmUgaXMgYSBoaWRkZW4gZWxlbWVudCBhbmQgaXQncyBjbG9zZXIgdGhhbiB0aGUgZmlyc3QgdmlzaWJsZSBlbGVtZW50XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIC8vIHRoZXJlIG1heSBiZSBhIGhpZGRlbiBlbGVtZW50LCBidXQgdGhlIGNsb3Nlc3QgZWxlbWVudCBpcyB2aXNpYmxlXHJcbiAgcmV0dXJuIGZhbHNlO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjb2xsYXBzZWRQYXJlbnQoX3BhdGgpIHtcclxuICB2YXIgb2Zmc2V0ID0gMTtcclxuICBpZiAoX3BhdGhbMF0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3N1bW1hcnknKSB7XHJcbiAgICBvZmZzZXQgPSAyO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIF9wYXRoLnNsaWNlKG9mZnNldCkuc29tZShmdW5jdGlvbiAoZWxlbWVudCkge1xyXG4gICAgLy8gXCJjb250ZW50IGNoaWxkcmVuXCIgb2YgYSBjbG9zZWQgZGV0YWlscyBlbGVtZW50IGFyZSBub3QgdmlzaWJsZVxyXG4gICAgcmV0dXJuIGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2RldGFpbHMnICYmIGVsZW1lbnQub3BlbiA9PT0gZmFsc2U7XHJcbiAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzVmlzaWJsZVJ1bGVzKCkge1xyXG4gIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcclxuICAgICAgY29udGV4dCA9IF9yZWYuY29udGV4dCxcclxuICAgICAgX3JlZiRleGNlcHQgPSBfcmVmLmV4Y2VwdCxcclxuICAgICAgZXhjZXB0ID0gX3JlZiRleGNlcHQgPT09IHVuZGVmaW5lZCA/IHtcclxuICAgIG5vdFJlbmRlcmVkOiBmYWxzZSxcclxuICAgIGNzc0Rpc3BsYXk6IGZhbHNlLFxyXG4gICAgY3NzVmlzaWJpbGl0eTogZmFsc2UsXHJcbiAgICBkZXRhaWxzRWxlbWVudDogZmFsc2UsXHJcbiAgICBicm93c2luZ0NvbnRleHQ6IGZhbHNlXHJcbiAgfSA6IF9yZWYkZXhjZXB0O1xyXG5cclxuICB2YXIgZWxlbWVudCA9ICgwLCBfY29udGV4dFRvRWxlbWVudDIuZGVmYXVsdCkoe1xyXG4gICAgbGFiZWw6ICdpcy92aXNpYmxlJyxcclxuICAgIHJlc29sdmVEb2N1bWVudDogdHJ1ZSxcclxuICAgIGNvbnRleHQ6IGNvbnRleHRcclxuICB9KTtcclxuXHJcbiAgdmFyIG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xyXG4gIGlmICghZXhjZXB0Lm5vdFJlbmRlcmVkICYmIG5vdFJlbmRlcmVkRWxlbWVudHNQYXR0ZXJuLnRlc3Qobm9kZU5hbWUpKSB7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIHZhciBfcGF0aCA9ICgwLCBfcGFyZW50czIuZGVmYXVsdCkoeyBjb250ZXh0OiBlbGVtZW50IH0pO1xyXG5cclxuICAvLyBpbiBJbnRlcm5ldCBFeHBsb3JlciA8YXVkaW8+IGhhcyBhIGRlZmF1bHQgZGlzcGxheTogbm9uZSwgd2hlcmUgb3RoZXJzIGhhdmUgZGlzcGxheTogaW5saW5lXHJcbiAgLy8gYnV0IElFIGFsbG93cyBmb2N1c2luZyA8YXVkaW8gc3R5bGU9XCJkaXNwbGF5Om5vbmVcIj4sIGJ1dCBub3QgPGRpdiBkaXNwbGF5Om5vbmU+PGF1ZGlvPlxyXG4gIC8vIHRoaXMgaXMgaXJyZWxldmFudCB0byBvdGhlciBicm93c2VycywgYXMgdGhlIGNvbnRyb2xzIGF0dHJpYnV0ZSBpcyByZXF1aXJlZCB0byBtYWtlIDxhdWRpbz4gZm9jdXNhYmxlXHJcbiAgdmFyIGlzQXVkaW9XaXRob3V0Q29udHJvbHMgPSBub2RlTmFtZSA9PT0gJ2F1ZGlvJyAmJiAhZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2NvbnRyb2xzJyk7XHJcbiAgaWYgKCFleGNlcHQuY3NzRGlzcGxheSAmJiBub3REaXNwbGF5ZWQoaXNBdWRpb1dpdGhvdXRDb250cm9scyA/IF9wYXRoLnNsaWNlKDEpIDogX3BhdGgpKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICBpZiAoIWV4Y2VwdC5jc3NWaXNpYmlsaXR5ICYmIG5vdFZpc2libGUoX3BhdGgpKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICBpZiAoIWV4Y2VwdC5kZXRhaWxzRWxlbWVudCAmJiBjb2xsYXBzZWRQYXJlbnQoX3BhdGgpKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICBpZiAoIWV4Y2VwdC5icm93c2luZ0NvbnRleHQpIHtcclxuICAgIC8vIGVsZW1lbnRzIHdpdGhpbiBhIGJyb3dzaW5nIGNvbnRleHQgYXJlIGFmZmVjdGVkIGJ5IHRoZVxyXG4gICAgLy8gYnJvd3NpbmcgY29udGV4dCBob3N0IGVsZW1lbnQncyB2aXNpYmlsaXR5IGFuZCB0YWJpbmRleFxyXG4gICAgdmFyIGZyYW1lRWxlbWVudCA9ICgwLCBfZ2V0RnJhbWVFbGVtZW50Mi5kZWZhdWx0KShlbGVtZW50KTtcclxuICAgIHZhciBfaXNWaXNpYmxlID0gaXNWaXNpYmxlUnVsZXMuZXhjZXB0KGV4Y2VwdCk7XHJcbiAgICBpZiAoZnJhbWVFbGVtZW50ICYmICFfaXNWaXNpYmxlKGZyYW1lRWxlbWVudCkpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRydWU7XHJcbn1cclxuXHJcbi8vIGJpbmQgZXhjZXB0aW9ucyB0byBhbiBpdGVyYXRvciBjYWxsYmFja1xyXG5pc1Zpc2libGVSdWxlcy5leGNlcHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIGV4Y2VwdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XHJcblxyXG4gIHZhciBpc1Zpc2libGUgPSBmdW5jdGlvbiBpc1Zpc2libGUoY29udGV4dCkge1xyXG4gICAgcmV0dXJuIGlzVmlzaWJsZVJ1bGVzKHtcclxuICAgICAgY29udGV4dDogY29udGV4dCxcclxuICAgICAgZXhjZXB0OiBleGNlcHRcclxuICAgIH0pO1xyXG4gIH07XHJcblxyXG4gIGlzVmlzaWJsZS5ydWxlcyA9IGlzVmlzaWJsZVJ1bGVzO1xyXG4gIHJldHVybiBpc1Zpc2libGU7XHJcbn07XHJcblxyXG4vLyBwcm92aWRlIGlzVmlzaWJsZShjb250ZXh0KSBhcyBkZWZhdWx0IGl0ZXJhdG9yIGNhbGxiYWNrXHJcbnZhciBpc1Zpc2libGUgPSBpc1Zpc2libGVSdWxlcy5leGNlcHQoe30pO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBpc1Zpc2libGU7XHJcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD12aXNpYmxlLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcclxuLypcclxuICBVdGlsaXR5IHRvIG1ha2UgYSBzdWItdHJlZSBvZiB0aGUgRE9NIGluZXJ0LiBJbmVydCBtZWFucyB0aGUgZWxlbWVudHMgY2Fubm90IGJlIGludGVyYWN0ZWRcclxuICB3aXRoIGFuZCB0aGV5IGNhbm5vdCBiZSBmb2N1c2VkIHZpYSBzY3JpcHQsIHBvaW50ZXIgb3Iga2V5Ym9hcmQuXHJcblxyXG4gIGluZXJ0IGF0dHJpYnV0ZSB3YXMgW3JlbW92ZWRdKGh0dHBzOi8vaHRtbDUub3JnL3IvODUzNikgW3R3ZWV0IGJ5IHN0ZXZlXShodHRwczovL3R3aXR0ZXIuY29tL3N0ZXZlZmF1bGtuZXIvc3RhdHVzLzQ0MzA3NTkwMDIwMTI1OTAwOClcclxuICBidXQgZGVmaW5pdGlvbiBvZiBbaW5lcnQgc3VidHJlZXNdKGh0dHBzOi8vd3d3LnczLm9yZy9odG1sL3dnL2RyYWZ0cy9odG1sL21hc3Rlci9lZGl0aW5nLmh0bWwjaW5lcnQtc3VidHJlZXMpIHJlbWFpbnMuXHJcblxyXG4gIFtpbXBsZW1lbnRhdGlvbiBpZGVhIGJ5IFZhc2lsaXNdKGh0dHBzOi8vY29kZXBlbi5pby92YXNpbGlzdmcvcGVuL3Njb3dJKVxyXG4gIFtpbmVydCBhdHRyaWJ1dGUgcG9seWZpbGwgYnkgR29vZ2xlQ2hyb21lXShodHRwczovL2dpdGh1Yi5jb20vR29vZ2xlQ2hyb21lL2luZXJ0LXBvbHlmaWxsKVxyXG5cclxuICBbR2Vja28gQnVnOiBJbmVydCBBdHRyaWJ1dGVdKGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTkyMTUwNClcclxuICBbQ2hyb21pdW0gQnVnOiBJbmVydCBBdHRyaWJ1dGVdKGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0yNjk4NDYpXHJcbiAgW0Nocm9taXVtIEJ1ZzogSW5lcnQgU3VidHJlZV0oaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTI0MTY5OSlcclxuICBbV2ViS2l0IEJ1ZzogSW5lcnQgU3VidHJlZV0oaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTExMDk1MilcclxuKi9cclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgX3JlZjIgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxyXG4gICAgICBjb250ZXh0ID0gX3JlZjIuY29udGV4dCxcclxuICAgICAgZmlsdGVyID0gX3JlZjIuZmlsdGVyO1xyXG5cclxuICB2YXIgc2VydmljZSA9IG5ldyBJbmVydFN1YnRyZWUoeyBjb250ZXh0OiBjb250ZXh0LCBmaWx0ZXI6IGZpbHRlciB9KTtcclxuICByZXR1cm4geyBkaXNlbmdhZ2U6IHNlcnZpY2UuZGlzZW5nYWdlIH07XHJcbn07XHJcblxyXG52YXIgX25vZGVBcnJheSA9IHJlcXVpcmUoJy4uL3V0aWwvbm9kZS1hcnJheScpO1xyXG5cclxudmFyIF9ub2RlQXJyYXkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbm9kZUFycmF5KTtcclxuXHJcbnZhciBfZm9jdXNhYmxlID0gcmVxdWlyZSgnLi4vcXVlcnkvZm9jdXNhYmxlJyk7XHJcblxyXG52YXIgX2ZvY3VzYWJsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mb2N1c2FibGUpO1xyXG5cclxudmFyIF9kaXNhYmxlZCA9IHJlcXVpcmUoJy4uL2VsZW1lbnQvZGlzYWJsZWQnKTtcclxuXHJcbnZhciBfZGlzYWJsZWQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGlzYWJsZWQpO1xyXG5cclxudmFyIF9zaGFkb3dNdXRhdGlvbnMgPSByZXF1aXJlKCcuLi9vYnNlcnZlL3NoYWRvdy1tdXRhdGlvbnMnKTtcclxuXHJcbnZhciBfc2hhZG93TXV0YXRpb25zMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NoYWRvd011dGF0aW9ucyk7XHJcblxyXG52YXIgX2NvbXBhcmVQb3NpdGlvbiA9IHJlcXVpcmUoJy4uL3V0aWwvY29tcGFyZS1wb3NpdGlvbicpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XHJcblxyXG5mdW5jdGlvbiBtYWtlRWxlbWVudEluZXJ0KGVsZW1lbnQpIHtcclxuICByZXR1cm4gKDAsIF9kaXNhYmxlZDIuZGVmYXVsdCkoZWxlbWVudCwgdHJ1ZSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHVuZG9FbGVtZW50SW5lcnQoZWxlbWVudCkge1xyXG4gIHJldHVybiAoMCwgX2Rpc2FibGVkMi5kZWZhdWx0KShlbGVtZW50LCBmYWxzZSk7XHJcbn1cclxuXHJcbnZhciBvYnNlcnZlckNvbmZpZyA9IHtcclxuICBhdHRyaWJ1dGVzOiB0cnVlLFxyXG4gIGNoaWxkTGlzdDogdHJ1ZSxcclxuICBzdWJ0cmVlOiB0cnVlLFxyXG4gIGF0dHJpYnV0ZUZpbHRlcjogWyd0YWJpbmRleCcsICdkaXNhYmxlZCcsICdkYXRhLWFsbHktZGlzYWJsZWQnXVxyXG59O1xyXG5cclxudmFyIEluZXJ0U3VidHJlZSA9IGZ1bmN0aW9uICgpIHtcclxuICBmdW5jdGlvbiBJbmVydFN1YnRyZWUoKSB7XHJcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG5cclxuICAgIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcclxuICAgICAgICBjb250ZXh0ID0gX3JlZi5jb250ZXh0LFxyXG4gICAgICAgIGZpbHRlciA9IF9yZWYuZmlsdGVyO1xyXG5cclxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbmVydFN1YnRyZWUpO1xyXG5cclxuICAgIHRoaXMuX2NvbnRleHQgPSAoMCwgX25vZGVBcnJheTIuZGVmYXVsdCkoY29udGV4dCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpWzBdO1xyXG4gICAgdGhpcy5fZmlsdGVyID0gKDAsIF9ub2RlQXJyYXkyLmRlZmF1bHQpKGZpbHRlcik7XHJcbiAgICB0aGlzLl9pbmVydEVsZW1lbnRDYWNoZSA9IFtdO1xyXG5cclxuICAgIHRoaXMuZGlzZW5nYWdlID0gdGhpcy5kaXNlbmdhZ2UuYmluZCh0aGlzKTtcclxuICAgIHRoaXMuaGFuZGxlTXV0YXRpb24gPSB0aGlzLmhhbmRsZU11dGF0aW9uLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzLnJlbmRlckluZXJ0ID0gdGhpcy5yZW5kZXJJbmVydC5iaW5kKHRoaXMpO1xyXG4gICAgdGhpcy5maWx0ZXJFbGVtZW50cyA9IHRoaXMuZmlsdGVyRWxlbWVudHMuYmluZCh0aGlzKTtcclxuICAgIHRoaXMuZmlsdGVyUGFyZW50RWxlbWVudHMgPSB0aGlzLmZpbHRlclBhcmVudEVsZW1lbnRzLmJpbmQodGhpcyk7XHJcblxyXG4gICAgdmFyIGZvY3VzYWJsZSA9ICgwLCBfZm9jdXNhYmxlMi5kZWZhdWx0KSh7XHJcbiAgICAgIGNvbnRleHQ6IHRoaXMuX2NvbnRleHQsXHJcbiAgICAgIGluY2x1ZGVDb250ZXh0OiB0cnVlLFxyXG4gICAgICBzdHJhdGVneTogJ2FsbCdcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMucmVuZGVySW5lcnQoZm9jdXNhYmxlKTtcclxuXHJcbiAgICB0aGlzLnNoYWRvd09ic2VydmVyID0gKDAsIF9zaGFkb3dNdXRhdGlvbnMyLmRlZmF1bHQpKHtcclxuICAgICAgY29udGV4dDogdGhpcy5fY29udGV4dCxcclxuICAgICAgY29uZmlnOiBvYnNlcnZlckNvbmZpZyxcclxuICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uIGNhbGxiYWNrKG11dGF0aW9ucykge1xyXG4gICAgICAgIHJldHVybiBtdXRhdGlvbnMuZm9yRWFjaChfdGhpcy5oYW5kbGVNdXRhdGlvbik7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgX2NyZWF0ZUNsYXNzKEluZXJ0U3VidHJlZSwgW3tcclxuICAgIGtleTogJ2Rpc2VuZ2FnZScsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzZW5nYWdlKCkge1xyXG4gICAgICBpZiAoIXRoaXMuX2NvbnRleHQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHVuZG9FbGVtZW50SW5lcnQodGhpcy5fY29udGV4dCk7XHJcbiAgICAgIHRoaXMuX2luZXJ0RWxlbWVudENhY2hlLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuICAgICAgICByZXR1cm4gdW5kb0VsZW1lbnRJbmVydChlbGVtZW50KTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICB0aGlzLl9pbmVydEVsZW1lbnRDYWNoZSA9IG51bGw7XHJcbiAgICAgIHRoaXMuX2ZpbHRlciA9IG51bGw7XHJcbiAgICAgIHRoaXMuX2NvbnRleHQgPSBudWxsO1xyXG4gICAgICB0aGlzLnNoYWRvd09ic2VydmVyICYmIHRoaXMuc2hhZG93T2JzZXJ2ZXIuZGlzZW5nYWdlKCk7XHJcbiAgICAgIHRoaXMuc2hhZG93T2JzZXJ2ZXIgPSBudWxsO1xyXG4gICAgfVxyXG4gIH0sIHtcclxuICAgIGtleTogJ2xpc3RRdWVyeUZvY3VzYWJsZScsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gbGlzdFF1ZXJ5Rm9jdXNhYmxlKGxpc3QpIHtcclxuICAgICAgcmV0dXJuIGxpc3RcclxuICAgICAgLy8gZmluZCBhbGwgZm9jdXNhYmxlIGVsZW1lbnRzIHdpdGhpbiB0aGUgZ2l2ZW4gY29udGV4dHNcclxuICAgICAgLm1hcChmdW5jdGlvbiAoZWxlbWVudCkge1xyXG4gICAgICAgIHJldHVybiAoMCwgX2ZvY3VzYWJsZTIuZGVmYXVsdCkoeyBjb250ZXh0OiBlbGVtZW50LCBpbmNsdWRlQ29udGV4dDogdHJ1ZSwgc3RyYXRlZ3k6ICdhbGwnIH0pO1xyXG4gICAgICB9KVxyXG4gICAgICAvLyBmbGF0dGVuIG5lc3RlZCBhcnJheXNcclxuICAgICAgLnJlZHVjZShmdW5jdGlvbiAocHJldmlvdXMsIGN1cnJlbnQpIHtcclxuICAgICAgICByZXR1cm4gcHJldmlvdXMuY29uY2F0KGN1cnJlbnQpO1xyXG4gICAgICB9LCBbXSk7XHJcbiAgICB9XHJcbiAgfSwge1xyXG4gICAga2V5OiAncmVuZGVySW5lcnQnLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlckluZXJ0KGVsZW1lbnRzKSB7XHJcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xyXG5cclxuICAgICAgdmFyIG1ha2VJbmVydCA9IGZ1bmN0aW9uIG1ha2VJbmVydChlbGVtZW50KSB7XHJcbiAgICAgICAgX3RoaXMyLl9pbmVydEVsZW1lbnRDYWNoZS5wdXNoKGVsZW1lbnQpO1xyXG4gICAgICAgIG1ha2VFbGVtZW50SW5lcnQoZWxlbWVudCk7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICBlbGVtZW50cy5maWx0ZXIodGhpcy5maWx0ZXJFbGVtZW50cykuZmlsdGVyKHRoaXMuZmlsdGVyUGFyZW50RWxlbWVudHMpXHJcbiAgICAgIC8vIGlnbm9yZSBlbGVtZW50cyB0aGF0IGFscmVhZHkgYXJlIGRpc2FibGVkXHJcbiAgICAgIC8vIHNvIHdlIGRvbid0IGVuYWJsZSB0aGVtIG9uIGRpc2VuZ2FnZSgpXHJcbiAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuICAgICAgICByZXR1cm4gISgwLCBfZGlzYWJsZWQyLmRlZmF1bHQpKGVsZW1lbnQpO1xyXG4gICAgICB9KS5mb3JFYWNoKG1ha2VJbmVydCk7XHJcbiAgICB9XHJcbiAgfSwge1xyXG4gICAga2V5OiAnZmlsdGVyRWxlbWVudHMnLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbHRlckVsZW1lbnRzKGVsZW1lbnQpIHtcclxuICAgICAgLy8gaWdub3JlIGVsZW1lbnRzIHdpdGhpbiB0aGUgZXhlbXB0ZWQgc3ViLXRyZWVzXHJcbiAgICAgIHZhciBpc1BhcmVudE9mRWxlbWVudCA9ICgwLCBfY29tcGFyZVBvc2l0aW9uLmdldFBhcmVudENvbXBhcmF0b3IpKHsgZWxlbWVudDogZWxlbWVudCwgaW5jbHVkZVNlbGY6IHRydWUgfSk7XHJcbiAgICAgIHJldHVybiAhdGhpcy5fZmlsdGVyLnNvbWUoaXNQYXJlbnRPZkVsZW1lbnQpO1xyXG4gICAgfVxyXG4gIH0sIHtcclxuICAgIGtleTogJ2ZpbHRlclBhcmVudEVsZW1lbnRzJyxcclxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaWx0ZXJQYXJlbnRFbGVtZW50cyhlbGVtZW50KSB7XHJcbiAgICAgIC8vIGlnbm9yZSBhbmNlc3RvcnMgb2YgdGhlIGV4ZW1wdGVkIHN1Yi10cmVlc1xyXG4gICAgICB2YXIgaXNQYXJlbnRPZkVsZW1lbnQgPSAoMCwgX2NvbXBhcmVQb3NpdGlvbi5nZXRQYXJlbnRDb21wYXJhdG9yKSh7IHBhcmVudDogZWxlbWVudCB9KTtcclxuICAgICAgcmV0dXJuICF0aGlzLl9maWx0ZXIuc29tZShpc1BhcmVudE9mRWxlbWVudCk7XHJcbiAgICB9XHJcbiAgfSwge1xyXG4gICAga2V5OiAnaGFuZGxlTXV0YXRpb24nLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZU11dGF0aW9uKG11dGF0aW9uKSB7XHJcbiAgICAgIGlmIChtdXRhdGlvbi50eXBlID09PSAnY2hpbGRMaXN0Jykge1xyXG4gICAgICAgIHZhciBhZGRlZEVsZW1lbnRzID0gKDAsIF9ub2RlQXJyYXkyLmRlZmF1bHQpKG11dGF0aW9uLmFkZGVkTm9kZXMpLmZpbHRlcihmdW5jdGlvbiAoZWxlbWVudCkge1xyXG4gICAgICAgICAgcmV0dXJuIGVsZW1lbnQubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmICghYWRkZWRFbGVtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBhZGRlZEZvY3VzYWJsZUVsZW1lbnRzID0gdGhpcy5saXN0UXVlcnlGb2N1c2FibGUoYWRkZWRFbGVtZW50cyk7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJJbmVydChhZGRlZEZvY3VzYWJsZUVsZW1lbnRzKTtcclxuICAgICAgfSBlbHNlIGlmIChtdXRhdGlvbi50eXBlID09PSAnYXR0cmlidXRlcycpIHtcclxuICAgICAgICB0aGlzLnJlbmRlckluZXJ0KFttdXRhdGlvbi50YXJnZXRdKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1dKTtcclxuXHJcbiAgcmV0dXJuIEluZXJ0U3VidHJlZTtcclxufSgpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRpc2FibGVkLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcclxuICAgICAgY29udGV4dCA9IF9yZWYuY29udGV4dDtcclxuXHJcbiAgaWYgKCFjb250ZXh0KSB7XHJcbiAgICBjb250ZXh0ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xyXG4gIH1cclxuXHJcbiAgLy8gTWFrZSBzdXJlIHRoZSBzdXBwb3J0cyB0ZXN0cyBhcmUgcnVuIGJlZm9yZSBpbnRlcmNlcHRpbmcgdGhlIFRhYiBrZXksXHJcbiAgLy8gb3IgSUUxMCBhbmQgSUUxMSB3aWxsIGZhaWwgdG8gcHJvY2VzcyB0aGUgZmlyc3QgVGFiIGtleSBldmVudC4gTm90XHJcbiAgLy8gbGltaXRpbmcgdGhpcyB3YXJtLXVwIHRvIElFIGJlY2F1c2UgaXQgbWF5IGJlIGEgcHJvYmxlbSBlbHNld2hlcmUsIHRvby5cclxuICAoMCwgX3RhYnNlcXVlbmNlMi5kZWZhdWx0KSgpO1xyXG5cclxuICByZXR1cm4gKDAsIF9rZXkyLmRlZmF1bHQpKHtcclxuICAgIC8vIFNhZmFyaSBvbiBPU1ggbWF5IHJlcXVpcmUgQUxUK1RBQiB0byByZWFjaCBsaW5rcyxcclxuICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbWVkaWFsaXplL2FsbHkuanMvaXNzdWVzLzE0NlxyXG4gICAgJz9hbHQrP3NoaWZ0K3RhYic6IGZ1bmN0aW9uIGFsdFNoaWZ0VGFiKGV2ZW50KSB7XHJcbiAgICAgIC8vIHdlJ3JlIGNvbXBsZXRlbHkgdGFraW5nIG92ZXIgdGhlIFRhYiBrZXkgaGFuZGxpbmdcclxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuXHJcbiAgICAgIHZhciBzZXF1ZW5jZSA9ICgwLCBfdGFic2VxdWVuY2UyLmRlZmF1bHQpKHtcclxuICAgICAgICBjb250ZXh0OiBjb250ZXh0XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgdmFyIGJhY2t3YXJkID0gZXZlbnQuc2hpZnRLZXk7XHJcbiAgICAgIHZhciBmaXJzdCA9IHNlcXVlbmNlWzBdO1xyXG4gICAgICB2YXIgbGFzdCA9IHNlcXVlbmNlW3NlcXVlbmNlLmxlbmd0aCAtIDFdO1xyXG5cclxuICAgICAgLy8gd3JhcCBhcm91bmQgZmlyc3QgdG8gbGFzdCwgbGFzdCB0byBmaXJzdFxyXG4gICAgICB2YXIgc291cmNlID0gYmFja3dhcmQgPyBmaXJzdCA6IGxhc3Q7XHJcbiAgICAgIHZhciB0YXJnZXQgPSBiYWNrd2FyZCA/IGxhc3QgOiBmaXJzdDtcclxuICAgICAgaWYgKCgwLCBfYWN0aXZlRWxlbWVudDIuZGVmYXVsdCkoc291cmNlKSkge1xyXG4gICAgICAgIHRhcmdldC5mb2N1cygpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gZmluZCBjdXJyZW50IHBvc2l0aW9uIGluIHRhYnNlcXVlbmNlXHJcbiAgICAgIHZhciBjdXJyZW50SW5kZXggPSB2b2lkIDA7XHJcbiAgICAgIHZhciBmb3VuZCA9IHNlcXVlbmNlLnNvbWUoZnVuY3Rpb24gKGVsZW1lbnQsIGluZGV4KSB7XHJcbiAgICAgICAgaWYgKCEoMCwgX2FjdGl2ZUVsZW1lbnQyLmRlZmF1bHQpKGVsZW1lbnQpKSB7XHJcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjdXJyZW50SW5kZXggPSBpbmRleDtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBpZiAoIWZvdW5kKSB7XHJcbiAgICAgICAgLy8gcmVkaXJlY3QgdG8gZmlyc3QgYXMgd2UncmUgbm90IGluIG91ciB0YWJzZXF1ZW5jZVxyXG4gICAgICAgIGZpcnN0LmZvY3VzKCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBzaGlmdCBmb2N1cyB0byBwcmV2aW91cy9uZXh0IGVsZW1lbnQgaW4gdGhlIHNlcXVlbmNlXHJcbiAgICAgIHZhciBvZmZzZXQgPSBiYWNrd2FyZCA/IC0xIDogMTtcclxuICAgICAgc2VxdWVuY2VbY3VycmVudEluZGV4ICsgb2Zmc2V0XS5mb2N1cygpO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59O1xyXG5cclxudmFyIF9hY3RpdmVFbGVtZW50ID0gcmVxdWlyZSgnLi4vaXMvYWN0aXZlLWVsZW1lbnQnKTtcclxuXHJcbnZhciBfYWN0aXZlRWxlbWVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hY3RpdmVFbGVtZW50KTtcclxuXHJcbnZhciBfdGFic2VxdWVuY2UgPSByZXF1aXJlKCcuLi9xdWVyeS90YWJzZXF1ZW5jZScpO1xyXG5cclxudmFyIF90YWJzZXF1ZW5jZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90YWJzZXF1ZW5jZSk7XHJcblxyXG52YXIgX2tleSA9IHJlcXVpcmUoJy4uL3doZW4va2V5Jyk7XHJcblxyXG52YXIgX2tleTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9rZXkpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD10YWItZm9jdXMuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG4vLyBjb2RlcyBtb3N0bHkgY2xvbmVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2tlaXRoYW11cy9qd2VydHkvYmxvYi9tYXN0ZXIvandlcnR5LmpzXHJcbi8vIGRlbGliZXJhdGVseSBub3QgZXhwb3NpbmcgY2hhcmFjdGVycyBsaWtlIDwsLi0jKiBiZWNhdXNlIHRoZXkgdmFyeSAqd2lsZGx5KlxyXG4vLyBhY3Jvc3Mga2V5Ym9hcmQgbGF5b3V0cyBhbmQgbWF5IGNhdXNlIHZhcmlvdXMgcHJvYmxlbXNcclxuLy8gKGUuZy4gXCIqXCIgaXMgXCJTaGlmdCArXCIgb24gYSBHZXJtYW4gTWFjIGtleWJvYXJkKVxyXG4vLyAoZS5nLiBcIkBcIiBpcyBcIkFsdCBMXCIgb24gYSBHZXJtYW4gTWFjIGtleWJvYXJkKVxyXG5cclxudmFyIGtleWNvZGUgPSB7XHJcbiAgLy8gRWxlbWVudCBGb2N1c1xyXG4gIHRhYjogOSxcclxuXHJcbiAgLy8gTmF2aWdhdGlvblxyXG4gIGxlZnQ6IDM3LFxyXG4gIHVwOiAzOCxcclxuICByaWdodDogMzksXHJcbiAgZG93bjogNDAsXHJcbiAgcGFnZVVwOiAzMyxcclxuICAncGFnZS11cCc6IDMzLFxyXG4gIHBhZ2VEb3duOiAzNCxcclxuICAncGFnZS1kb3duJzogMzQsXHJcbiAgZW5kOiAzNSxcclxuICBob21lOiAzNixcclxuXHJcbiAgLy8gQWN0aW9uXHJcbiAgZW50ZXI6IDEzLFxyXG4gIGVzY2FwZTogMjcsXHJcbiAgc3BhY2U6IDMyLFxyXG5cclxuICAvLyBNb2RpZmllclxyXG4gIHNoaWZ0OiAxNixcclxuICBjYXBzTG9jazogMjAsXHJcbiAgJ2NhcHMtbG9jayc6IDIwLFxyXG4gIGN0cmw6IDE3LFxyXG4gIGFsdDogMTgsXHJcbiAgbWV0YTogOTEsXHJcbiAgLy8gaW4gZmlyZWZveDogMjI0XHJcbiAgLy8gb24gbWFjIChjaHJvbWUpOiBtZXRhLWxlZnQ9OTEsIG1ldGEtcmlnaHQ9OTNcclxuICAvLyBvbiB3aW4gKElFMTEpOiBtZXRhLWxlZnQ9OTEsIG1ldGEtcmlnaHQ9OTJcclxuICBwYXVzZTogMTksXHJcblxyXG4gIC8vIENvbnRlbnQgTWFuaXB1bGF0aW9uXHJcbiAgaW5zZXJ0OiA0NSxcclxuICAnZGVsZXRlJzogNDYsXHJcbiAgYmFja3NwYWNlOiA4LFxyXG5cclxuICAvLyB0aGUgc2FtZSBsb2dpY2FsIGtleSBtYXkgYmUgaWRlbnRpZmllZCB0aHJvdWdoIGRpZmZlcmVudCBrZXlDb2Rlc1xyXG4gIF9hbGlhczoge1xyXG4gICAgOTE6IFs5MiwgOTMsIDIyNF1cclxuICB9XHJcbn07XHJcblxyXG4vLyBGdW5jdGlvbiBrZXlzICgxMTIgLSAxMzcpXHJcbi8vIE5PVEU6IG5vdCBldmVyeSBrZXlib2FyZCBrbm93cyBGMTMrXHJcbmZvciAodmFyIG4gPSAxOyBuIDwgMjY7IG4rKykge1xyXG4gIGtleWNvZGVbJ2YnICsgbl0gPSBuICsgMTExO1xyXG59XHJcblxyXG4vLyBOdW1iZXIga2V5cyAoNDgtNTcsIG51bXBhZCA5Ni0xMDUpXHJcbi8vIE5PVEU6IG5vdCBldmVyeSBrZXlib2FyZCBrbm93cyBudW0tMCtcclxuZm9yICh2YXIgX24gPSAwOyBfbiA8IDEwOyBfbisrKSB7XHJcbiAgdmFyIGNvZGUgPSBfbiArIDQ4O1xyXG4gIHZhciBudW1Db2RlID0gX24gKyA5NjtcclxuICBrZXljb2RlW19uXSA9IGNvZGU7XHJcbiAga2V5Y29kZVsnbnVtLScgKyBfbl0gPSBudW1Db2RlO1xyXG4gIGtleWNvZGUuX2FsaWFzW2NvZGVdID0gW251bUNvZGVdO1xyXG59XHJcblxyXG4vLyBMYXRpbiBjaGFyYWN0ZXJzICg2NSAtIDkwKVxyXG5mb3IgKHZhciBfbjIgPSAwOyBfbjIgPCAyNjsgX24yKyspIHtcclxuICB2YXIgX2NvZGUgPSBfbjIgKyA2NTtcclxuICB2YXIgbmFtZSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoX2NvZGUpLnRvTG93ZXJDYXNlKCk7XHJcbiAga2V5Y29kZVtuYW1lXSA9IF9jb2RlO1xyXG59XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBrZXljb2RlO1xyXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9a2V5Y29kZS5qcy5tYXAiLCIndXNlIHN0cmljdCc7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcclxuXHJcbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIF9yZWYyID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcclxuICAgICAgY29udGV4dCA9IF9yZWYyLmNvbnRleHQsXHJcbiAgICAgIGNhbGxiYWNrID0gX3JlZjIuY2FsbGJhY2ssXHJcbiAgICAgIGNvbmZpZyA9IF9yZWYyLmNvbmZpZztcclxuXHJcbiAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb2JzZXJ2ZS9zaGFkb3ctbXV0YXRpb25zIHJlcXVpcmVzIG9wdGlvbnMuY2FsbGJhY2sgdG8gYmUgYSBmdW5jdGlvbicpO1xyXG4gIH1cclxuXHJcbiAgaWYgKCh0eXBlb2YgY29uZmlnID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihjb25maWcpKSAhPT0gJ29iamVjdCcpIHtcclxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29ic2VydmUvc2hhZG93LW11dGF0aW9ucyByZXF1aXJlcyBvcHRpb25zLmNvbmZpZyB0byBiZSBhbiBvYmplY3QnKTtcclxuICB9XHJcblxyXG4gIGlmICghd2luZG93Lk11dGF0aW9uT2JzZXJ2ZXIpIHtcclxuICAgIC8vIG5vdCBzdXBwb3J0aW5nIElFMTAgdmlhIE11dGF0aW9uIEV2ZW50cywgYmVjYXVzZSB0aGV5J3JlIHRvbyBleHBlbnNpdmVcclxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0d1aWRlL0V2ZW50cy9NdXRhdGlvbl9ldmVudHNcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGRpc2VuZ2FnZTogZnVuY3Rpb24gZGlzZW5nYWdlKCkge31cclxuICAgIH07XHJcbiAgfVxyXG5cclxuICB2YXIgZWxlbWVudCA9ICgwLCBfY29udGV4dFRvRWxlbWVudDIuZGVmYXVsdCkoe1xyXG4gICAgbGFiZWw6ICdvYnNlcnZlL3NoYWRvdy1tdXRhdGlvbnMnLFxyXG4gICAgcmVzb2x2ZURvY3VtZW50OiB0cnVlLFxyXG4gICAgZGVmYXVsdFRvRG9jdW1lbnQ6IHRydWUsXHJcbiAgICBjb250ZXh0OiBjb250ZXh0XHJcbiAgfSk7XHJcblxyXG4gIHZhciBzZXJ2aWNlID0gbmV3IFNoYWRvd011dGF0aW9uT2JzZXJ2ZXIoe1xyXG4gICAgY29udGV4dDogZWxlbWVudCxcclxuICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcclxuICAgIGNvbmZpZzogY29uZmlnXHJcbiAgfSk7XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBkaXNlbmdhZ2U6IHNlcnZpY2UuZGlzZW5nYWdlXHJcbiAgfTtcclxufTtcclxuXHJcbnZhciBfbm9kZUFycmF5ID0gcmVxdWlyZSgnLi4vdXRpbC9ub2RlLWFycmF5Jyk7XHJcblxyXG52YXIgX25vZGVBcnJheTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ub2RlQXJyYXkpO1xyXG5cclxudmFyIF9zaGFkb3dIb3N0cyA9IHJlcXVpcmUoJy4uL3F1ZXJ5L3NoYWRvdy1ob3N0cycpO1xyXG5cclxudmFyIF9zaGFkb3dIb3N0czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zaGFkb3dIb3N0cyk7XHJcblxyXG52YXIgX2NvbnRleHRUb0VsZW1lbnQgPSByZXF1aXJlKCcuLi91dGlsL2NvbnRleHQtdG8tZWxlbWVudCcpO1xyXG5cclxudmFyIF9jb250ZXh0VG9FbGVtZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvbnRleHRUb0VsZW1lbnQpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XHJcblxyXG52YXIgc2hhZG93T2JzZXJ2ZXJDb25maWcgPSB7XHJcbiAgY2hpbGRMaXN0OiB0cnVlLFxyXG4gIHN1YnRyZWU6IHRydWVcclxufTtcclxuXHJcbnZhciBTaGFkb3dNdXRhdGlvbk9ic2VydmVyID0gZnVuY3Rpb24gKCkge1xyXG4gIGZ1bmN0aW9uIFNoYWRvd011dGF0aW9uT2JzZXJ2ZXIoKSB7XHJcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG5cclxuICAgIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcclxuICAgICAgICBjb250ZXh0ID0gX3JlZi5jb250ZXh0LFxyXG4gICAgICAgIGNhbGxiYWNrID0gX3JlZi5jYWxsYmFjayxcclxuICAgICAgICBjb25maWcgPSBfcmVmLmNvbmZpZztcclxuXHJcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2hhZG93TXV0YXRpb25PYnNlcnZlcik7XHJcblxyXG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XHJcblxyXG4gICAgdGhpcy5kaXNlbmdhZ2UgPSB0aGlzLmRpc2VuZ2FnZS5iaW5kKHRoaXMpO1xyXG5cclxuICAgIHRoaXMuY2xpZW50T2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihjYWxsYmFjayk7XHJcbiAgICB0aGlzLmhvc3RPYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKGZ1bmN0aW9uIChtdXRhdGlvbnMpIHtcclxuICAgICAgcmV0dXJuIG11dGF0aW9ucy5mb3JFYWNoKF90aGlzLmhhbmRsZUhvc3RNdXRhdGlvbiwgX3RoaXMpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy5vYnNlcnZlQ29udGV4dChjb250ZXh0KTtcclxuICAgIHRoaXMub2JzZXJ2ZVNoYWRvd0hvc3RzKGNvbnRleHQpO1xyXG4gIH1cclxuXHJcbiAgX2NyZWF0ZUNsYXNzKFNoYWRvd011dGF0aW9uT2JzZXJ2ZXIsIFt7XHJcbiAgICBrZXk6ICdkaXNlbmdhZ2UnLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc2VuZ2FnZSgpIHtcclxuICAgICAgdGhpcy5jbGllbnRPYnNlcnZlciAmJiB0aGlzLmNsaWVudE9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcclxuICAgICAgdGhpcy5jbGllbnRPYnNlcnZlciA9IG51bGw7XHJcbiAgICAgIHRoaXMuaG9zdE9ic2VydmVyICYmIHRoaXMuaG9zdE9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcclxuICAgICAgdGhpcy5ob3N0T2JzZXJ2ZXIgPSBudWxsO1xyXG4gICAgfVxyXG4gIH0sIHtcclxuICAgIGtleTogJ29ic2VydmVTaGFkb3dIb3N0cycsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gb2JzZXJ2ZVNoYWRvd0hvc3RzKGNvbnRleHQpIHtcclxuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XHJcblxyXG4gICAgICB2YXIgaG9zdHMgPSAoMCwgX3NoYWRvd0hvc3RzMi5kZWZhdWx0KSh7XHJcbiAgICAgICAgY29udGV4dDogY29udGV4dFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGhvc3RzLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuICAgICAgICByZXR1cm4gX3RoaXMyLm9ic2VydmVDb250ZXh0KGVsZW1lbnQuc2hhZG93Um9vdCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH0sIHtcclxuICAgIGtleTogJ29ic2VydmVDb250ZXh0JyxcclxuICAgIHZhbHVlOiBmdW5jdGlvbiBvYnNlcnZlQ29udGV4dChjb250ZXh0KSB7XHJcbiAgICAgIHRoaXMuY2xpZW50T2JzZXJ2ZXIub2JzZXJ2ZShjb250ZXh0LCB0aGlzLmNvbmZpZyk7XHJcbiAgICAgIHRoaXMuaG9zdE9ic2VydmVyLm9ic2VydmUoY29udGV4dCwgc2hhZG93T2JzZXJ2ZXJDb25maWcpO1xyXG4gICAgfVxyXG4gIH0sIHtcclxuICAgIGtleTogJ2hhbmRsZUhvc3RNdXRhdGlvbicsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlSG9zdE11dGF0aW9uKG11dGF0aW9uKSB7XHJcbiAgICAgIGlmIChtdXRhdGlvbi50eXBlICE9PSAnY2hpbGRMaXN0Jykge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIGFkZGVkRWxlbWVudHMgPSAoMCwgX25vZGVBcnJheTIuZGVmYXVsdCkobXV0YXRpb24uYWRkZWROb2RlcykuZmlsdGVyKGZ1bmN0aW9uIChlbGVtZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFO1xyXG4gICAgICB9KTtcclxuICAgICAgYWRkZWRFbGVtZW50cy5mb3JFYWNoKHRoaXMub2JzZXJ2ZVNoYWRvd0hvc3RzLCB0aGlzKTtcclxuICAgIH1cclxuICB9XSk7XHJcblxyXG4gIHJldHVybiBTaGFkb3dNdXRhdGlvbk9ic2VydmVyO1xyXG59KCk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hhZG93LW11dGF0aW9ucy5qcy5tYXAiLCIndXNlIHN0cmljdCc7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sXHJcbiAgICAgIGNvbnRleHQgPSBfcmVmLmNvbnRleHQsXHJcbiAgICAgIGluY2x1ZGVDb250ZXh0ID0gX3JlZi5pbmNsdWRlQ29udGV4dCxcclxuICAgICAgaW5jbHVkZU9ubHlUYWJiYWJsZSA9IF9yZWYuaW5jbHVkZU9ubHlUYWJiYWJsZSxcclxuICAgICAgX3JlZiRzdHJhdGVneSA9IF9yZWYuc3RyYXRlZ3ksXHJcbiAgICAgIHN0cmF0ZWd5ID0gX3JlZiRzdHJhdGVneSA9PT0gdW5kZWZpbmVkID8gJ3F1aWNrJyA6IF9yZWYkc3RyYXRlZ3k7XHJcblxyXG4gIHZhciBlbGVtZW50ID0gKDAsIF9jb250ZXh0VG9FbGVtZW50Mi5kZWZhdWx0KSh7XHJcbiAgICBsYWJlbDogJ3F1ZXJ5L2ZvY3VzYWJsZScsXHJcbiAgICByZXNvbHZlRG9jdW1lbnQ6IHRydWUsXHJcbiAgICBkZWZhdWx0VG9Eb2N1bWVudDogdHJ1ZSxcclxuICAgIGNvbnRleHQ6IGNvbnRleHRcclxuICB9KTtcclxuXHJcbiAgdmFyIG9wdGlvbnMgPSB7XHJcbiAgICBjb250ZXh0OiBlbGVtZW50LFxyXG4gICAgaW5jbHVkZUNvbnRleHQ6IGluY2x1ZGVDb250ZXh0LFxyXG4gICAgaW5jbHVkZU9ubHlUYWJiYWJsZTogaW5jbHVkZU9ubHlUYWJiYWJsZSxcclxuICAgIHN0cmF0ZWd5OiBzdHJhdGVneVxyXG4gIH07XHJcblxyXG4gIGlmIChzdHJhdGVneSA9PT0gJ3F1aWNrJykge1xyXG4gICAgcmV0dXJuICgwLCBfZm9jdXNhYmxlNC5kZWZhdWx0KShvcHRpb25zKTtcclxuICB9IGVsc2UgaWYgKHN0cmF0ZWd5ID09PSAnc3RyaWN0JyB8fCBzdHJhdGVneSA9PT0gJ2FsbCcpIHtcclxuICAgIHJldHVybiAoMCwgX2ZvY3VzYWJsZTIuZGVmYXVsdCkob3B0aW9ucyk7XHJcbiAgfVxyXG5cclxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdxdWVyeS9mb2N1c2FibGUgcmVxdWlyZXMgb3B0aW9uLnN0cmF0ZWd5IHRvIGJlIG9uZSBvZiBbXCJxdWlja1wiLCBcInN0cmljdFwiLCBcImFsbFwiXScpO1xyXG59O1xyXG5cclxudmFyIF9jb250ZXh0VG9FbGVtZW50ID0gcmVxdWlyZSgnLi4vdXRpbC9jb250ZXh0LXRvLWVsZW1lbnQnKTtcclxuXHJcbnZhciBfY29udGV4dFRvRWxlbWVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb250ZXh0VG9FbGVtZW50KTtcclxuXHJcbnZhciBfZm9jdXNhYmxlID0gcmVxdWlyZSgnLi9mb2N1c2FibGUuc3RyaWN0Jyk7XHJcblxyXG52YXIgX2ZvY3VzYWJsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mb2N1c2FibGUpO1xyXG5cclxudmFyIF9mb2N1c2FibGUzID0gcmVxdWlyZSgnLi9mb2N1c2FibGUucXVpY2snKTtcclxuXHJcbnZhciBfZm9jdXNhYmxlNCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ZvY3VzYWJsZTMpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbi8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lZGl0aW5nLmh0bWwjZm9jdXNhYmxlXHJcbi8vIGh0dHBzOi8vd3d3LnczLm9yZy9XQUkvUEYvYXJpYS1wcmFjdGljZXMvI2tleWJvYXJkXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9jdXNhYmxlLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBxdWVyeUZvY3VzYWJsZVF1aWNrO1xyXG5cclxudmFyIF9mb2N1c2FibGUgPSByZXF1aXJlKCcuLi9zZWxlY3Rvci9mb2N1c2FibGUnKTtcclxuXHJcbnZhciBfZm9jdXNhYmxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ZvY3VzYWJsZSk7XHJcblxyXG52YXIgX2ZvY3VzYWJsZTMgPSByZXF1aXJlKCcuLi9pcy9mb2N1c2FibGUnKTtcclxuXHJcbnZhciBfZm9jdXNhYmxlNCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ZvY3VzYWJsZTMpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbi8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lZGl0aW5nLmh0bWwjZm9jdXNhYmxlXHJcbi8vIGh0dHBzOi8vd3d3LnczLm9yZy9XQUkvUEYvYXJpYS1wcmFjdGljZXMvI2tleWJvYXJkXHJcblxyXG5mdW5jdGlvbiBxdWVyeUZvY3VzYWJsZVF1aWNrKCkge1xyXG4gIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcclxuICAgICAgY29udGV4dCA9IF9yZWYuY29udGV4dCxcclxuICAgICAgaW5jbHVkZUNvbnRleHQgPSBfcmVmLmluY2x1ZGVDb250ZXh0LFxyXG4gICAgICBpbmNsdWRlT25seVRhYmJhYmxlID0gX3JlZi5pbmNsdWRlT25seVRhYmJhYmxlO1xyXG5cclxuICB2YXIgX3NlbGVjdG9yID0gKDAsIF9mb2N1c2FibGUyLmRlZmF1bHQpKCk7XHJcbiAgdmFyIGVsZW1lbnRzID0gY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKF9zZWxlY3Rvcik7XHJcbiAgLy8gdGhlIHNlbGVjdG9yIHBvdGVudGlhbGx5IG1hdGNoZXMgbW9yZSB0aGFuIHJlYWxseSBpcyBmb2N1c2FibGVcclxuXHJcbiAgdmFyIF9pc0ZvY3VzYWJsZSA9IF9mb2N1c2FibGU0LmRlZmF1bHQucnVsZXMuZXhjZXB0KHtcclxuICAgIG9ubHlUYWJiYWJsZTogaW5jbHVkZU9ubHlUYWJiYWJsZVxyXG4gIH0pO1xyXG5cclxuICB2YXIgcmVzdWx0ID0gW10uZmlsdGVyLmNhbGwoZWxlbWVudHMsIF9pc0ZvY3VzYWJsZSk7XHJcblxyXG4gIC8vIGFkZCBjb250ZXh0IGlmIHJlcXVlc3RlZCBhbmQgZm9jdXNhYmxlXHJcbiAgaWYgKGluY2x1ZGVDb250ZXh0ICYmIF9pc0ZvY3VzYWJsZShjb250ZXh0KSkge1xyXG4gICAgcmVzdWx0LnVuc2hpZnQoY29udGV4dCk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb2N1c2FibGUucXVpY2suanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IHF1ZXJ5Rm9jdXNhYmxlU3RyaWN0O1xyXG5cclxudmFyIF9mb2N1c2FibGUgPSByZXF1aXJlKCcuLi9pcy9mb2N1c2FibGUnKTtcclxuXHJcbnZhciBfZm9jdXNhYmxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ZvY3VzYWJsZSk7XHJcblxyXG52YXIgX2ZvY3VzUmVsZXZhbnQgPSByZXF1aXJlKCcuLi9pcy9mb2N1cy1yZWxldmFudCcpO1xyXG5cclxudmFyIF9mb2N1c1JlbGV2YW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ZvY3VzUmVsZXZhbnQpO1xyXG5cclxudmFyIF9nZXREb2N1bWVudCA9IHJlcXVpcmUoJy4uL3V0aWwvZ2V0LWRvY3VtZW50Jyk7XHJcblxyXG52YXIgX2dldERvY3VtZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldERvY3VtZW50KTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVGaWx0ZXIoY29uZGl0aW9uKSB7XHJcbiAgLy8gc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Ob2RlRmlsdGVyXHJcbiAgdmFyIGZpbHRlciA9IGZ1bmN0aW9uIGZpbHRlcihub2RlKSB7XHJcbiAgICBpZiAobm9kZS5zaGFkb3dSb290KSB7XHJcbiAgICAgIC8vIHJldHVybiBTaGFkb3dSb290IGVsZW1lbnRzIHJlZ2FyZGxlc3Mgb2YgdGhlbSBiZWluZyBmb2N1c2FibGUsXHJcbiAgICAgIC8vIHNvIHRoZXkgY2FuIGJlIHdhbGtlZCByZWN1cnNpdmVseSBsYXRlclxyXG4gICAgICByZXR1cm4gTm9kZUZpbHRlci5GSUxURVJfQUNDRVBUO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChjb25kaXRpb24obm9kZSkpIHtcclxuICAgICAgLy8gZmluZHMgZWxlbWVudHMgdGhhdCBjb3VsZCBoYXZlIGJlZW4gZm91bmQgYnkgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgpXHJcbiAgICAgIHJldHVybiBOb2RlRmlsdGVyLkZJTFRFUl9BQ0NFUFQ7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIE5vZGVGaWx0ZXIuRklMVEVSX1NLSVA7XHJcbiAgfTtcclxuICAvLyBJRSByZXF1aXJlcyBhIGZ1bmN0aW9uLCBCcm93c2VycyByZXF1aXJlIHthY2NlcHROb2RlOiBmdW5jdGlvbn1cclxuICAvLyBzZWUgaHR0cDovL3d3dy5iZW5uYWRlbC5jb20vYmxvZy8yNjA3LWZpbmRpbmctaHRtbC1jb21tZW50LW5vZGVzLWluLXRoZS1kb20tdXNpbmctdHJlZXdhbGtlci5odG1cclxuICBmaWx0ZXIuYWNjZXB0Tm9kZSA9IGZpbHRlcjtcclxuICByZXR1cm4gZmlsdGVyO1xyXG59XHJcbi8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lZGl0aW5nLmh0bWwjZm9jdXNhYmxlXHJcbi8vIGh0dHBzOi8vd3d3LnczLm9yZy9XQUkvUEYvYXJpYS1wcmFjdGljZXMvI2tleWJvYXJkXHJcblxyXG52YXIgUG9zc2libHlGb2N1c2FibGVGaWx0ZXIgPSBjcmVhdGVGaWx0ZXIoX2ZvY3VzUmVsZXZhbnQyLmRlZmF1bHQpO1xyXG5cclxuZnVuY3Rpb24gcXVlcnlGb2N1c2FibGVTdHJpY3QoKSB7XHJcbiAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxyXG4gICAgICBjb250ZXh0ID0gX3JlZi5jb250ZXh0LFxyXG4gICAgICBpbmNsdWRlQ29udGV4dCA9IF9yZWYuaW5jbHVkZUNvbnRleHQsXHJcbiAgICAgIGluY2x1ZGVPbmx5VGFiYmFibGUgPSBfcmVmLmluY2x1ZGVPbmx5VGFiYmFibGUsXHJcbiAgICAgIHN0cmF0ZWd5ID0gX3JlZi5zdHJhdGVneTtcclxuXHJcbiAgaWYgKCFjb250ZXh0KSB7XHJcbiAgICBjb250ZXh0ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xyXG4gIH1cclxuXHJcbiAgdmFyIF9pc0ZvY3VzYWJsZSA9IF9mb2N1c2FibGUyLmRlZmF1bHQucnVsZXMuZXhjZXB0KHtcclxuICAgIG9ubHlUYWJiYWJsZTogaW5jbHVkZU9ubHlUYWJiYWJsZVxyXG4gIH0pO1xyXG5cclxuICB2YXIgX2RvY3VtZW50ID0gKDAsIF9nZXREb2N1bWVudDIuZGVmYXVsdCkoY29udGV4dCk7XHJcbiAgLy8gc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Eb2N1bWVudC9jcmVhdGVUcmVlV2Fsa2VyXHJcbiAgdmFyIHdhbGtlciA9IF9kb2N1bWVudC5jcmVhdGVUcmVlV2Fsa2VyKFxyXG4gIC8vIHJvb3QgZWxlbWVudCB0byBzdGFydCBzZWFyY2ggaW5cclxuICBjb250ZXh0LFxyXG4gIC8vIGVsZW1lbnQgdHlwZSBmaWx0ZXJcclxuICBOb2RlRmlsdGVyLlNIT1dfRUxFTUVOVCxcclxuICAvLyBjdXN0b20gTm9kZUZpbHRlciBmaWx0ZXJcclxuICBzdHJhdGVneSA9PT0gJ2FsbCcgPyBQb3NzaWJseUZvY3VzYWJsZUZpbHRlciA6IGNyZWF0ZUZpbHRlcihfaXNGb2N1c2FibGUpLFxyXG4gIC8vIGRlcHJlY2F0ZWQsIGJ1dCBJRSByZXF1aXJlcyBpdFxyXG4gIGZhbHNlKTtcclxuXHJcbiAgdmFyIGxpc3QgPSBbXTtcclxuXHJcbiAgd2hpbGUgKHdhbGtlci5uZXh0Tm9kZSgpKSB7XHJcbiAgICBpZiAod2Fsa2VyLmN1cnJlbnROb2RlLnNoYWRvd1Jvb3QpIHtcclxuICAgICAgaWYgKF9pc0ZvY3VzYWJsZSh3YWxrZXIuY3VycmVudE5vZGUpKSB7XHJcbiAgICAgICAgbGlzdC5wdXNoKHdhbGtlci5jdXJyZW50Tm9kZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGxpc3QgPSBsaXN0LmNvbmNhdChxdWVyeUZvY3VzYWJsZVN0cmljdCh7XHJcbiAgICAgICAgY29udGV4dDogd2Fsa2VyLmN1cnJlbnROb2RlLnNoYWRvd1Jvb3QsXHJcbiAgICAgICAgaW5jbHVkZU9ubHlUYWJiYWJsZTogaW5jbHVkZU9ubHlUYWJiYWJsZSxcclxuICAgICAgICBzdHJhdGVneTogc3RyYXRlZ3lcclxuICAgICAgfSkpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbGlzdC5wdXNoKHdhbGtlci5jdXJyZW50Tm9kZSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBhZGQgY29udGV4dCBpZiByZXF1ZXN0ZWQgYW5kIGZvY3VzYWJsZVxyXG4gIGlmIChpbmNsdWRlQ29udGV4dCkge1xyXG4gICAgaWYgKHN0cmF0ZWd5ID09PSAnYWxsJykge1xyXG4gICAgICBpZiAoKDAsIF9mb2N1c1JlbGV2YW50Mi5kZWZhdWx0KShjb250ZXh0KSkge1xyXG4gICAgICAgIGxpc3QudW5zaGlmdChjb250ZXh0KTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChfaXNGb2N1c2FibGUoY29udGV4dCkpIHtcclxuICAgICAgbGlzdC51bnNoaWZ0KGNvbnRleHQpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGxpc3Q7XHJcbn1cclxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvY3VzYWJsZS5zdHJpY3QuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IHF1ZXJ5U2hhZG93SG9zdHM7XHJcblxyXG52YXIgX2NvbnRleHRUb0VsZW1lbnQgPSByZXF1aXJlKCcuLi91dGlsL2NvbnRleHQtdG8tZWxlbWVudCcpO1xyXG5cclxudmFyIF9jb250ZXh0VG9FbGVtZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvbnRleHRUb0VsZW1lbnQpO1xyXG5cclxudmFyIF9nZXREb2N1bWVudCA9IHJlcXVpcmUoJy4uL3V0aWwvZ2V0LWRvY3VtZW50Jyk7XHJcblxyXG52YXIgX2dldERvY3VtZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldERvY3VtZW50KTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG4vLyBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL05vZGVGaWx0ZXJcclxudmFyIGZpbHRlciA9IGZ1bmN0aW9uIGZpbHRlcihub2RlKSB7XHJcbiAgaWYgKG5vZGUuc2hhZG93Um9vdCkge1xyXG4gICAgcmV0dXJuIE5vZGVGaWx0ZXIuRklMVEVSX0FDQ0VQVDtcclxuICB9XHJcblxyXG4gIHJldHVybiBOb2RlRmlsdGVyLkZJTFRFUl9TS0lQO1xyXG59O1xyXG4vLyBJRSByZXF1aXJlcyBhIGZ1bmN0aW9uLCBCcm93c2VycyByZXF1aXJlIHthY2NlcHROb2RlOiBmdW5jdGlvbn1cclxuLy8gc2VlIGh0dHA6Ly93d3cuYmVubmFkZWwuY29tL2Jsb2cvMjYwNy1maW5kaW5nLWh0bWwtY29tbWVudC1ub2Rlcy1pbi10aGUtZG9tLXVzaW5nLXRyZWV3YWxrZXIuaHRtXHJcbmZpbHRlci5hY2NlcHROb2RlID0gZmlsdGVyO1xyXG5cclxuZnVuY3Rpb24gcXVlcnlTaGFkb3dIb3N0cygpIHtcclxuICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sXHJcbiAgICAgIGNvbnRleHQgPSBfcmVmLmNvbnRleHQ7XHJcblxyXG4gIHZhciBlbGVtZW50ID0gKDAsIF9jb250ZXh0VG9FbGVtZW50Mi5kZWZhdWx0KSh7XHJcbiAgICBsYWJlbDogJ3F1ZXJ5L3NoYWRvdy1ob3N0cycsXHJcbiAgICByZXNvbHZlRG9jdW1lbnQ6IHRydWUsXHJcbiAgICBkZWZhdWx0VG9Eb2N1bWVudDogdHJ1ZSxcclxuICAgIGNvbnRleHQ6IGNvbnRleHRcclxuICB9KTtcclxuXHJcbiAgdmFyIF9kb2N1bWVudCA9ICgwLCBfZ2V0RG9jdW1lbnQyLmRlZmF1bHQpKGNvbnRleHQpO1xyXG4gIC8vIHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRG9jdW1lbnQvY3JlYXRlVHJlZVdhbGtlclxyXG4gIHZhciB3YWxrZXIgPSBfZG9jdW1lbnQuY3JlYXRlVHJlZVdhbGtlcihcclxuICAvLyByb290IGVsZW1lbnQgdG8gc3RhcnQgc2VhcmNoIGluXHJcbiAgZWxlbWVudCxcclxuICAvLyBlbGVtZW50IHR5cGUgZmlsdGVyXHJcbiAgTm9kZUZpbHRlci5TSE9XX0VMRU1FTlQsXHJcbiAgLy8gY3VzdG9tIE5vZGVGaWx0ZXIgZmlsdGVyXHJcbiAgZmlsdGVyLFxyXG4gIC8vIGRlcHJlY2F0ZWQsIGJ1dCBJRSByZXF1aXJlcyBpdFxyXG4gIGZhbHNlKTtcclxuXHJcbiAgdmFyIGxpc3QgPSBbXTtcclxuXHJcbiAgaWYgKGVsZW1lbnQuc2hhZG93Um9vdCkge1xyXG4gICAgLy8gVHJlZVdhbGtlciBkb2VzIG5vdCBydW4gdGhlIGZpbHRlciBvbiB0aGUgY29udGV4dCBlbGVtZW50XHJcbiAgICBsaXN0LnB1c2goZWxlbWVudCk7XHJcbiAgICBsaXN0ID0gbGlzdC5jb25jYXQocXVlcnlTaGFkb3dIb3N0cyh7XHJcbiAgICAgIGNvbnRleHQ6IGVsZW1lbnQuc2hhZG93Um9vdFxyXG4gICAgfSkpO1xyXG4gIH1cclxuXHJcbiAgd2hpbGUgKHdhbGtlci5uZXh0Tm9kZSgpKSB7XHJcbiAgICBsaXN0LnB1c2god2Fsa2VyLmN1cnJlbnROb2RlKTtcclxuICAgIGxpc3QgPSBsaXN0LmNvbmNhdChxdWVyeVNoYWRvd0hvc3RzKHtcclxuICAgICAgY29udGV4dDogd2Fsa2VyLmN1cnJlbnROb2RlLnNoYWRvd1Jvb3RcclxuICAgIH0pKTtcclxuICB9XHJcblxyXG4gIHJldHVybiBsaXN0O1xyXG59XHJcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGFkb3ctaG9zdHMuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxyXG4gICAgICBjb250ZXh0ID0gX3JlZi5jb250ZXh0LFxyXG4gICAgICBpbmNsdWRlQ29udGV4dCA9IF9yZWYuaW5jbHVkZUNvbnRleHQsXHJcbiAgICAgIGluY2x1ZGVPbmx5VGFiYmFibGUgPSBfcmVmLmluY2x1ZGVPbmx5VGFiYmFibGUsXHJcbiAgICAgIHN0cmF0ZWd5ID0gX3JlZi5zdHJhdGVneTtcclxuXHJcbiAgdmFyIF9pc1RhYmJhYmxlID0gX3RhYmJhYmxlMi5kZWZhdWx0LnJ1bGVzLmV4Y2VwdCh7XHJcbiAgICBvbmx5VGFiYmFibGU6IGluY2x1ZGVPbmx5VGFiYmFibGVcclxuICB9KTtcclxuXHJcbiAgcmV0dXJuICgwLCBfZm9jdXNhYmxlMi5kZWZhdWx0KSh7XHJcbiAgICBjb250ZXh0OiBjb250ZXh0LFxyXG4gICAgaW5jbHVkZUNvbnRleHQ6IGluY2x1ZGVDb250ZXh0LFxyXG4gICAgaW5jbHVkZU9ubHlUYWJiYWJsZTogaW5jbHVkZU9ubHlUYWJiYWJsZSxcclxuICAgIHN0cmF0ZWd5OiBzdHJhdGVneVxyXG4gIH0pLmZpbHRlcihfaXNUYWJiYWJsZSk7XHJcbn07XHJcblxyXG52YXIgX2ZvY3VzYWJsZSA9IHJlcXVpcmUoJy4vZm9jdXNhYmxlJyk7XHJcblxyXG52YXIgX2ZvY3VzYWJsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mb2N1c2FibGUpO1xyXG5cclxudmFyIF90YWJiYWJsZSA9IHJlcXVpcmUoJy4uL2lzL3RhYmJhYmxlJyk7XHJcblxyXG52YXIgX3RhYmJhYmxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RhYmJhYmxlKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcclxuLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VkaXRpbmcuaHRtbCNzZXF1ZW50aWFsLWZvY3VzLW5hdmlnYXRpb24tYW5kLXRoZS10YWJpbmRleC1hdHRyaWJ1dGVcclxuLy8gaHR0cHM6Ly93d3cudzMub3JnL1dBSS9QRi9hcmlhLXByYWN0aWNlcy8ja2V5Ym9hcmRcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGFiYmFibGUuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxyXG4gICAgICBjb250ZXh0ID0gX3JlZi5jb250ZXh0LFxyXG4gICAgICBpbmNsdWRlQ29udGV4dCA9IF9yZWYuaW5jbHVkZUNvbnRleHQsXHJcbiAgICAgIGluY2x1ZGVPbmx5VGFiYmFibGUgPSBfcmVmLmluY2x1ZGVPbmx5VGFiYmFibGUsXHJcbiAgICAgIHN0cmF0ZWd5ID0gX3JlZi5zdHJhdGVneTtcclxuXHJcbiAgaWYgKCFzdXBwb3J0cykge1xyXG4gICAgc3VwcG9ydHMgPSAoMCwgX3N1cHBvcnRzMy5kZWZhdWx0KSgpO1xyXG4gIH1cclxuXHJcbiAgdmFyIF9jb250ZXh0ID0gKDAsIF9ub2RlQXJyYXkyLmRlZmF1bHQpKGNvbnRleHQpWzBdIHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcclxuICB2YXIgZWxlbWVudHMgPSAoMCwgX3RhYmJhYmxlMi5kZWZhdWx0KSh7XHJcbiAgICBjb250ZXh0OiBfY29udGV4dCxcclxuICAgIGluY2x1ZGVDb250ZXh0OiBpbmNsdWRlQ29udGV4dCxcclxuICAgIGluY2x1ZGVPbmx5VGFiYmFibGU6IGluY2x1ZGVPbmx5VGFiYmFibGUsXHJcbiAgICBzdHJhdGVneTogc3RyYXRlZ3lcclxuICB9KTtcclxuXHJcbiAgaWYgKGRvY3VtZW50LmJvZHkuY3JlYXRlU2hhZG93Um9vdCAmJiBfcGxhdGZvcm0yLmRlZmF1bHQuaXMuQkxJTkspIHtcclxuICAgIC8vIHNvcnQgdGFiaW5kZXggbG9jYWxpemVkIHRvIHNoYWRvdyBkb21cclxuICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbWVkaWFsaXplL2FsbHkuanMvaXNzdWVzLzZcclxuICAgIGVsZW1lbnRzID0gKDAsIF90YWJzZXF1ZW5jZTQuZGVmYXVsdCkoZWxlbWVudHMsIF9jb250ZXh0LCBzb3J0RWxlbWVudHMpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBlbGVtZW50cyA9IHNvcnRFbGVtZW50cyhlbGVtZW50cywgX2NvbnRleHQpO1xyXG4gIH1cclxuXHJcbiAgaWYgKGluY2x1ZGVDb250ZXh0KSB7XHJcbiAgICAvLyBpZiB3ZSBpbmNsdWRlIHRoZSBjb250ZXh0IGl0c2VsZiwgaXQgaGFzIHRvIGJlIHRoZSBmaXJzdFxyXG4gICAgLy8gZWxlbWVudCBvZiB0aGUgc2VxdWVuY2VcclxuICAgIGVsZW1lbnRzID0gbW92ZUNvbnRleHRUb0JlZ2lubmluZyhlbGVtZW50cywgX2NvbnRleHQpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGVsZW1lbnRzO1xyXG59O1xyXG5cclxudmFyIF90YWJiYWJsZSA9IHJlcXVpcmUoJy4vdGFiYmFibGUnKTtcclxuXHJcbnZhciBfdGFiYmFibGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdGFiYmFibGUpO1xyXG5cclxudmFyIF9ub2RlQXJyYXkgPSByZXF1aXJlKCcuLi91dGlsL25vZGUtYXJyYXknKTtcclxuXHJcbnZhciBfbm9kZUFycmF5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX25vZGVBcnJheSk7XHJcblxyXG52YXIgX3BsYXRmb3JtID0gcmVxdWlyZSgnLi4vdXRpbC9wbGF0Zm9ybScpO1xyXG5cclxudmFyIF9wbGF0Zm9ybTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wbGF0Zm9ybSk7XHJcblxyXG52YXIgX3RhYnNlcXVlbmNlID0gcmVxdWlyZSgnLi90YWJzZXF1ZW5jZS5zb3J0LWFyZWEnKTtcclxuXHJcbnZhciBfdGFic2VxdWVuY2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdGFic2VxdWVuY2UpO1xyXG5cclxudmFyIF90YWJzZXF1ZW5jZTMgPSByZXF1aXJlKCcuL3RhYnNlcXVlbmNlLnNvcnQtc2hhZG93ZWQnKTtcclxuXHJcbnZhciBfdGFic2VxdWVuY2U0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdGFic2VxdWVuY2UzKTtcclxuXHJcbnZhciBfdGFic2VxdWVuY2U1ID0gcmVxdWlyZSgnLi90YWJzZXF1ZW5jZS5zb3J0LXRhYmluZGV4Jyk7XHJcblxyXG52YXIgX3RhYnNlcXVlbmNlNiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RhYnNlcXVlbmNlNSk7XHJcblxyXG52YXIgX3N1cHBvcnRzMiA9IHJlcXVpcmUoJy4uL3N1cHBvcnRzL3N1cHBvcnRzJyk7XHJcblxyXG52YXIgX3N1cHBvcnRzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3N1cHBvcnRzMik7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxudmFyIHN1cHBvcnRzID0gdm9pZCAwO1xyXG4vLyBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZWRpdGluZy5odG1sI3NlcXVlbnRpYWwtZm9jdXMtbmF2aWdhdGlvbi1hbmQtdGhlLXRhYmluZGV4LWF0dHJpYnV0ZVxyXG4vLyBodHRwczovL3d3dy53My5vcmcvV0FJL1BGL2FyaWEtcHJhY3RpY2VzLyNrZXlib2FyZFxyXG5cclxuZnVuY3Rpb24gbW92ZUNvbnRleHRUb0JlZ2lubmluZyhlbGVtZW50cywgY29udGV4dCkge1xyXG4gIHZhciBwb3MgPSBlbGVtZW50cy5pbmRleE9mKGNvbnRleHQpO1xyXG4gIGlmIChwb3MgPiAwKSB7XHJcbiAgICB2YXIgdG1wID0gZWxlbWVudHMuc3BsaWNlKHBvcywgMSk7XHJcbiAgICByZXR1cm4gdG1wLmNvbmNhdChlbGVtZW50cyk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gZWxlbWVudHM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNvcnRFbGVtZW50cyhlbGVtZW50cywgX2NvbnRleHQpIHtcclxuICBpZiAoc3VwcG9ydHMudGFic2VxdWVuY2VBcmVhQXRJbWdQb3NpdGlvbikge1xyXG4gICAgLy8gU29tZSBicm93c2VycyBzb3J0IDxhcmVhPiBpbiBET00gb3JkZXIsIHNvbWUgcGxhY2UgdGhlIDxhcmVhPnNcclxuICAgIC8vIHdoZXJlIHRoZSA8aW1nPiByZWZlcmVjaW5nIHRoZW0gd291bGQndmUgYmVlbiBpbiBET00gb3JkZXIuXHJcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbWVkaWFsaXplL2FsbHkuanMvaXNzdWVzLzVcclxuICAgIGVsZW1lbnRzID0gKDAsIF90YWJzZXF1ZW5jZTIuZGVmYXVsdCkoZWxlbWVudHMsIF9jb250ZXh0KTtcclxuICB9XHJcblxyXG4gIGVsZW1lbnRzID0gKDAsIF90YWJzZXF1ZW5jZTYuZGVmYXVsdCkoZWxlbWVudHMpO1xyXG4gIHJldHVybiBlbGVtZW50cztcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRhYnNlcXVlbmNlLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcclxuLy8gbW92ZSA8YXJlYT4gZWxlbWVudHMgdG8gdGhlIGxvY2F0aW9uIG9mIHRoZSA8aW1nPiBlbGVtZW50cyB0aGF0IHJlZmVyZW5jZSB0aGVtXHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoZWxlbWVudHMsIGNvbnRleHQpIHtcclxuICAvLyBpbWFnZXMgLSB1bmxlc3MgdGhleSBhcmUgZm9jdXNhYmxlIHRoZW1zZWx2ZXMsIGxpa2VseSBub3RcclxuICAvLyBwYXJ0IG9mIHRoZSBlbGVtZW50cyBsaXN0LCBzbyB3ZSdsbCBoYXZlIHRvIGZpbmQgdGhlbSBhbmRcclxuICAvLyBzb3J0IHRoZW0gaW50byB0aGUgZWxlbWVudHMgbGlzdCBtYW51YWxseVxyXG4gIHZhciB1c2VtYXBzID0gY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCdpbWdbdXNlbWFwXScpO1xyXG4gIHZhciBtYXBzID0gbmV3IE1hcHMoY29udGV4dCk7XHJcblxyXG4gIC8vIHJlbW92ZSBhbGwgPGFyZWE+IGVsZW1lbnRzIGZyb20gdGhlIGVsZW1lbnRzIGxpc3QsXHJcbiAgLy8gYnV0IHB1dCB0aGVtIHRoZSBtYXAgZm9yIGxhdGVyIHJldHJpZXZhbFxyXG4gIHZhciBfZWxlbWVudHMgPSBtYXBzLmV4dHJhY3RBcmVhc0Zyb21MaXN0KGVsZW1lbnRzKTtcclxuXHJcbiAgaWYgKCF1c2VtYXBzLmxlbmd0aCkge1xyXG4gICAgLy8gdGhlIGNvbnRleHQgZG9lcyBub3QgY29udGFpbiBhbnkgPGFyZWE+cyBzbyBubyBuZWVkXHJcbiAgICAvLyB0byByZXBsYWNlIGFueXRoaW5nLCBqdXN0IHJlbW92ZSBhbnkgbWFwc1xyXG4gICAgcmV0dXJuIF9lbGVtZW50cztcclxuICB9XHJcblxyXG4gIHJldHVybiAoMCwgX21lcmdlRG9tT3JkZXIyLmRlZmF1bHQpKHtcclxuICAgIGxpc3Q6IF9lbGVtZW50cyxcclxuICAgIGVsZW1lbnRzOiB1c2VtYXBzLFxyXG4gICAgcmVzb2x2ZUVsZW1lbnQ6IGZ1bmN0aW9uIHJlc29sdmVFbGVtZW50KGltYWdlKSB7XHJcbiAgICAgIHZhciBuYW1lID0gaW1hZ2UuZ2V0QXR0cmlidXRlKCd1c2VtYXAnKS5zbGljZSgxKTtcclxuICAgICAgcmV0dXJuIG1hcHMuZ2V0QXJlYXNGb3IobmFtZSk7XHJcbiAgICB9XHJcbiAgfSk7XHJcbn07XHJcblxyXG52YXIgX3RhYmJhYmxlID0gcmVxdWlyZSgnLi90YWJiYWJsZScpO1xyXG5cclxudmFyIF90YWJiYWJsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90YWJiYWJsZSk7XHJcblxyXG52YXIgX21lcmdlRG9tT3JkZXIgPSByZXF1aXJlKCcuLi91dGlsL21lcmdlLWRvbS1vcmRlcicpO1xyXG5cclxudmFyIF9tZXJnZURvbU9yZGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21lcmdlRG9tT3JkZXIpO1xyXG5cclxudmFyIF9nZXREb2N1bWVudCA9IHJlcXVpcmUoJy4uL3V0aWwvZ2V0LWRvY3VtZW50Jyk7XHJcblxyXG52YXIgX2dldERvY3VtZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldERvY3VtZW50KTtcclxuXHJcbnZhciBfaW1hZ2VNYXAgPSByZXF1aXJlKCcuLi91dGlsL2ltYWdlLW1hcCcpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XHJcblxyXG52YXIgTWFwcyA9IGZ1bmN0aW9uICgpIHtcclxuICBmdW5jdGlvbiBNYXBzKGNvbnRleHQpIHtcclxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNYXBzKTtcclxuXHJcbiAgICB0aGlzLl9kb2N1bWVudCA9ICgwLCBfZ2V0RG9jdW1lbnQyLmRlZmF1bHQpKGNvbnRleHQpO1xyXG4gICAgdGhpcy5tYXBzID0ge307XHJcbiAgfVxyXG5cclxuICBfY3JlYXRlQ2xhc3MoTWFwcywgW3tcclxuICAgIGtleTogJ2dldEFyZWFzRm9yJyxcclxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRBcmVhc0ZvcihuYW1lKSB7XHJcbiAgICAgIGlmICghdGhpcy5tYXBzW25hbWVdKSB7XHJcbiAgICAgICAgLy8gdGhlIG1hcCBpcyBub3QgZGVmaW5lZCB3aXRoaW4gdGhlIGNvbnRleHQsIHNvIHdlXHJcbiAgICAgICAgLy8gaGF2ZSB0byBnbyBmaW5kIGl0IGVsc2V3aGVyZSBpbiB0aGUgZG9jdW1lbnRcclxuICAgICAgICB0aGlzLmFkZE1hcEJ5TmFtZShuYW1lKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHRoaXMubWFwc1tuYW1lXTtcclxuICAgIH1cclxuICB9LCB7XHJcbiAgICBrZXk6ICdhZGRNYXBCeU5hbWUnLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZE1hcEJ5TmFtZShuYW1lKSB7XHJcbiAgICAgIHZhciBtYXAgPSAoMCwgX2ltYWdlTWFwLmdldE1hcEJ5TmFtZSkobmFtZSwgdGhpcy5fZG9jdW1lbnQpO1xyXG4gICAgICBpZiAoIW1hcCkge1xyXG4gICAgICAgIC8vIGlmIHRoZXJlIGlzIG5vIG1hcCwgdGhlIGltZ1t1c2VtYXBdIHdhc24ndCBkb2luZyBhbnl0aGluZyBhbnl3YXlcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMubWFwc1ttYXAubmFtZV0gPSAoMCwgX3RhYmJhYmxlMi5kZWZhdWx0KSh7IGNvbnRleHQ6IG1hcCB9KTtcclxuICAgIH1cclxuICB9LCB7XHJcbiAgICBrZXk6ICdleHRyYWN0QXJlYXNGcm9tTGlzdCcsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXh0cmFjdEFyZWFzRnJvbUxpc3QoZWxlbWVudHMpIHtcclxuICAgICAgLy8gcmVtb3ZlIGFsbCA8YXJlYT4gZWxlbWVudHMgZnJvbSB0aGUgZWxlbWVudHMgbGlzdCxcclxuICAgICAgLy8gYnV0IHB1dCB0aGVtIHRoZSBtYXAgZm9yIGxhdGVyIHJldHJpZXZhbFxyXG4gICAgICByZXR1cm4gZWxlbWVudHMuZmlsdGVyKGZ1bmN0aW9uIChlbGVtZW50KSB7XHJcbiAgICAgICAgdmFyIG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgIGlmIChub2RlTmFtZSAhPT0gJ2FyZWEnKSB7XHJcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBtYXAgPSBlbGVtZW50LnBhcmVudE5vZGU7XHJcbiAgICAgICAgaWYgKCF0aGlzLm1hcHNbbWFwLm5hbWVdKSB7XHJcbiAgICAgICAgICB0aGlzLm1hcHNbbWFwLm5hbWVdID0gW107XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLm1hcHNbbWFwLm5hbWVdLnB1c2goZWxlbWVudCk7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9LCB0aGlzKTtcclxuICAgIH1cclxuICB9XSk7XHJcblxyXG4gIHJldHVybiBNYXBzO1xyXG59KCk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGFic2VxdWVuY2Uuc29ydC1hcmVhLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChlbGVtZW50cywgY29udGV4dCwgc29ydEVsZW1lbnRzKSB7XHJcbiAgdmFyIHNoYWRvd3MgPSBuZXcgU2hhZG93cyhjb250ZXh0LCBzb3J0RWxlbWVudHMpO1xyXG4gIHZhciBfZWxlbWVudHMgPSBzaGFkb3dzLmV4dHJhY3RFbGVtZW50cyhlbGVtZW50cyk7XHJcblxyXG4gIGlmIChfZWxlbWVudHMubGVuZ3RoID09PSBlbGVtZW50cy5sZW5ndGgpIHtcclxuICAgIC8vIG5vIHNoYWRvd2VkIGNvbnRlbnQgZm91bmQsIG5vIG5lZWQgdG8gY29udGludWVcclxuICAgIHJldHVybiBzb3J0RWxlbWVudHMoZWxlbWVudHMpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHNoYWRvd3Muc29ydChfZWxlbWVudHMpO1xyXG59O1xyXG5cclxudmFyIF9zaGFkb3dIb3N0ID0gcmVxdWlyZSgnLi4vZ2V0L3NoYWRvdy1ob3N0Jyk7XHJcblxyXG52YXIgX3NoYWRvd0hvc3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc2hhZG93SG9zdCk7XHJcblxyXG52YXIgX21lcmdlRG9tT3JkZXIgPSByZXF1aXJlKCcuLi91dGlsL21lcmdlLWRvbS1vcmRlcicpO1xyXG5cclxudmFyIF9tZXJnZURvbU9yZGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21lcmdlRG9tT3JkZXIpO1xyXG5cclxudmFyIF90YWJpbmRleFZhbHVlID0gcmVxdWlyZSgnLi4vdXRpbC90YWJpbmRleC12YWx1ZScpO1xyXG5cclxudmFyIF90YWJpbmRleFZhbHVlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RhYmluZGV4VmFsdWUpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XHJcblxyXG52YXIgU2hhZG93cyA9IGZ1bmN0aW9uICgpIHtcclxuICBmdW5jdGlvbiBTaGFkb3dzKGNvbnRleHQsIHNvcnRFbGVtZW50cykge1xyXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNoYWRvd3MpO1xyXG5cclxuICAgIC8vIGRvY3VtZW50IGNvbnRleHQgd2UncmUgd29ya2luZyB3aXRoXHJcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xyXG4gICAgLy8gY2FsbGJhY2sgdGhhdCBzb3J0cyBhbiBhcnJheSBvZiBlbGVtZW50c1xyXG4gICAgdGhpcy5zb3J0RWxlbWVudHMgPSBzb3J0RWxlbWVudHM7XHJcbiAgICAvLyByZWZlcmVuY2UgdG8gY3JlYXRlIHVuaXF1ZSBJRHMgZm9yIGVhY2ggU2hhZG93SG9zdFxyXG4gICAgdGhpcy5ob3N0Q291bnRlciA9IDE7XHJcbiAgICAvLyByZWZlcmVuY2UgbWFwIGZvciBjaGlsZC1TaGFkb3dIb3N0cyBvZiBhIFNoYWRvd0hvc3RcclxuICAgIHRoaXMuaW5Ib3N0ID0ge307XHJcbiAgICAvLyByZWZlcmVuY2UgbWFwIGZvciBjaGlsZC1TaGFkb3dIb3N0IG9mIHRoZSBkb2N1bWVudFxyXG4gICAgdGhpcy5pbkRvY3VtZW50ID0gW107XHJcbiAgICAvLyByZWZlcmVuY2UgbWFwIGZvciBTaGFkb3dIb3N0c1xyXG4gICAgdGhpcy5ob3N0cyA9IHt9O1xyXG4gICAgLy8gcmVmZXJlbmNlIG1hcCBmb3IgdGFiYmFibGUgZWxlbWVudHMgb2YgYSBTaGFkb3dIb3N0XHJcbiAgICB0aGlzLmVsZW1lbnRzID0ge307XHJcbiAgfVxyXG5cclxuICAvLyByZW1lbWJlciB3aGljaCBob3N0cyB3ZSBoYXZlIHRvIHNvcnQgd2l0aGluIGxhdGVyXHJcblxyXG5cclxuICBfY3JlYXRlQ2xhc3MoU2hhZG93cywgW3tcclxuICAgIGtleTogJ19yZWdpc3Rlckhvc3QnLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZWdpc3Rlckhvc3QoaG9zdCkge1xyXG4gICAgICBpZiAoaG9zdC5fc29ydGluZ0lkKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBtYWtlIHRoZSBTaGFkb3dIb3N0IGlkZW50aWZpYWJsZSAoc2VlIGNsZWFudXAoKSBmb3IgdW5kbylcclxuICAgICAgaG9zdC5fc29ydGluZ0lkID0gJ3NoYWRvdy0nICsgdGhpcy5ob3N0Q291bnRlcisrO1xyXG4gICAgICB0aGlzLmhvc3RzW2hvc3QuX3NvcnRpbmdJZF0gPSBob3N0O1xyXG5cclxuICAgICAgLy8gaG9zdHMgbWF5IGNvbnRhaW4gb3RoZXIgaG9zdHNcclxuICAgICAgdmFyIHBhcmVudEhvc3QgPSAoMCwgX3NoYWRvd0hvc3QyLmRlZmF1bHQpKHsgY29udGV4dDogaG9zdCB9KTtcclxuICAgICAgaWYgKHBhcmVudEhvc3QpIHtcclxuICAgICAgICB0aGlzLl9yZWdpc3Rlckhvc3QocGFyZW50SG9zdCk7XHJcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJIb3N0UGFyZW50KGhvc3QsIHBhcmVudEhvc3QpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuaW5Eb2N1bWVudC5wdXNoKGhvc3QpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gcmVtZW1iZXIgd2hpY2ggaG9zdCBpcyB0aGUgY2hpbGQgb2Ygd2hpY2ggb3RoZXIgaG9zdFxyXG5cclxuICB9LCB7XHJcbiAgICBrZXk6ICdfcmVnaXN0ZXJIb3N0UGFyZW50JyxcclxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVnaXN0ZXJIb3N0UGFyZW50KGhvc3QsIHBhcmVudCkge1xyXG4gICAgICBpZiAoIXRoaXMuaW5Ib3N0W3BhcmVudC5fc29ydGluZ0lkXSkge1xyXG4gICAgICAgIHRoaXMuaW5Ib3N0W3BhcmVudC5fc29ydGluZ0lkXSA9IFtdO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLmluSG9zdFtwYXJlbnQuX3NvcnRpbmdJZF0ucHVzaChob3N0KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyByZW1lbWJlciB3aGljaCBlbGVtZW50cyBhIGhvc3QgY29udGFpbnNcclxuXHJcbiAgfSwge1xyXG4gICAga2V5OiAnX3JlZ2lzdGVyRWxlbWVudCcsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlZ2lzdGVyRWxlbWVudChlbGVtZW50LCBob3N0KSB7XHJcbiAgICAgIGlmICghdGhpcy5lbGVtZW50c1tob3N0Ll9zb3J0aW5nSWRdKSB7XHJcbiAgICAgICAgdGhpcy5lbGVtZW50c1tob3N0Ll9zb3J0aW5nSWRdID0gW107XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMuZWxlbWVudHNbaG9zdC5fc29ydGluZ0lkXS5wdXNoKGVsZW1lbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHJlbW92ZSBzaGFkb3dlZCBlbGVtZW50cyBmcm9tIHRoZSBzZXF1ZW5jZSBhbmQgcmVnaXN0ZXJcclxuICAgIC8vIHRoZSBTaGFkb3dIb3N0cyB0aGV5IGJlbG9uZyB0byBzbyB3ZSBrbm93IHdoYXQgdG8gc29ydFxyXG4gICAgLy8gbGF0ZXIgb25cclxuXHJcbiAgfSwge1xyXG4gICAga2V5OiAnZXh0cmFjdEVsZW1lbnRzJyxcclxuICAgIHZhbHVlOiBmdW5jdGlvbiBleHRyYWN0RWxlbWVudHMoZWxlbWVudHMpIHtcclxuICAgICAgcmV0dXJuIGVsZW1lbnRzLmZpbHRlcihmdW5jdGlvbiAoZWxlbWVudCkge1xyXG4gICAgICAgIHZhciBob3N0ID0gKDAsIF9zaGFkb3dIb3N0Mi5kZWZhdWx0KSh7IGNvbnRleHQ6IGVsZW1lbnQgfSk7XHJcbiAgICAgICAgaWYgKCFob3N0KSB7XHJcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuX3JlZ2lzdGVySG9zdChob3N0KTtcclxuICAgICAgICB0aGlzLl9yZWdpc3RlckVsZW1lbnQoZWxlbWVudCwgaG9zdCk7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9LCB0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBpbmplY3QgaG9zdHMgaW50byB0aGUgc2VxdWVuY2UsIHNvcnQgZXZlcnl0aGluZyxcclxuICAgIC8vIGFuZCByZWNvdXJzaXZlbHkgcmVwbGFjZSBob3N0cyBieSBpdHMgZGVzY2VuZGFudHNcclxuXHJcbiAgfSwge1xyXG4gICAga2V5OiAnc29ydCcsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gc29ydChlbGVtZW50cykge1xyXG4gICAgICB2YXIgX2VsZW1lbnRzID0gdGhpcy5faW5qZWN0SG9zdHMoZWxlbWVudHMpO1xyXG4gICAgICBfZWxlbWVudHMgPSB0aGlzLl9yZXBsYWNlSG9zdHMoX2VsZW1lbnRzKTtcclxuICAgICAgdGhpcy5fY2xlYW51cCgpO1xyXG4gICAgICByZXR1cm4gX2VsZW1lbnRzO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIG1lcmdlIFNoYWRvd0hvc3RzIGludG8gdGhlIGVsZW1lbnQgbGlzdHMgb2Ygb3RoZXIgU2hhZG93SG9zdHNcclxuICAgIC8vIG9yIHRoZSBkb2N1bWVudCwgdGhlbiBzb3J0IHRoZSBpbmRpdmlkdWFsIGxpc3RzXHJcblxyXG4gIH0sIHtcclxuICAgIGtleTogJ19pbmplY3RIb3N0cycsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2luamVjdEhvc3RzKGVsZW1lbnRzKSB7XHJcbiAgICAgIE9iamVjdC5rZXlzKHRoaXMuaG9zdHMpLmZvckVhY2goZnVuY3Rpb24gKF9zb3J0aW5nSWQpIHtcclxuICAgICAgICB2YXIgX2xpc3QgPSB0aGlzLmVsZW1lbnRzW19zb3J0aW5nSWRdO1xyXG4gICAgICAgIHZhciBfZWxlbWVudHMgPSB0aGlzLmluSG9zdFtfc29ydGluZ0lkXTtcclxuICAgICAgICB2YXIgX2NvbnRleHQgPSB0aGlzLmhvc3RzW19zb3J0aW5nSWRdLnNoYWRvd1Jvb3Q7XHJcbiAgICAgICAgdGhpcy5lbGVtZW50c1tfc29ydGluZ0lkXSA9IHRoaXMuX21lcmdlKF9saXN0LCBfZWxlbWVudHMsIF9jb250ZXh0KTtcclxuICAgICAgfSwgdGhpcyk7XHJcblxyXG4gICAgICByZXR1cm4gdGhpcy5fbWVyZ2UoZWxlbWVudHMsIHRoaXMuaW5Eb2N1bWVudCwgdGhpcy5jb250ZXh0KTtcclxuICAgIH1cclxuICB9LCB7XHJcbiAgICBrZXk6ICdfbWVyZ2UnLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9tZXJnZShsaXN0LCBlbGVtZW50cywgY29udGV4dCkge1xyXG4gICAgICB2YXIgbWVyZ2VkID0gKDAsIF9tZXJnZURvbU9yZGVyMi5kZWZhdWx0KSh7XHJcbiAgICAgICAgbGlzdDogbGlzdCxcclxuICAgICAgICBlbGVtZW50czogZWxlbWVudHNcclxuICAgICAgfSk7XHJcblxyXG4gICAgICByZXR1cm4gdGhpcy5zb3J0RWxlbWVudHMobWVyZ2VkLCBjb250ZXh0KTtcclxuICAgIH1cclxuICB9LCB7XHJcbiAgICBrZXk6ICdfcmVwbGFjZUhvc3RzJyxcclxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVwbGFjZUhvc3RzKGVsZW1lbnRzKSB7XHJcbiAgICAgIHJldHVybiAoMCwgX21lcmdlRG9tT3JkZXIyLmRlZmF1bHQpKHtcclxuICAgICAgICBsaXN0OiBlbGVtZW50cyxcclxuICAgICAgICBlbGVtZW50czogdGhpcy5pbkRvY3VtZW50LFxyXG4gICAgICAgIHJlc29sdmVFbGVtZW50OiB0aGlzLl9yZXNvbHZlSG9zdEVsZW1lbnQuYmluZCh0aGlzKVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9LCB7XHJcbiAgICBrZXk6ICdfcmVzb2x2ZUhvc3RFbGVtZW50JyxcclxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVzb2x2ZUhvc3RFbGVtZW50KGhvc3QpIHtcclxuICAgICAgdmFyIG1lcmdlZCA9ICgwLCBfbWVyZ2VEb21PcmRlcjIuZGVmYXVsdCkoe1xyXG4gICAgICAgIGxpc3Q6IHRoaXMuZWxlbWVudHNbaG9zdC5fc29ydGluZ0lkXSxcclxuICAgICAgICBlbGVtZW50czogdGhpcy5pbkhvc3RbaG9zdC5fc29ydGluZ0lkXSxcclxuICAgICAgICByZXNvbHZlRWxlbWVudDogdGhpcy5fcmVzb2x2ZUhvc3RFbGVtZW50LmJpbmQodGhpcylcclxuICAgICAgfSk7XHJcblxyXG4gICAgICB2YXIgX3RhYmluZGV4ID0gKDAsIF90YWJpbmRleFZhbHVlMi5kZWZhdWx0KShob3N0KTtcclxuICAgICAgaWYgKF90YWJpbmRleCAhPT0gbnVsbCAmJiBfdGFiaW5kZXggPiAtMSkge1xyXG4gICAgICAgIHJldHVybiBbaG9zdF0uY29uY2F0KG1lcmdlZCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBtZXJnZWQ7XHJcbiAgICB9XHJcbiAgfSwge1xyXG4gICAga2V5OiAnX2NsZWFudXAnLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jbGVhbnVwKCkge1xyXG4gICAgICAvLyByZW1vdmUgdGhvc2UgaWRlbnRpZmVycyB3ZSBwdXQgb24gdGhlIFNoYWRvd0hvc3QgdG8gYXZvaWQgdXNpbmcgTWFwKClcclxuICAgICAgT2JqZWN0LmtleXModGhpcy5ob3N0cykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgZGVsZXRlIHRoaXMuaG9zdHNba2V5XS5fc29ydGluZ0lkO1xyXG4gICAgICB9LCB0aGlzKTtcclxuICAgIH1cclxuICB9XSk7XHJcblxyXG4gIHJldHVybiBTaGFkb3dzO1xyXG59KCk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGFic2VxdWVuY2Uuc29ydC1zaGFkb3dlZC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChlbGVtZW50cykge1xyXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9IVE1MRWxlbWVudC50YWJJbmRleFxyXG4gIC8vIGVsZW1lbnRzIHdpdGggdGFiSW5kZXggXCIwXCIgKGluY2x1ZGluZyB0YWJiYWJsZUVsZW1lbnRzIHdpdGhvdXQgdGFiSW5kZXgpIHNob3VsZCBiZSBuYXZpZ2F0ZWQgaW4gdGhlIG9yZGVyIHRoZXkgYXBwZWFyLlxyXG4gIC8vIGVsZW1lbnRzIHdpdGggYSBwb3NpdGl2ZSB0YWJJbmRleDpcclxuICAvLyAgIEVsZW1lbnRzIHRoYXQgaGF2ZSBpZGVudGljYWwgdGFiSW5kZXhlcyBzaG91bGQgYmUgbmF2aWdhdGVkIGluIHRoZSBvcmRlciB0aGV5IGFwcGVhci5cclxuICAvLyAgIE5hdmlnYXRpb24gcHJvY2VlZHMgZnJvbSB0aGUgbG93ZXN0IHRhYkluZGV4IHRvIHRoZSBoaWdoZXN0IHRhYkluZGV4LlxyXG5cclxuICAvLyBOT1RFOiBzb3J0IGltcGxlbWVudGF0aW9uIG1heSBiZSB1bnN0YWJsZSBhbmQgdGh1cyBtZXNzIHVwIERPTSBvcmRlcixcclxuICAvLyB0aGF0J3Mgd2h5IHdlIGJ1aWxkIGEgbWFwIHRoYXQncyBiZWluZyBzb3J0ZWQgaW5zdGVhZC4gSWYgd2Ugd2VyZSBhYmxlIHRvIHJlbHlcclxuICAvLyBvbiBhIHN0YWJsZSBzb3J0aW5nIGFsZ29yaXRobSwgc29ydFRhYmluZGV4KCkgY291bGQgYmUgYXMgc2ltcGxlIGFzXHJcbiAgLy8gZWxlbWVudHMuc29ydChmdW5jdGlvbihhLCBiKSB7IHJldHVybiBhLnRhYkluZGV4IC0gYi50YWJJbmRleDsgfSk7XHJcbiAgLy8gYXQgdGhpcyB0aW1lIENocm9tZSBkb2VzIG5vdCB1c2UgYSBzdGFibGUgc29ydGluZyBhbGdvcml0aG1cclxuICAvLyBzZWUgaHR0cDovL2Jsb2cucm9kbmV5cmVobS5kZS9hcmNoaXZlcy8xNC1Tb3J0aW5nLVdlcmUtRG9pbmctSXQtV3JvbmcuaHRtbCNzdGFiaWxpdHlcclxuXHJcbiAgLy8gTk9URTogY29tcGFyZURvY3VtZW50UG9zaXRpb24gc2VlbWVkIGxpa2UgbW9yZSBvdmVyaGVhZCB0aGFuIGp1c3Qgc29ydGluZyB0aGlzIHdpdGggYnVja2V0c1xyXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Ob2RlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uXHJcblxyXG4gIHZhciBtYXAgPSB7fTtcclxuICB2YXIgaW5kZXhlcyA9IFtdO1xyXG4gIHZhciBub3JtYWwgPSBlbGVtZW50cy5maWx0ZXIoZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuICAgIC8vIGluIFRyaWRlbnQgYW5kIEdlY2tvIFNWR0VsZW1lbnQgZG9lcyBub3Qga25vdyBhYm91dCB0aGUgdGFiSW5kZXggcHJvcGVydHlcclxuICAgIHZhciB0YWJJbmRleCA9IGVsZW1lbnQudGFiSW5kZXg7XHJcbiAgICBpZiAodGFiSW5kZXggPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICB0YWJJbmRleCA9ICgwLCBfdGFiaW5kZXhWYWx1ZTIuZGVmYXVsdCkoZWxlbWVudCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZXh0cmFjdCBlbGVtZW50cyB0aGF0IGRvbid0IG5lZWQgc29ydGluZ1xyXG4gICAgaWYgKHRhYkluZGV4IDw9IDAgfHwgdGFiSW5kZXggPT09IG51bGwgfHwgdGFiSW5kZXggPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIW1hcFt0YWJJbmRleF0pIHtcclxuICAgICAgLy8gY3JlYXRlIHNvcnRhYmxlIGJ1Y2tldCBmb3IgZG9tLW9yZGVyLXByZXNlcnZhdGlvbiBvZiBlbGVtZW50cyB3aXRoIHRoZSBzYW1lIHRhYkluZGV4XHJcbiAgICAgIG1hcFt0YWJJbmRleF0gPSBbXTtcclxuICAgICAgLy8gbWFpbnRhaW4gYSBsaXN0IG9mIHVuaXF1ZSB0YWJJbmRleGVzXHJcbiAgICAgIGluZGV4ZXMucHVzaCh0YWJJbmRleCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gc29ydCBlbGVtZW50IGludG8gdGhlIHByb3BlciBidWNrZXRcclxuICAgIG1hcFt0YWJJbmRleF0ucHVzaChlbGVtZW50KTtcclxuICAgIC8vIGVsZW1lbnQgbW92ZWQgdG8gc29ydGluZyBtYXAsIHNvIG5vdCBcIm5vcm1hbFwiIGFueW1vcmVcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9KTtcclxuXHJcbiAgLy8gc29ydCB0aGUgdGFiaW5kZXggYXNjZW5kaW5nLFxyXG4gIC8vIHRoZW4gcmVzb2x2ZSB0aGVtIHRvIHRoZWlyIGFwcHJvcHJpYXRlIGJ1Y2tldHMsXHJcbiAgLy8gdGhlbiBmbGF0dGVuIHRoZSBhcnJheSBvZiBhcnJheXMgdG8gYW4gYXJyYXlcclxuICB2YXIgX2VsZW1lbnRzID0gaW5kZXhlcy5zb3J0KCkubWFwKGZ1bmN0aW9uICh0YWJJbmRleCkge1xyXG4gICAgcmV0dXJuIG1hcFt0YWJJbmRleF07XHJcbiAgfSkucmVkdWNlUmlnaHQoZnVuY3Rpb24gKHByZXZpb3VzLCBjdXJyZW50KSB7XHJcbiAgICByZXR1cm4gY3VycmVudC5jb25jYXQocHJldmlvdXMpO1xyXG4gIH0sIG5vcm1hbCk7XHJcblxyXG4gIHJldHVybiBfZWxlbWVudHM7XHJcbn07XHJcblxyXG52YXIgX3RhYmluZGV4VmFsdWUgPSByZXF1aXJlKCcuLi91dGlsL3RhYmluZGV4LXZhbHVlJyk7XHJcblxyXG52YXIgX3RhYmluZGV4VmFsdWUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdGFiaW5kZXhWYWx1ZSk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRhYnNlcXVlbmNlLnNvcnQtdGFiaW5kZXguanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgaWYgKCFzdXBwb3J0cykge1xyXG4gICAgc3VwcG9ydHMgPSAoMCwgX3N1cHBvcnRzMy5kZWZhdWx0KSgpO1xyXG4gIH1cclxuXHJcbiAgaWYgKHR5cGVvZiBzZWxlY3RvciA9PT0gJ3N0cmluZycpIHtcclxuICAgIHJldHVybiBzZWxlY3RvcjtcclxuICB9XHJcblxyXG4gIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lZGl0aW5nLmh0bWwjc2VxdWVudGlhbC1mb2N1cy1uYXZpZ2F0aW9uLWFuZC10aGUtdGFiaW5kZXgtYXR0cmlidXRlXHJcbiAgc2VsZWN0b3IgPSAnJ1xyXG4gIC8vIElFMTEgc3VwcG9ydHMuY2FuIGZvY3VzIDx0YWJsZT4gYW5kIDx0ZD5cclxuICArIChzdXBwb3J0cy5mb2N1c1RhYmxlID8gJ3RhYmxlLCB0ZCwnIDogJycpXHJcbiAgLy8gSUUxMSBzdXBwb3J0cy5jYW4gZm9jdXMgPGZpZWxkc2V0PlxyXG4gICsgKHN1cHBvcnRzLmZvY3VzRmllbGRzZXQgPyAnZmllbGRzZXQsJyA6ICcnKVxyXG4gIC8vIE5hbWVzcGFjZSBwcm9ibGVtcyBvZiBbeGxpbms6aHJlZl0gZXhwbGFpbmVkIGluIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMzA0Nzg4OC81MTUxMjRcclxuICAvLyBzdmcgYVsqfGhyZWZdIGRvZXMgbm90IG1hdGNoIGluIElFOSwgYnV0IHNpbmNlIHdlJ3JlIGZpbHRlcmluZ1xyXG4gIC8vIHRocm91Z2ggaXMvZm9jdXNhYmxlIHdlIGNhbiBpbmNsdWRlIGFsbCA8YT4gZnJvbSBTVkdcclxuICArICdzdmcgYSwnXHJcbiAgLy8gbWF5IGJlaGF2ZSBhcyAnc3ZnLCBzdmcgKiwnIGluIGNocm9tZSBhcyAqZXZlcnkqIHN2ZyBlbGVtZW50IHdpdGggYSBmb2N1cyBldmVudCBsaXN0ZW5lciBpcyBmb2N1c2FibGVcclxuICAvLyBuYXZpZ2F0aW9uYWwgZWxlbWVudHNcclxuICArICdhW2hyZWZdLCdcclxuICAvLyB2YWxpZGl0eSBkZXRlcm1pbmVkIGJ5IGlzL3ZhbGlkLWFyZWEuanNcclxuICArICdhcmVhW2hyZWZdLCdcclxuICAvLyB2YWxpZGl0eSBkZXRlcm1pbmVkIGJ5IGlzL2Rpc2FibGVkLmpzXHJcbiAgKyAnaW5wdXQsIHNlbGVjdCwgdGV4dGFyZWEsIGJ1dHRvbiwnXHJcbiAgLy8gYnJvd3NpbmcgY29udGV4dCBjb250YWluZXJzXHJcbiAgKyAnaWZyYW1lLCBvYmplY3QsIGVtYmVkLCdcclxuICAvLyBpbnRlcmFjdGl2ZSBjb250ZW50XHJcbiAgKyAna2V5Z2VuLCcgKyAoc3VwcG9ydHMuZm9jdXNBdWRpb1dpdGhvdXRDb250cm9scyA/ICdhdWRpbywnIDogJ2F1ZGlvW2NvbnRyb2xzXSwnKSArIChzdXBwb3J0cy5mb2N1c1ZpZGVvV2l0aG91dENvbnRyb2xzID8gJ3ZpZGVvLCcgOiAndmlkZW9bY29udHJvbHNdLCcpICsgKHN1cHBvcnRzLmZvY3VzU3VtbWFyeSA/ICdzdW1tYXJ5LCcgOiAnJylcclxuICAvLyB2YWxpZGl0eSBkZXRlcm1pbmVkIGJ5IGlzL3ZhbGlkLXRhYmluZGV4LmpzXHJcbiAgKyAnW3RhYmluZGV4XSwnXHJcbiAgLy8gZWRpdGluZyBob3N0c1xyXG4gICsgJ1tjb250ZW50ZWRpdGFibGVdJztcclxuXHJcbiAgLy8gd2hlcmUgU2hhZG93RE9NIGlzIHN1cHBvcnRlZCwgd2UgYWxzbyB3YW50IHRoZSBzaGFkb3dlZCBmb2N1c2FibGUgZWxlbWVudHMgKHZpYSBcIj4+PlwiIG9yIFwiL2RlZXAvXCIpXHJcbiAgc2VsZWN0b3IgPSAoMCwgX3NlbGVjdEluU2hhZG93czIuZGVmYXVsdCkoc2VsZWN0b3IpO1xyXG5cclxuICByZXR1cm4gc2VsZWN0b3I7XHJcbn07XHJcblxyXG52YXIgX3NlbGVjdEluU2hhZG93cyA9IHJlcXVpcmUoJy4uL3V0aWwvc2VsZWN0LWluLXNoYWRvd3MnKTtcclxuXHJcbnZhciBfc2VsZWN0SW5TaGFkb3dzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NlbGVjdEluU2hhZG93cyk7XHJcblxyXG52YXIgX3N1cHBvcnRzMiA9IHJlcXVpcmUoJy4uL3N1cHBvcnRzL3N1cHBvcnRzJyk7XHJcblxyXG52YXIgX3N1cHBvcnRzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3N1cHBvcnRzMik7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuLy8gTk9URTogdGhpcyBzZWxlY3RvciBNVVNUICpuZXZlciogYmUgdXNlZCBkaXJlY3RseSxcclxuLy8gYWx3YXlzIGdvIHRocm91Z2ggcXVlcnkvZm9jdXNhYmxlIG9yIGlzL2ZvY3VzYWJsZS5qc1xyXG4vLyB0aGVyZSBhcmUgdG9vIG1hbnkgZWRnZSBjYXNlcyB0aGF0IHRoZXkgY291bGQgYmUgY292ZXJlZCBpblxyXG4vLyBhIHNpbXBsZSBDU1Mgc2VsZWN0b3LigKZcclxuXHJcbnZhciBzdXBwb3J0cyA9IHZvaWQgMDtcclxuXHJcbnZhciBzZWxlY3RvciA9IHZvaWQgMDtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb2N1c2FibGUuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIGNvbWJpbmF0b3IgPSB2b2lkIDA7XHJcblxyXG4gIC8vIHNlZSBodHRwczovL2Rldi53My5vcmcvY3Nzd2cvY3NzLXNjb3BpbmctMS8jZGVlcC1jb21iaW5hdG9yXHJcbiAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTExNzU3MlxyXG4gIC8vIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00NDYwNTFcclxuICB0cnkge1xyXG4gICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignaHRtbCA+Pj4gOmZpcnN0LWNoaWxkJyk7XHJcbiAgICBjb21iaW5hdG9yID0gJz4+Pic7XHJcbiAgfSBjYXRjaCAobm9BcnJvd0Fycm93QXJyb3cpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIG9sZCBzeW50YXggc3VwcG9ydGVkIGF0IGxlYXN0IHVwIHRvIENocm9tZSA0MVxyXG4gICAgICAvLyBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDQ2MDUxXHJcbiAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2h0bWwgL2RlZXAvIDpmaXJzdC1jaGlsZCcpO1xyXG4gICAgICBjb21iaW5hdG9yID0gJy9kZWVwLyc7XHJcbiAgICB9IGNhdGNoIChub0RlZXApIHtcclxuICAgICAgY29tYmluYXRvciA9ICcnO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGNvbWJpbmF0b3I7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3NzLXNoYWRvdy1waWVyY2luZy1kZWVwLWNvbWJpbmF0b3IuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAodGVzdHMpIHtcclxuICB2YXIgZGF0YSA9IGJlZm9yZSgpO1xyXG5cclxuICB2YXIgcmVzdWx0cyA9IHt9O1xyXG4gIE9iamVjdC5rZXlzKHRlc3RzKS5tYXAoZnVuY3Rpb24gKGtleSkge1xyXG4gICAgcmVzdWx0c1trZXldID0gdGVzdChkYXRhLCB0ZXN0c1trZXldKTtcclxuICB9KTtcclxuXHJcbiAgYWZ0ZXIoZGF0YSk7XHJcbiAgcmV0dXJuIHJlc3VsdHM7XHJcbn07XHJcblxyXG52YXIgX3BsYXRmb3JtID0gcmVxdWlyZSgnLi4vdXRpbC9wbGF0Zm9ybScpO1xyXG5cclxudmFyIF9wbGF0Zm9ybTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wbGF0Zm9ybSk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuZnVuY3Rpb24gYmVmb3JlKCkge1xyXG4gIHZhciBkYXRhID0ge1xyXG4gICAgLy8gcmVtZW1iZXIgd2hhdCBoYWQgZm9jdXMgdG8gcmVzdG9yZSBhZnRlciB0ZXN0XHJcbiAgICBhY3RpdmVFbGVtZW50OiBkb2N1bWVudC5hY3RpdmVFbGVtZW50LFxyXG4gICAgLy8gcmVtZW1iZXIgc2Nyb2xsIHBvc2l0aW9ucyB0byByZXN0b3JlIGFmdGVyIHRlc3RcclxuICAgIHdpbmRvd1Njcm9sbFRvcDogd2luZG93LnNjcm9sbFRvcCxcclxuICAgIHdpbmRvd1Njcm9sbExlZnQ6IHdpbmRvdy5zY3JvbGxMZWZ0LFxyXG4gICAgYm9keVNjcm9sbFRvcDogZG9jdW1lbnQuYm9keS5zY3JvbGxUb3AsXHJcbiAgICBib2R5U2Nyb2xsTGVmdDogZG9jdW1lbnQuYm9keS5zY3JvbGxMZWZ0XHJcbiAgfTtcclxuXHJcbiAgLy8gd3JhcCB0ZXN0cyBpbiBhbiBlbGVtZW50IGhpZGRlbiBmcm9tIHNjcmVlbiByZWFkZXJzIHRvIHByZXZlbnQgdGhlbVxyXG4gIC8vIGZyb20gYW5ub3VuY2luZyBmb2N1cywgd2hpY2ggY2FuIGJlIHF1aXRlIGlycml0YXRpbmcgdG8gdGhlIHVzZXJcclxuICB2YXIgaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XHJcbiAgaWZyYW1lLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAncG9zaXRpb246YWJzb2x1dGU7IHBvc2l0aW9uOmZpeGVkOyB0b3A6MDsgbGVmdDotMnB4OyB3aWR0aDoxcHg7IGhlaWdodDoxcHg7IG92ZXJmbG93OmhpZGRlbjsnKTtcclxuICBpZnJhbWUuc2V0QXR0cmlidXRlKCdhcmlhLWxpdmUnLCAnb2ZmJyk7XHJcbiAgaWZyYW1lLnNldEF0dHJpYnV0ZSgnYXJpYS1idXN5JywgJ3RydWUnKTtcclxuICBpZnJhbWUuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsICd0cnVlJyk7XHJcbiAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChpZnJhbWUpO1xyXG5cclxuICB2YXIgX3dpbmRvdyA9IGlmcmFtZS5jb250ZW50V2luZG93O1xyXG4gIHZhciBfZG9jdW1lbnQgPSBfd2luZG93LmRvY3VtZW50O1xyXG5cclxuICBfZG9jdW1lbnQub3BlbigpO1xyXG4gIF9kb2N1bWVudC5jbG9zZSgpO1xyXG4gIHZhciB3cmFwcGVyID0gX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gIF9kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHdyYXBwZXIpO1xyXG5cclxuICBkYXRhLmlmcmFtZSA9IGlmcmFtZTtcclxuICBkYXRhLndyYXBwZXIgPSB3cmFwcGVyO1xyXG4gIGRhdGEud2luZG93ID0gX3dpbmRvdztcclxuICBkYXRhLmRvY3VtZW50ID0gX2RvY3VtZW50O1xyXG5cclxuICByZXR1cm4gZGF0YTtcclxufVxyXG5cclxuLy8gb3B0aW9ucy5lbGVtZW50OlxyXG4vLyAge3N0cmluZ30gZWxlbWVudCBuYW1lXHJcbi8vICB7ZnVuY3Rpb259IGNhbGxiYWNrKHdyYXBwZXIsIGRvY3VtZW50KSB0byBnZW5lcmF0ZSBhbiBlbGVtZW50XHJcbi8vIG9wdGlvbnMubXV0YXRlOiAob3B0aW9uYWwpXHJcbi8vICB7ZnVuY3Rpb259IGNhbGxiYWNrKGVsZW1lbnQsIHdyYXBwZXIsIGRvY3VtZW50KSB0byBtYW5pcHVsYXRlIGVsZW1lbnQgcHJpb3IgdG8gZm9jdXMtdGVzdC5cclxuLy8gICAgICAgICAgICAgQ2FuIHJldHVybiBET01FbGVtZW50IHRvIGRlZmluZSBmb2N1cyB0YXJnZXQgKGRlZmF1bHQ6IGVsZW1lbnQpXHJcbi8vIG9wdGlvbnMudmFsaWRhdGU6IChvcHRpb25hbClcclxuLy8gIHtmdW5jdGlvbn0gY2FsbGJhY2soZWxlbWVudCwgZm9jdXNUYXJnZXQsIGRvY3VtZW50KSB0byBtYW5pcHVsYXRlIHRlc3QtcmVzdWx0XHJcbmZ1bmN0aW9uIHRlc3QoZGF0YSwgb3B0aW9ucykge1xyXG4gIC8vIG1ha2Ugc3VyZSB3ZSBvcGVyYXRlIG9uIGEgY2xlYW4gc2xhdGVcclxuICBkYXRhLndyYXBwZXIuaW5uZXJIVE1MID0gJyc7XHJcbiAgLy8gY3JlYXRlIGR1bW15IGVsZW1lbnQgdG8gdGVzdCBmb2N1c2FiaWxpdHkgb2ZcclxuICB2YXIgZWxlbWVudCA9IHR5cGVvZiBvcHRpb25zLmVsZW1lbnQgPT09ICdzdHJpbmcnID8gZGF0YS5kb2N1bWVudC5jcmVhdGVFbGVtZW50KG9wdGlvbnMuZWxlbWVudCkgOiBvcHRpb25zLmVsZW1lbnQoZGF0YS53cmFwcGVyLCBkYXRhLmRvY3VtZW50KTtcclxuICAvLyBhbGxvdyBjYWxsYmFjayB0byBmdXJ0aGVyIHNwZWNpZnkgZHVtbXkgZWxlbWVudFxyXG4gIC8vIGFuZCBvcHRpb25hbGx5IGRlZmluZSBlbGVtZW50IHRvIGZvY3VzXHJcbiAgdmFyIGZvY3VzID0gb3B0aW9ucy5tdXRhdGUgJiYgb3B0aW9ucy5tdXRhdGUoZWxlbWVudCwgZGF0YS53cmFwcGVyLCBkYXRhLmRvY3VtZW50KTtcclxuICBpZiAoIWZvY3VzICYmIGZvY3VzICE9PSBmYWxzZSkge1xyXG4gICAgZm9jdXMgPSBlbGVtZW50O1xyXG4gIH1cclxuICAvLyBlbGVtZW50IG5lZWRzIHRvIGJlIHBhcnQgb2YgdGhlIERPTSB0byBiZSBmb2N1c2FibGVcclxuICAhZWxlbWVudC5wYXJlbnROb2RlICYmIGRhdGEud3JhcHBlci5hcHBlbmRDaGlsZChlbGVtZW50KTtcclxuICAvLyB0ZXN0IGlmIHRoZSBlbGVtZW50IHdpdGggaW52YWxpZCB0YWJpbmRleCBjYW4gYmUgZm9jdXNlZFxyXG4gIGZvY3VzICYmIGZvY3VzLmZvY3VzICYmIGZvY3VzLmZvY3VzKCk7XHJcbiAgLy8gdmFsaWRhdGUgdGVzdCdzIHJlc3VsdFxyXG4gIHJldHVybiBvcHRpb25zLnZhbGlkYXRlID8gb3B0aW9ucy52YWxpZGF0ZShlbGVtZW50LCBmb2N1cywgZGF0YS5kb2N1bWVudCkgOiBkYXRhLmRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IGZvY3VzO1xyXG59XHJcblxyXG5mdW5jdGlvbiBhZnRlcihkYXRhKSB7XHJcbiAgLy8gcmVzdG9yZSBmb2N1cyB0byB3aGF0IGl0IHdhcyBiZWZvcmUgdGVzdCBhbmQgY2xlYW51cFxyXG4gIGlmIChkYXRhLmFjdGl2ZUVsZW1lbnQgPT09IGRvY3VtZW50LmJvZHkpIHtcclxuICAgIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgJiYgZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5ibHVyICYmIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuYmx1cigpO1xyXG4gICAgaWYgKF9wbGF0Zm9ybTIuZGVmYXVsdC5pcy5JRTEwKSB7XHJcbiAgICAgIC8vIElFMTAgZG9lcyBub3QgcmVkaXJlY3QgZm9jdXMgdG8gPGJvZHk+IHdoZW4gdGhlIGFjdGl2ZUVsZW1lbnQgaXMgcmVtb3ZlZFxyXG4gICAgICBkb2N1bWVudC5ib2R5LmZvY3VzKCk7XHJcbiAgICB9XHJcbiAgfSBlbHNlIHtcclxuICAgIGRhdGEuYWN0aXZlRWxlbWVudCAmJiBkYXRhLmFjdGl2ZUVsZW1lbnQuZm9jdXMgJiYgZGF0YS5hY3RpdmVFbGVtZW50LmZvY3VzKCk7XHJcbiAgfVxyXG5cclxuICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGRhdGEuaWZyYW1lKTtcclxuXHJcbiAgLy8gcmVzdG9yZSBzY3JvbGwgcG9zaXRpb25cclxuICB3aW5kb3cuc2Nyb2xsVG9wID0gZGF0YS53aW5kb3dTY3JvbGxUb3A7XHJcbiAgd2luZG93LnNjcm9sbExlZnQgPSBkYXRhLndpbmRvd1Njcm9sbExlZnQ7XHJcbiAgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3AgPSBkYXRhLmJvZHlTY3JvbGxUb3A7XHJcbiAgZG9jdW1lbnQuYm9keS5zY3JvbGxMZWZ0ID0gZGF0YS5ib2R5U2Nyb2xsTGVmdDtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRldGVjdC1mb2N1cy5qcy5tYXAiLCIndXNlIHN0cmljdCc7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfZ2lmID0gcmVxdWlyZSgnLi9tZWRpYS9naWYnKTtcclxuXHJcbnZhciBfZ2lmMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dpZik7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9FbGVtZW50L2ltZyNhdHRyLXVzZW1hcFxyXG5leHBvcnRzLmRlZmF1bHQgPSB7XHJcbiAgZWxlbWVudDogJ2RpdicsXHJcbiAgbXV0YXRlOiBmdW5jdGlvbiBtdXRhdGUoZWxlbWVudCkge1xyXG4gICAgZWxlbWVudC5pbm5lckhUTUwgPSAnPG1hcCBuYW1lPVwiaW1hZ2UtbWFwLXRhYmluZGV4LXRlc3RcIj4nICsgJzxhcmVhIHNoYXBlPVwicmVjdFwiIGNvb3Jkcz1cIjYzLDE5LDE0NCw0NVwiPjwvbWFwPicgKyAnPGltZyB1c2VtYXA9XCIjaW1hZ2UtbWFwLXRhYmluZGV4LXRlc3RcIiB0YWJpbmRleD1cIi0xXCIgYWx0PVwiXCIgc3JjPVwiJyArIF9naWYyLmRlZmF1bHQgKyAnXCI+JztcclxuXHJcbiAgICByZXR1cm4gZWxlbWVudC5xdWVyeVNlbGVjdG9yKCdhcmVhJyk7XHJcbiAgfVxyXG59O1xyXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9jdXMtYXJlYS1pbWctdGFiaW5kZXguanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX2dpZiA9IHJlcXVpcmUoJy4vbWVkaWEvZ2lmJyk7XHJcblxyXG52YXIgX2dpZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9naWYpO1xyXG5cclxudmFyIF9wbGF0Zm9ybSA9IHJlcXVpcmUoJy4uL3V0aWwvcGxhdGZvcm0nKTtcclxuXHJcbnZhciBfcGxhdGZvcm0yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcGxhdGZvcm0pO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvRWxlbWVudC9pbWcjYXR0ci11c2VtYXBcclxuZXhwb3J0cy5kZWZhdWx0ID0ge1xyXG4gIGVsZW1lbnQ6ICdkaXYnLFxyXG4gIG11dGF0ZTogZnVuY3Rpb24gbXV0YXRlKGVsZW1lbnQpIHtcclxuICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gJzxtYXAgbmFtZT1cImltYWdlLW1hcC10YWJpbmRleC10ZXN0XCI+JyArICc8YXJlYSBocmVmPVwiI3ZvaWRcIiB0YWJpbmRleD1cIi0xXCIgc2hhcGU9XCJyZWN0XCIgY29vcmRzPVwiNjMsMTksMTQ0LDQ1XCI+PC9tYXA+JyArICc8aW1nIHVzZW1hcD1cIiNpbWFnZS1tYXAtdGFiaW5kZXgtdGVzdFwiIGFsdD1cIlwiIHNyYz1cIicgKyBfZ2lmMi5kZWZhdWx0ICsgJ1wiPic7XHJcblxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH0sXHJcbiAgdmFsaWRhdGU6IGZ1bmN0aW9uIHZhbGlkYXRlKGVsZW1lbnQsIGZvY3VzVGFyZ2V0LCBfZG9jdW1lbnQpIHtcclxuICAgIGlmIChfcGxhdGZvcm0yLmRlZmF1bHQuaXMuR0VDS08pIHtcclxuICAgICAgLy8gZml4ZXMgaHR0cHM6Ly9naXRodWIuY29tL21lZGlhbGl6ZS9hbGx5LmpzL2lzc3Vlcy8zNVxyXG4gICAgICAvLyBGaXJlZm94IGxvYWRzIHRoZSBEYXRhVVJJIGFzeW5jaHJvbm91c2x5LCBjYXVzaW5nIGEgZmFsc2UtbmVnYXRpdmVcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGZvY3VzID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yKCdhcmVhJyk7XHJcbiAgICBmb2N1cy5mb2N1cygpO1xyXG4gICAgcmV0dXJuIF9kb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSBmb2N1cztcclxuICB9XHJcbn07XHJcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb2N1cy1hcmVhLXRhYmluZGV4LmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9naWYgPSByZXF1aXJlKCcuL21lZGlhL2dpZicpO1xyXG5cclxudmFyIF9naWYyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2lmKTtcclxuXHJcbnZhciBfcGxhdGZvcm0gPSByZXF1aXJlKCcuLi91dGlsL3BsYXRmb3JtJyk7XHJcblxyXG52YXIgX3BsYXRmb3JtMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BsYXRmb3JtKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0VsZW1lbnQvaW1nI2F0dHItdXNlbWFwXHJcbmV4cG9ydHMuZGVmYXVsdCA9IHtcclxuICBlbGVtZW50OiAnZGl2JyxcclxuICBtdXRhdGU6IGZ1bmN0aW9uIG11dGF0ZShlbGVtZW50KSB7XHJcbiAgICBlbGVtZW50LmlubmVySFRNTCA9ICc8bWFwIG5hbWU9XCJpbWFnZS1tYXAtYXJlYS1ocmVmLXRlc3RcIj4nICsgJzxhcmVhIHNoYXBlPVwicmVjdFwiIGNvb3Jkcz1cIjYzLDE5LDE0NCw0NVwiPjwvbWFwPicgKyAnPGltZyB1c2VtYXA9XCIjaW1hZ2UtbWFwLWFyZWEtaHJlZi10ZXN0XCIgYWx0PVwiXCIgc3JjPVwiJyArIF9naWYyLmRlZmF1bHQgKyAnXCI+JztcclxuXHJcbiAgICByZXR1cm4gZWxlbWVudC5xdWVyeVNlbGVjdG9yKCdhcmVhJyk7XHJcbiAgfSxcclxuICB2YWxpZGF0ZTogZnVuY3Rpb24gdmFsaWRhdGUoZWxlbWVudCwgZm9jdXNUYXJnZXQsIF9kb2N1bWVudCkge1xyXG4gICAgaWYgKF9wbGF0Zm9ybTIuZGVmYXVsdC5pcy5HRUNLTykge1xyXG4gICAgICAvLyBmaXhlcyBodHRwczovL2dpdGh1Yi5jb20vbWVkaWFsaXplL2FsbHkuanMvaXNzdWVzLzM1XHJcbiAgICAgIC8vIEZpcmVmb3ggbG9hZHMgdGhlIERhdGFVUkkgYXN5bmNocm9ub3VzbHksIGNhdXNpbmcgYSBmYWxzZS1uZWdhdGl2ZVxyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gX2RvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IGZvY3VzVGFyZ2V0O1xyXG4gIH1cclxufTtcclxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvY3VzLWFyZWEtd2l0aG91dC1ocmVmLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9tcCA9IHJlcXVpcmUoJy4vbWVkaWEvbXAzJyk7XHJcblxyXG52YXIgX21wMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21wKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSB7XHJcbiAgbmFtZTogJ2Nhbi1mb2N1cy1hdWRpby13aXRob3V0LWNvbnRyb2xzJyxcclxuICBlbGVtZW50OiAnYXVkaW8nLFxyXG4gIG11dGF0ZTogZnVuY3Rpb24gbXV0YXRlKGVsZW1lbnQpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIGludmFsaWQgbWVkaWEgZmlsZSBjYW4gdHJpZ2dlciB3YXJuaW5nIGluIGNvbnNvbGUsIGRhdGEtdXJpIHRvIHByZXZlbnQgSFRUUCByZXF1ZXN0XHJcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdzcmMnLCBfbXAyLmRlZmF1bHQpO1xyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAvLyBJRTkgbWF5IHRocm93IFwiRXJyb3I6IE5vdCBpbXBsZW1lbnRlZFwiXHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9jdXMtYXVkaW8td2l0aG91dC1jb250cm9scy5qcy5tYXAiLCIndXNlIHN0cmljdCc7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfZ2lmID0gcmVxdWlyZSgnLi9tZWRpYS9naWYuaW52YWxpZCcpO1xyXG5cclxudmFyIF9naWYyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2lmKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG4vLyBOT1RFOiBodHRwczovL2dpdGh1Yi5jb20vbWVkaWFsaXplL2FsbHkuanMvaXNzdWVzLzM1XHJcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvRWxlbWVudC9pbWcjYXR0ci11c2VtYXBcclxuZXhwb3J0cy5kZWZhdWx0ID0ge1xyXG4gIGVsZW1lbnQ6ICdkaXYnLFxyXG4gIG11dGF0ZTogZnVuY3Rpb24gbXV0YXRlKGVsZW1lbnQpIHtcclxuICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gJzxtYXAgbmFtZT1cImJyb2tlbi1pbWFnZS1tYXAtdGVzdFwiPjxhcmVhIGhyZWY9XCIjdm9pZFwiIHNoYXBlPVwicmVjdFwiIGNvb3Jkcz1cIjYzLDE5LDE0NCw0NVwiPjwvbWFwPicgKyAnPGltZyB1c2VtYXA9XCIjYnJva2VuLWltYWdlLW1hcC10ZXN0XCIgYWx0PVwiXCIgc3JjPVwiJyArIF9naWYyLmRlZmF1bHQgKyAnXCI+JztcclxuXHJcbiAgICByZXR1cm4gZWxlbWVudC5xdWVyeVNlbGVjdG9yKCdhcmVhJyk7XHJcbiAgfVxyXG59O1xyXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9jdXMtYnJva2VuLWltYWdlLW1hcC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbi8vIENoaWxkcmVuIG9mIGZvY3VzYWJsZSBlbGVtZW50cyB3aXRoIGRpc3BsYXk6ZmxleCBhcmUgZm9jdXNhYmxlIGluIElFMTAtMTFcclxuZXhwb3J0cy5kZWZhdWx0ID0ge1xyXG4gIGVsZW1lbnQ6ICdkaXYnLFxyXG4gIG11dGF0ZTogZnVuY3Rpb24gbXV0YXRlKGVsZW1lbnQpIHtcclxuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsICctMScpO1xyXG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJ2Rpc3BsYXk6IC13ZWJraXQtZmxleDsgZGlzcGxheTogLW1zLWZsZXhib3g7IGRpc3BsYXk6IGZsZXg7Jyk7XHJcbiAgICBlbGVtZW50LmlubmVySFRNTCA9ICc8c3BhbiBzdHlsZT1cImRpc3BsYXk6IGJsb2NrO1wiPmhlbGxvPC9zcGFuPic7XHJcbiAgICByZXR1cm4gZWxlbWVudC5xdWVyeVNlbGVjdG9yKCdzcGFuJyk7XHJcbiAgfVxyXG59O1xyXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9jdXMtY2hpbGRyZW4tb2YtZm9jdXNhYmxlLWZsZXhib3guanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG4vLyBmaWVsZHNldFt0YWJpbmRleD0wXVtkaXNhYmxlZF0gc2hvdWxkIG5vdCBiZSBmb2N1c2FibGUsIGJ1dCBCbGluayBhbmQgV2ViS2l0IGRpc2FncmVlXHJcbi8vIEBzcGVjaWZpY2F0aW9uIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9kaXNhYmxlZC1lbGVtZW50cy5odG1sI2NvbmNlcHQtZWxlbWVudC1kaXNhYmxlZFxyXG4vLyBAYnJvd3Nlci1pc3N1ZSBDaHJvbWl1bSBodHRwczovL2NyYnVnLmNvbS80NTM4NDdcclxuLy8gQGJyb3dzZXItaXNzdWUgV2ViS2l0IGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xNDEwODZcclxuZXhwb3J0cy5kZWZhdWx0ID0ge1xyXG4gIGVsZW1lbnQ6ICdmaWVsZHNldCcsXHJcbiAgbXV0YXRlOiBmdW5jdGlvbiBtdXRhdGUoZWxlbWVudCkge1xyXG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgMCk7XHJcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnZGlzYWJsZWQnLCAnZGlzYWJsZWQnKTtcclxuICB9XHJcbn07XHJcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb2N1cy1maWVsZHNldC1kaXNhYmxlZC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5kZWZhdWx0ID0ge1xyXG4gIGVsZW1lbnQ6ICdmaWVsZHNldCcsXHJcbiAgbXV0YXRlOiBmdW5jdGlvbiBtdXRhdGUoZWxlbWVudCkge1xyXG4gICAgZWxlbWVudC5pbm5lckhUTUwgPSAnPGxlZ2VuZD5sZWdlbmQ8L2xlZ2VuZD48cD5jb250ZW50PC9wPic7XHJcbiAgfVxyXG59O1xyXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9jdXMtZmllbGRzZXQuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG4vLyBlbGVtZW50cyB3aXRoIGRpc3BsYXk6ZmxleCBhcmUgZm9jdXNhYmxlIGluIElFMTAtMTFcclxuZXhwb3J0cy5kZWZhdWx0ID0ge1xyXG4gIGVsZW1lbnQ6ICdzcGFuJyxcclxuICBtdXRhdGU6IGZ1bmN0aW9uIG11dGF0ZShlbGVtZW50KSB7XHJcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAnZGlzcGxheTogLXdlYmtpdC1mbGV4OyBkaXNwbGF5OiAtbXMtZmxleGJveDsgZGlzcGxheTogZmxleDsnKTtcclxuICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gJzxzcGFuIHN0eWxlPVwiZGlzcGxheTogYmxvY2s7XCI+aGVsbG88L3NwYW4+JztcclxuICB9XHJcbn07XHJcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb2N1cy1mbGV4Ym94LWNvbnRhaW5lci5qcy5tYXAiLCIndXNlIHN0cmljdCc7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbi8vIGZvcm1bdGFiaW5kZXg9MF1bZGlzYWJsZWRdIHNob3VsZCBiZSBmb2N1c2FibGUgYXMgdGhlXHJcbi8vIHNwZWNpZmljYXRpb24gZG9lc24ndCBrbm93IHRoZSBkaXNhYmxlZCBhdHRyaWJ1dGUgb24gdGhlIGZvcm0gZWxlbWVudFxyXG4vLyBAc3BlY2lmaWNhdGlvbiBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZm9ybXMuaHRtbCN0aGUtZm9ybS1lbGVtZW50XHJcbmV4cG9ydHMuZGVmYXVsdCA9IHtcclxuICBlbGVtZW50OiAnZm9ybScsXHJcbiAgbXV0YXRlOiBmdW5jdGlvbiBtdXRhdGUoZWxlbWVudCkge1xyXG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgMCk7XHJcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnZGlzYWJsZWQnLCAnZGlzYWJsZWQnKTtcclxuICB9XHJcbn07XHJcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb2N1cy1mb3JtLWRpc2FibGVkLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9naWYgPSByZXF1aXJlKCcuL21lZGlhL2dpZicpO1xyXG5cclxudmFyIF9naWYyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2lmKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG4vLyBOT1RFOiBodHRwczovL2dpdGh1Yi5jb20vbWVkaWFsaXplL2FsbHkuanMvaXNzdWVzLzM1XHJcbi8vIGZpeGVzIGh0dHBzOi8vZ2l0aHViLmNvbS9tZWRpYWxpemUvYWxseS5qcy9pc3N1ZXMvMjBcclxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9FbGVtZW50L2ltZyNhdHRyLWlzbWFwXHJcbmV4cG9ydHMuZGVmYXVsdCA9IHtcclxuICBlbGVtZW50OiAnYScsXHJcbiAgbXV0YXRlOiBmdW5jdGlvbiBtdXRhdGUoZWxlbWVudCkge1xyXG4gICAgZWxlbWVudC5ocmVmID0gJyN2b2lkJztcclxuICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gJzxpbWcgaXNtYXAgc3JjPVwiJyArIF9naWYyLmRlZmF1bHQgKyAnXCIgYWx0PVwiXCI+JztcclxuICAgIHJldHVybiBlbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ2ltZycpO1xyXG4gIH1cclxufTtcclxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvY3VzLWltZy1pc21hcC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfZ2lmID0gcmVxdWlyZSgnLi9tZWRpYS9naWYnKTtcclxuXHJcbnZhciBfZ2lmMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dpZik7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuLy8gTk9URTogaHR0cHM6Ly9naXRodWIuY29tL21lZGlhbGl6ZS9hbGx5LmpzL2lzc3Vlcy8zNVxyXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0VsZW1lbnQvaW1nI2F0dHItdXNlbWFwXHJcbmV4cG9ydHMuZGVmYXVsdCA9IHtcclxuICBlbGVtZW50OiAnZGl2JyxcclxuICBtdXRhdGU6IGZ1bmN0aW9uIG11dGF0ZShlbGVtZW50KSB7XHJcbiAgICBlbGVtZW50LmlubmVySFRNTCA9ICc8bWFwIG5hbWU9XCJpbWFnZS1tYXAtdGFiaW5kZXgtdGVzdFwiPjxhcmVhIGhyZWY9XCIjdm9pZFwiIHNoYXBlPVwicmVjdFwiIGNvb3Jkcz1cIjYzLDE5LDE0NCw0NVwiPjwvbWFwPicgKyAnPGltZyB1c2VtYXA9XCIjaW1hZ2UtbWFwLXRhYmluZGV4LXRlc3RcIiB0YWJpbmRleD1cIi0xXCIgYWx0PVwiXCIgJyArICdzcmM9XCInICsgX2dpZjIuZGVmYXVsdCArICdcIj4nO1xyXG5cclxuICAgIHJldHVybiBlbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ2ltZycpO1xyXG4gIH1cclxufTtcclxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvY3VzLWltZy11c2VtYXAtdGFiaW5kZXguanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IHtcclxuICBlbGVtZW50OiBmdW5jdGlvbiBlbGVtZW50KHdyYXBwZXIsIF9kb2N1bWVudCkge1xyXG4gICAgdmFyIGlmcmFtZSA9IF9kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcclxuXHJcbiAgICAvLyBpZnJhbWUgbXVzdCBiZSBwYXJ0IG9mIHRoZSBET00gYmVmb3JlIGFjY2Vzc2luZyB0aGUgY29udGVudFdpbmRvdyBpcyBwb3NzaWJsZVxyXG4gICAgd3JhcHBlci5hcHBlbmRDaGlsZChpZnJhbWUpO1xyXG5cclxuICAgIC8vIGNyZWF0ZSB0aGUgaWZyYW1lJ3MgZGVmYXVsdCBkb2N1bWVudCAoPGh0bWw+PGhlYWQ+PC9oZWFkPjxib2R5PjwvYm9keT48L2h0bWw+KVxyXG4gICAgdmFyIGlmcmFtZURvY3VtZW50ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ7XHJcbiAgICBpZnJhbWVEb2N1bWVudC5vcGVuKCk7XHJcbiAgICBpZnJhbWVEb2N1bWVudC5jbG9zZSgpO1xyXG4gICAgcmV0dXJuIGlmcmFtZTtcclxuICB9LFxyXG4gIG11dGF0ZTogZnVuY3Rpb24gbXV0YXRlKGlmcmFtZSkge1xyXG4gICAgaWZyYW1lLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcclxuXHJcbiAgICB2YXIgaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcclxuICAgIHZhciBpbnB1dCA9IGlmcmFtZURvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XHJcbiAgICBpZnJhbWVEb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGlucHV0KTtcclxuICAgIHJldHVybiBpbnB1dDtcclxuICB9LFxyXG4gIHZhbGlkYXRlOiBmdW5jdGlvbiB2YWxpZGF0ZShpZnJhbWUpIHtcclxuICAgIHZhciBpZnJhbWVEb2N1bWVudCA9IGlmcmFtZS5jb250ZW50V2luZG93LmRvY3VtZW50O1xyXG4gICAgdmFyIGZvY3VzID0gaWZyYW1lRG9jdW1lbnQucXVlcnlTZWxlY3RvcignaW5wdXQnKTtcclxuICAgIHJldHVybiBpZnJhbWVEb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSBmb2N1cztcclxuICB9XHJcbn07XHJcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb2N1cy1pbi1oaWRkZW4taWZyYW1lLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xyXG4gIHJldHVybiByZXN1bHQ7XHJcbn07XHJcblxyXG52YXIgX3BsYXRmb3JtID0gcmVxdWlyZSgnLi4vdXRpbC9wbGF0Zm9ybScpO1xyXG5cclxudmFyIF9wbGF0Zm9ybTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wbGF0Zm9ybSk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxudmFyIHJlc3VsdCA9ICFfcGxhdGZvcm0yLmRlZmF1bHQuaXMuV0VCS0lUO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvY3VzLWluLXplcm8tZGltZW5zaW9uLW9iamVjdC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbi8vIEZpcmVmb3ggYWxsb3dzICphbnkqIHZhbHVlIGFuZCB0cmVhdHMgaW52YWxpZCB2YWx1ZXMgbGlrZSB0YWJpbmRleD1cIi0xXCJcclxuLy8gQGJyb3dzZXItaXNzdWUgR2Vja28gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTEyODA1NFxyXG5leHBvcnRzLmRlZmF1bHQgPSB7XHJcbiAgZWxlbWVudDogJ2RpdicsXHJcbiAgbXV0YXRlOiBmdW5jdGlvbiBtdXRhdGUoZWxlbWVudCkge1xyXG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgJ2ludmFsaWQtdmFsdWUnKTtcclxuICB9XHJcbn07XHJcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb2N1cy1pbnZhbGlkLXRhYmluZGV4LmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLmRlZmF1bHQgPSB7XHJcbiAgZWxlbWVudDogJ2xhYmVsJyxcclxuICBtdXRhdGU6IGZ1bmN0aW9uIG11dGF0ZShlbGVtZW50KSB7XHJcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAnLTEnKTtcclxuICB9LFxyXG4gIHZhbGlkYXRlOiBmdW5jdGlvbiB2YWxpZGF0ZShlbGVtZW50LCBmb2N1c1RhcmdldCwgX2RvY3VtZW50KSB7XHJcbiAgICAvLyBmb3JjZSBsYXlvdXQgaW4gQ2hyb21lIDQ5LCBvdGhlcndpc2UgdGhlIGVsZW1lbnQgd29uJ3QgYmUgZm9jdXNhYmxlXHJcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xyXG4gICAgdmFyIHZhcmlhYmxlVG9QcmV2ZW50RGVhZENvZGVFbGltaW5hdGlvbiA9IGVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xyXG4gICAgLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtdmFycyAqL1xyXG4gICAgZWxlbWVudC5mb2N1cygpO1xyXG4gICAgcmV0dXJuIF9kb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSBlbGVtZW50O1xyXG4gIH1cclxufTtcclxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvY3VzLWxhYmVsLXRhYmluZGV4LmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9zdmcgPSByZXF1aXJlKCcuL21lZGlhL3N2ZycpO1xyXG5cclxudmFyIF9zdmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3ZnKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG4vLyBOb3RlOiBJRTEwIG9uIEJyb3dzZXJTdGFjayBkb2VzIG5vdCBsaWtlIHRoaXMgdGVzdFxyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0ge1xyXG4gIGVsZW1lbnQ6ICdvYmplY3QnLFxyXG4gIG11dGF0ZTogZnVuY3Rpb24gbXV0YXRlKGVsZW1lbnQpIHtcclxuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCd0eXBlJywgJ2ltYWdlL3N2Zyt4bWwnKTtcclxuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdkYXRhJywgX3N2ZzIuZGVmYXVsdCk7XHJcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnd2lkdGgnLCAnMjAwJyk7XHJcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgJzUwJyk7XHJcbiAgICBlbGVtZW50LnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcclxuICB9XHJcbn07XHJcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb2N1cy1vYmplY3Qtc3ZnLWhpZGRlbi5qcy5tYXAiLCIndXNlIHN0cmljdCc7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfc3ZnID0gcmVxdWlyZSgnLi9tZWRpYS9zdmcnKTtcclxuXHJcbnZhciBfc3ZnMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3N2Zyk7XHJcblxyXG52YXIgX3BsYXRmb3JtID0gcmVxdWlyZSgnLi4vdXRpbC9wbGF0Zm9ybScpO1xyXG5cclxudmFyIF9wbGF0Zm9ybTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wbGF0Zm9ybSk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuLy8gTm90ZTogSUUxMCBvbiBCcm93c2VyU3RhY2sgZG9lcyBub3QgbGlrZSB0aGlzIHRlc3RcclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IHtcclxuICBuYW1lOiAnY2FuLWZvY3VzLW9iamVjdC1zdmcnLFxyXG4gIGVsZW1lbnQ6ICdvYmplY3QnLFxyXG4gIG11dGF0ZTogZnVuY3Rpb24gbXV0YXRlKGVsZW1lbnQpIHtcclxuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCd0eXBlJywgJ2ltYWdlL3N2Zyt4bWwnKTtcclxuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdkYXRhJywgX3N2ZzIuZGVmYXVsdCk7XHJcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnd2lkdGgnLCAnMjAwJyk7XHJcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgJzUwJyk7XHJcbiAgfSxcclxuICB2YWxpZGF0ZTogZnVuY3Rpb24gdmFsaWRhdGUoZWxlbWVudCwgZm9jdXNUYXJnZXQsIF9kb2N1bWVudCkge1xyXG4gICAgaWYgKF9wbGF0Zm9ybTIuZGVmYXVsdC5pcy5HRUNLTykge1xyXG4gICAgICAvLyBGaXJlZm94IHNlZW1zIHRvIGJlIGhhbmRsaW5nIHRoZSBvYmplY3QgY3JlYXRpb24gYXN5bmNocm9ub3VzbHkgYW5kIHRoZXJlYnkgcHJvZHVjZXMgYSBmYWxzZSBuZWdhdGl2ZSB0ZXN0IHJlc3VsdC5cclxuICAgICAgLy8gQmVjYXVzZSB3ZSBrbm93IEZpcmVmb3ggaXMgYWJsZSB0byBmb2N1cyBvYmplY3QgZWxlbWVudHMgcmVmZXJlbmNpbmcgU1ZHcywgd2Ugc2ltcGx5IGNoZWF0IGJ5IHNuaWZmaW5nIHRoZSB1c2VyIGFnZW50IHN0cmluZ1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gX2RvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IGVsZW1lbnQ7XHJcbiAgfVxyXG59O1xyXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9jdXMtb2JqZWN0LXN2Zy5qcy5tYXAiLCIndXNlIHN0cmljdCc7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcclxuICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5cclxudmFyIF9wbGF0Zm9ybSA9IHJlcXVpcmUoJy4uL3V0aWwvcGxhdGZvcm0nKTtcclxuXHJcbnZhciBfcGxhdGZvcm0yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcGxhdGZvcm0pO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbi8vIEV2ZXJ5IEVudmlyb25tZW50IGV4Y2VwdCBJRTkgY29uc2lkZXJzIFNXRiBvYmplY3RzIGZvY3VzYWJsZVxyXG52YXIgcmVzdWx0ID0gIV9wbGF0Zm9ybTIuZGVmYXVsdC5pcy5JRTk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9jdXMtb2JqZWN0LXN3Zi5qcy5tYXAiLCIndXNlIHN0cmljdCc7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfZ2lmID0gcmVxdWlyZSgnLi9tZWRpYS9naWYnKTtcclxuXHJcbnZhciBfZ2lmMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dpZik7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0ge1xyXG4gIGVsZW1lbnQ6ICdkaXYnLFxyXG4gIG11dGF0ZTogZnVuY3Rpb24gbXV0YXRlKGVsZW1lbnQpIHtcclxuICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gJzxtYXAgbmFtZT1cImZvY3VzLXJlZGlyZWN0LWltZy11c2VtYXBcIj48YXJlYSBocmVmPVwiI3ZvaWRcIiBzaGFwZT1cInJlY3RcIiBjb29yZHM9XCI2MywxOSwxNDQsNDVcIj48L21hcD4nICsgJzxpbWcgdXNlbWFwPVwiI2ZvY3VzLXJlZGlyZWN0LWltZy11c2VtYXBcIiBhbHQ9XCJcIiAnICsgJ3NyYz1cIicgKyBfZ2lmMi5kZWZhdWx0ICsgJ1wiPic7XHJcblxyXG4gICAgLy8gZm9jdXMgdGhlIDxpbWc+LCBub3QgdGhlIDxkaXY+XHJcbiAgICByZXR1cm4gZWxlbWVudC5xdWVyeVNlbGVjdG9yKCdpbWcnKTtcclxuICB9LFxyXG4gIHZhbGlkYXRlOiBmdW5jdGlvbiB2YWxpZGF0ZShlbGVtZW50LCBmb2N1c1RhcmdldCwgX2RvY3VtZW50KSB7XHJcbiAgICB2YXIgdGFyZ2V0ID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yKCdhcmVhJyk7XHJcbiAgICByZXR1cm4gX2RvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IHRhcmdldDtcclxuICB9XHJcbn07XHJcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb2N1cy1yZWRpcmVjdC1pbWctdXNlbWFwLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxuLy8gc2VlIGh0dHBzOi8vanNiaW4uY29tL25lbmlyaXNhZ2UvZWRpdD9odG1sLGpzLGNvbnNvbGUsb3V0cHV0XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSB7XHJcbiAgZWxlbWVudDogJ2ZpZWxkc2V0JyxcclxuICBtdXRhdGU6IGZ1bmN0aW9uIG11dGF0ZShlbGVtZW50KSB7XHJcbiAgICBlbGVtZW50LmlubmVySFRNTCA9ICc8bGVnZW5kPmxlZ2VuZDwvbGVnZW5kPjxpbnB1dCB0YWJpbmRleD1cIi0xXCI+PGlucHV0IHRhYmluZGV4PVwiMFwiPic7XHJcbiAgICAvLyB0YWtlIGNhcmUgb2YgZm9jdXMgaW4gdmFsaWRhdGUoKTtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9LFxyXG4gIHZhbGlkYXRlOiBmdW5jdGlvbiB2YWxpZGF0ZShlbGVtZW50LCBmb2N1c1RhcmdldCwgX2RvY3VtZW50KSB7XHJcbiAgICB2YXIgZm9jdXNhYmxlID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yKCdpbnB1dFt0YWJpbmRleD1cIi0xXCJdJyk7XHJcbiAgICB2YXIgdGFiYmFibGUgPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ2lucHV0W3RhYmluZGV4PVwiMFwiXScpO1xyXG5cclxuICAgIC8vIEZpcmVmb3ggcmVxdWlyZXMgdGhpcyB0ZXN0IHRvIGZvY3VzIHRoZSA8ZmllbGRzZXQ+IGZpcnN0LCB3aGlsZSB0aGlzIGlzIG5vdCBuZWNlc3NhcnkgaW5cclxuICAgIC8vIGh0dHBzOi8vanNiaW4uY29tL25lbmlyaXNhZ2UvZWRpdD9odG1sLGpzLGNvbnNvbGUsb3V0cHV0XHJcbiAgICBlbGVtZW50LmZvY3VzKCk7XHJcblxyXG4gICAgZWxlbWVudC5xdWVyeVNlbGVjdG9yKCdsZWdlbmQnKS5mb2N1cygpO1xyXG4gICAgcmV0dXJuIF9kb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSBmb2N1c2FibGUgJiYgJ2ZvY3VzYWJsZScgfHwgX2RvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IHRhYmJhYmxlICYmICd0YWJiYWJsZScgfHwgJyc7XHJcbiAgfVxyXG59O1xyXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9jdXMtcmVkaXJlY3QtbGVnZW5kLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxuLy8gaHR0cHM6Ly9naXRodWIuY29tL21lZGlhbGl6ZS9hbGx5LmpzL2lzc3Vlcy8yMVxyXG5leHBvcnRzLmRlZmF1bHQgPSB7XHJcbiAgZWxlbWVudDogJ2RpdicsXHJcbiAgbXV0YXRlOiBmdW5jdGlvbiBtdXRhdGUoZWxlbWVudCkge1xyXG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJ3dpZHRoOiAxMDBweDsgaGVpZ2h0OiA1MHB4OyBvdmVyZmxvdzogYXV0bzsnKTtcclxuICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gJzxkaXYgc3R5bGU9XCJ3aWR0aDogNTAwcHg7IGhlaWdodDogNDBweDtcIj5zY3JvbGxhYmxlIGNvbnRlbnQ8L2Rpdj4nO1xyXG4gICAgcmV0dXJuIGVsZW1lbnQucXVlcnlTZWxlY3RvcignZGl2Jyk7XHJcbiAgfVxyXG59O1xyXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9jdXMtc2Nyb2xsLWJvZHkuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbWVkaWFsaXplL2FsbHkuanMvaXNzdWVzLzIxXHJcbmV4cG9ydHMuZGVmYXVsdCA9IHtcclxuICBlbGVtZW50OiAnZGl2JyxcclxuICBtdXRhdGU6IGZ1bmN0aW9uIG11dGF0ZShlbGVtZW50KSB7XHJcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAnd2lkdGg6IDEwMHB4OyBoZWlnaHQ6IDUwcHg7Jyk7XHJcbiAgICBlbGVtZW50LmlubmVySFRNTCA9ICc8ZGl2IHN0eWxlPVwid2lkdGg6IDUwMHB4OyBoZWlnaHQ6IDQwcHg7XCI+c2Nyb2xsYWJsZSBjb250ZW50PC9kaXY+JztcclxuICB9XHJcbn07XHJcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb2N1cy1zY3JvbGwtY29udGFpbmVyLXdpdGhvdXQtb3ZlcmZsb3cuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbWVkaWFsaXplL2FsbHkuanMvaXNzdWVzLzIxXHJcbmV4cG9ydHMuZGVmYXVsdCA9IHtcclxuICBlbGVtZW50OiAnZGl2JyxcclxuICBtdXRhdGU6IGZ1bmN0aW9uIG11dGF0ZShlbGVtZW50KSB7XHJcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAnd2lkdGg6IDEwMHB4OyBoZWlnaHQ6IDUwcHg7IG92ZXJmbG93OiBhdXRvOycpO1xyXG4gICAgZWxlbWVudC5pbm5lckhUTUwgPSAnPGRpdiBzdHlsZT1cIndpZHRoOiA1MDBweDsgaGVpZ2h0OiA0MHB4O1wiPnNjcm9sbGFibGUgY29udGVudDwvZGl2Pic7XHJcbiAgfVxyXG59O1xyXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9jdXMtc2Nyb2xsLWNvbnRhaW5lci5qcy5tYXAiLCIndXNlIHN0cmljdCc7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5kZWZhdWx0ID0ge1xyXG4gIGVsZW1lbnQ6ICdkZXRhaWxzJyxcclxuICBtdXRhdGU6IGZ1bmN0aW9uIG11dGF0ZShlbGVtZW50KSB7XHJcbiAgICBlbGVtZW50LmlubmVySFRNTCA9ICc8c3VtbWFyeT5mb288L3N1bW1hcnk+PHA+Y29udGVudDwvcD4nO1xyXG4gICAgcmV0dXJuIGVsZW1lbnQuZmlyc3RFbGVtZW50Q2hpbGQ7XHJcbiAgfVxyXG59O1xyXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9jdXMtc3VtbWFyeS5qcy5tYXAiLCIndXNlIHN0cmljdCc7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfc3ZnID0gcmVxdWlyZSgnLi9oZWxwZXIvc3ZnJyk7XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSB7XHJcbiAgZWxlbWVudDogJ2RpdicsXHJcbiAgbXV0YXRlOiBmdW5jdGlvbiBtdXRhdGUoZWxlbWVudCkge1xyXG4gICAgZWxlbWVudC5pbm5lckhUTUwgPSAoMCwgX3N2Zy5nZW5lcmF0ZSkoJzx0ZXh0IGZvY3VzYWJsZT1cInRydWVcIj5hPC90ZXh0PicpO1xyXG4gICAgcmV0dXJuIGVsZW1lbnQucXVlcnlTZWxlY3RvcigndGV4dCcpO1xyXG4gIH0sXHJcbiAgdmFsaWRhdGU6IF9zdmcudmFsaWRhdGVcclxufTtcclxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvY3VzLXN2Zy1mb2N1c2FibGUtYXR0cmlidXRlLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9zdmcgPSByZXF1aXJlKCcuL2hlbHBlci9zdmcnKTtcclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IHtcclxuICBlbGVtZW50OiAnZGl2JyxcclxuICBtdXRhdGU6IGZ1bmN0aW9uIG11dGF0ZShlbGVtZW50KSB7XHJcbiAgICBlbGVtZW50LmlubmVySFRNTCA9ICgwLCBfc3ZnLmdlbmVyYXRlKSgnPGZvcmVpZ25PYmplY3QgdGFiaW5kZXg9XCItMVwiPjxpbnB1dCB0eXBlPVwidGV4dFwiIC8+PC9mb3JlaWduT2JqZWN0PicpO1xyXG4gICAgLy8gU2FmYXJpIDgncyBxdWVyc1NlbGVjdG9yKCkgY2FuJ3QgaWRlbnRpZnkgZm9yZWlnbk9iamVjdCwgYnV0IGdldEVsZW1lbnR5QnlUYWdOYW1lKCkgY2FuXHJcbiAgICByZXR1cm4gZWxlbWVudC5xdWVyeVNlbGVjdG9yKCdmb3JlaWduT2JqZWN0JykgfHwgZWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnZm9yZWlnbk9iamVjdCcpWzBdO1xyXG4gIH0sXHJcbiAgdmFsaWRhdGU6IF9zdmcudmFsaWRhdGVcclxuXHJcbn07XHJcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb2N1cy1zdmctZm9yZWlnbm9iamVjdC10YWJpbmRleC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcclxuICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5cclxudmFyIF9wbGF0Zm9ybSA9IHJlcXVpcmUoJy4uL3V0aWwvcGxhdGZvcm0nKTtcclxuXHJcbnZhciBfcGxhdGZvcm0yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcGxhdGZvcm0pO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbi8vIEZpcmVmb3ggc2VlbXMgdG8gYmUgaGFuZGxpbmcgdGhlIFNWRy1kb2N1bWVudC1pbi1pZnJhbWUgY3JlYXRpb24gYXN5bmNocm9ub3VzbHlcclxuLy8gYW5kIHRoZXJlYnkgcHJvZHVjZXMgYSBmYWxzZSBuZWdhdGl2ZSB0ZXN0IHJlc3VsdC4gVGh1cyB0aGUgdGVzdCBpcyBwb2ludGxlc3NcclxuLy8gYW5kIHdlIHJlc29ydCB0byBVQSBzbmlmZmluZyBvbmNlIGFnYWluLlxyXG4vLyBzZWUgaHR0cDovL2pzYmluLmNvbS92dW5hZG9ob2tvLzEvZWRpdD9qcyxjb25zb2xlLG91dHB1dFxyXG5cclxudmFyIHJlc3VsdCA9IEJvb2xlYW4oX3BsYXRmb3JtMi5kZWZhdWx0LmlzLkdFQ0tPICYmIHR5cGVvZiBTVkdFbGVtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBTVkdFbGVtZW50LnByb3RvdHlwZS5mb2N1cyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9jdXMtc3ZnLWluLWlmcmFtZS5qcy5tYXAiLCIndXNlIHN0cmljdCc7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfc3ZnID0gcmVxdWlyZSgnLi9oZWxwZXIvc3ZnJyk7XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSB7XHJcbiAgZWxlbWVudDogJ2RpdicsXHJcbiAgbXV0YXRlOiBmdW5jdGlvbiBtdXRhdGUoZWxlbWVudCkge1xyXG4gICAgZWxlbWVudC5pbm5lckhUTUwgPSAoMCwgX3N2Zy5nZW5lcmF0ZSkoJzx0ZXh0IHRhYmluZGV4PVwiLTFcIj5hPC90ZXh0PicpO1xyXG4gICAgcmV0dXJuIGVsZW1lbnQucXVlcnlTZWxlY3RvcigndGV4dCcpO1xyXG4gIH0sXHJcbiAgdmFsaWRhdGU6IF9zdmcudmFsaWRhdGVcclxufTtcclxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvY3VzLXN2Zy1uZWdhdGl2ZS10YWJpbmRleC1hdHRyaWJ1dGUuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX3N2ZyA9IHJlcXVpcmUoJy4vaGVscGVyL3N2ZycpO1xyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0ge1xyXG4gIGVsZW1lbnQ6ICdkaXYnLFxyXG4gIG11dGF0ZTogZnVuY3Rpb24gbXV0YXRlKGVsZW1lbnQpIHtcclxuICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gKDAsIF9zdmcuZ2VuZXJhdGUpKCc8dGV4dCB0YWJpbmRleD1cIjBcIj5hPC90ZXh0PicpO1xyXG4gICAgcmV0dXJuIGVsZW1lbnQucXVlcnlTZWxlY3RvcigndGV4dCcpO1xyXG4gIH0sXHJcbiAgdmFsaWRhdGU6IF9zdmcudmFsaWRhdGVcclxufTtcclxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvY3VzLXN2Zy10YWJpbmRleC1hdHRyaWJ1dGUuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX3N2ZyA9IHJlcXVpcmUoJy4vaGVscGVyL3N2ZycpO1xyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0ge1xyXG4gIGVsZW1lbnQ6ICdkaXYnLFxyXG4gIG11dGF0ZTogZnVuY3Rpb24gbXV0YXRlKGVsZW1lbnQpIHtcclxuICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gKDAsIF9zdmcuZ2VuZXJhdGUpKFsnPGcgaWQ9XCJhbGx5LXRlc3QtdGFyZ2V0XCI+PGEgeGxpbms6aHJlZj1cIiN2b2lkXCI+PHRleHQ+bGluazwvdGV4dD48L2E+PC9nPicsICc8dXNlIHhsaW5rOmhyZWY9XCIjYWxseS10ZXN0LXRhcmdldFwiIHg9XCIwXCIgeT1cIjBcIiB0YWJpbmRleD1cIi0xXCIgLz4nXS5qb2luKCcnKSk7XHJcblxyXG4gICAgcmV0dXJuIGVsZW1lbnQucXVlcnlTZWxlY3RvcigndXNlJyk7XHJcbiAgfSxcclxuICB2YWxpZGF0ZTogX3N2Zy52YWxpZGF0ZVxyXG59O1xyXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9jdXMtc3ZnLXVzZS10YWJpbmRleC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfc3ZnID0gcmVxdWlyZSgnLi9oZWxwZXIvc3ZnJyk7XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSB7XHJcbiAgZWxlbWVudDogJ2RpdicsXHJcbiAgbXV0YXRlOiBmdW5jdGlvbiBtdXRhdGUoZWxlbWVudCkge1xyXG4gICAgZWxlbWVudC5pbm5lckhUTUwgPSAoMCwgX3N2Zy5nZW5lcmF0ZSkoJycpO1xyXG4gICAgcmV0dXJuIGVsZW1lbnQuZmlyc3RDaGlsZDtcclxuICB9LFxyXG4gIHZhbGlkYXRlOiBfc3ZnLnZhbGlkYXRlXHJcbn07XHJcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb2N1cy1zdmcuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG4vLyBGaXJlZm94IGFsbG93cyAqYW55KiB2YWx1ZSBhbmQgdHJlYXRzIGludmFsaWQgdmFsdWVzIGxpa2UgdGFiaW5kZXg9XCItMVwiXHJcbi8vIEBicm93c2VyLWlzc3VlIEdlY2tvIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTExMjgwNTRcclxuZXhwb3J0cy5kZWZhdWx0ID0ge1xyXG4gIGVsZW1lbnQ6ICdkaXYnLFxyXG4gIG11dGF0ZTogZnVuY3Rpb24gbXV0YXRlKGVsZW1lbnQpIHtcclxuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsICczeCcpO1xyXG4gIH1cclxufTtcclxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvY3VzLXRhYmluZGV4LXRyYWlsaW5nLWNoYXJhY3RlcnMuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IHtcclxuICBlbGVtZW50OiAndGFibGUnLFxyXG4gIG11dGF0ZTogZnVuY3Rpb24gbXV0YXRlKGVsZW1lbnQsIHdyYXBwZXIsIF9kb2N1bWVudCkge1xyXG4gICAgLy8gSUU5IGhhcyBhIHByb2JsZW0gcmVwbGFjaW5nIFRCT0RZIGNvbnRlbnRzIHdpdGggaW5uZXJIVE1MLlxyXG4gICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzgwOTcwNTUvNTE1MTI0XHJcbiAgICAvLyBlbGVtZW50LmlubmVySFRNTCA9ICc8dHI+PHRkPmNlbGw8L3RkPjwvdHI+JztcclxuICAgIHZhciBmcmFnbWVudCA9IF9kb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XHJcbiAgICBmcmFnbWVudC5pbm5lckhUTUwgPSAnPHRyPjx0ZD5jZWxsPC90ZD48L3RyPic7XHJcbiAgICBlbGVtZW50LmFwcGVuZENoaWxkKGZyYWdtZW50KTtcclxuICB9XHJcbn07XHJcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb2N1cy10YWJsZS5qcy5tYXAiLCIndXNlIHN0cmljdCc7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfbXAgPSByZXF1aXJlKCcuL21lZGlhL21wNCcpO1xyXG5cclxudmFyIF9tcDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tcCk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0ge1xyXG4gIGVsZW1lbnQ6ICd2aWRlbycsXHJcbiAgbXV0YXRlOiBmdW5jdGlvbiBtdXRhdGUoZWxlbWVudCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gaW52YWxpZCBtZWRpYSBmaWxlIGNhbiB0cmlnZ2VyIHdhcm5pbmcgaW4gY29uc29sZSwgZGF0YS11cmkgdG8gcHJldmVudCBIVFRQIHJlcXVlc3RcclxuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3NyYycsIF9tcDIuZGVmYXVsdCk7XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgIC8vIElFOSBtYXkgdGhyb3cgXCJFcnJvcjogTm90IGltcGxlbWVudGVkXCJcclxuICAgIH1cclxuICB9XHJcbn07XHJcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb2N1cy12aWRlby13aXRob3V0LWNvbnRyb2xzLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLmdlbmVyYXRlID0gZ2VuZXJhdGU7XHJcbmV4cG9ydHMuZm9jdXMgPSBmb2N1cztcclxuZXhwb3J0cy52YWxpZGF0ZSA9IHZhbGlkYXRlO1xyXG5cclxudmFyIF9mb2N1cyA9IHJlcXVpcmUoJy4uLy4uL2VsZW1lbnQvZm9jdXMuc3ZnLWZvcmVpZ24tb2JqZWN0LWhhY2snKTtcclxuXHJcbnZhciBfZm9jdXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZm9jdXMpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmZ1bmN0aW9uIGdlbmVyYXRlKGVsZW1lbnQpIHtcclxuICByZXR1cm4gJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHhtbG5zOnhsaW5rPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiPicgKyBlbGVtZW50ICsgJzwvc3ZnPic7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGZvY3VzKGVsZW1lbnQpIHtcclxuICBpZiAoZWxlbWVudC5mb2N1cykge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgdHJ5IHtcclxuICAgIEhUTUxFbGVtZW50LnByb3RvdHlwZS5mb2N1cy5jYWxsKGVsZW1lbnQpO1xyXG4gIH0gY2F0Y2ggKGUpIHtcclxuICAgICgwLCBfZm9jdXMyLmRlZmF1bHQpKGVsZW1lbnQpO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gdmFsaWRhdGUoZWxlbWVudCwgZm9jdXNUYXJnZXQsIF9kb2N1bWVudCkge1xyXG4gIGZvY3VzKGZvY3VzVGFyZ2V0KTtcclxuICByZXR1cm4gX2RvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IGZvY3VzVGFyZ2V0O1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN2Zy5qcy5tYXAiLCIndXNlIHN0cmljdCc7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gJ2RhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxSMGxHT0RsaEFRQUJBSUFBQUFBQUFQLy8vWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWic7XHJcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1naWYuaW52YWxpZC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gJ2RhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxSMGxHT0RsaEFRQUJBSUFBQUFBQUFQLy8veUg1QkFFQUFBQUFMQUFBQUFBQkFBRUFBQUlCUkFBNyc7XHJcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1naWYuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX2dpZiA9IHJlcXVpcmUoJy4vZ2lmJyk7XHJcblxyXG52YXIgX2dpZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9naWYpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IF9naWYyLmRlZmF1bHQ7XHJcbi8vIGV4cG9ydCBkZWZhdWx0ICdkYXRhOmF1ZGlvL21wMztiYXNlNjQsYXVkaW8tZm9jdXMtdGVzdCc7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bXAzLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9naWYgPSByZXF1aXJlKCcuL2dpZicpO1xyXG5cclxudmFyIF9naWYyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2lmKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBfZ2lmMi5kZWZhdWx0O1xyXG4vLyBleHBvcnQgZGVmYXVsdCAnZGF0YTp2aWRlby9tcDQ7YmFzZTY0LHZpZGVvLWZvY3VzLXRlc3QnO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1wNC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gJ2RhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIaHRiJyArICdHNXpPbmhzYVc1clBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHhPVGs1TDNoc2FXNXJJaUJwWkQwaWMzWm5JajQ4ZEdWNGRDQjRQU0l4TUNJZ2VUMGlNakFpSUdsa1BTSicgKyAnemRtY3RiR2x1YXkxMFpYaDBJajUwWlhoMFBDOTBaWGgwUGp3dmMzWm5QZz09JztcclxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN2Zy5qcy5tYXAiLCIndXNlIHN0cmljdCc7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfdmVyc2lvbiA9IHJlcXVpcmUoJy4uL3ZlcnNpb24nKTtcclxuXHJcbnZhciBfdmVyc2lvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF92ZXJzaW9uKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5mdW5jdGlvbiByZWFkTG9jYWxTdG9yYWdlKGtleSkge1xyXG4gIC8vIGFsbG93IHJlYWRpbmcgZnJvbSBzdG9yYWdlIHRvIHJldHJpZXZlIHByZXZpb3VzIHN1cHBvcnQgcmVzdWx0c1xyXG4gIC8vIGV2ZW4gd2hpbGUgdGhlIGRvY3VtZW50IGRvZXMgbm90IGhhdmUgZm9jdXNcclxuICB2YXIgZGF0YSA9IHZvaWQgMDtcclxuXHJcbiAgdHJ5IHtcclxuICAgIGRhdGEgPSB3aW5kb3cubG9jYWxTdG9yYWdlICYmIHdpbmRvdy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbShrZXkpO1xyXG4gICAgZGF0YSA9IGRhdGEgPyBKU09OLnBhcnNlKGRhdGEpIDoge307XHJcbiAgfSBjYXRjaCAoZSkge1xyXG4gICAgZGF0YSA9IHt9O1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGRhdGE7XHJcbn0gLypcclxuICAgICAgRmFjaWxpdHkgdG8gY2FjaGUgdGVzdCByZXN1bHRzIGluIGxvY2FsU3RvcmFnZS5cclxuICBcclxuICAgICAgVVNBR0U6XHJcbiAgICAgICAgY2FjaGUuZ2V0KCdrZXknKTtcclxuICAgICAgICBjYWNoZS5zZXQoJ2tleScsICd2YWx1ZScpO1xyXG4gICAqL1xyXG5cclxuZnVuY3Rpb24gd3JpdGVMb2NhbFN0b3JhZ2Uoa2V5LCB2YWx1ZSkge1xyXG4gIGlmICghZG9jdW1lbnQuaGFzRm9jdXMoKSkge1xyXG4gICAgLy8gaWYgdGhlIGRvY3VtZW50IGRvZXMgbm90IGhhdmUgZm9jdXMgd2hlbiB0ZXN0cyBhcmUgZXhlY3V0ZWQsIGZvY3VzKCkgbWF5XHJcbiAgICAvLyBub3QgYmUgaGFuZGxlZCBwcm9wZXJseSBhbmQgZXZlbnRzIG1heSBub3QgYmUgZGlzcGF0Y2hlZCBpbW1lZGlhdGVseS5cclxuICAgIC8vIFRoaXMgY2FuIGhhcHBlbiB3aGVuIGEgZG9jdW1lbnQgaXMgcmVsb2FkZWQgd2hpbGUgRGV2ZWxvcGVyIFRvb2xzIGhhdmUgZm9jdXMuXHJcbiAgICB0cnkge1xyXG4gICAgICB3aW5kb3cubG9jYWxTdG9yYWdlICYmIHdpbmRvdy5sb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpO1xyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAvLyBpZ25vcmVcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICB0cnkge1xyXG4gICAgd2luZG93LmxvY2FsU3RvcmFnZSAmJiB3aW5kb3cubG9jYWxTdG9yYWdlLnNldEl0ZW0oa2V5LCBKU09OLnN0cmluZ2lmeSh2YWx1ZSkpO1xyXG4gIH0gY2F0Y2ggKGUpIHtcclxuICAgIC8vIGlnbm9yZVxyXG4gIH1cclxufVxyXG5cclxudmFyIHVzZXJBZ2VudCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50IHx8ICcnO1xyXG52YXIgY2FjaGVLZXkgPSAnYWxseS1zdXBwb3J0cy1jYWNoZSc7XHJcbnZhciBjYWNoZSA9IHJlYWRMb2NhbFN0b3JhZ2UoY2FjaGVLZXkpO1xyXG5cclxuLy8gdXBkYXRlIHRoZSBjYWNoZSBpZiBhbGx5IG9yIHRoZSB1c2VyIGFnZW50IGNoYW5nZWQgKG5ld2VyIHZlcnNpb24sIGV0YylcclxuaWYgKGNhY2hlLnVzZXJBZ2VudCAhPT0gdXNlckFnZW50IHx8IGNhY2hlLnZlcnNpb24gIT09IF92ZXJzaW9uMi5kZWZhdWx0KSB7XHJcbiAgY2FjaGUgPSB7fTtcclxufVxyXG5cclxuY2FjaGUudXNlckFnZW50ID0gdXNlckFnZW50O1xyXG5jYWNoZS52ZXJzaW9uID0gX3ZlcnNpb24yLmRlZmF1bHQ7XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSB7XHJcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XHJcbiAgICByZXR1cm4gY2FjaGU7XHJcbiAgfSxcclxuICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZXMpIHtcclxuICAgIE9iamVjdC5rZXlzKHZhbHVlcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgIGNhY2hlW2tleV0gPSB2YWx1ZXNba2V5XTtcclxuICAgIH0pO1xyXG5cclxuICAgIGNhY2hlLnRpbWUgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XHJcbiAgICB3cml0ZUxvY2FsU3RvcmFnZShjYWNoZUtleSwgY2FjaGUpO1xyXG4gIH1cclxufTtcclxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN1cHBvcnRzLWNhY2hlLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xyXG4gIGlmIChzdXBwb3J0c0NhY2hlKSB7XHJcbiAgICByZXR1cm4gc3VwcG9ydHNDYWNoZTtcclxuICB9XHJcblxyXG4gIHN1cHBvcnRzQ2FjaGUgPSBfc3VwcG9ydHNDYWNoZTIuZGVmYXVsdC5nZXQoKTtcclxuICBpZiAoIXN1cHBvcnRzQ2FjaGUudGltZSkge1xyXG4gICAgX3N1cHBvcnRzQ2FjaGUyLmRlZmF1bHQuc2V0KGV4ZWN1dGVUZXN0cygpKTtcclxuICAgIHN1cHBvcnRzQ2FjaGUgPSBfc3VwcG9ydHNDYWNoZTIuZGVmYXVsdC5nZXQoKTtcclxuICB9XHJcblxyXG4gIHJldHVybiBzdXBwb3J0c0NhY2hlO1xyXG59O1xyXG5cclxudmFyIF9kZXRlY3RGb2N1cyA9IHJlcXVpcmUoJy4vZGV0ZWN0LWZvY3VzJyk7XHJcblxyXG52YXIgX2RldGVjdEZvY3VzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RldGVjdEZvY3VzKTtcclxuXHJcbnZhciBfc3VwcG9ydHNDYWNoZSA9IHJlcXVpcmUoJy4vc3VwcG9ydHMtY2FjaGUnKTtcclxuXHJcbnZhciBfc3VwcG9ydHNDYWNoZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zdXBwb3J0c0NhY2hlKTtcclxuXHJcbnZhciBfY3NzU2hhZG93UGllcmNpbmdEZWVwQ29tYmluYXRvciA9IHJlcXVpcmUoJy4vY3NzLXNoYWRvdy1waWVyY2luZy1kZWVwLWNvbWJpbmF0b3InKTtcclxuXHJcbnZhciBfY3NzU2hhZG93UGllcmNpbmdEZWVwQ29tYmluYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jc3NTaGFkb3dQaWVyY2luZ0RlZXBDb21iaW5hdG9yKTtcclxuXHJcbnZhciBfZm9jdXNBcmVhSW1nVGFiaW5kZXggPSByZXF1aXJlKCcuL2ZvY3VzLWFyZWEtaW1nLXRhYmluZGV4Jyk7XHJcblxyXG52YXIgX2ZvY3VzQXJlYUltZ1RhYmluZGV4MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ZvY3VzQXJlYUltZ1RhYmluZGV4KTtcclxuXHJcbnZhciBfZm9jdXNBcmVhVGFiaW5kZXggPSByZXF1aXJlKCcuL2ZvY3VzLWFyZWEtdGFiaW5kZXgnKTtcclxuXHJcbnZhciBfZm9jdXNBcmVhVGFiaW5kZXgyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZm9jdXNBcmVhVGFiaW5kZXgpO1xyXG5cclxudmFyIF9mb2N1c0FyZWFXaXRob3V0SHJlZiA9IHJlcXVpcmUoJy4vZm9jdXMtYXJlYS13aXRob3V0LWhyZWYnKTtcclxuXHJcbnZhciBfZm9jdXNBcmVhV2l0aG91dEhyZWYyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZm9jdXNBcmVhV2l0aG91dEhyZWYpO1xyXG5cclxudmFyIF9mb2N1c0F1ZGlvV2l0aG91dENvbnRyb2xzID0gcmVxdWlyZSgnLi9mb2N1cy1hdWRpby13aXRob3V0LWNvbnRyb2xzJyk7XHJcblxyXG52YXIgX2ZvY3VzQXVkaW9XaXRob3V0Q29udHJvbHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZm9jdXNBdWRpb1dpdGhvdXRDb250cm9scyk7XHJcblxyXG52YXIgX2ZvY3VzQnJva2VuSW1hZ2VNYXAgPSByZXF1aXJlKCcuL2ZvY3VzLWJyb2tlbi1pbWFnZS1tYXAnKTtcclxuXHJcbnZhciBfZm9jdXNCcm9rZW5JbWFnZU1hcDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mb2N1c0Jyb2tlbkltYWdlTWFwKTtcclxuXHJcbnZhciBfZm9jdXNDaGlsZHJlbk9mRm9jdXNhYmxlRmxleGJveCA9IHJlcXVpcmUoJy4vZm9jdXMtY2hpbGRyZW4tb2YtZm9jdXNhYmxlLWZsZXhib3gnKTtcclxuXHJcbnZhciBfZm9jdXNDaGlsZHJlbk9mRm9jdXNhYmxlRmxleGJveDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mb2N1c0NoaWxkcmVuT2ZGb2N1c2FibGVGbGV4Ym94KTtcclxuXHJcbnZhciBfZm9jdXNGaWVsZHNldERpc2FibGVkID0gcmVxdWlyZSgnLi9mb2N1cy1maWVsZHNldC1kaXNhYmxlZCcpO1xyXG5cclxudmFyIF9mb2N1c0ZpZWxkc2V0RGlzYWJsZWQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZm9jdXNGaWVsZHNldERpc2FibGVkKTtcclxuXHJcbnZhciBfZm9jdXNGaWVsZHNldCA9IHJlcXVpcmUoJy4vZm9jdXMtZmllbGRzZXQnKTtcclxuXHJcbnZhciBfZm9jdXNGaWVsZHNldDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mb2N1c0ZpZWxkc2V0KTtcclxuXHJcbnZhciBfZm9jdXNGbGV4Ym94Q29udGFpbmVyID0gcmVxdWlyZSgnLi9mb2N1cy1mbGV4Ym94LWNvbnRhaW5lcicpO1xyXG5cclxudmFyIF9mb2N1c0ZsZXhib3hDb250YWluZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZm9jdXNGbGV4Ym94Q29udGFpbmVyKTtcclxuXHJcbnZhciBfZm9jdXNGb3JtRGlzYWJsZWQgPSByZXF1aXJlKCcuL2ZvY3VzLWZvcm0tZGlzYWJsZWQnKTtcclxuXHJcbnZhciBfZm9jdXNGb3JtRGlzYWJsZWQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZm9jdXNGb3JtRGlzYWJsZWQpO1xyXG5cclxudmFyIF9mb2N1c0ltZ0lzbWFwID0gcmVxdWlyZSgnLi9mb2N1cy1pbWctaXNtYXAnKTtcclxuXHJcbnZhciBfZm9jdXNJbWdJc21hcDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mb2N1c0ltZ0lzbWFwKTtcclxuXHJcbnZhciBfZm9jdXNJbWdVc2VtYXBUYWJpbmRleCA9IHJlcXVpcmUoJy4vZm9jdXMtaW1nLXVzZW1hcC10YWJpbmRleCcpO1xyXG5cclxudmFyIF9mb2N1c0ltZ1VzZW1hcFRhYmluZGV4MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ZvY3VzSW1nVXNlbWFwVGFiaW5kZXgpO1xyXG5cclxudmFyIF9mb2N1c0luSGlkZGVuSWZyYW1lID0gcmVxdWlyZSgnLi9mb2N1cy1pbi1oaWRkZW4taWZyYW1lJyk7XHJcblxyXG52YXIgX2ZvY3VzSW5IaWRkZW5JZnJhbWUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZm9jdXNJbkhpZGRlbklmcmFtZSk7XHJcblxyXG52YXIgX2ZvY3VzSW5aZXJvRGltZW5zaW9uT2JqZWN0ID0gcmVxdWlyZSgnLi9mb2N1cy1pbi16ZXJvLWRpbWVuc2lvbi1vYmplY3QnKTtcclxuXHJcbnZhciBfZm9jdXNJblplcm9EaW1lbnNpb25PYmplY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZm9jdXNJblplcm9EaW1lbnNpb25PYmplY3QpO1xyXG5cclxudmFyIF9mb2N1c0ludmFsaWRUYWJpbmRleCA9IHJlcXVpcmUoJy4vZm9jdXMtaW52YWxpZC10YWJpbmRleCcpO1xyXG5cclxudmFyIF9mb2N1c0ludmFsaWRUYWJpbmRleDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mb2N1c0ludmFsaWRUYWJpbmRleCk7XHJcblxyXG52YXIgX2ZvY3VzTGFiZWxUYWJpbmRleCA9IHJlcXVpcmUoJy4vZm9jdXMtbGFiZWwtdGFiaW5kZXgnKTtcclxuXHJcbnZhciBfZm9jdXNMYWJlbFRhYmluZGV4MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ZvY3VzTGFiZWxUYWJpbmRleCk7XHJcblxyXG52YXIgX2ZvY3VzT2JqZWN0U3ZnSGlkZGVuID0gcmVxdWlyZSgnLi9mb2N1cy1vYmplY3Qtc3ZnLWhpZGRlbicpO1xyXG5cclxudmFyIF9mb2N1c09iamVjdFN2Z0hpZGRlbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mb2N1c09iamVjdFN2Z0hpZGRlbik7XHJcblxyXG52YXIgX2ZvY3VzT2JqZWN0U3ZnID0gcmVxdWlyZSgnLi9mb2N1cy1vYmplY3Qtc3ZnJyk7XHJcblxyXG52YXIgX2ZvY3VzT2JqZWN0U3ZnMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ZvY3VzT2JqZWN0U3ZnKTtcclxuXHJcbnZhciBfZm9jdXNPYmplY3RTd2YgPSByZXF1aXJlKCcuL2ZvY3VzLW9iamVjdC1zd2YnKTtcclxuXHJcbnZhciBfZm9jdXNPYmplY3RTd2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZm9jdXNPYmplY3RTd2YpO1xyXG5cclxudmFyIF9mb2N1c1JlZGlyZWN0SW1nVXNlbWFwID0gcmVxdWlyZSgnLi9mb2N1cy1yZWRpcmVjdC1pbWctdXNlbWFwJyk7XHJcblxyXG52YXIgX2ZvY3VzUmVkaXJlY3RJbWdVc2VtYXAyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZm9jdXNSZWRpcmVjdEltZ1VzZW1hcCk7XHJcblxyXG52YXIgX2ZvY3VzUmVkaXJlY3RMZWdlbmQgPSByZXF1aXJlKCcuL2ZvY3VzLXJlZGlyZWN0LWxlZ2VuZCcpO1xyXG5cclxudmFyIF9mb2N1c1JlZGlyZWN0TGVnZW5kMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ZvY3VzUmVkaXJlY3RMZWdlbmQpO1xyXG5cclxudmFyIF9mb2N1c1Njcm9sbEJvZHkgPSByZXF1aXJlKCcuL2ZvY3VzLXNjcm9sbC1ib2R5Jyk7XHJcblxyXG52YXIgX2ZvY3VzU2Nyb2xsQm9keTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mb2N1c1Njcm9sbEJvZHkpO1xyXG5cclxudmFyIF9mb2N1c1Njcm9sbENvbnRhaW5lcldpdGhvdXRPdmVyZmxvdyA9IHJlcXVpcmUoJy4vZm9jdXMtc2Nyb2xsLWNvbnRhaW5lci13aXRob3V0LW92ZXJmbG93Jyk7XHJcblxyXG52YXIgX2ZvY3VzU2Nyb2xsQ29udGFpbmVyV2l0aG91dE92ZXJmbG93MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ZvY3VzU2Nyb2xsQ29udGFpbmVyV2l0aG91dE92ZXJmbG93KTtcclxuXHJcbnZhciBfZm9jdXNTY3JvbGxDb250YWluZXIgPSByZXF1aXJlKCcuL2ZvY3VzLXNjcm9sbC1jb250YWluZXInKTtcclxuXHJcbnZhciBfZm9jdXNTY3JvbGxDb250YWluZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZm9jdXNTY3JvbGxDb250YWluZXIpO1xyXG5cclxudmFyIF9mb2N1c1N1bW1hcnkgPSByZXF1aXJlKCcuL2ZvY3VzLXN1bW1hcnknKTtcclxuXHJcbnZhciBfZm9jdXNTdW1tYXJ5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ZvY3VzU3VtbWFyeSk7XHJcblxyXG52YXIgX2ZvY3VzU3ZnRm9jdXNhYmxlQXR0cmlidXRlID0gcmVxdWlyZSgnLi9mb2N1cy1zdmctZm9jdXNhYmxlLWF0dHJpYnV0ZScpO1xyXG5cclxudmFyIF9mb2N1c1N2Z0ZvY3VzYWJsZUF0dHJpYnV0ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mb2N1c1N2Z0ZvY3VzYWJsZUF0dHJpYnV0ZSk7XHJcblxyXG52YXIgX2ZvY3VzU3ZnVGFiaW5kZXhBdHRyaWJ1dGUgPSByZXF1aXJlKCcuL2ZvY3VzLXN2Zy10YWJpbmRleC1hdHRyaWJ1dGUnKTtcclxuXHJcbnZhciBfZm9jdXNTdmdUYWJpbmRleEF0dHJpYnV0ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mb2N1c1N2Z1RhYmluZGV4QXR0cmlidXRlKTtcclxuXHJcbnZhciBfZm9jdXNTdmdOZWdhdGl2ZVRhYmluZGV4QXR0cmlidXRlID0gcmVxdWlyZSgnLi9mb2N1cy1zdmctbmVnYXRpdmUtdGFiaW5kZXgtYXR0cmlidXRlJyk7XHJcblxyXG52YXIgX2ZvY3VzU3ZnTmVnYXRpdmVUYWJpbmRleEF0dHJpYnV0ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mb2N1c1N2Z05lZ2F0aXZlVGFiaW5kZXhBdHRyaWJ1dGUpO1xyXG5cclxudmFyIF9mb2N1c1N2Z1VzZVRhYmluZGV4ID0gcmVxdWlyZSgnLi9mb2N1cy1zdmctdXNlLXRhYmluZGV4Jyk7XHJcblxyXG52YXIgX2ZvY3VzU3ZnVXNlVGFiaW5kZXgyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZm9jdXNTdmdVc2VUYWJpbmRleCk7XHJcblxyXG52YXIgX2ZvY3VzU3ZnRm9yZWlnbm9iamVjdFRhYmluZGV4ID0gcmVxdWlyZSgnLi9mb2N1cy1zdmctZm9yZWlnbm9iamVjdC10YWJpbmRleCcpO1xyXG5cclxudmFyIF9mb2N1c1N2Z0ZvcmVpZ25vYmplY3RUYWJpbmRleDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mb2N1c1N2Z0ZvcmVpZ25vYmplY3RUYWJpbmRleCk7XHJcblxyXG52YXIgX2ZvY3VzU3ZnSW5JZnJhbWUgPSByZXF1aXJlKCcuL2ZvY3VzLXN2Zy1pbi1pZnJhbWUnKTtcclxuXHJcbnZhciBfZm9jdXNTdmdJbklmcmFtZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mb2N1c1N2Z0luSWZyYW1lKTtcclxuXHJcbnZhciBfZm9jdXNTdmcgPSByZXF1aXJlKCcuL2ZvY3VzLXN2ZycpO1xyXG5cclxudmFyIF9mb2N1c1N2ZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mb2N1c1N2Zyk7XHJcblxyXG52YXIgX2ZvY3VzVGFiaW5kZXhUcmFpbGluZ0NoYXJhY3RlcnMgPSByZXF1aXJlKCcuL2ZvY3VzLXRhYmluZGV4LXRyYWlsaW5nLWNoYXJhY3RlcnMnKTtcclxuXHJcbnZhciBfZm9jdXNUYWJpbmRleFRyYWlsaW5nQ2hhcmFjdGVyczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mb2N1c1RhYmluZGV4VHJhaWxpbmdDaGFyYWN0ZXJzKTtcclxuXHJcbnZhciBfZm9jdXNUYWJsZSA9IHJlcXVpcmUoJy4vZm9jdXMtdGFibGUnKTtcclxuXHJcbnZhciBfZm9jdXNUYWJsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mb2N1c1RhYmxlKTtcclxuXHJcbnZhciBfZm9jdXNWaWRlb1dpdGhvdXRDb250cm9scyA9IHJlcXVpcmUoJy4vZm9jdXMtdmlkZW8td2l0aG91dC1jb250cm9scycpO1xyXG5cclxudmFyIF9mb2N1c1ZpZGVvV2l0aG91dENvbnRyb2xzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ZvY3VzVmlkZW9XaXRob3V0Q29udHJvbHMpO1xyXG5cclxudmFyIF90YWJzZXF1ZW5jZUFyZWFBdEltZ1Bvc2l0aW9uID0gcmVxdWlyZSgnLi90YWJzZXF1ZW5jZS1hcmVhLWF0LWltZy1wb3NpdGlvbicpO1xyXG5cclxudmFyIF90YWJzZXF1ZW5jZUFyZWFBdEltZ1Bvc2l0aW9uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RhYnNlcXVlbmNlQXJlYUF0SW1nUG9zaXRpb24pO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbnZhciB0ZXN0Q2FsbGJhY2tzID0ge1xyXG4gIGNzc1NoYWRvd1BpZXJjaW5nRGVlcENvbWJpbmF0b3I6IF9jc3NTaGFkb3dQaWVyY2luZ0RlZXBDb21iaW5hdG9yMi5kZWZhdWx0LFxyXG4gIGZvY3VzSW5aZXJvRGltZW5zaW9uT2JqZWN0OiBfZm9jdXNJblplcm9EaW1lbnNpb25PYmplY3QyLmRlZmF1bHQsXHJcbiAgZm9jdXNPYmplY3RTd2Y6IF9mb2N1c09iamVjdFN3ZjIuZGVmYXVsdCxcclxuICBmb2N1c1N2Z0luSWZyYW1lOiBfZm9jdXNTdmdJbklmcmFtZTIuZGVmYXVsdCxcclxuICB0YWJzZXF1ZW5jZUFyZWFBdEltZ1Bvc2l0aW9uOiBfdGFic2VxdWVuY2VBcmVhQXRJbWdQb3NpdGlvbjIuZGVmYXVsdFxyXG59O1xyXG5cclxudmFyIHRlc3REZXNjcmlwdGlvbnMgPSB7XHJcbiAgZm9jdXNBcmVhSW1nVGFiaW5kZXg6IF9mb2N1c0FyZWFJbWdUYWJpbmRleDIuZGVmYXVsdCxcclxuICBmb2N1c0FyZWFUYWJpbmRleDogX2ZvY3VzQXJlYVRhYmluZGV4Mi5kZWZhdWx0LFxyXG4gIGZvY3VzQXJlYVdpdGhvdXRIcmVmOiBfZm9jdXNBcmVhV2l0aG91dEhyZWYyLmRlZmF1bHQsXHJcbiAgZm9jdXNBdWRpb1dpdGhvdXRDb250cm9sczogX2ZvY3VzQXVkaW9XaXRob3V0Q29udHJvbHMyLmRlZmF1bHQsXHJcbiAgZm9jdXNCcm9rZW5JbWFnZU1hcDogX2ZvY3VzQnJva2VuSW1hZ2VNYXAyLmRlZmF1bHQsXHJcbiAgZm9jdXNDaGlsZHJlbk9mRm9jdXNhYmxlRmxleGJveDogX2ZvY3VzQ2hpbGRyZW5PZkZvY3VzYWJsZUZsZXhib3gyLmRlZmF1bHQsXHJcbiAgZm9jdXNGaWVsZHNldERpc2FibGVkOiBfZm9jdXNGaWVsZHNldERpc2FibGVkMi5kZWZhdWx0LFxyXG4gIGZvY3VzRmllbGRzZXQ6IF9mb2N1c0ZpZWxkc2V0Mi5kZWZhdWx0LFxyXG4gIGZvY3VzRmxleGJveENvbnRhaW5lcjogX2ZvY3VzRmxleGJveENvbnRhaW5lcjIuZGVmYXVsdCxcclxuICBmb2N1c0Zvcm1EaXNhYmxlZDogX2ZvY3VzRm9ybURpc2FibGVkMi5kZWZhdWx0LFxyXG4gIGZvY3VzSW1nSXNtYXA6IF9mb2N1c0ltZ0lzbWFwMi5kZWZhdWx0LFxyXG4gIGZvY3VzSW1nVXNlbWFwVGFiaW5kZXg6IF9mb2N1c0ltZ1VzZW1hcFRhYmluZGV4Mi5kZWZhdWx0LFxyXG4gIGZvY3VzSW5IaWRkZW5JZnJhbWU6IF9mb2N1c0luSGlkZGVuSWZyYW1lMi5kZWZhdWx0LFxyXG4gIGZvY3VzSW52YWxpZFRhYmluZGV4OiBfZm9jdXNJbnZhbGlkVGFiaW5kZXgyLmRlZmF1bHQsXHJcbiAgZm9jdXNMYWJlbFRhYmluZGV4OiBfZm9jdXNMYWJlbFRhYmluZGV4Mi5kZWZhdWx0LFxyXG4gIGZvY3VzT2JqZWN0U3ZnOiBfZm9jdXNPYmplY3RTdmcyLmRlZmF1bHQsXHJcbiAgZm9jdXNPYmplY3RTdmdIaWRkZW46IF9mb2N1c09iamVjdFN2Z0hpZGRlbjIuZGVmYXVsdCxcclxuICBmb2N1c1JlZGlyZWN0SW1nVXNlbWFwOiBfZm9jdXNSZWRpcmVjdEltZ1VzZW1hcDIuZGVmYXVsdCxcclxuICBmb2N1c1JlZGlyZWN0TGVnZW5kOiBfZm9jdXNSZWRpcmVjdExlZ2VuZDIuZGVmYXVsdCxcclxuICBmb2N1c1Njcm9sbEJvZHk6IF9mb2N1c1Njcm9sbEJvZHkyLmRlZmF1bHQsXHJcbiAgZm9jdXNTY3JvbGxDb250YWluZXJXaXRob3V0T3ZlcmZsb3c6IF9mb2N1c1Njcm9sbENvbnRhaW5lcldpdGhvdXRPdmVyZmxvdzIuZGVmYXVsdCxcclxuICBmb2N1c1Njcm9sbENvbnRhaW5lcjogX2ZvY3VzU2Nyb2xsQ29udGFpbmVyMi5kZWZhdWx0LFxyXG4gIGZvY3VzU3VtbWFyeTogX2ZvY3VzU3VtbWFyeTIuZGVmYXVsdCxcclxuICBmb2N1c1N2Z0ZvY3VzYWJsZUF0dHJpYnV0ZTogX2ZvY3VzU3ZnRm9jdXNhYmxlQXR0cmlidXRlMi5kZWZhdWx0LFxyXG4gIGZvY3VzU3ZnVGFiaW5kZXhBdHRyaWJ1dGU6IF9mb2N1c1N2Z1RhYmluZGV4QXR0cmlidXRlMi5kZWZhdWx0LFxyXG4gIGZvY3VzU3ZnTmVnYXRpdmVUYWJpbmRleEF0dHJpYnV0ZTogX2ZvY3VzU3ZnTmVnYXRpdmVUYWJpbmRleEF0dHJpYnV0ZTIuZGVmYXVsdCxcclxuICBmb2N1c1N2Z1VzZVRhYmluZGV4OiBfZm9jdXNTdmdVc2VUYWJpbmRleDIuZGVmYXVsdCxcclxuICBmb2N1c1N2Z0ZvcmVpZ25vYmplY3RUYWJpbmRleDogX2ZvY3VzU3ZnRm9yZWlnbm9iamVjdFRhYmluZGV4Mi5kZWZhdWx0LFxyXG4gIGZvY3VzU3ZnOiBfZm9jdXNTdmcyLmRlZmF1bHQsXHJcbiAgZm9jdXNUYWJpbmRleFRyYWlsaW5nQ2hhcmFjdGVyczogX2ZvY3VzVGFiaW5kZXhUcmFpbGluZ0NoYXJhY3RlcnMyLmRlZmF1bHQsXHJcbiAgZm9jdXNUYWJsZTogX2ZvY3VzVGFibGUyLmRlZmF1bHQsXHJcbiAgZm9jdXNWaWRlb1dpdGhvdXRDb250cm9sczogX2ZvY3VzVmlkZW9XaXRob3V0Q29udHJvbHMyLmRlZmF1bHRcclxufTtcclxuXHJcbmZ1bmN0aW9uIGV4ZWN1dGVUZXN0cygpIHtcclxuICB2YXIgcmVzdWx0cyA9ICgwLCBfZGV0ZWN0Rm9jdXMyLmRlZmF1bHQpKHRlc3REZXNjcmlwdGlvbnMpO1xyXG4gIE9iamVjdC5rZXlzKHRlc3RDYWxsYmFja3MpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xyXG4gICAgcmVzdWx0c1trZXldID0gdGVzdENhbGxiYWNrc1trZXldKCk7XHJcbiAgfSk7XHJcblxyXG4gIHJldHVybiByZXN1bHRzO1xyXG59XHJcblxyXG52YXIgc3VwcG9ydHNDYWNoZSA9IG51bGw7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3VwcG9ydHMuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuXHJcbnZhciBfcGxhdGZvcm0gPSByZXF1aXJlKCcuLi91dGlsL3BsYXRmb3JtJyk7XHJcblxyXG52YXIgX3BsYXRmb3JtMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BsYXRmb3JtKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG4vLyBodHRwczovL2pzYmluLmNvbS92YWZhYmEvMy9lZGl0P2h0bWwsanMsY29uc29sZSxvdXRwdXRcclxudmFyIHJlc3VsdCA9IF9wbGF0Zm9ybTIuZGVmYXVsdC5pcy5HRUNLTyB8fCBfcGxhdGZvcm0yLmRlZmF1bHQuaXMuVFJJREVOVCB8fCBfcGxhdGZvcm0yLmRlZmF1bHQuaXMuRURHRTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD10YWJzZXF1ZW5jZS1hcmVhLWF0LWltZy1wb3NpdGlvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBmaW5kSW5kZXg7XHJcbmZ1bmN0aW9uIGZpbmRJbmRleChhcnJheSwgY2FsbGJhY2spIHtcclxuICAvLyBhdHRlbXB0IHRvIHVzZSBuYXRpdmUgb3IgcG9seWZpbGxlZCBBcnJheSNmaW5kSW5kZXggZmlyc3RcclxuICBpZiAoYXJyYXkuZmluZEluZGV4KSB7XHJcbiAgICByZXR1cm4gYXJyYXkuZmluZEluZGV4KGNhbGxiYWNrKTtcclxuICB9XHJcblxyXG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XHJcblxyXG4gIC8vIHNob3J0Y3V0IGlmIHRoZSBhcnJheSBpcyBlbXB0eVxyXG4gIGlmIChsZW5ndGggPT09IDApIHtcclxuICAgIHJldHVybiAtMTtcclxuICB9XHJcblxyXG4gIC8vIG90aGVyd2lzZSBsb29wIG92ZXIgYXJyYXlcclxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICBpZiAoY2FsbGJhY2soYXJyYXlbaV0sIGksIGFycmF5KSkge1xyXG4gICAgICByZXR1cm4gaTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiAtMTtcclxufVxyXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbXCJkZWZhdWx0XCJdO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcnJheS1maW5kLWluZGV4LmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLmdldFBhcmVudENvbXBhcmF0b3IgPSBnZXRQYXJlbnRDb21wYXJhdG9yO1xyXG5cclxuLy8gTm9kZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiBpcyBhdmFpbGFibGUgc2luY2UgSUU5XHJcbi8vIHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTm9kZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvblxyXG5cclxuLy8gY2FsbGJhY2sgcmV0dXJucyB0cnVlIHdoZW4gZWxlbWVudCBpcyBjb250YWluZWQgYnkgcGFyZW50IG9yIGlzIHRoZSBwYXJlbnQgc3VpdGVkIGZvciB1c2Ugd2l0aCBBcnJheS5zb21lKClcclxuLypcclxuICBVU0FHRTpcclxuICAgIHZhciBpc0NoaWxkT2YgPSBnZXRQYXJlbnRDb21wYXJhdG9yKHtwYXJlbnQ6IHNvbWVOb2RlfSk7XHJcbiAgICBsaXN0T2ZFbGVtZW50cy5zb21lKGlzQ2hpbGRPZilcclxuKi9cclxuXHJcbmZ1bmN0aW9uIGdldFBhcmVudENvbXBhcmF0b3IoKSB7XHJcbiAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxyXG4gICAgICBwYXJlbnQgPSBfcmVmLnBhcmVudCxcclxuICAgICAgZWxlbWVudCA9IF9yZWYuZWxlbWVudCxcclxuICAgICAgaW5jbHVkZVNlbGYgPSBfcmVmLmluY2x1ZGVTZWxmO1xyXG5cclxuICBpZiAocGFyZW50KSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gaXNDaGlsZE9mKG5vZGUpIHtcclxuICAgICAgcmV0dXJuIEJvb2xlYW4oaW5jbHVkZVNlbGYgJiYgbm9kZSA9PT0gcGFyZW50IHx8IHBhcmVudC5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihub2RlKSAmIE5vZGUuRE9DVU1FTlRfUE9TSVRJT05fQ09OVEFJTkVEX0JZKTtcclxuICAgIH07XHJcbiAgfSBlbHNlIGlmIChlbGVtZW50KSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gaXNQYXJlbnRPZihub2RlKSB7XHJcbiAgICAgIHJldHVybiBCb29sZWFuKGluY2x1ZGVTZWxmICYmIGVsZW1lbnQgPT09IG5vZGUgfHwgbm9kZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihlbGVtZW50KSAmIE5vZGUuRE9DVU1FTlRfUE9TSVRJT05fQ09OVEFJTkVEX0JZKTtcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd1dGlsL2NvbXBhcmUtcG9zaXRpb24jZ2V0UGFyZW50Q29tcGFyYXRvciByZXF1aXJlZCBlaXRoZXIgb3B0aW9ucy5wYXJlbnQgb3Igb3B0aW9ucy5lbGVtZW50Jyk7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29tcGFyZS1wb3NpdGlvbi5qcy5tYXAiLCIndXNlIHN0cmljdCc7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChfcmVmKSB7XHJcbiAgdmFyIGNvbnRleHQgPSBfcmVmLmNvbnRleHQsXHJcbiAgICAgIF9yZWYkbGFiZWwgPSBfcmVmLmxhYmVsLFxyXG4gICAgICBsYWJlbCA9IF9yZWYkbGFiZWwgPT09IHVuZGVmaW5lZCA/ICdjb250ZXh0LXRvLWVsZW1lbnQnIDogX3JlZiRsYWJlbCxcclxuICAgICAgcmVzb2x2ZURvY3VtZW50ID0gX3JlZi5yZXNvbHZlRG9jdW1lbnQsXHJcbiAgICAgIGRlZmF1bHRUb0RvY3VtZW50ID0gX3JlZi5kZWZhdWx0VG9Eb2N1bWVudDtcclxuXHJcbiAgdmFyIGVsZW1lbnQgPSAoMCwgX25vZGVBcnJheTIuZGVmYXVsdCkoY29udGV4dClbMF07XHJcblxyXG4gIGlmIChyZXNvbHZlRG9jdW1lbnQgJiYgZWxlbWVudCAmJiBlbGVtZW50Lm5vZGVUeXBlID09PSBOb2RlLkRPQ1VNRU5UX05PREUpIHtcclxuICAgIGVsZW1lbnQgPSBlbGVtZW50LmRvY3VtZW50RWxlbWVudDtcclxuICB9XHJcblxyXG4gIGlmICghZWxlbWVudCAmJiBkZWZhdWx0VG9Eb2N1bWVudCkge1xyXG4gICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcclxuICB9XHJcblxyXG4gIGlmICghZWxlbWVudCkge1xyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihsYWJlbCArICcgcmVxdWlyZXMgdmFsaWQgb3B0aW9ucy5jb250ZXh0Jyk7XHJcbiAgfVxyXG5cclxuICBpZiAoZWxlbWVudC5ub2RlVHlwZSAhPT0gTm9kZS5FTEVNRU5UX05PREUgJiYgZWxlbWVudC5ub2RlVHlwZSAhPT0gTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFKSB7XHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGxhYmVsICsgJyByZXF1aXJlcyBvcHRpb25zLmNvbnRleHQgdG8gYmUgYW4gRWxlbWVudCcpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGVsZW1lbnQ7XHJcbn07XHJcblxyXG52YXIgX25vZGVBcnJheSA9IHJlcXVpcmUoJy4uL3V0aWwvbm9kZS1hcnJheScpO1xyXG5cclxudmFyIF9ub2RlQXJyYXkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbm9kZUFycmF5KTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29udGV4dC10by1lbGVtZW50LmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBlbGVtZW50TWF0Y2hlcztcclxuXHJcbi8vIEVsZW1lbnQucHJvdG90eXBlLm1hdGNoZXMgbWF5IGJlIGF2YWlsYWJsZSBhdCBhIGRpZmZlcmVudCBuYW1lXHJcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9FbGVtZW50L21hdGNoZXNcclxuXHJcbnZhciBuYW1lcyA9IFsnbWF0Y2hlcycsICd3ZWJraXRNYXRjaGVzU2VsZWN0b3InLCAnbW96TWF0Y2hlc1NlbGVjdG9yJywgJ21zTWF0Y2hlc1NlbGVjdG9yJ107XHJcbnZhciBuYW1lID0gbnVsbDtcclxuXHJcbmZ1bmN0aW9uIGZpbmRNZXRob2ROYW1lKGVsZW1lbnQpIHtcclxuICBuYW1lcy5zb21lKGZ1bmN0aW9uIChfbmFtZSkge1xyXG4gICAgaWYgKCFlbGVtZW50W19uYW1lXSkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgbmFtZSA9IF9uYW1lO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGVsZW1lbnRNYXRjaGVzKGVsZW1lbnQsIHNlbGVjdG9yKSB7XHJcbiAgaWYgKCFuYW1lKSB7XHJcbiAgICBmaW5kTWV0aG9kTmFtZShlbGVtZW50KTtcclxuICB9XHJcblxyXG4gIHJldHVybiBlbGVtZW50W25hbWVdKHNlbGVjdG9yKTtcclxufVxyXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZWxlbWVudC1tYXRjaGVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAobm9kZSkge1xyXG4gIHRyeSB7XHJcbiAgICAvLyB3b3JrcyBvbiA8b2JqZWN0PiBhbmQgPGlmcmFtZT5cclxuICAgIHJldHVybiBub2RlLmNvbnRlbnREb2N1bWVudFxyXG4gICAgLy8gd29ya3Mgb24gPG9iamVjdD4gYW5kIDxpZnJhbWU+XHJcbiAgICB8fCBub2RlLmNvbnRlbnRXaW5kb3cgJiYgbm9kZS5jb250ZW50V2luZG93LmRvY3VtZW50XHJcbiAgICAvLyB3b3JrcyBvbiA8b2JqZWN0PiBhbmQgPGlmcmFtZT4gdGhhdCBjb250YWluIFNWR1xyXG4gICAgfHwgbm9kZS5nZXRTVkdEb2N1bWVudCAmJiBub2RlLmdldFNWR0RvY3VtZW50KCkgfHwgbnVsbDtcclxuICB9IGNhdGNoIChlKSB7XHJcbiAgICAvLyBTZWN1cml0eUVycm9yOiBGYWlsZWQgdG8gcmVhZCB0aGUgJ2NvbnRlbnREb2N1bWVudCcgcHJvcGVydHkgZnJvbSAnSFRNTE9iamVjdEVsZW1lbnQnXHJcbiAgICAvLyBhbHNvIElFIG1heSB0aHJvdyBtZW1iZXIgbm90IGZvdW5kIGV4Y2VwdGlvbiBlLmcuIG9uIDxvYmplY3QgdHlwZT1cImltYWdlL3BuZ1wiPlxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzW1wiZGVmYXVsdFwiXTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0LWNvbnRlbnQtZG9jdW1lbnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgaWYgKCFub2RlKSB7XHJcbiAgICByZXR1cm4gZG9jdW1lbnQ7XHJcbiAgfVxyXG5cclxuICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5ET0NVTUVOVF9OT0RFKSB7XHJcbiAgICByZXR1cm4gbm9kZTtcclxuICB9XHJcblxyXG4gIHJldHVybiBub2RlLm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQ7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbXCJkZWZhdWx0XCJdO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXQtZG9jdW1lbnQuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IGdldEZyYW1lRWxlbWVudDtcclxuXHJcbnZhciBfZ2V0Q29udGVudERvY3VtZW50ID0gcmVxdWlyZSgnLi9nZXQtY29udGVudC1kb2N1bWVudCcpO1xyXG5cclxudmFyIF9nZXRDb250ZW50RG9jdW1lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0Q29udGVudERvY3VtZW50KTtcclxuXHJcbnZhciBfZ2V0V2luZG93ID0gcmVxdWlyZSgnLi9nZXQtd2luZG93Jyk7XHJcblxyXG52YXIgX2dldFdpbmRvdzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRXaW5kb3cpO1xyXG5cclxudmFyIF9zZWxlY3RJblNoYWRvd3MgPSByZXF1aXJlKCcuL3NlbGVjdC1pbi1zaGFkb3dzJyk7XHJcblxyXG52YXIgX3NlbGVjdEluU2hhZG93czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zZWxlY3RJblNoYWRvd3MpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbnZhciBzZWxlY3RvciA9IHZvaWQgMDtcclxuXHJcbmZ1bmN0aW9uIGZpbmREb2N1bWVudEhvc3RFbGVtZW50KF93aW5kb3cpIHtcclxuICBpZiAoIXNlbGVjdG9yKSB7XHJcbiAgICBzZWxlY3RvciA9ICgwLCBfc2VsZWN0SW5TaGFkb3dzMi5kZWZhdWx0KSgnb2JqZWN0LCBpZnJhbWUnKTtcclxuICB9XHJcblxyXG4gIGlmIChfd2luZG93Ll9mcmFtZUVsZW1lbnQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgcmV0dXJuIF93aW5kb3cuX2ZyYW1lRWxlbWVudDtcclxuICB9XHJcblxyXG4gIF93aW5kb3cuX2ZyYW1lRWxlbWVudCA9IG51bGw7XHJcblxyXG4gIHZhciBwb3RlbnRpYWxIb3N0cyA9IF93aW5kb3cucGFyZW50LmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xyXG4gIFtdLnNvbWUuY2FsbChwb3RlbnRpYWxIb3N0cywgZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuICAgIHZhciBfZG9jdW1lbnQgPSAoMCwgX2dldENvbnRlbnREb2N1bWVudDIuZGVmYXVsdCkoZWxlbWVudCk7XHJcbiAgICBpZiAoX2RvY3VtZW50ICE9PSBfd2luZG93LmRvY3VtZW50KSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBfd2luZG93Ll9mcmFtZUVsZW1lbnQgPSBlbGVtZW50O1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfSk7XHJcblxyXG4gIHJldHVybiBfd2luZG93Ll9mcmFtZUVsZW1lbnQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldEZyYW1lRWxlbWVudChlbGVtZW50KSB7XHJcbiAgdmFyIF93aW5kb3cgPSAoMCwgX2dldFdpbmRvdzIuZGVmYXVsdCkoZWxlbWVudCk7XHJcbiAgaWYgKCFfd2luZG93LnBhcmVudCB8fCBfd2luZG93LnBhcmVudCA9PT0gX3dpbmRvdykge1xyXG4gICAgLy8gaWYgdGhlcmUgaXMgbm8gcGFyZW50IGJyb3dzaW5nIGNvbnRleHQsXHJcbiAgICAvLyB3ZSdyZSBub3QgZ29pbmcgdG8gZ2V0IGEgZnJhbWVFbGVtZW50IGVpdGhlciB3YXlcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuXHJcbiAgdHJ5IHtcclxuICAgIC8vIHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2luZG93L2ZyYW1lRWxlbWVudFxyXG4gICAgLy8gZG9lcyBub3Qgd29yayB3aXRoaW4gPGVtYmVkPiBhbnl3aGVyZSwgYW5kIG5vdCB3aXRoaW4gaW4gPG9iamVjdD4gaW4gSUVcclxuICAgIHJldHVybiBfd2luZG93LmZyYW1lRWxlbWVudCB8fCBmaW5kRG9jdW1lbnRIb3N0RWxlbWVudChfd2luZG93KTtcclxuICB9IGNhdGNoIChlKSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcbn1cclxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldC1mcmFtZS1lbGVtZW50LmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKG5vZGUpIHtcclxuICB2YXIgX2RvY3VtZW50ID0gKDAsIF9nZXREb2N1bWVudDIuZGVmYXVsdCkobm9kZSk7XHJcbiAgcmV0dXJuIF9kb2N1bWVudC5kZWZhdWx0VmlldyB8fCB3aW5kb3c7XHJcbn07XHJcblxyXG52YXIgX2dldERvY3VtZW50ID0gcmVxdWlyZSgnLi9nZXQtZG9jdW1lbnQnKTtcclxuXHJcbnZhciBfZ2V0RG9jdW1lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0RG9jdW1lbnQpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXQtd2luZG93LmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLmdldE1hcEJ5TmFtZSA9IGdldE1hcEJ5TmFtZTtcclxuZXhwb3J0cy5nZXRNYXBPZkltYWdlID0gZ2V0TWFwT2ZJbWFnZTtcclxuZXhwb3J0cy5nZXRJbWFnZU9mQXJlYSA9IGdldEltYWdlT2ZBcmVhO1xyXG5cclxudmFyIF9jc3MgPSByZXF1aXJlKCdjc3MuZXNjYXBlJyk7XHJcblxyXG52YXIgX2NzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jc3MpO1xyXG5cclxudmFyIF9nZXREb2N1bWVudCA9IHJlcXVpcmUoJy4uL3V0aWwvZ2V0LWRvY3VtZW50Jyk7XHJcblxyXG52YXIgX2dldERvY3VtZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldERvY3VtZW50KTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5mdW5jdGlvbiBnZXRNYXBCeU5hbWUobmFtZSwgX2RvY3VtZW50KSB7XHJcbiAgLy8gYXBwYXJlbnRseSBnZXRFbGVtZW50c0J5TmFtZSgpIGFsc28gY29uc2lkZXJzIGlkIGF0dHJpYnV0ZSBpbiBJRSAmIG9wZXJhXHJcbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0RvY3VtZW50L2dldEVsZW1lbnRzQnlOYW1lXHJcbiAgdmFyIG1hcCA9IF9kb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdtYXBbbmFtZT1cIicgKyAoMCwgX2NzczIuZGVmYXVsdCkobmFtZSkgKyAnXCJdJyk7XHJcbiAgcmV0dXJuIG1hcCB8fCBudWxsO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRNYXBPZkltYWdlKGVsZW1lbnQpIHtcclxuICB2YXIgdXNlbWFwID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3VzZW1hcCcpO1xyXG4gIGlmICghdXNlbWFwKSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIHZhciBfZG9jdW1lbnQgPSAoMCwgX2dldERvY3VtZW50Mi5kZWZhdWx0KShlbGVtZW50KTtcclxuICByZXR1cm4gZ2V0TWFwQnlOYW1lKHVzZW1hcC5zbGljZSgxKSwgX2RvY3VtZW50KTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0SW1hZ2VPZkFyZWEoZWxlbWVudCkge1xyXG4gIHZhciBtYXAgPSBlbGVtZW50LnBhcmVudEVsZW1lbnQ7XHJcblxyXG4gIGlmICghbWFwLm5hbWUgfHwgbWFwLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09ICdtYXAnKSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIC8vIE5PVEU6IGltYWdlIG1hcHMgY2FuIGFsc28gYmUgYXBwbGllZCB0byA8b2JqZWN0PiB3aXRoIGltYWdlIGNvbnRlbnQsXHJcbiAgLy8gYnV0IG5vIGJyb3dzZXIgc3VwcG9ydHMgdGhpcyBhdCB0aGUgbW9tZW50XHJcblxyXG4gIC8vIEhUTUw1IHNwZWNpZmllcyBIVE1MTWFwRWxlbWVudC5pbWFnZXMgdG8gYmUgYW4gSFRNTENvbGxlY3Rpb24gb2YgYWxsXHJcbiAgLy8gPGltZz4gYW5kIDxvYmplY3Q+IHJlZmVyZW5jaW5nIHRoZSA8bWFwPiBlbGVtZW50LCBidXQgbm8gYnJvd3NlciBpbXBsZW1lbnRzIHRoaXNcclxuICAvLyAgIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCN0aGUtbWFwLWVsZW1lbnRcclxuICAvLyAgIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9IVE1MTWFwRWxlbWVudFxyXG4gIC8vIHRoZSBpbWFnZSBtdXN0IGJlIHZhbGlkIGFuZCBsb2FkZWQgZm9yIHRoZSBtYXAgdG8gdGFrZSBlZmZlY3RcclxuICB2YXIgX2RvY3VtZW50ID0gKDAsIF9nZXREb2N1bWVudDIuZGVmYXVsdCkoZWxlbWVudCk7XHJcbiAgcmV0dXJuIF9kb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdpbWdbdXNlbWFwPVwiIycgKyAoMCwgX2NzczIuZGVmYXVsdCkobWFwLm5hbWUpICsgJ1wiXScpIHx8IG51bGw7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW1hZ2UtbWFwLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIG5vb3AgPSBmdW5jdGlvbiBub29wKCkge307XHJcbnZhciBfY29uc29sZSA9IHtcclxuICBsb2c6IG5vb3AsXHJcbiAgZGVidWc6IG5vb3AsXHJcbiAgaW5mbzogbm9vcCxcclxuICB3YXJuOiBub29wLFxyXG4gIGVycm9yOiBub29wXHJcbn07XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgPyBjb25zb2xlIDogX2NvbnNvbGU7XHJcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2dnZXIuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxyXG4gICAgICBsaXN0ID0gX3JlZi5saXN0LFxyXG4gICAgICBlbGVtZW50cyA9IF9yZWYuZWxlbWVudHMsXHJcbiAgICAgIHJlc29sdmVFbGVtZW50ID0gX3JlZi5yZXNvbHZlRWxlbWVudDtcclxuXHJcbiAgLy8gb3BlcmF0ZSBvbiBhIGNvcHkgc28gd2UgZG9uJ3QgbXV0YXRlIHRoZSBvcmlnaW5hbCBhcnJheVxyXG4gIHZhciBfbGlzdCA9IGxpc3Quc2xpY2UoMCk7XHJcbiAgLy8gbWFrZSBzdXJlIHRoZSBlbGVtZW50cyB3ZSdyZSBpbmplY3RpbmcgYXJlIHByb3ZpZGVkIGluIERPTSBvcmRlclxyXG4gIHZhciBfZWxlbWVudHMgPSAoMCwgX25vZGVBcnJheTIuZGVmYXVsdCkoZWxlbWVudHMpLnNsaWNlKDApO1xyXG4gICgwLCBfc29ydERvbU9yZGVyMi5kZWZhdWx0KShfZWxlbWVudHMpO1xyXG4gIC8vIGZpbmQgdGhlIG9mZnNldHMgd2l0aGluIHRoZSB0YXJnZXQgYXJyYXkgKGxpc3QpIGF0IHdoaWNoIHRvIGluamVjdFxyXG4gIC8vIGVhY2ggaW5kaXZpZHVhbCBlbGVtZW50IChmcm9tIGVsZW1lbnRzKVxyXG4gIHZhciBpbnNlcnRpb25zID0gZmluZEluc2VydGlvbk9mZnNldHMoX2xpc3QsIF9lbGVtZW50cywgcmVzb2x2ZUVsZW1lbnQpO1xyXG4gIC8vIGFjdHVhbGx5IGluamVjdCB0aGUgZWxlbWVudHMgaW50byB0aGUgdGFyZ2V0IGFycmF5IGF0IHRoZSBpZGVudGlmaWVkIHBvc2l0aW9uc1xyXG4gIGluc2VydEVsZW1lbnRzQXRPZmZzZXRzKF9saXN0LCBpbnNlcnRpb25zKTtcclxuICByZXR1cm4gX2xpc3Q7XHJcbn07XHJcblxyXG52YXIgX2FycmF5RmluZEluZGV4ID0gcmVxdWlyZSgnLi4vdXRpbC9hcnJheS1maW5kLWluZGV4Jyk7XHJcblxyXG52YXIgX2FycmF5RmluZEluZGV4MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2FycmF5RmluZEluZGV4KTtcclxuXHJcbnZhciBfbm9kZUFycmF5ID0gcmVxdWlyZSgnLi9ub2RlLWFycmF5Jyk7XHJcblxyXG52YXIgX25vZGVBcnJheTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ub2RlQXJyYXkpO1xyXG5cclxudmFyIF9zb3J0RG9tT3JkZXIgPSByZXF1aXJlKCcuL3NvcnQtZG9tLW9yZGVyJyk7XHJcblxyXG52YXIgX3NvcnREb21PcmRlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zb3J0RG9tT3JkZXIpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmZ1bmN0aW9uIGdldEZpcnN0U3VjY2Vzc29yT2Zmc2V0KGxpc3QsIHRhcmdldCkge1xyXG4gIC8vIGZpbmQgdGhlIGZpcnN0IGVsZW1lbnQgdGhhdCBjb21lcyBBRlRFUiB0aGUgdGFyZ2V0IGVsZW1lbnRcclxuICByZXR1cm4gKDAsIF9hcnJheUZpbmRJbmRleDIuZGVmYXVsdCkobGlzdCwgZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuICAgIHJldHVybiB0YXJnZXQuY29tcGFyZURvY3VtZW50UG9zaXRpb24oZWxlbWVudCkgJiBOb2RlLkRPQ1VNRU5UX1BPU0lUSU9OX0ZPTExPV0lORztcclxuICB9KTtcclxufVxyXG4vLyBzb3J0IGEgbGlzdCBvZiBlbGVtZW50cyBpbnRvIGFub3RoZXIgbGlzdCBvZiBlbGVtZW50cyBpbiBET00gb3JkZXJcclxuXHJcbi8qXHJcbiAgVVNBR0U6XHJcbiAgICBtZXJnZURvbU9yZGVyKHtcclxuICAgICAgLy8gRE9NIG9yZGVyZWQgYXJyYXkgb2YgZWxlbWVudHMgdG8gdXNlIGFzIGJhc2Ugb2YgbWVyZ2VcclxuICAgICAgbGlzdDogW10sXHJcbiAgICAgIC8vIHVub3JkZXJlZCBhcnJheSBvZiBlbGVtZW50cyB0byBtZXJnZSBpbnRvIGJhc2UgbGlzdFxyXG4gICAgICBlbGVtZW50czogW10sXHJcbiAgICAgIC8vIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIHJlc29sdmUgYW4gZWxlbWVudFxyXG4gICAgICByZXNvbHZlRWxlbWVudDogZnVuY3Rpb24oZWxlbWVudCkge1xyXG4gICAgICAgIC8vIHJldHVybiBudWxsIHRvIHNraXBcclxuICAgICAgICAvLyByZXR1cm4gZWxlbWVudCB0byByZXBsYWNlIGluc2VydGlvblxyXG4gICAgICAgIC8vIHJldHVybiBbZWxlbWVudDEsIGVsZW1lbnQyLCDigKZdIHRvIHJlcGxhY2UgaW5zZXJ0aW9uIHdpdGggbXVsdGlwbGUgZWxlbWVudHNcclxuICAgICAgICByZXR1cm4gZWxlbWVudDtcclxuICAgICAgfSxcclxuICAgIH0pXHJcbiovXHJcblxyXG5mdW5jdGlvbiBmaW5kSW5zZXJ0aW9uT2Zmc2V0cyhsaXN0LCBlbGVtZW50cywgcmVzb2x2ZUVsZW1lbnQpIHtcclxuICAvLyBpbnN0ZWFkIG9mIG11dGF0aW5nIHRoZSBlbGVtZW50cyBsaXN0IGRpcmVjdGx5LCByZW1lbWJlciBwb3NpdGlvbiBhbmQgbWFwXHJcbiAgLy8gdG8gaW5qZWN0IGxhdGVyLCB3aGVuIHdlIGNhbiBkbyB0aGlzIG1vcmUgZWZmaWNpZW50bHlcclxuICB2YXIgaW5zZXJ0aW9ucyA9IFtdO1xyXG4gIGVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuICAgIHZhciByZXBsYWNlID0gdHJ1ZTtcclxuICAgIHZhciBvZmZzZXQgPSBsaXN0LmluZGV4T2YoZWxlbWVudCk7XHJcblxyXG4gICAgaWYgKG9mZnNldCA9PT0gLTEpIHtcclxuICAgICAgLy8gZWxlbWVudCBpcyBub3QgaW4gdGFyZ2V0IGxpc3RcclxuICAgICAgb2Zmc2V0ID0gZ2V0Rmlyc3RTdWNjZXNzb3JPZmZzZXQobGlzdCwgZWxlbWVudCk7XHJcbiAgICAgIHJlcGxhY2UgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAob2Zmc2V0ID09PSAtMSkge1xyXG4gICAgICAvLyB0aGVyZSBpcyBubyBzdWNjZXNzb3IgaW4gdGhlIHRhYnNlcXVlbmNlLFxyXG4gICAgICAvLyBtZWFuaW5nIHRoZSBpbWFnZSBtdXN0IGJlIHRoZSBsYXN0IGVsZW1lbnRcclxuICAgICAgb2Zmc2V0ID0gbGlzdC5sZW5ndGg7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gYWxsb3cgdGhlIGNvbnN1bWVyIHRvIHJlcGxhY2UgdGhlIGluamVjdGVkIGVsZW1lbnRcclxuICAgIHZhciBpbmplY3Rpb25zID0gKDAsIF9ub2RlQXJyYXkyLmRlZmF1bHQpKHJlc29sdmVFbGVtZW50ID8gcmVzb2x2ZUVsZW1lbnQoZWxlbWVudCkgOiBlbGVtZW50KTtcclxuICAgIGlmICghaW5qZWN0aW9ucy5sZW5ndGgpIHtcclxuICAgICAgLy8gd2UgY2FuJ3QgaW5qZWN0IHplcm8gZWxlbWVudHNcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGluc2VydGlvbnMucHVzaCh7XHJcbiAgICAgIG9mZnNldDogb2Zmc2V0LFxyXG4gICAgICByZXBsYWNlOiByZXBsYWNlLFxyXG4gICAgICBlbGVtZW50czogaW5qZWN0aW9uc1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcblxyXG4gIHJldHVybiBpbnNlcnRpb25zO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpbnNlcnRFbGVtZW50c0F0T2Zmc2V0cyhsaXN0LCBpbnNlcnRpb25zKSB7XHJcbiAgLy8gcmVtZW1iZXIgdGhlIG51bWJlciBvZiBlbGVtZW50cyB3ZSBoYXZlIGFscmVhZHkgaW5qZWN0ZWRcclxuICAvLyBzbyB3ZSBhY2NvdW50IGZvciB0aGUgY2F1c2VkIGluZGV4IG9mZnNldFxyXG4gIHZhciBpbnNlcnRlZCA9IDA7XHJcbiAgLy8gbWFrZSBzdXJlIHRoYXQgd2UgaW5zZXJ0IHRoZSBlbGVtZW50cyBpbiBzZXF1ZW5jZSxcclxuICAvLyBvdGhlcndpc2UgdGhlIG9mZnNldCBjb21wZW5zYXRpb24gd29uJ3Qgd29ya1xyXG4gIGluc2VydGlvbnMuc29ydChmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgcmV0dXJuIGEub2Zmc2V0IC0gYi5vZmZzZXQ7XHJcbiAgfSk7XHJcbiAgaW5zZXJ0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChpbnNlcnRpb24pIHtcclxuICAgIC8vIGFycmF5LnNwbGljZSBoYXMgYW4gYW5ub3lpbmcgZnVuY3Rpb24gc2lnbmF0dXJlIDooXHJcbiAgICB2YXIgcmVtb3ZlID0gaW5zZXJ0aW9uLnJlcGxhY2UgPyAxIDogMDtcclxuICAgIHZhciBhcmdzID0gW2luc2VydGlvbi5vZmZzZXQgKyBpbnNlcnRlZCwgcmVtb3ZlXS5jb25jYXQoaW5zZXJ0aW9uLmVsZW1lbnRzKTtcclxuICAgIGxpc3Quc3BsaWNlLmFwcGx5KGxpc3QsIGFyZ3MpO1xyXG4gICAgaW5zZXJ0ZWQgKz0gaW5zZXJ0aW9uLmVsZW1lbnRzLmxlbmd0aCAtIHJlbW92ZTtcclxuICB9KTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lcmdlLWRvbS1vcmRlci5qcy5tYXAiLCIndXNlIHN0cmljdCc7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChpbnB1dCkge1xyXG4gIGlmICghaW5wdXQpIHtcclxuICAgIHJldHVybiBbXTtcclxuICB9XHJcblxyXG4gIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xyXG4gICAgcmV0dXJuIGlucHV0O1xyXG4gIH1cclxuXHJcbiAgLy8gaW5zdGFuY2VvZiBOb2RlIC0gZG9lcyBub3Qgd29yayB3aXRoIGlmcmFtZXNcclxuICBpZiAoaW5wdXQubm9kZVR5cGUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgcmV0dXJuIFtpbnB1dF07XHJcbiAgfVxyXG5cclxuICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xyXG4gICAgaW5wdXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGlucHV0KTtcclxuICB9XHJcblxyXG4gIGlmIChpbnB1dC5sZW5ndGggIT09IHVuZGVmaW5lZCkge1xyXG4gICAgcmV0dXJuIFtdLnNsaWNlLmNhbGwoaW5wdXQsIDApO1xyXG4gIH1cclxuXHJcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndW5leHBlY3RlZCBpbnB1dCAnICsgU3RyaW5nKGlucHV0KSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcclxuLy8gaW5wdXQgbWF5IGJlIHVuZGVmaW5lZCwgc2VsZWN0b3ItdHJpbmcsIE5vZGUsIE5vZGVMaXN0LCBIVE1MQ29sbGVjdGlvbiwgYXJyYXkgb2YgTm9kZXNcclxuLy8geWVzLCB0byBzb21lIGV4dGVudCB0aGlzIGlzIGEgYmFkIHJlcGxpY2Egb2YgalF1ZXJ5J3MgY29uc3RydWN0b3IgZnVuY3Rpb25cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bm9kZS1hcnJheS5qcy5tYXAiLCIndXNlIHN0cmljdCc7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfcGxhdGZvcm0yID0gcmVxdWlyZSgncGxhdGZvcm0nKTtcclxuXHJcbnZhciBfcGxhdGZvcm0zID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcGxhdGZvcm0yKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG4vLyBkZWVwIGNsb25lIG9mIG9yaWdpbmFsIHBsYXRmb3JtXHJcbnZhciBwbGF0Zm9ybSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoX3BsYXRmb3JtMy5kZWZhdWx0KSk7XHJcblxyXG4vLyBvcGVyYXRpbmcgc3lzdGVtXHJcblxyXG4vLyBzdWdhciBmb3IgaHR0cHM6Ly9naXRodWIuY29tL2Jlc3RpZWpzL3BsYXRmb3JtLmpzXHJcbi8vIG1ha2Ugc3VyZSB0byBBTFdBWVMgcmVmZXJlbmNlIHRoZSBsYXlvdXQgZW5naW5lLFxyXG4vLyBldmVuIGlmIGl0IGlzIG5vdCBuZWNlc3NhcnkgZm9yIHRoZSBjb25kaXRpb24sXHJcbi8vIGFzIHRoaXMgbWFrZXMgZ3JlcHBpbmcgZm9yIHRoaXMgc3R1ZmYgc2ltcGxlclxyXG5cclxudmFyIG9zID0gcGxhdGZvcm0ub3MuZmFtaWx5IHx8ICcnO1xyXG52YXIgQU5EUk9JRCA9IG9zID09PSAnQW5kcm9pZCc7XHJcbnZhciBXSU5ET1dTID0gb3Muc2xpY2UoMCwgNykgPT09ICdXaW5kb3dzJztcclxudmFyIE9TWCA9IG9zID09PSAnT1MgWCc7XHJcbnZhciBJT1MgPSBvcyA9PT0gJ2lPUyc7XHJcblxyXG4vLyBsYXlvdXRcclxudmFyIEJMSU5LID0gcGxhdGZvcm0ubGF5b3V0ID09PSAnQmxpbmsnO1xyXG52YXIgR0VDS08gPSBwbGF0Zm9ybS5sYXlvdXQgPT09ICdHZWNrbyc7XHJcbnZhciBUUklERU5UID0gcGxhdGZvcm0ubGF5b3V0ID09PSAnVHJpZGVudCc7XHJcbnZhciBFREdFID0gcGxhdGZvcm0ubGF5b3V0ID09PSAnRWRnZUhUTUwnO1xyXG52YXIgV0VCS0lUID0gcGxhdGZvcm0ubGF5b3V0ID09PSAnV2ViS2l0JztcclxuXHJcbi8vIGJyb3dzZXIgdmVyc2lvbiAobm90IGxheW91dCBlbmdpbmUgdmVyc2lvbiEpXHJcbnZhciB2ZXJzaW9uID0gcGFyc2VGbG9hdChwbGF0Zm9ybS52ZXJzaW9uKTtcclxudmFyIG1ham9yVmVyc2lvbiA9IE1hdGguZmxvb3IodmVyc2lvbik7XHJcbnBsYXRmb3JtLm1ham9yVmVyc2lvbiA9IG1ham9yVmVyc2lvbjtcclxuXHJcbnBsYXRmb3JtLmlzID0ge1xyXG4gIC8vIG9wZXJhdGluZyBzeXN0ZW1cclxuICBBTkRST0lEOiBBTkRST0lELFxyXG4gIFdJTkRPV1M6IFdJTkRPV1MsXHJcbiAgT1NYOiBPU1gsXHJcbiAgSU9TOiBJT1MsXHJcbiAgLy8gbGF5b3V0XHJcbiAgQkxJTks6IEJMSU5LLCAvLyBcIkNocm9tZVwiLCBcIkNocm9tZSBNb2JpbGVcIiwgXCJPcGVyYVwiXHJcbiAgR0VDS086IEdFQ0tPLCAvLyBcIkZpcmVmb3hcIlxyXG4gIFRSSURFTlQ6IFRSSURFTlQsIC8vIFwiSW50ZXJuZXQgRXhwbG9yZXJcIlxyXG4gIEVER0U6IEVER0UsIC8vIFwiTWljcm9zb2Z0IEVkZ2VcIlxyXG4gIFdFQktJVDogV0VCS0lULCAvLyBcIlNhZmFyaVwiXHJcbiAgLy8gSU5URVJORVQgRVhQTE9SRVJTXHJcbiAgSUU5OiBUUklERU5UICYmIG1ham9yVmVyc2lvbiA9PT0gOSxcclxuICBJRTEwOiBUUklERU5UICYmIG1ham9yVmVyc2lvbiA9PT0gMTAsXHJcbiAgSUUxMTogVFJJREVOVCAmJiBtYWpvclZlcnNpb24gPT09IDExXHJcbn07XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBwbGF0Zm9ybTtcclxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBsYXRmb3JtLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKHNlbGVjdG9yKSB7XHJcbiAgaWYgKHR5cGVvZiBzaGFkb3dQcmVmaXggIT09ICdzdHJpbmcnKSB7XHJcbiAgICB2YXIgb3BlcmF0b3IgPSAoMCwgX2Nzc1NoYWRvd1BpZXJjaW5nRGVlcENvbWJpbmF0b3IyLmRlZmF1bHQpKCk7XHJcbiAgICBpZiAob3BlcmF0b3IpIHtcclxuICAgICAgc2hhZG93UHJlZml4ID0gJywgaHRtbCAnICsgb3BlcmF0b3IgKyAnICc7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBpZiAoIXNoYWRvd1ByZWZpeCkge1xyXG4gICAgcmV0dXJuIHNlbGVjdG9yO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHNlbGVjdG9yICsgc2hhZG93UHJlZml4ICsgc2VsZWN0b3IucmVwbGFjZSgvXFxzKixcXHMqL2csICcsJykuc3BsaXQoJywnKS5qb2luKHNoYWRvd1ByZWZpeCk7XHJcbn07XHJcblxyXG52YXIgX2Nzc1NoYWRvd1BpZXJjaW5nRGVlcENvbWJpbmF0b3IgPSByZXF1aXJlKCcuLi9zdXBwb3J0cy9jc3Mtc2hhZG93LXBpZXJjaW5nLWRlZXAtY29tYmluYXRvcicpO1xyXG5cclxudmFyIF9jc3NTaGFkb3dQaWVyY2luZ0RlZXBDb21iaW5hdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Nzc1NoYWRvd1BpZXJjaW5nRGVlcENvbWJpbmF0b3IpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbnZhciBzaGFkb3dQcmVmaXggPSB2b2lkIDA7XHJcbi8vIGNvbnZlcnQgYSBDU1Mgc2VsZWN0b3Igc28gdGhhdCBpdCBhbHNvIHBpZXJjZXMgU2hhZG93RE9NXHJcbi8vIHRha2VzIFwiLmEsICNiXCIgYW5kIHR1cm5zIGl0IGludG8gXCIuYSwgI2IsIGh0bWwgPj4+IC5hLCBodG1sID4+PiAjYlwiXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VsZWN0LWluLXNoYWRvd3MuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChlbGVtZW50cykge1xyXG4gIHJldHVybiBlbGVtZW50cy5zb3J0KGNvbXBhcmVEb21Qb3NpdGlvbik7XHJcbn07XHJcblxyXG4vLyBzb3J0cyBhIGxpc3Qgb2YgZWxlbWVudHMgYWNjb3JkaW5nIHRvIHRoZWlyIG9yZGVyIGluIHRoZSBET01cclxuXHJcbmZ1bmN0aW9uIGNvbXBhcmVEb21Qb3NpdGlvbihhLCBiKSB7XHJcbiAgcmV0dXJuIGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oYikgJiBOb2RlLkRPQ1VNRU5UX1BPU0lUSU9OX0ZPTExPV0lORyA/IC0xIDogMTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzW1wiZGVmYXVsdFwiXTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c29ydC1kb20tb3JkZXIuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xyXG4gIGlmICghKDAsIF92YWxpZFRhYmluZGV4Mi5kZWZhdWx0KShlbGVtZW50KSkge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICAvLyBFZGdlIDE0IGhhcyBhIGNhcGl0YWxpemF0aW9uIHByb2JsZW0gb24gU1ZHIGVsZW1lbnRzLFxyXG4gIC8vIHNlZSBodHRwczovL2RldmVsb3Blci5taWNyb3NvZnQuY29tL2VuLXVzL21pY3Jvc29mdC1lZGdlL3BsYXRmb3JtL2lzc3Vlcy85MjgyMDU4L1xyXG4gIHZhciBoYXNUYWJpbmRleCA9IGVsZW1lbnQuaGFzQXR0cmlidXRlKCd0YWJpbmRleCcpO1xyXG4gIHZhciBhdHRyaWJ1dGVOYW1lID0gaGFzVGFiaW5kZXggPyAndGFiaW5kZXgnIDogJ3RhYkluZGV4JztcclxuXHJcbiAgLy8gQGJyb3dzZXItaXNzdWUgR2Vja28gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTEyODA1NFxyXG4gIHZhciB0YWJpbmRleCA9IHBhcnNlSW50KGVsZW1lbnQuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpLCAxMCk7XHJcbiAgcmV0dXJuIGlzTmFOKHRhYmluZGV4KSA/IC0xIDogdGFiaW5kZXg7XHJcbn07XHJcblxyXG52YXIgX3ZhbGlkVGFiaW5kZXggPSByZXF1aXJlKCcuLi9pcy92YWxpZC10YWJpbmRleCcpO1xyXG5cclxudmFyIF92YWxpZFRhYmluZGV4MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3ZhbGlkVGFiaW5kZXgpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD10YWJpbmRleC12YWx1ZS5qcy5tYXAiLCIndXNlIHN0cmljdCc7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChfcmVmKSB7XHJcbiAgdmFyIGVsZW1lbnQgPSBfcmVmLmVsZW1lbnQsXHJcbiAgICAgIGF0dHJpYnV0ZSA9IF9yZWYuYXR0cmlidXRlLFxyXG4gICAgICB0ZW1wb3JhcnlWYWx1ZSA9IF9yZWYudGVtcG9yYXJ5VmFsdWUsXHJcbiAgICAgIHNhdmVWYWx1ZSA9IF9yZWYuc2F2ZVZhbHVlO1xyXG5cclxuICB2YXIgdGVtcG9yYXJ5QXR0cmlidXRlID0gJ2RhdGEtY2FjaGVkLScgKyBhdHRyaWJ1dGU7XHJcblxyXG4gIGlmICh0ZW1wb3JhcnlWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICB2YXIgX3ZhbHVlID0gc2F2ZVZhbHVlIHx8IGVsZW1lbnQuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZSk7XHJcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSh0ZW1wb3JhcnlBdHRyaWJ1dGUsIF92YWx1ZSB8fCAnJyk7XHJcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShhdHRyaWJ1dGUsIHRlbXBvcmFyeVZhbHVlKTtcclxuICB9IGVsc2Uge1xyXG4gICAgdmFyIF92YWx1ZTIgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSh0ZW1wb3JhcnlBdHRyaWJ1dGUpO1xyXG4gICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUodGVtcG9yYXJ5QXR0cmlidXRlKTtcclxuICAgIGlmIChfdmFsdWUyID09PSAnJykge1xyXG4gICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShhdHRyaWJ1dGUpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlLCBfdmFsdWUyKTtcclxuICAgIH1cclxuICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcclxuLy8gaGVscGVyIHRvIHR1cm5cclxuLy8gIDxkaXYgc29tZS1hdHRyaWJ1dGU9XCJvcmlnaW5hbFwiPlxyXG4vLyBpbnRvXHJcbi8vICA8ZGl2IHNvbWUtYXR0cmlidXRlPVwibmV3XCIgZGF0YS1jYWNoZWQtc29tZS1hdHRyaWJ1dGU9XCJvcmlnaW5hbFwiPlxyXG4vLyBhbmQgYmFja1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD10b2dnbGUtYXR0cmlidXRlLXZhbHVlLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKF9yZWYpIHtcclxuICB2YXIgZWxlbWVudCA9IF9yZWYuZWxlbWVudCxcclxuICAgICAgYXR0cmlidXRlID0gX3JlZi5hdHRyaWJ1dGU7XHJcblxyXG4gIHZhciB0ZW1wb3JhcnlBdHRyaWJ1dGUgPSAnZGF0YS1jYWNoZWQtJyArIGF0dHJpYnV0ZTtcclxuICB2YXIgdGVtcG9yYXJ5QXR0cmlidXRlVmFsdWUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSh0ZW1wb3JhcnlBdHRyaWJ1dGUpO1xyXG5cclxuICBpZiAodGVtcG9yYXJ5QXR0cmlidXRlVmFsdWUgPT09IG51bGwpIHtcclxuICAgIHZhciBfdmFsdWUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZShhdHRyaWJ1dGUpO1xyXG4gICAgaWYgKF92YWx1ZSA9PT0gbnVsbCkge1xyXG4gICAgICAvLyBjYW4ndCByZW1vdmUgd2hhdCdzIG5vdCB0aGVyZVxyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUodGVtcG9yYXJ5QXR0cmlidXRlLCBfdmFsdWUgfHwgJycpO1xyXG4gICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoYXR0cmlidXRlKTtcclxuICB9IGVsc2Uge1xyXG4gICAgdmFyIF92YWx1ZTIgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSh0ZW1wb3JhcnlBdHRyaWJ1dGUpO1xyXG4gICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUodGVtcG9yYXJ5QXR0cmlidXRlKTtcclxuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZSwgX3ZhbHVlMik7XHJcbiAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XHJcbi8vIGhlbHBlciB0byB0dXJuXHJcbi8vICA8ZGl2IHNvbWUtYXR0cmlidXRlPVwib3JpZ2luYWxcIj5cclxuLy8gaW50b1xyXG4vLyAgPGRpdiBkYXRhLWNhY2hlZC1zb21lLWF0dHJpYnV0ZT1cIm9yaWdpbmFsXCI+XHJcbi8vIGFuZCBiYWNrXHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRvZ2dsZS1hdHRyaWJ1dGUuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG4vLyB0aGlzIGZpbGUgaXMgb3ZlcndyaXR0ZW4gYnkgYG5wbSBydW4gYnVpbGQ6cHJlYFxyXG52YXIgdmVyc2lvbiA9ICcxLjQuMSc7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IHZlcnNpb247XHJcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD12ZXJzaW9uLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKHRleHQpIHtcclxuICByZXR1cm4gdGV4dC5zcGxpdCgvXFxzKy8pLm1hcChmdW5jdGlvbiAoX3RleHQpIHtcclxuICAgIHZhciB0b2tlbnMgPSBfdGV4dC5zcGxpdCgnKycpO1xyXG4gICAgdmFyIF9tb2RpZmllcnMgPSByZXNvbHZlTW9kaWZpZXJzKHRva2Vucy5zbGljZSgwLCAtMSkpO1xyXG4gICAgdmFyIF9rZXlDb2RlcyA9IHJlc29sdmVLZXkodG9rZW5zLnNsaWNlKC0xKSk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBrZXlDb2RlczogX2tleUNvZGVzLFxyXG4gICAgICBtb2RpZmllcnM6IF9tb2RpZmllcnMsXHJcbiAgICAgIG1hdGNoTW9kaWZpZXJzOiBtYXRjaE1vZGlmaWVycy5iaW5kKG51bGwsIF9tb2RpZmllcnMpXHJcbiAgICB9O1xyXG4gIH0pO1xyXG59O1xyXG5cclxudmFyIF9rZXljb2RlID0gcmVxdWlyZSgnLi4vbWFwL2tleWNvZGUnKTtcclxuXHJcbnZhciBfa2V5Y29kZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9rZXljb2RlKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG52YXIgbW9kaWZpZXIgPSB7XHJcbiAgYWx0OiAnYWx0S2V5JyxcclxuICBjdHJsOiAnY3RybEtleScsXHJcbiAgbWV0YTogJ21ldGFLZXknLFxyXG4gIHNoaWZ0OiAnc2hpZnRLZXknXHJcbn07XHJcbi8qXHJcbiAgZGVjb2RlcyBhIGtleSBiaW5kaW5nIHRva2VuIHRvIGEgSmF2YVNjcmlwdCBzdHJ1Y3R1cmVcclxuXHJcbiAgcmV0dXJucyBhbiBhcnJheSBvZiBvYmplY3RzOlxyXG4gICAge1xyXG4gICAgICAvLyBrZXkgbmFtZSB0cmFuc2xhdGVkIHRvIGtleUNvZGUgKHBvc3NpYmx5IG1vcmUgdGhhbiBvbmUpXHJcbiAgICAgIGtleUNvZGVzOiBbPG51bWJlcj5dLFxyXG4gICAgICAvLyB0cmFuc2xhdGVkIG1vZGlmaWVyc1xyXG4gICAgICBtb2RpZmllcnM6IHtcclxuICAgICAgICBhbHRLZXk6IG51bGwsICAgLy8gaWdub3JlXHJcbiAgICAgICAgY3RyS2V5OiBmYWxzZSwgIC8vIGV4cGVjdCBub3QgcHJlc3NlZFxyXG4gICAgICAgIG1ldGFLZXk6IHRydWUsICAvLyBleHBlY3QgcHJlc3NlZFxyXG4gICAgICAgIHNoaWZ0S2V5OiB0cnVlLCAvLyBleHBlY3QgcHJlc3NlZFxyXG4gICAgICB9LFxyXG4gICAgICAvLyBjYWxsYmFjayB0aGF0IHJldHVybnMgdHJ1ZSBpZiBldmVudCdzXHJcbiAgICAgIC8vIG1vZGlmaWVyIGtleXMgbWF0Y2ggdGhlIGV4cGVjdGVkIHN0YXRlXHJcbiAgICAgIG1hdGNoTW9kaWZpZXJzOiBmdW5jdGlvbihldmVudCl7fSxcclxuICAgIH1cclxuKi9cclxuXHJcbnZhciBtb2RpZmllclNlcXVlbmNlID0gT2JqZWN0LmtleXMobW9kaWZpZXIpLm1hcChmdW5jdGlvbiAobmFtZSkge1xyXG4gIHJldHVybiBtb2RpZmllcltuYW1lXTtcclxufSk7XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVFeHBlY3RlZE1vZGlmaWVycyhpZ25vcmVNb2RpZmllcnMpIHtcclxuICB2YXIgdmFsdWUgPSBpZ25vcmVNb2RpZmllcnMgPyBudWxsIDogZmFsc2U7XHJcbiAgcmV0dXJuIHtcclxuICAgIGFsdEtleTogdmFsdWUsXHJcbiAgICBjdHJsS2V5OiB2YWx1ZSxcclxuICAgIG1ldGFLZXk6IHZhbHVlLFxyXG4gICAgc2hpZnRLZXk6IHZhbHVlXHJcbiAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVzb2x2ZU1vZGlmaWVycyhtb2RpZmllcnMpIHtcclxuICB2YXIgaWdub3JlTW9kaWZpZXJzID0gbW9kaWZpZXJzLmluZGV4T2YoJyonKSAhPT0gLTE7XHJcbiAgdmFyIGV4cGVjdGVkID0gY3JlYXRlRXhwZWN0ZWRNb2RpZmllcnMoaWdub3JlTW9kaWZpZXJzKTtcclxuXHJcbiAgbW9kaWZpZXJzLmZvckVhY2goZnVuY3Rpb24gKHRva2VuKSB7XHJcbiAgICBpZiAodG9rZW4gPT09ICcqJykge1xyXG4gICAgICAvLyB3ZSd2ZSBhbHJlYWR5IGNvdmVyZWQgdGhlIGFsbC1pbiBvcGVyYXRvclxyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gd2Ugd2FudCB0aGUgbW9kaWZpZXIgcHJlc3NlZFxyXG4gICAgdmFyIHZhbHVlID0gdHJ1ZTtcclxuICAgIHZhciBvcGVyYXRvciA9IHRva2VuLnNsaWNlKDAsIDEpO1xyXG4gICAgaWYgKG9wZXJhdG9yID09PSAnPycpIHtcclxuICAgICAgLy8gd2UgZG9uJ3QgY2FyZSBpZiB0aGUgbW9kaWZpZXIgaXMgcHJlc3NlZFxyXG4gICAgICB2YWx1ZSA9IG51bGw7XHJcbiAgICB9IGVsc2UgaWYgKG9wZXJhdG9yID09PSAnIScpIHtcclxuICAgICAgLy8gd2UgZG8gbm90IHdhbnQgdGhlIG1vZGlmaWVyIHByZXNzZWRcclxuICAgICAgdmFsdWUgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodmFsdWUgIT09IHRydWUpIHtcclxuICAgICAgLy8gY29tcGVuc2F0ZSBmb3IgdGhlIG1vZGlmaWVyJ3Mgb3BlcmF0b3JcclxuICAgICAgdG9rZW4gPSB0b2tlbi5zbGljZSgxKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgcHJvcGVydHlOYW1lID0gbW9kaWZpZXJbdG9rZW5dO1xyXG4gICAgaWYgKCFwcm9wZXJ0eU5hbWUpIHtcclxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBtb2RpZmllciBcIicgKyB0b2tlbiArICdcIicpO1xyXG4gICAgfVxyXG5cclxuICAgIGV4cGVjdGVkW3Byb3BlcnR5TmFtZV0gPSB2YWx1ZTtcclxuICB9KTtcclxuXHJcbiAgcmV0dXJuIGV4cGVjdGVkO1xyXG59XHJcblxyXG5mdW5jdGlvbiByZXNvbHZlS2V5KGtleSkge1xyXG4gIHZhciBjb2RlID0gX2tleWNvZGUyLmRlZmF1bHRba2V5XSB8fCBwYXJzZUludChrZXksIDEwKTtcclxuICBpZiAoIWNvZGUgfHwgdHlwZW9mIGNvZGUgIT09ICdudW1iZXInIHx8IGlzTmFOKGNvZGUpKSB7XHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGtleSBcIicgKyBrZXkgKyAnXCInKTtcclxuICB9XHJcblxyXG4gIHJldHVybiBbY29kZV0uY29uY2F0KF9rZXljb2RlMi5kZWZhdWx0Ll9hbGlhc1tjb2RlXSB8fCBbXSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG1hdGNoTW9kaWZpZXJzKGV4cGVjdGVkLCBldmVudCkge1xyXG4gIC8vIHJldHVybnMgdHJ1ZSBvbiBtYXRjaFxyXG4gIHJldHVybiAhbW9kaWZpZXJTZXF1ZW5jZS5zb21lKGZ1bmN0aW9uIChwcm9wKSB7XHJcbiAgICAvLyByZXR1cm5zIHRydWUgb24gbWlzbWF0Y2hcclxuICAgIHJldHVybiB0eXBlb2YgZXhwZWN0ZWRbcHJvcF0gPT09ICdib29sZWFuJyAmJiBCb29sZWFuKGV2ZW50W3Byb3BdKSAhPT0gZXhwZWN0ZWRbcHJvcF07XHJcbiAgfSk7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1rZXkuYmluZGluZy5qcy5tYXAiLCIndXNlIHN0cmljdCc7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgbWFwID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcclxuXHJcbiAgdmFyIGJpbmRpbmdzID0ge307XHJcblxyXG4gIHZhciBjb250ZXh0ID0gKDAsIF9ub2RlQXJyYXkyLmRlZmF1bHQpKG1hcC5jb250ZXh0KVswXSB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XHJcbiAgZGVsZXRlIG1hcC5jb250ZXh0O1xyXG4gIHZhciBmaWx0ZXIgPSAoMCwgX25vZGVBcnJheTIuZGVmYXVsdCkobWFwLmZpbHRlcik7XHJcbiAgZGVsZXRlIG1hcC5maWx0ZXI7XHJcblxyXG4gIHZhciBtYXBLZXlzID0gT2JqZWN0LmtleXMobWFwKTtcclxuICBpZiAoIW1hcEtleXMubGVuZ3RoKSB7XHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd3aGVuL2tleSByZXF1aXJlcyBhdCBsZWFzdCBvbmUgb3B0aW9uIGtleScpO1xyXG4gIH1cclxuXHJcbiAgdmFyIHJlZ2lzdGVyQmluZGluZyA9IGZ1bmN0aW9uIHJlZ2lzdGVyQmluZGluZyhldmVudCkge1xyXG4gICAgZXZlbnQua2V5Q29kZXMuZm9yRWFjaChmdW5jdGlvbiAoY29kZSkge1xyXG4gICAgICBpZiAoIWJpbmRpbmdzW2NvZGVdKSB7XHJcbiAgICAgICAgYmluZGluZ3NbY29kZV0gPSBbXTtcclxuICAgICAgfVxyXG5cclxuICAgICAgYmluZGluZ3NbY29kZV0ucHVzaChldmVudCk7XHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICBtYXBLZXlzLmZvckVhY2goZnVuY3Rpb24gKHRleHQpIHtcclxuICAgIGlmICh0eXBlb2YgbWFwW3RleHRdICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3doZW4va2V5IHJlcXVpcmVzIG9wdGlvbltcIicgKyB0ZXh0ICsgJ1wiXSB0byBiZSBhIGZ1bmN0aW9uJyk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGFkZENhbGxiYWNrID0gZnVuY3Rpb24gYWRkQ2FsbGJhY2soZXZlbnQpIHtcclxuICAgICAgZXZlbnQuY2FsbGJhY2sgPSBtYXBbdGV4dF07XHJcbiAgICAgIHJldHVybiBldmVudDtcclxuICAgIH07XHJcblxyXG4gICAgKDAsIF9rZXkyLmRlZmF1bHQpKHRleHQpLm1hcChhZGRDYWxsYmFjaykuZm9yRWFjaChyZWdpc3RlckJpbmRpbmcpO1xyXG4gIH0pO1xyXG5cclxuICB2YXIgaGFuZGxlS2V5RG93biA9IGZ1bmN0aW9uIGhhbmRsZUtleURvd24oZXZlbnQpIHtcclxuICAgIGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoZmlsdGVyLmxlbmd0aCkge1xyXG4gICAgICAvLyBpZ25vcmUgZWxlbWVudHMgd2l0aGluIHRoZSBleGVtcHRlZCBzdWItdHJlZXNcclxuICAgICAgdmFyIGlzUGFyZW50T2ZFbGVtZW50ID0gKDAsIF9jb21wYXJlUG9zaXRpb24uZ2V0UGFyZW50Q29tcGFyYXRvcikoeyBlbGVtZW50OiBldmVudC50YXJnZXQsIGluY2x1ZGVTZWxmOiB0cnVlIH0pO1xyXG4gICAgICBpZiAoZmlsdGVyLnNvbWUoaXNQYXJlbnRPZkVsZW1lbnQpKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGtleSA9IGV2ZW50LmtleUNvZGUgfHwgZXZlbnQud2hpY2g7XHJcbiAgICBpZiAoIWJpbmRpbmdzW2tleV0pIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGJpbmRpbmdzW2tleV0uZm9yRWFjaChmdW5jdGlvbiAoX2V2ZW50KSB7XHJcbiAgICAgIGlmICghX2V2ZW50Lm1hdGNoTW9kaWZpZXJzKGV2ZW50KSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgX2V2ZW50LmNhbGxiYWNrLmNhbGwoY29udGV4dCwgZXZlbnQsIGRpc2VuZ2FnZSk7XHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICBjb250ZXh0LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBoYW5kbGVLZXlEb3duLCBmYWxzZSk7XHJcblxyXG4gIHZhciBkaXNlbmdhZ2UgPSBmdW5jdGlvbiBkaXNlbmdhZ2UoKSB7XHJcbiAgICBjb250ZXh0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBoYW5kbGVLZXlEb3duLCBmYWxzZSk7XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIHsgZGlzZW5nYWdlOiBkaXNlbmdhZ2UgfTtcclxufTtcclxuXHJcbnZhciBfa2V5ID0gcmVxdWlyZSgnLi9rZXkuYmluZGluZycpO1xyXG5cclxudmFyIF9rZXkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfa2V5KTtcclxuXHJcbnZhciBfbm9kZUFycmF5ID0gcmVxdWlyZSgnLi4vdXRpbC9ub2RlLWFycmF5Jyk7XHJcblxyXG52YXIgX25vZGVBcnJheTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ub2RlQXJyYXkpO1xyXG5cclxudmFyIF9jb21wYXJlUG9zaXRpb24gPSByZXF1aXJlKCcuLi91dGlsL2NvbXBhcmUtcG9zaXRpb24nKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcclxuXHJcbi8vIEJ1ZyAyODY5MzMgLSBLZXkgZXZlbnRzIGluIHRoZSBhdXRvY29tcGxldGUgcG9wdXAgc2hvdWxkIGJlIGhpZGRlbiBmcm9tIHBhZ2Ugc2NyaXB0c1xyXG4vLyBAYnJvd3Nlci1pc3N1ZSBHZWNrbyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0yODY5MzNcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9a2V5LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxuLy8gVGhpcyBmaWxlIHdhcyBvcmlnaW5hbGx5IHdyaXR0ZW4gYnkgQGRydWRydSAoaHR0cHM6Ly9naXRodWIuY29tL2RydWRydS9hbnNpX3VwKSwgTUlULCAyMDExXHJcblxyXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xyXG5cclxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cclxuXHJcbnZhciBBTlNJX0NPTE9SUyA9IFtbeyBjb2xvcjogXCIwLCAwLCAwXCIsIFwiY2xhc3NcIjogXCJhbnNpLWJsYWNrXCIgfSwgeyBjb2xvcjogXCIxODcsIDAsIDBcIiwgXCJjbGFzc1wiOiBcImFuc2ktcmVkXCIgfSwgeyBjb2xvcjogXCIwLCAxODcsIDBcIiwgXCJjbGFzc1wiOiBcImFuc2ktZ3JlZW5cIiB9LCB7IGNvbG9yOiBcIjE4NywgMTg3LCAwXCIsIFwiY2xhc3NcIjogXCJhbnNpLXllbGxvd1wiIH0sIHsgY29sb3I6IFwiMCwgMCwgMTg3XCIsIFwiY2xhc3NcIjogXCJhbnNpLWJsdWVcIiB9LCB7IGNvbG9yOiBcIjE4NywgMCwgMTg3XCIsIFwiY2xhc3NcIjogXCJhbnNpLW1hZ2VudGFcIiB9LCB7IGNvbG9yOiBcIjAsIDE4NywgMTg3XCIsIFwiY2xhc3NcIjogXCJhbnNpLWN5YW5cIiB9LCB7IGNvbG9yOiBcIjI1NSwyNTUsMjU1XCIsIFwiY2xhc3NcIjogXCJhbnNpLXdoaXRlXCIgfV0sIFt7IGNvbG9yOiBcIjg1LCA4NSwgODVcIiwgXCJjbGFzc1wiOiBcImFuc2ktYnJpZ2h0LWJsYWNrXCIgfSwgeyBjb2xvcjogXCIyNTUsIDg1LCA4NVwiLCBcImNsYXNzXCI6IFwiYW5zaS1icmlnaHQtcmVkXCIgfSwgeyBjb2xvcjogXCIwLCAyNTUsIDBcIiwgXCJjbGFzc1wiOiBcImFuc2ktYnJpZ2h0LWdyZWVuXCIgfSwgeyBjb2xvcjogXCIyNTUsIDI1NSwgODVcIiwgXCJjbGFzc1wiOiBcImFuc2ktYnJpZ2h0LXllbGxvd1wiIH0sIHsgY29sb3I6IFwiODUsIDg1LCAyNTVcIiwgXCJjbGFzc1wiOiBcImFuc2ktYnJpZ2h0LWJsdWVcIiB9LCB7IGNvbG9yOiBcIjI1NSwgODUsIDI1NVwiLCBcImNsYXNzXCI6IFwiYW5zaS1icmlnaHQtbWFnZW50YVwiIH0sIHsgY29sb3I6IFwiODUsIDI1NSwgMjU1XCIsIFwiY2xhc3NcIjogXCJhbnNpLWJyaWdodC1jeWFuXCIgfSwgeyBjb2xvcjogXCIyNTUsIDI1NSwgMjU1XCIsIFwiY2xhc3NcIjogXCJhbnNpLWJyaWdodC13aGl0ZVwiIH1dXTtcclxuXHJcbnZhciBBbnNlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgIF9jcmVhdGVDbGFzcyhBbnNlciwgbnVsbCwgW3tcclxuICAgICAgICBrZXk6IFwiZXNjYXBlRm9ySHRtbFwiLFxyXG5cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQW5zZXIuZXNjYXBlRm9ySHRtbFxyXG4gICAgICAgICAqIEVzY2FwZSB0aGUgaW5wdXQgSFRNTC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFRoaXMgZG9lcyB0aGUgbWluaW11bSBlc2NhcGluZyBvZiB0ZXh0IHRvIG1ha2UgaXQgY29tcGxpYW50IHdpdGggSFRNTC5cclxuICAgICAgICAgKiBJbiBwYXJ0aWN1bGFyLCB0aGUgJyYnLCc8JywgYW5kICc+JyBjaGFyYWN0ZXJzIGFyZSBlc2NhcGVkLiBUaGlzIHNob3VsZFxyXG4gICAgICAgICAqIGJlIHJ1biBwcmlvciB0byBgYW5zaVRvSHRtbGAuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbmFtZSBBbnNlci5lc2NhcGVGb3JIdG1sXHJcbiAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHR4dCBUaGUgaW5wdXQgdGV4dCAoY29udGFpbmluZyB0aGUgQU5TSSBzbmlwcGV0cykuXHJcbiAgICAgICAgICogQHJldHVybnMge1N0cmluZ30gVGhlIGVzY2FwZWQgaHRtbC5cclxuICAgICAgICAgKi9cclxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZXNjYXBlRm9ySHRtbCh0eHQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBbnNlcigpLmVzY2FwZUZvckh0bWwodHh0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFuc2VyLmxpbmtpZnlcclxuICAgICAgICAgKiBBZGRzIHRoZSBsaW5rcyBpbiB0aGUgSFRNTC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFRoaXMgcmVwbGFjZXMgYW55IGxpbmtzIGluIHRoZSB0ZXh0IHdpdGggYW5jaG9yIHRhZ3MgdGhhdCBkaXNwbGF5IHRoZVxyXG4gICAgICAgICAqIGxpbmsuIFRoZSBsaW5rcyBzaG91bGQgaGF2ZSBhdCBsZWFzdCBvbmUgd2hpdGVzcGFjZSBjaGFyYWN0ZXJcclxuICAgICAgICAgKiBzdXJyb3VuZGluZyBpdC4gQWxzbywgeW91IHNob3VsZCBhcHBseSB0aGlzIGFmdGVyIHlvdSBoYXZlIHJ1blxyXG4gICAgICAgICAqIGBhbnNpVG9IdG1sYCBvbiB0aGUgdGV4dC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBuYW1lIEFuc2VyLmxpbmtpZnlcclxuICAgICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHh0IFRoZSBpbnB1dCB0ZXh0LlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBIVE1MIGNvbnRhaW5pbmcgdGhlIDxhPiB0YWdzICh1bmVzY2FwZWQpLlxyXG4gICAgICAgICAqL1xyXG5cclxuICAgIH0sIHtcclxuICAgICAgICBrZXk6IFwibGlua2lmeVwiLFxyXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBsaW5raWZ5KHR4dCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEFuc2VyKCkubGlua2lmeSh0eHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQW5zZXIuYW5zaVRvSHRtbFxyXG4gICAgICAgICAqIFRoaXMgcmVwbGFjZXMgQU5TSSB0ZXJtaW5hbCBlc2NhcGUgY29kZXMgd2l0aCBTUEFOIHRhZ3MgdGhhdCB3cmFwIHRoZVxyXG4gICAgICAgICAqIGNvbnRlbnQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBUaGlzIGZ1bmN0aW9uIG9ubHkgaW50ZXJwcmV0cyBBTlNJIFNHUiAoU2VsZWN0IEdyYXBoaWMgUmVuZGl0aW9uKSBjb2Rlc1xyXG4gICAgICAgICAqIHRoYXQgY2FuIGJlIHJlcHJlc2VudGVkIGluIEhUTUwuXHJcbiAgICAgICAgICogRm9yIGV4YW1wbGUsIGN1cnNvciBtb3ZlbWVudCBjb2RlcyBhcmUgaWdub3JlZCBhbmQgaGlkZGVuIGZyb20gb3V0cHV0LlxyXG4gICAgICAgICAqIFRoZSBkZWZhdWx0IHN0eWxlIHVzZXMgY29sb3JzIHRoYXQgYXJlIHZlcnkgY2xvc2UgdG8gdGhlIHByZXNjcmliZWRcclxuICAgICAgICAgKiBzdGFuZGFyZC4gVGhlIHN0YW5kYXJkIGFzc3VtZXMgdGhhdCB0aGUgdGV4dCB3aWxsIGhhdmUgYSBibGFja1xyXG4gICAgICAgICAqIGJhY2tncm91bmQuIFRoZXNlIGNvbG9ycyBhcmUgc2V0IGFzIGlubGluZSBzdHlsZXMgb24gdGhlIFNQQU4gdGFncy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEFub3RoZXIgb3B0aW9uIGlzIHRvIHNldCBgdXNlX2NsYXNzZXM6IHRydWVgIGluIHRoZSBvcHRpb25zIGFyZ3VtZW50LlxyXG4gICAgICAgICAqIFRoaXMgd2lsbCBpbnN0ZWFkIHNldCBjbGFzc2VzIG9uIHRoZSBzcGFucyBzbyB0aGUgY29sb3JzIGNhbiBiZSBzZXQgdmlhXHJcbiAgICAgICAgICogQ1NTLiBUaGUgY2xhc3MgbmFtZXMgdXNlZCBhcmUgb2YgdGhlIGZvcm1hdCBgYW5zaS0qLWZnL2JnYCBhbmRcclxuICAgICAgICAgKiBgYW5zaS1icmlnaHQtKi1mZy9iZ2Agd2hlcmUgYCpgIGlzIHRoZSBjb2xvciBuYW1lLFxyXG4gICAgICAgICAqIGkuZSBibGFjay9yZWQvZ3JlZW4veWVsbG93L2JsdWUvbWFnZW50YS9jeWFuL3doaXRlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG5hbWUgQW5zZXIuYW5zaVRvSHRtbFxyXG4gICAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eHQgVGhlIGlucHV0IHRleHQuXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgVGhlIG9wdGlvbnMgcGFzc2VkIHRvIHRoZSBhbnNpVG9IVE1MIG1ldGhvZC5cclxuICAgICAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgSFRNTCBvdXRwdXQuXHJcbiAgICAgICAgICovXHJcblxyXG4gICAgfSwge1xyXG4gICAgICAgIGtleTogXCJhbnNpVG9IdG1sXCIsXHJcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFuc2lUb0h0bWwodHh0LCBvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQW5zZXIoKS5hbnNpVG9IdG1sKHR4dCwgb3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBbnNlci5hbnNpVG9Kc29uXHJcbiAgICAgICAgICogQ29udmVydHMgQU5TSSBpbnB1dCBpbnRvIEpTT04gb3V0cHV0LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG5hbWUgQW5zZXIuYW5zaVRvSnNvblxyXG4gICAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eHQgVGhlIGlucHV0IHRleHQuXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgVGhlIG9wdGlvbnMgcGFzc2VkIHRvIHRoZSBhbnNpVG9IVE1MIG1ldGhvZC5cclxuICAgICAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgSFRNTCBvdXRwdXQuXHJcbiAgICAgICAgICovXHJcblxyXG4gICAgfSwge1xyXG4gICAgICAgIGtleTogXCJhbnNpVG9Kc29uXCIsXHJcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFuc2lUb0pzb24odHh0LCBvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQW5zZXIoKS5hbnNpVG9Kc29uKHR4dCwgb3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBbnNlci5hbnNpVG9UZXh0XHJcbiAgICAgICAgICogQ29udmVydHMgQU5TSSBpbnB1dCBpbnRvIHRleHQgb3V0cHV0LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG5hbWUgQW5zZXIuYW5zaVRvVGV4dFxyXG4gICAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eHQgVGhlIGlucHV0IHRleHQuXHJcbiAgICAgICAgICogQHJldHVybnMge1N0cmluZ30gVGhlIHRleHQgb3V0cHV0LlxyXG4gICAgICAgICAqL1xyXG5cclxuICAgIH0sIHtcclxuICAgICAgICBrZXk6IFwiYW5zaVRvVGV4dFwiLFxyXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhbnNpVG9UZXh0KHR4dCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEFuc2VyKCkuYW5zaVRvVGV4dCh0eHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQW5zZXJcclxuICAgICAgICAgKiBUaGUgYEFuc2VyYCBjbGFzcy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBuYW1lIEFuc2VyXHJcbiAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICogQHJldHVybnMge0Fuc2VyfVxyXG4gICAgICAgICAqL1xyXG5cclxuICAgIH1dKTtcclxuXHJcbiAgICBmdW5jdGlvbiBBbnNlcigpIHtcclxuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQW5zZXIpO1xyXG5cclxuICAgICAgICB0aGlzLmZnID0gdGhpcy5iZyA9IHRoaXMuZmdfdHJ1ZWNvbG9yID0gdGhpcy5iZ190cnVlY29sb3IgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuYnJpZ2h0ID0gMDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIHNldHVwUGFsZXR0ZVxyXG4gICAgICogU2V0cyB1cCB0aGUgcGFsZXR0ZS5cclxuICAgICAqXHJcbiAgICAgKiBAbmFtZSBzZXR1cFBhbGV0dGVcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICovXHJcblxyXG5cclxuICAgIF9jcmVhdGVDbGFzcyhBbnNlciwgW3tcclxuICAgICAgICBrZXk6IFwic2V0dXBQYWxldHRlXCIsXHJcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldHVwUGFsZXR0ZSgpIHtcclxuICAgICAgICAgICAgdGhpcy5QQUxFVFRFX0NPTE9SUyA9IFtdO1xyXG5cclxuICAgICAgICAgICAgLy8gSW5kZXggMC4uMTUgOiBTeXN0ZW0gY29sb3JcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyOyArK2kpIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgODsgKytqKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5QQUxFVFRFX0NPTE9SUy5wdXNoKEFOU0lfQ09MT1JTW2ldW2pdLmNvbG9yKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gSW5kZXggMTYuLjIzMSA6IFJHQiA2eDZ4NlxyXG4gICAgICAgICAgICAvLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9qYXNvbm0yMy8yODY4OTgxI2ZpbGUteHRlcm0tMjU2Y29sb3IteWFtbFxyXG4gICAgICAgICAgICB2YXIgbGV2ZWxzID0gWzAsIDk1LCAxMzUsIDE3NSwgMjE1LCAyNTVdO1xyXG4gICAgICAgICAgICB2YXIgZm9ybWF0ID0gZnVuY3Rpb24gZm9ybWF0KHIsIGcsIGIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBsZXZlbHNbcl0gKyBcIiwgXCIgKyBsZXZlbHNbZ10gKyBcIiwgXCIgKyBsZXZlbHNbYl07XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHZhciByID0gdm9pZCAwLFxyXG4gICAgICAgICAgICAgICAgZyA9IHZvaWQgMCxcclxuICAgICAgICAgICAgICAgIGIgPSB2b2lkIDA7XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9yID0gMDsgX3IgPCA2OyArK19yKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfZyA9IDA7IF9nIDwgNjsgKytfZykge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9iID0gMDsgX2IgPCA2OyArK19iKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuUEFMRVRURV9DT0xPUlMucHVzaChmb3JtYXQoX3IsIF9nLCBfYikpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gSW5kZXggMjMyLi4yNTUgOiBHcmF5c2NhbGVcclxuICAgICAgICAgICAgdmFyIGxldmVsID0gODtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IDI0OyArK19pLCBsZXZlbCArPSAxMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5QQUxFVFRFX0NPTE9SUy5wdXNoKGZvcm1hdChsZXZlbCwgbGV2ZWwsIGxldmVsKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIGVzY2FwZUZvckh0bWxcclxuICAgICAgICAgKiBFc2NhcGVzIHRoZSBpbnB1dCB0ZXh0LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG5hbWUgZXNjYXBlRm9ySHRtbFxyXG4gICAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eHQgVGhlIGlucHV0IHRleHQuXHJcbiAgICAgICAgICogQHJldHVybnMge1N0cmluZ30gVGhlIGVzY3BhZWQgSFRNTCBvdXRwdXQuXHJcbiAgICAgICAgICovXHJcblxyXG4gICAgfSwge1xyXG4gICAgICAgIGtleTogXCJlc2NhcGVGb3JIdG1sXCIsXHJcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGVzY2FwZUZvckh0bWwodHh0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0eHQucmVwbGFjZSgvWyY8Pl0vZ20sIGZ1bmN0aW9uIChzdHIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzdHIgPT0gXCImXCIgPyBcIiZhbXA7XCIgOiBzdHIgPT0gXCI8XCIgPyBcIiZsdDtcIiA6IHN0ciA9PSBcIj5cIiA/IFwiJmd0O1wiIDogXCJcIjtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBsaW5raWZ5XHJcbiAgICAgICAgICogQWRkcyBIVE1MIGxpbmsgZWxlbWVudHMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbmFtZSBsaW5raWZ5XHJcbiAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHR4dCBUaGUgaW5wdXQgdGV4dC5cclxuICAgICAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgSFRNTCBvdXRwdXQgY29udGFpbmluZyBsaW5rIGVsZW1lbnRzLlxyXG4gICAgICAgICAqL1xyXG5cclxuICAgIH0sIHtcclxuICAgICAgICBrZXk6IFwibGlua2lmeVwiLFxyXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBsaW5raWZ5KHR4dCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHh0LnJlcGxhY2UoLyhodHRwcz86XFwvXFwvW15cXHNdKykvZ20sIGZ1bmN0aW9uIChzdHIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBcIjxhIGhyZWY9XFxcIlwiICsgc3RyICsgXCJcXFwiPlwiICsgc3RyICsgXCI8L2E+XCI7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogYW5zaVRvSHRtbFxyXG4gICAgICAgICAqIENvbnZlcnRzIEFOU0kgaW5wdXQgaW50byBIVE1MIG91dHB1dC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBuYW1lIGFuc2lUb0h0bWxcclxuICAgICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHh0IFRoZSBpbnB1dCB0ZXh0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFRoZSBvcHRpb25zIHBhc3NlZCBvdCB0aGUgYHByb2Nlc3NgIG1ldGhvZC5cclxuICAgICAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgSFRNTCBvdXRwdXQuXHJcbiAgICAgICAgICovXHJcblxyXG4gICAgfSwge1xyXG4gICAgICAgIGtleTogXCJhbnNpVG9IdG1sXCIsXHJcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFuc2lUb0h0bWwodHh0LCBvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb2Nlc3ModHh0LCBvcHRpb25zLCB0cnVlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIGFuc2lUb0pzb25cclxuICAgICAgICAgKiBDb252ZXJ0cyBBTlNJIGlucHV0IGludG8gSFRNTCBvdXRwdXQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbmFtZSBhbnNpVG9Kc29uXHJcbiAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHR4dCBUaGUgaW5wdXQgdGV4dC5cclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBUaGUgb3B0aW9ucyBwYXNzZWQgb3QgdGhlIGBwcm9jZXNzYCBtZXRob2QuXHJcbiAgICAgICAgICogQHJldHVybnMge1N0cmluZ30gVGhlIEpTT04gb3V0cHV0LlxyXG4gICAgICAgICAqL1xyXG5cclxuICAgIH0sIHtcclxuICAgICAgICBrZXk6IFwiYW5zaVRvSnNvblwiLFxyXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhbnNpVG9Kc29uKHR4dCwgb3B0aW9ucykge1xyXG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuICAgICAgICAgICAgb3B0aW9ucy5qc29uID0gdHJ1ZTtcclxuICAgICAgICAgICAgb3B0aW9ucy5jbGVhckxpbmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzcyh0eHQsIG9wdGlvbnMsIHRydWUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogYW5zaVRvVGV4dFxyXG4gICAgICAgICAqIENvbnZlcnRzIEFOU0kgaW5wdXQgaW50byBIVE1MIG91dHB1dC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBuYW1lIGFuc2lUb1RleHRcclxuICAgICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHh0IFRoZSBpbnB1dCB0ZXh0LlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSB0ZXh0IG91dHB1dC5cclxuICAgICAgICAgKi9cclxuXHJcbiAgICB9LCB7XHJcbiAgICAgICAga2V5OiBcImFuc2lUb1RleHRcIixcclxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYW5zaVRvVGV4dCh0eHQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzcyh0eHQsIHt9LCBmYWxzZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBwcm9jZXNzXHJcbiAgICAgICAgICogUHJvY2Vzc2VzIHRoZSBpbnB1dC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBuYW1lIHByb2Nlc3NcclxuICAgICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHh0IFRoZSBpbnB1dCB0ZXh0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIEFuIG9iamVjdCBwYXNzZWQgdG8gYHByb2Nlc3NDaHVua2AgbWV0aG9kLCBleHRlbmRlZCB3aXRoOlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogIC0gYGpzb25gIChCb29sZWFuKTogSWYgYHRydWVgLCB0aGUgcmVzdWx0IHdpbGwgYmUgYW4gb2JqZWN0LlxyXG4gICAgICAgICAqICAtIGB1c2VfY2xhc3Nlc2AgKEJvb2xlYW4pOiBJZiBgdHJ1ZWAsIEhUTUwgY2xhc3NlcyB3aWxsIGJlIGFwcGVuZGVkIHRvIHRoZSBIVE1MIG91dHB1dC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gbWFya3VwXHJcbiAgICAgICAgICovXHJcblxyXG4gICAgfSwge1xyXG4gICAgICAgIGtleTogXCJwcm9jZXNzXCIsXHJcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHByb2Nlc3ModHh0LCBvcHRpb25zLCBtYXJrdXApIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuXHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICAgICAgdmFyIHJhd190ZXh0X2NodW5rcyA9IHR4dC5zcGxpdCgvXFwwMzNcXFsvKTtcclxuICAgICAgICAgICAgdmFyIGZpcnN0X2NodW5rID0gcmF3X3RleHRfY2h1bmtzLnNoaWZ0KCk7IC8vIHRoZSBmaXJzdCBjaHVuayBpcyBub3QgdGhlIHJlc3VsdCBvZiB0aGUgc3BsaXRcclxuXHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucyA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9wdGlvbnMuY2xlYXJMaW5lID0gL1xcci8udGVzdCh0eHQpOyAvLyBjaGVjayBmb3IgQ2FycmlhZ2UgUmV0dXJuXHJcbiAgICAgICAgICAgIHZhciBjb2xvcl9jaHVua3MgPSByYXdfdGV4dF9jaHVua3MubWFwKGZ1bmN0aW9uIChjaHVuaykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnByb2Nlc3NDaHVuayhjaHVuaywgb3B0aW9ucywgbWFya3VwKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmpzb24pIHtcclxuICAgICAgICAgICAgICAgIHZhciBmaXJzdCA9IHNlbGYucHJvY2Vzc0NodW5rSnNvbihcIlwiKTtcclxuICAgICAgICAgICAgICAgIGZpcnN0LmNvbnRlbnQgPSBmaXJzdF9jaHVuaztcclxuICAgICAgICAgICAgICAgIGZpcnN0LmNsZWFyTGluZSA9IG9wdGlvbnMuY2xlYXJMaW5lO1xyXG4gICAgICAgICAgICAgICAgY29sb3JfY2h1bmtzLnVuc2hpZnQoZmlyc3QpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMucmVtb3ZlX2VtcHR5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29sb3JfY2h1bmtzID0gY29sb3JfY2h1bmtzLmZpbHRlcihmdW5jdGlvbiAoYykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gIWMuaXNFbXB0eSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbG9yX2NodW5rcztcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbG9yX2NodW5rcy51bnNoaWZ0KGZpcnN0X2NodW5rKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGNvbG9yX2NodW5rcy5qb2luKFwiXCIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogcHJvY2Vzc0NodW5rSnNvblxyXG4gICAgICAgICAqIFByb2Nlc3NlcyB0aGUgY3VycmVudCBjaHVuayBpbnRvIGpzb24gb3V0cHV0LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG5hbWUgcHJvY2Vzc0NodW5rSnNvblxyXG4gICAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IFRoZSBpbnB1dCB0ZXh0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBmb2xsb3dpbmcgZmllbGRzOlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogIC0gYGpzb25gIChCb29sZWFuKTogSWYgYHRydWVgLCB0aGUgcmVzdWx0IHdpbGwgYmUgYW4gb2JqZWN0LlxyXG4gICAgICAgICAqICAtIGB1c2VfY2xhc3Nlc2AgKEJvb2xlYW4pOiBJZiBgdHJ1ZWAsIEhUTUwgY2xhc3NlcyB3aWxsIGJlIGFwcGVuZGVkIHRvIHRoZSBIVE1MIG91dHB1dC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gbWFya3VwIElmIGZhbHNlLCB0aGUgY29sb3JzIHdpbGwgbm90IGJlIHBhcnNlZC5cclxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSByZXN1bHQgb2JqZWN0OlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogIC0gYGNvbnRlbnRgIChTdHJpbmcpOiBUaGUgdGV4dC5cclxuICAgICAgICAgKiAgLSBgZmdgIChTdHJpbmd8bnVsbCk6IFRoZSBmb3JlZ3JvdW5kIGNvbG9yLlxyXG4gICAgICAgICAqICAtIGBiZ2AgKFN0cmluZ3xudWxsKTogVGhlIGJhY2tncm91bmQgY29sb3IuXHJcbiAgICAgICAgICogIC0gYGZnX3RydWVjb2xvcmAgKFN0cmluZ3xudWxsKTogVGhlIGZvcmVncm91bmQgdHJ1ZSBjb2xvciAoaWYgMTZtIGNvbG9yIGlzIGVuYWJsZWQpLlxyXG4gICAgICAgICAqICAtIGBiZ190cnVlY29sb3JgIChTdHJpbmd8bnVsbCk6IFRoZSBiYWNrZ3JvdW5kIHRydWUgY29sb3IgKGlmIDE2bSBjb2xvciBpcyBlbmFibGVkKS5cclxuICAgICAgICAgKiAgLSBgY2xlYXJMaW5lYCAoQm9vbGVhbik6IGB0cnVlYCBpZiBhIGNhcnJpYWdlUmV0dXJuIFxcciB3YXMgZm91bnQgYXQgZW5kIG9mIGxpbmUuXHJcbiAgICAgICAgICogIC0gYHdhc19wcm9jZXNzZWRgIChCb2xlYW4pOiBgdHJ1ZWAgaWYgdGhlIGNvbG9ycyB3ZXJlIHByb2Nlc3NlZCwgYGZhbHNlYCBvdGhlcndpc2UuXHJcbiAgICAgICAgICogIC0gYGlzRW1wdHlgIChGdW5jdGlvbik6IEEgZnVuY3Rpb24gcmV0dXJuaW5nIGB0cnVlYCBpZiB0aGUgY29udGVudCBpcyBlbXB0eSwgb3IgYGZhbHNlYCBvdGhlcndpc2UuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKi9cclxuXHJcbiAgICB9LCB7XHJcbiAgICAgICAga2V5OiBcInByb2Nlc3NDaHVua0pzb25cIixcclxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcHJvY2Vzc0NodW5rSnNvbih0ZXh0LCBvcHRpb25zLCBtYXJrdXApIHtcclxuXHJcbiAgICAgICAgICAgIC8vIEFyZSB3ZSB1c2luZyBjbGFzc2VzIG9yIHN0eWxlcz9cclxuICAgICAgICAgICAgb3B0aW9ucyA9IHR5cGVvZiBvcHRpb25zID09IFwidW5kZWZpbmVkXCIgPyB7fSA6IG9wdGlvbnM7XHJcbiAgICAgICAgICAgIHZhciB1c2VfY2xhc3NlcyA9IG9wdGlvbnMudXNlX2NsYXNzZXMgPSB0eXBlb2Ygb3B0aW9ucy51c2VfY2xhc3NlcyAhPSBcInVuZGVmaW5lZFwiICYmIG9wdGlvbnMudXNlX2NsYXNzZXM7XHJcbiAgICAgICAgICAgIHZhciBrZXkgPSBvcHRpb25zLmtleSA9IHVzZV9jbGFzc2VzID8gXCJjbGFzc1wiIDogXCJjb2xvclwiO1xyXG5cclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHtcclxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHRleHQsXHJcbiAgICAgICAgICAgICAgICBmZzogbnVsbCxcclxuICAgICAgICAgICAgICAgIGJnOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgZmdfdHJ1ZWNvbG9yOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgYmdfdHJ1ZWNvbG9yOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgY2xlYXJMaW5lOiBvcHRpb25zLmNsZWFyTGluZSxcclxuICAgICAgICAgICAgICAgIGRlY29yYXRpb246IG51bGwsXHJcbiAgICAgICAgICAgICAgICB3YXNfcHJvY2Vzc2VkOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGlzRW1wdHk6IGZ1bmN0aW9uIGlzRW1wdHkoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFyZXN1bHQuY29udGVudDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8vIEVhY2ggXCJjaHVua1wiIGlzIHRoZSB0ZXh0IGFmdGVyIHRoZSBDU0kgKEVTQyArIFwiW1wiKSBhbmQgYmVmb3JlIHRoZSBuZXh0IENTSS9FT0YuXHJcbiAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgIC8vIFRoaXMgcmVnZXggbWF0Y2hlcyBmb3VyIGdyb3VwcyB3aXRoaW4gYSBjaHVuay5cclxuICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgLy8gVGhlIGZpcnN0IGFuZCB0aGlyZCBncm91cHMgbWF0Y2ggY29kZSB0eXBlLlxyXG4gICAgICAgICAgICAvLyBXZSBzdXBwb3J0ZWQgb25seSBTR1IgY29tbWFuZC4gSXQgaGFzIGVtcHR5IGZpcnN0IGdyb3VwIGFuZCBcIm1cIiBpbiB0aGlyZC5cclxuICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgLy8gVGhlIHNlY29uZCBncm91cCBtYXRjaGVzIGFsbCBvZiB0aGUgbnVtYmVyK3NlbWljb2xvbiBjb21tYW5kIHNlcXVlbmNlc1xyXG4gICAgICAgICAgICAvLyBiZWZvcmUgdGhlIFwibVwiIChvciBvdGhlciB0cmFpbGluZykgY2hhcmFjdGVyLlxyXG4gICAgICAgICAgICAvLyBUaGVzZSBhcmUgdGhlIGdyYXBoaWNzIG9yIFNHUiBjb21tYW5kcy5cclxuICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgLy8gVGhlIGxhc3QgZ3JvdXAgaXMgdGhlIHRleHQgKGluY2x1ZGluZyBuZXdsaW5lcykgdGhhdCBpcyBjb2xvcmVkIGJ5XHJcbiAgICAgICAgICAgIC8vIHRoZSBvdGhlciBncm91cFwicyBjb21tYW5kcy5cclxuICAgICAgICAgICAgdmFyIG1hdGNoZXMgPSB0ZXh0Lm1hdGNoKC9eKFshXFx4M2MtXFx4M2ZdKikoW1xcZDtdKikoW1xceDIwLVxceDJjXSpbXFx4NDAtXFx4N2VdKShbXFxzXFxTXSopL20pO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFtYXRjaGVzKSByZXR1cm4gcmVzdWx0O1xyXG5cclxuICAgICAgICAgICAgdmFyIG9yaWdfdHh0ID0gcmVzdWx0LmNvbnRlbnQgPSBtYXRjaGVzWzRdO1xyXG4gICAgICAgICAgICB2YXIgbnVtcyA9IG1hdGNoZXNbMl0uc3BsaXQoXCI7XCIpO1xyXG5cclxuICAgICAgICAgICAgLy8gV2UgY3VycmVudGx5IHN1cHBvcnQgb25seSBcIlNHUlwiIChTZWxlY3QgR3JhcGhpYyBSZW5kaXRpb24pXHJcbiAgICAgICAgICAgIC8vIFNpbXBseSBpZ25vcmUgaWYgbm90IGEgU0dSIGNvbW1hbmQuXHJcbiAgICAgICAgICAgIGlmIChtYXRjaGVzWzFdICE9PSBcIlwiIHx8IG1hdGNoZXNbM10gIT09IFwibVwiKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIW1hcmt1cCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICAgICAgc2VsZi5kZWNvcmF0aW9uID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAgIHdoaWxlIChudW1zLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIHZhciBudW1fc3RyID0gbnVtcy5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIG51bSA9IHBhcnNlSW50KG51bV9zdHIpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChpc05hTihudW0pIHx8IG51bSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZmcgPSBzZWxmLmJnID0gc2VsZi5kZWNvcmF0aW9uID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobnVtID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5kZWNvcmF0aW9uID0gXCJib2xkXCI7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG51bSA9PT0gMikge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZGVjb3JhdGlvbiA9IFwiZGltXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRW5hYmxlIGNvZGUgMiB0byBnZXQgc3RyaW5nXHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG51bSA9PSAzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5kZWNvcmF0aW9uID0gXCJpdGFsaWNcIjtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobnVtID09IDQpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLmRlY29yYXRpb24gPSBcInVuZGVybGluZVwiO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChudW0gPT0gNSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZGVjb3JhdGlvbiA9IFwiYmxpbmtcIjtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobnVtID09PSA3KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5kZWNvcmF0aW9uID0gXCJyZXZlcnNlXCI7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG51bSA9PT0gOCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZGVjb3JhdGlvbiA9IFwiaGlkZGVuXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRW5hYmxlIGNvZGUgOSB0byBnZXQgc3RyaWtldGhyb3VnaFxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChudW0gPT09IDkpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLmRlY29yYXRpb24gPSBcInN0cmlrZXRocm91Z2hcIjtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobnVtID09IDM5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5mZyA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG51bSA9PSA0OSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuYmcgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEZvcmVncm91bmQgY29sb3JcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobnVtID49IDMwICYmIG51bSA8IDM4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5mZyA9IEFOU0lfQ09MT1JTWzBdW251bSAlIDEwXVtrZXldO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEZvcmVncm91bmQgYnJpZ2h0IGNvbG9yXHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG51bSA+PSA5MCAmJiBudW0gPCA5OCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZmcgPSBBTlNJX0NPTE9SU1sxXVtudW0gJSAxMF1ba2V5XTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBCYWNrZ3JvdW5kIGNvbG9yXHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG51bSA+PSA0MCAmJiBudW0gPCA0OCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuYmcgPSBBTlNJX0NPTE9SU1swXVtudW0gJSAxMF1ba2V5XTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBCYWNrZ3JvdW5kIGJyaWdodCBjb2xvclxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChudW0gPj0gMTAwICYmIG51bSA8IDEwOCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuYmcgPSBBTlNJX0NPTE9SU1sxXVtudW0gJSAxMF1ba2V5XTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobnVtID09PSAzOCB8fCBudW0gPT09IDQ4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZXh0ZW5kIGNvbG9yICgzOD1mZywgNDg9YmcpXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlzX2ZvcmVncm91bmQgPSBudW0gPT09IDM4O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChudW1zLmxlbmd0aCA+PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtb2RlID0gbnVtcy5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobW9kZSA9PT0gXCI1XCIgJiYgbnVtcy5sZW5ndGggPj0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcGFsZXR0ZSBjb2xvclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhbGV0dGVfaW5kZXggPSBwYXJzZUludChudW1zLnNoaWZ0KCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhbGV0dGVfaW5kZXggPj0gMCAmJiBwYWxldHRlX2luZGV4IDw9IDI1NSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdXNlX2NsYXNzZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLlBBTEVUVEVfQ09MT1JTKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnNldHVwUGFsZXR0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc19mb3JlZ3JvdW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmZnID0gdGhpcy5QQUxFVFRFX0NPTE9SU1twYWxldHRlX2luZGV4XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuYmcgPSB0aGlzLlBBTEVUVEVfQ09MT1JTW3BhbGV0dGVfaW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtsYXNzID0gcGFsZXR0ZV9pbmRleCA+PSAxNiA/IFwiYW5zaS1wYWxldHRlLVwiICsgcGFsZXR0ZV9pbmRleCA6IEFOU0lfQ09MT1JTW3BhbGV0dGVfaW5kZXggPiA3ID8gMSA6IDBdW3BhbGV0dGVfaW5kZXggJSA4XVtcImNsYXNzXCJdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNfZm9yZWdyb3VuZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5mZyA9IGtsYXNzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5iZyA9IGtsYXNzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1vZGUgPT09IFwiMlwiICYmIG51bXMubGVuZ3RoID49IDMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRydWUgY29sb3JcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByID0gcGFyc2VJbnQobnVtcy5zaGlmdCgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBnID0gcGFyc2VJbnQobnVtcy5zaGlmdCgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiID0gcGFyc2VJbnQobnVtcy5zaGlmdCgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyID49IDAgJiYgciA8PSAyNTUgJiYgZyA+PSAwICYmIGcgPD0gMjU1ICYmIGIgPj0gMCAmJiBiIDw9IDI1NSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb2xvciA9IHIgKyBcIiwgXCIgKyBnICsgXCIsIFwiICsgYjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXVzZV9jbGFzc2VzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc19mb3JlZ3JvdW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmZnID0gY29sb3I7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmJnID0gY29sb3I7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNfZm9yZWdyb3VuZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5mZyA9IFwiYW5zaS10cnVlY29sb3JcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZmdfdHJ1ZWNvbG9yID0gY29sb3I7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmJnID0gXCJhbnNpLXRydWVjb2xvclwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5iZ190cnVlY29sb3IgPSBjb2xvcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHNlbGYuZmcgPT09IG51bGwgJiYgc2VsZi5iZyA9PT0gbnVsbCAmJiBzZWxmLmRlY29yYXRpb24gPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3R5bGVzID0gW107XHJcbiAgICAgICAgICAgICAgICB2YXIgY2xhc3NlcyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSB7fTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXN1bHQuZmcgPSBzZWxmLmZnO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LmJnID0gc2VsZi5iZztcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5mZ190cnVlY29sb3IgPSBzZWxmLmZnX3RydWVjb2xvcjtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5iZ190cnVlY29sb3IgPSBzZWxmLmJnX3RydWVjb2xvcjtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5kZWNvcmF0aW9uID0gc2VsZi5kZWNvcmF0aW9uO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0Lndhc19wcm9jZXNzZWQgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIHByb2Nlc3NDaHVua1xyXG4gICAgICAgICAqIFByb2Nlc3NlcyB0aGUgY3VycmVudCBjaHVuayBvZiB0ZXh0LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG5hbWUgcHJvY2Vzc0NodW5rXHJcbiAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHRleHQgVGhlIGlucHV0IHRleHQuXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGZvbGxvd2luZyBmaWVsZHM6XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgLSBganNvbmAgKEJvb2xlYW4pOiBJZiBgdHJ1ZWAsIHRoZSByZXN1bHQgd2lsbCBiZSBhbiBvYmplY3QuXHJcbiAgICAgICAgICogIC0gYHVzZV9jbGFzc2VzYCAoQm9vbGVhbik6IElmIGB0cnVlYCwgSFRNTCBjbGFzc2VzIHdpbGwgYmUgYXBwZW5kZWQgdG8gdGhlIEhUTUwgb3V0cHV0LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBtYXJrdXAgSWYgZmFsc2UsIHRoZSBjb2xvcnMgd2lsbCBub3QgYmUgcGFyc2VkLlxyXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdHxTdHJpbmd9IFRoZSByZXN1bHQgKG9iamVjdCBpZiBganNvbmAgaXMgd2FudGVkIGJhY2sgb3Igc3RyaW5nIG90aGVyd2lzZSkuXHJcbiAgICAgICAgICovXHJcblxyXG4gICAgfSwge1xyXG4gICAgICAgIGtleTogXCJwcm9jZXNzQ2h1bmtcIixcclxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcHJvY2Vzc0NodW5rKHRleHQsIG9wdGlvbnMsIG1hcmt1cCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcclxuXHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcbiAgICAgICAgICAgIHZhciBqc29uQ2h1bmsgPSB0aGlzLnByb2Nlc3NDaHVua0pzb24odGV4dCwgb3B0aW9ucywgbWFya3VwKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmpzb24pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBqc29uQ2h1bms7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGpzb25DaHVuay5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBcIlwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghanNvbkNodW5rLndhc19wcm9jZXNzZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBqc29uQ2h1bmsuY29udGVudDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHVzZV9jbGFzc2VzID0gb3B0aW9ucy51c2VfY2xhc3NlcztcclxuXHJcbiAgICAgICAgICAgIHZhciBzdHlsZXMgPSBbXTtcclxuICAgICAgICAgICAgdmFyIGNsYXNzZXMgPSBbXTtcclxuICAgICAgICAgICAgdmFyIGRhdGEgPSB7fTtcclxuICAgICAgICAgICAgdmFyIHJlbmRlcl9kYXRhID0gZnVuY3Rpb24gcmVuZGVyX2RhdGEoZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGZyYWdtZW50cyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IHZvaWQgMDtcclxuICAgICAgICAgICAgICAgIGZvciAoa2V5IGluIGRhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyYWdtZW50cy5wdXNoKFwiZGF0YS1cIiArIGtleSArIFwiPVxcXCJcIiArIF90aGlzMi5lc2NhcGVGb3JIdG1sKGRhdGFba2V5XSkgKyBcIlxcXCJcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZyYWdtZW50cy5sZW5ndGggPiAwID8gXCIgXCIgKyBmcmFnbWVudHMuam9pbihcIiBcIikgOiBcIlwiO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgaWYgKGpzb25DaHVuay5mZykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHVzZV9jbGFzc2VzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKGpzb25DaHVuay5mZyArIFwiLWZnXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChqc29uQ2h1bmsuZmdfdHJ1ZWNvbG9yICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbXCJhbnNpLXRydWVjb2xvci1mZ1wiXSA9IGpzb25DaHVuay5mZ190cnVlY29sb3I7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGpzb25DaHVuay5mZ190cnVlY29sb3IgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVzLnB1c2goXCJjb2xvcjpyZ2IoXCIgKyBqc29uQ2h1bmsuZmcgKyBcIilcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChqc29uQ2h1bmsuYmcpIHtcclxuICAgICAgICAgICAgICAgIGlmICh1c2VfY2xhc3Nlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzZXMucHVzaChqc29uQ2h1bmsuYmcgKyBcIi1iZ1wiKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoanNvbkNodW5rLmJnX3RydWVjb2xvciAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhW1wiYW5zaS10cnVlY29sb3ItYmdcIl0gPSBqc29uQ2h1bmsuYmdfdHJ1ZWNvbG9yO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBqc29uQ2h1bmsuYmdfdHJ1ZWNvbG9yID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlcy5wdXNoKFwiYmFja2dyb3VuZC1jb2xvcjpyZ2IoXCIgKyBqc29uQ2h1bmsuYmcgKyBcIilcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChqc29uQ2h1bmsuZGVjb3JhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgaWYgKHVzZV9jbGFzc2VzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKFwiYW5zaS1cIiArIGpzb25DaHVuay5kZWNvcmF0aW9uKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoanNvbkNodW5rLmRlY29yYXRpb24gPT09IFwiYm9sZFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVzLnB1c2goXCJmb250LXdlaWdodDpib2xkXCIpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChqc29uQ2h1bmsuZGVjb3JhdGlvbiA9PT0gXCJkaW1cIikge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlcy5wdXNoKFwib3BhY2l0eTowLjVcIik7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGpzb25DaHVuay5kZWNvcmF0aW9uID09PSBcIml0YWxpY1wiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVzLnB1c2goXCJmb250LXN0eWxlOml0YWxpY1wiKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyB1bmRlcmxpbmUgYW5kIGJsaW5rIGFyZSB0cmVhdGVkIGJlbGxvd1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChqc29uQ2h1bmsuZGVjb3JhdGlvbiA9PT0gXCJyZXZlcnNlXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdHlsZXMucHVzaChcImZpbHRlcjppbnZlcnQoMTAwJSlcIik7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGpzb25DaHVuay5kZWNvcmF0aW9uID09PSBcImhpZGRlblwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVzLnB1c2goXCJ2aXNpYmlsaXR5OmhpZGRlblwiKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoanNvbkNodW5rLmRlY29yYXRpb24gPT09IFwic3RyaWtldGhyb3VnaFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVzLnB1c2goXCJ0ZXh0LWRlY29yYXRpb246bGluZS10aHJvdWdoXCIpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBzdHlsZXMucHVzaChcInRleHQtZGVjb3JhdGlvbjpcIiArIGpzb25DaHVuay5kZWNvcmF0aW9uKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHVzZV9jbGFzc2VzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXCI8c3BhbiBjbGFzcz1cXFwiXCIgKyBjbGFzc2VzLmpvaW4oXCIgXCIpICsgXCJcXFwiXCIgKyByZW5kZXJfZGF0YShkYXRhKSArIFwiPlwiICsganNvbkNodW5rLmNvbnRlbnQgKyBcIjwvc3Bhbj5cIjtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBcIjxzcGFuIHN0eWxlPVxcXCJcIiArIHN0eWxlcy5qb2luKFwiO1wiKSArIFwiXFxcIlwiICsgcmVuZGVyX2RhdGEoZGF0YSkgKyBcIj5cIiArIGpzb25DaHVuay5jb250ZW50ICsgXCI8L3NwYW4+XCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XSk7XHJcblxyXG4gICAgcmV0dXJuIEFuc2VyO1xyXG59KCk7XHJcblxyXG47XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEFuc2VyOyIsIid1c2Ugc3RyaWN0JztcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gKHtvbmx5Rmlyc3QgPSBmYWxzZX0gPSB7fSkgPT4ge1xyXG5cdGNvbnN0IHBhdHRlcm4gPSBbXHJcblx0XHQnW1xcXFx1MDAxQlxcXFx1MDA5Ql1bW1xcXFxdKCkjOz9dKig/Oig/Oig/OlthLXpBLVpcXFxcZF0qKD86O1stYS16QS1aXFxcXGRcXFxcLyMmLjo9PyVAfl9dKikqKT9cXFxcdTAwMDcpJyxcclxuXHRcdCcoPzooPzpcXFxcZHsxLDR9KD86O1xcXFxkezAsNH0pKik/W1xcXFxkQS1QUi1UWmNmLW50cXJ5PT48fl0pKSdcclxuXHRdLmpvaW4oJ3wnKTtcclxuXHJcblx0cmV0dXJuIG5ldyBSZWdFeHAocGF0dGVybiwgb25seUZpcnN0ID8gdW5kZWZpbmVkIDogJ2cnKTtcclxufTtcclxuIiwiLyohIGh0dHBzOi8vbXRocy5iZS9jc3Nlc2NhcGUgdjEuNS4xIGJ5IEBtYXRoaWFzIHwgTUlUIGxpY2Vuc2UgKi9cclxuOyhmdW5jdGlvbihyb290LCBmYWN0b3J5KSB7XHJcblx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL3VtZGpzL3VtZC9ibG9iL21hc3Rlci9yZXR1cm5FeHBvcnRzLmpzXHJcblx0aWYgKHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnKSB7XHJcblx0XHQvLyBGb3IgTm9kZS5qcy5cclxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyb290KTtcclxuXHR9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XHJcblx0XHQvLyBGb3IgQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxyXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5LmJpbmQocm9vdCwgcm9vdCkpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHQvLyBGb3IgYnJvd3NlciBnbG9iYWxzIChub3QgZXhwb3NpbmcgdGhlIGZ1bmN0aW9uIHNlcGFyYXRlbHkpLlxyXG5cdFx0ZmFjdG9yeShyb290KTtcclxuXHR9XHJcbn0odHlwZW9mIGdsb2JhbCAhPSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHRoaXMsIGZ1bmN0aW9uKHJvb3QpIHtcclxuXHJcblx0aWYgKHJvb3QuQ1NTICYmIHJvb3QuQ1NTLmVzY2FwZSkge1xyXG5cdFx0cmV0dXJuIHJvb3QuQ1NTLmVzY2FwZTtcclxuXHR9XHJcblxyXG5cdC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3NvbS8jc2VyaWFsaXplLWFuLWlkZW50aWZpZXJcclxuXHR2YXIgY3NzRXNjYXBlID0gZnVuY3Rpb24odmFsdWUpIHtcclxuXHRcdGlmIChhcmd1bWVudHMubGVuZ3RoID09IDApIHtcclxuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignYENTUy5lc2NhcGVgIHJlcXVpcmVzIGFuIGFyZ3VtZW50LicpO1xyXG5cdFx0fVxyXG5cdFx0dmFyIHN0cmluZyA9IFN0cmluZyh2YWx1ZSk7XHJcblx0XHR2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcclxuXHRcdHZhciBpbmRleCA9IC0xO1xyXG5cdFx0dmFyIGNvZGVVbml0O1xyXG5cdFx0dmFyIHJlc3VsdCA9ICcnO1xyXG5cdFx0dmFyIGZpcnN0Q29kZVVuaXQgPSBzdHJpbmcuY2hhckNvZGVBdCgwKTtcclxuXHRcdHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XHJcblx0XHRcdGNvZGVVbml0ID0gc3RyaW5nLmNoYXJDb2RlQXQoaW5kZXgpO1xyXG5cdFx0XHQvLyBOb3RlOiB0aGVyZeKAmXMgbm8gbmVlZCB0byBzcGVjaWFsLWNhc2UgYXN0cmFsIHN5bWJvbHMsIHN1cnJvZ2F0ZVxyXG5cdFx0XHQvLyBwYWlycywgb3IgbG9uZSBzdXJyb2dhdGVzLlxyXG5cclxuXHRcdFx0Ly8gSWYgdGhlIGNoYXJhY3RlciBpcyBOVUxMIChVKzAwMDApLCB0aGVuIHRoZSBSRVBMQUNFTUVOVCBDSEFSQUNURVJcclxuXHRcdFx0Ly8gKFUrRkZGRCkuXHJcblx0XHRcdGlmIChjb2RlVW5pdCA9PSAweDAwMDApIHtcclxuXHRcdFx0XHRyZXN1bHQgKz0gJ1xcdUZGRkQnO1xyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoXHJcblx0XHRcdFx0Ly8gSWYgdGhlIGNoYXJhY3RlciBpcyBpbiB0aGUgcmFuZ2UgW1xcMS1cXDFGXSAoVSswMDAxIHRvIFUrMDAxRikgb3IgaXNcclxuXHRcdFx0XHQvLyBVKzAwN0YsIFvigKZdXHJcblx0XHRcdFx0KGNvZGVVbml0ID49IDB4MDAwMSAmJiBjb2RlVW5pdCA8PSAweDAwMUYpIHx8IGNvZGVVbml0ID09IDB4MDA3RiB8fFxyXG5cdFx0XHRcdC8vIElmIHRoZSBjaGFyYWN0ZXIgaXMgdGhlIGZpcnN0IGNoYXJhY3RlciBhbmQgaXMgaW4gdGhlIHJhbmdlIFswLTldXHJcblx0XHRcdFx0Ly8gKFUrMDAzMCB0byBVKzAwMzkpLCBb4oCmXVxyXG5cdFx0XHRcdChpbmRleCA9PSAwICYmIGNvZGVVbml0ID49IDB4MDAzMCAmJiBjb2RlVW5pdCA8PSAweDAwMzkpIHx8XHJcblx0XHRcdFx0Ly8gSWYgdGhlIGNoYXJhY3RlciBpcyB0aGUgc2Vjb25kIGNoYXJhY3RlciBhbmQgaXMgaW4gdGhlIHJhbmdlIFswLTldXHJcblx0XHRcdFx0Ly8gKFUrMDAzMCB0byBVKzAwMzkpIGFuZCB0aGUgZmlyc3QgY2hhcmFjdGVyIGlzIGEgYC1gIChVKzAwMkQpLCBb4oCmXVxyXG5cdFx0XHRcdChcclxuXHRcdFx0XHRcdGluZGV4ID09IDEgJiZcclxuXHRcdFx0XHRcdGNvZGVVbml0ID49IDB4MDAzMCAmJiBjb2RlVW5pdCA8PSAweDAwMzkgJiZcclxuXHRcdFx0XHRcdGZpcnN0Q29kZVVuaXQgPT0gMHgwMDJEXHJcblx0XHRcdFx0KVxyXG5cdFx0XHQpIHtcclxuXHRcdFx0XHQvLyBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3Nzb20vI2VzY2FwZS1hLWNoYXJhY3Rlci1hcy1jb2RlLXBvaW50XHJcblx0XHRcdFx0cmVzdWx0ICs9ICdcXFxcJyArIGNvZGVVbml0LnRvU3RyaW5nKDE2KSArICcgJztcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKFxyXG5cdFx0XHRcdC8vIElmIHRoZSBjaGFyYWN0ZXIgaXMgdGhlIGZpcnN0IGNoYXJhY3RlciBhbmQgaXMgYSBgLWAgKFUrMDAyRCksIGFuZFxyXG5cdFx0XHRcdC8vIHRoZXJlIGlzIG5vIHNlY29uZCBjaGFyYWN0ZXIsIFvigKZdXHJcblx0XHRcdFx0aW5kZXggPT0gMCAmJlxyXG5cdFx0XHRcdGxlbmd0aCA9PSAxICYmXHJcblx0XHRcdFx0Y29kZVVuaXQgPT0gMHgwMDJEXHJcblx0XHRcdCkge1xyXG5cdFx0XHRcdHJlc3VsdCArPSAnXFxcXCcgKyBzdHJpbmcuY2hhckF0KGluZGV4KTtcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gSWYgdGhlIGNoYXJhY3RlciBpcyBub3QgaGFuZGxlZCBieSBvbmUgb2YgdGhlIGFib3ZlIHJ1bGVzIGFuZCBpc1xyXG5cdFx0XHQvLyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gVSswMDgwLCBpcyBgLWAgKFUrMDAyRCkgb3IgYF9gIChVKzAwNUYpLCBvclxyXG5cdFx0XHQvLyBpcyBpbiBvbmUgb2YgdGhlIHJhbmdlcyBbMC05XSAoVSswMDMwIHRvIFUrMDAzOSksIFtBLVpdIChVKzAwNDEgdG9cclxuXHRcdFx0Ly8gVSswMDVBKSwgb3IgW2Etel0gKFUrMDA2MSB0byBVKzAwN0EpLCBb4oCmXVxyXG5cdFx0XHRpZiAoXHJcblx0XHRcdFx0Y29kZVVuaXQgPj0gMHgwMDgwIHx8XHJcblx0XHRcdFx0Y29kZVVuaXQgPT0gMHgwMDJEIHx8XHJcblx0XHRcdFx0Y29kZVVuaXQgPT0gMHgwMDVGIHx8XHJcblx0XHRcdFx0Y29kZVVuaXQgPj0gMHgwMDMwICYmIGNvZGVVbml0IDw9IDB4MDAzOSB8fFxyXG5cdFx0XHRcdGNvZGVVbml0ID49IDB4MDA0MSAmJiBjb2RlVW5pdCA8PSAweDAwNUEgfHxcclxuXHRcdFx0XHRjb2RlVW5pdCA+PSAweDAwNjEgJiYgY29kZVVuaXQgPD0gMHgwMDdBXHJcblx0XHRcdCkge1xyXG5cdFx0XHRcdC8vIHRoZSBjaGFyYWN0ZXIgaXRzZWxmXHJcblx0XHRcdFx0cmVzdWx0ICs9IHN0cmluZy5jaGFyQXQoaW5kZXgpO1xyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBPdGhlcndpc2UsIHRoZSBlc2NhcGVkIGNoYXJhY3Rlci5cclxuXHRcdFx0Ly8gaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzc29tLyNlc2NhcGUtYS1jaGFyYWN0ZXJcclxuXHRcdFx0cmVzdWx0ICs9ICdcXFxcJyArIHN0cmluZy5jaGFyQXQoaW5kZXgpO1xyXG5cclxuXHRcdH1cclxuXHRcdHJldHVybiByZXN1bHQ7XHJcblx0fTtcclxuXHJcblx0aWYgKCFyb290LkNTUykge1xyXG5cdFx0cm9vdC5DU1MgPSB7fTtcclxuXHR9XHJcblxyXG5cdHJvb3QuQ1NTLmVzY2FwZSA9IGNzc0VzY2FwZTtcclxuXHRyZXR1cm4gY3NzRXNjYXBlO1xyXG5cclxufSkpO1xyXG4iLCJ2YXIgZSx0PShlPXJlcXVpcmUoXCJxdWVyeXN0cmluZ1wiKSkmJlwib2JqZWN0XCI9PXR5cGVvZiBlJiZcImRlZmF1bHRcImluIGU/ZS5kZWZhdWx0OmUscj0vaHR0cHM/fGZ0cHxnb3BoZXJ8ZmlsZS87ZnVuY3Rpb24gbyhlKXtcInN0cmluZ1wiPT10eXBlb2YgZSYmKGU9ZyhlKSk7dmFyIG89ZnVuY3Rpb24oZSx0LHIpe3ZhciBvPWUuYXV0aCxhPWUuaG9zdG5hbWUscz1lLnByb3RvY29sfHxcIlwiLGM9ZS5wYXRobmFtZXx8XCJcIixoPWUuaGFzaHx8XCJcIixwPWUucXVlcnl8fFwiXCIsbj0hMTtvPW8/ZW5jb2RlVVJJQ29tcG9uZW50KG8pLnJlcGxhY2UoLyUzQS9pLFwiOlwiKStcIkBcIjpcIlwiLGUuaG9zdD9uPW8rZS5ob3N0OmEmJihuPW8rKH5hLmluZGV4T2YoXCI6XCIpP1wiW1wiK2ErXCJdXCI6YSksZS5wb3J0JiYobis9XCI6XCIrZS5wb3J0KSkscCYmXCJvYmplY3RcIj09dHlwZW9mIHAmJihwPXQuZW5jb2RlKHApKTt2YXIgbD1lLnNlYXJjaHx8cCYmXCI/XCIrcHx8XCJcIjtyZXR1cm4gcyYmXCI6XCIhPT1zLnN1YnN0cigtMSkmJihzKz1cIjpcIiksZS5zbGFzaGVzfHwoIXN8fHIudGVzdChzKSkmJiExIT09bj8obj1cIi8vXCIrKG58fFwiXCIpLGMmJlwiL1wiIT09Y1swXSYmKGM9XCIvXCIrYykpOm58fChuPVwiXCIpLGgmJlwiI1wiIT09aFswXSYmKGg9XCIjXCIraCksbCYmXCI/XCIhPT1sWzBdJiYobD1cIj9cIitsKSx7cHJvdG9jb2w6cyxob3N0Om4scGF0aG5hbWU6Yz1jLnJlcGxhY2UoL1s/I10vZyxlbmNvZGVVUklDb21wb25lbnQpLHNlYXJjaDpsPWwucmVwbGFjZShcIiNcIixcIiUyM1wiKSxoYXNoOmh9fShlLHQscik7cmV0dXJuXCJcIitvLnByb3RvY29sK28uaG9zdCtvLnBhdGhuYW1lK28uc2VhcmNoK28uaGFzaH12YXIgYT1cImh0dHA6Ly9cIixzPVwidy53XCIsYz1hK3MsaD0vXihbYS16MC05ListXSo6XFwvXFwvXFwvKShbYS16MC05ListXTpcXC8qKT8vaSxwPS9odHRwcz98ZnRwfGdvcGhlcnxmaWxlLztmdW5jdGlvbiBuKGUsdCl7dmFyIHI9XCJzdHJpbmdcIj09dHlwZW9mIGU/ZyhlKTplO2U9XCJvYmplY3RcIj09dHlwZW9mIGU/byhlKTplO3ZhciBzPWcodCksbj1cIlwiO3IucHJvdG9jb2wmJiFyLnNsYXNoZXMmJihuPXIucHJvdG9jb2wsZT1lLnJlcGxhY2Uoci5wcm90b2NvbCxcIlwiKSxuKz1cIi9cIj09PXRbMF18fFwiL1wiPT09ZVswXT9cIi9cIjpcIlwiKSxuJiZzLnByb3RvY29sJiYobj1cIlwiLHMuc2xhc2hlc3x8KG49cy5wcm90b2NvbCx0PXQucmVwbGFjZShzLnByb3RvY29sLFwiXCIpKSk7dmFyIGw9ZS5tYXRjaChoKTtsJiYhcy5wcm90b2NvbCYmKGU9ZS5zdWJzdHIoKG49bFsxXSsobFsyXXx8XCJcIikpLmxlbmd0aCksL15cXC9cXC9bXi9dLy50ZXN0KHQpJiYobj1uLnNsaWNlKDAsLTEpKSk7dmFyIGk9bmV3IFVSTChlLGMrXCIvXCIpLGY9bmV3IFVSTCh0LGkpLnRvU3RyaW5nKCkucmVwbGFjZShjLFwiXCIpLHU9cy5wcm90b2NvbHx8ci5wcm90b2NvbDtyZXR1cm4gdSs9ci5zbGFzaGVzfHxzLnNsYXNoZXM/XCIvL1wiOlwiXCIsIW4mJnU/Zj1mLnJlcGxhY2UoYSx1KTpuJiYoZj1mLnJlcGxhY2UoYSxcIlwiKSkscC50ZXN0KGYpfHx+dC5pbmRleE9mKFwiLlwiKXx8XCIvXCI9PT1lLnNsaWNlKC0xKXx8XCIvXCI9PT10LnNsaWNlKC0xKXx8XCIvXCIhPT1mLnNsaWNlKC0xKXx8KGY9Zi5zbGljZSgwLC0xKSksbiYmKGY9bisoXCIvXCI9PT1mWzBdP2Yuc3Vic3RyKDEpOmYpKSxmfWZ1bmN0aW9uIGwoKXt9bC5wYXJzZT1nLGwuZm9ybWF0PW8sbC5yZXNvbHZlPW4sbC5yZXNvbHZlT2JqZWN0PW47dmFyIGk9L15odHRwcz98ZnRwfGdvcGhlcnxmaWxlLyxmPS9eKC4qPykoWyM/XS4qKS8sdT0vXihbYS16MC05ListXSo6KShcXC97MCwzfSkoLiopL2ksbT0vXihbYS16MC05ListXSo6KT9cXC9cXC9cXC8qL2ksdj0vXihbYS16MC05ListXSo6KShcXC97MCwyfSlcXFsoLiopXFxdJC9pO2Z1bmN0aW9uIGQoZSl7dHJ5e3JldHVybiBkZWNvZGVVUkkoZSl9Y2F0Y2godCl7cmV0dXJuIGV9fWZ1bmN0aW9uIGcoZSxyLGEpe2lmKHZvaWQgMD09PXImJihyPSExKSx2b2lkIDA9PT1hJiYoYT0hMSksZSYmXCJvYmplY3RcIj09dHlwZW9mIGUmJmUgaW5zdGFuY2VvZiBsKXJldHVybiBlO3ZhciBoPShlPWUudHJpbSgpKS5tYXRjaChmKTtlPWg/ZChoWzFdKS5yZXBsYWNlKC9cXFxcL2csXCIvXCIpK2hbMl06ZChlKS5yZXBsYWNlKC9cXFxcL2csXCIvXCIpLHYudGVzdChlKSYmXCIvXCIhPT1lLnNsaWNlKC0xKSYmKGUrPVwiL1wiKTt2YXIgcD0hLyheamF2YXNjcmlwdCkvLnRlc3QoZSkmJmUubWF0Y2godSksbj1tLnRlc3QoZSksZz1cIlwiO3AmJihpLnRlc3QocFsxXSl8fChnPXBbMV0udG9Mb3dlckNhc2UoKSxlPVwiXCIrcFsyXStwWzNdKSxwWzJdfHwobj0hMSxpLnRlc3QocFsxXSk/KGc9cFsxXSxlPVwiXCIrcFszXSk6ZT1cIi8vXCIrcFszXSksMyE9PXBbMl0ubGVuZ3RoJiYxIT09cFsyXS5sZW5ndGh8fChnPXBbMV0sZT1cIi9cIitwWzNdKSk7dmFyIGIseT0oaD9oWzFdOmUpLm1hdGNoKC8oOlswLTldKykvKSxqPVwiXCI7eSYmeVsxXSYmMz09PXlbMV0ubGVuZ3RoJiYoZT1lLnJlcGxhY2Uoaj15WzFdLGorXCIwMFwiKSk7dmFyIHc9bmV3IGwseD1cIlwiLFU9XCJcIjt0cnl7Yj1uZXcgVVJMKGUpfWNhdGNoKHQpe3g9dCxnfHxhfHwhL15cXC9cXC8vLnRlc3QoZSl8fC9eXFwvXFwvLitbQC5dLy50ZXN0KGUpfHwoVT1cIi9cIixlPWUuc3Vic3RyKDEpKTt0cnl7Yj1uZXcgVVJMKGUsYyl9Y2F0Y2goZSl7cmV0dXJuIHcucHJvdG9jb2w9Zyx3LmhyZWY9Zyx3fX13LnNsYXNoZXM9biYmIVUsdy5ob3N0PWIuaG9zdD09PXM/XCJcIjpiLmhvc3Qsdy5ob3N0bmFtZT1iLmhvc3RuYW1lPT09cz9cIlwiOmIuaG9zdG5hbWUucmVwbGFjZSgvKFxcW3xcXF0pL2csXCJcIiksdy5wcm90b2NvbD14P2d8fG51bGw6Yi5wcm90b2NvbCx3LnNlYXJjaD1iLnNlYXJjaC5yZXBsYWNlKC9cXFxcL2csXCIlNUNcIiksdy5oYXNoPWIuaGFzaC5yZXBsYWNlKC9cXFxcL2csXCIlNUNcIik7dmFyIFI9ZS5zcGxpdChcIiNcIik7IXcuc2VhcmNoJiZ+UlswXS5pbmRleE9mKFwiP1wiKSYmKHcuc2VhcmNoPVwiP1wiKSx3Lmhhc2h8fFwiXCIhPT1SWzFdfHwody5oYXNoPVwiI1wiKSx3LnF1ZXJ5PXI/dC5kZWNvZGUoYi5zZWFyY2guc3Vic3RyKDEpKTp3LnNlYXJjaC5zdWJzdHIoMSksdy5wYXRobmFtZT1VK2QoYi5wYXRobmFtZSkucmVwbGFjZSgvXCIvZyxcIiUyMlwiKSxcImFib3V0OlwiPT09dy5wcm90b2NvbCYmXCJibGFua1wiPT09dy5wYXRobmFtZSYmKHcucHJvdG9jb2w9XCJcIix3LnBhdGhuYW1lPVwiXCIpLHgmJlwiL1wiIT09ZVswXSYmKHcucGF0aG5hbWU9dy5wYXRobmFtZS5zdWJzdHIoMSkpLGcmJiFpLnRlc3QoZykmJlwiL1wiIT09ZS5zbGljZSgtMSkmJlwiL1wiPT09dy5wYXRobmFtZSYmKHcucGF0aG5hbWU9XCJcIiksdy5wYXRoPXcucGF0aG5hbWUrdy5zZWFyY2gsdy5hdXRoPVtiLnVzZXJuYW1lLGIucGFzc3dvcmRdLm1hcChkZWNvZGVVUklDb21wb25lbnQpLmZpbHRlcihCb29sZWFuKS5qb2luKFwiOlwiKSx3LnBvcnQ9Yi5wb3J0LGomJih3Lmhvc3Q9dy5ob3N0LnJlcGxhY2UoaitcIjAwXCIsaiksdy5wb3J0PXcucG9ydC5zbGljZSgwLC0yKSksdy5ocmVmPVU/XCJcIit3LnBhdGhuYW1lK3cuc2VhcmNoK3cuaGFzaDpvKHcpO3ZhciBPPS9eKGZpbGUpLy50ZXN0KHcuaHJlZik/W1wiaG9zdFwiLFwiaG9zdG5hbWVcIl06W107cmV0dXJuIE9iamVjdC5rZXlzKHcpLmZvckVhY2goZnVuY3Rpb24oZSl7fk8uaW5kZXhPZihlKXx8KHdbZV09d1tlXXx8bnVsbCl9KSx3fWV4cG9ydHMucGFyc2U9ZyxleHBvcnRzLmZvcm1hdD1vLGV4cG9ydHMucmVzb2x2ZT1uLGV4cG9ydHMucmVzb2x2ZU9iamVjdD1mdW5jdGlvbihlLHQpe3JldHVybiBnKG4oZSx0KSl9LGV4cG9ydHMuVXJsPWw7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxyXG4iLCJQcm9taXNlLnByb3RvdHlwZS5maW5hbGx5PWZ1bmN0aW9uKG4pe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIG4pcmV0dXJuIHRoaXMudGhlbihuLG4pO3ZhciB0PXRoaXMuY29uc3RydWN0b3J8fFByb21pc2U7cmV0dXJuIHRoaXMudGhlbihmdW5jdGlvbihyKXtyZXR1cm4gdC5yZXNvbHZlKG4oKSkudGhlbihmdW5jdGlvbigpe3JldHVybiByfSl9LGZ1bmN0aW9uKHIpe3JldHVybiB0LnJlc29sdmUobigpKS50aGVuKGZ1bmN0aW9uKCl7dGhyb3cgcn0pfSl9OyIsIm1vZHVsZS5leHBvcnRzPWZ1bmN0aW9uKGUsbil7cmV0dXJuIG49bnx8e30sbmV3IFByb21pc2UoZnVuY3Rpb24odCxyKXt2YXIgcz1uZXcgWE1MSHR0cFJlcXVlc3Qsbz1bXSx1PVtdLGk9e30sYT1mdW5jdGlvbigpe3JldHVybntvazoyPT0ocy5zdGF0dXMvMTAwfDApLHN0YXR1c1RleHQ6cy5zdGF0dXNUZXh0LHN0YXR1czpzLnN0YXR1cyx1cmw6cy5yZXNwb25zZVVSTCx0ZXh0OmZ1bmN0aW9uKCl7cmV0dXJuIFByb21pc2UucmVzb2x2ZShzLnJlc3BvbnNlVGV4dCl9LGpzb246ZnVuY3Rpb24oKXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKEpTT04ucGFyc2Uocy5yZXNwb25zZVRleHQpKX0sYmxvYjpmdW5jdGlvbigpe3JldHVybiBQcm9taXNlLnJlc29sdmUobmV3IEJsb2IoW3MucmVzcG9uc2VdKSl9LGNsb25lOmEsaGVhZGVyczp7a2V5czpmdW5jdGlvbigpe3JldHVybiBvfSxlbnRyaWVzOmZ1bmN0aW9uKCl7cmV0dXJuIHV9LGdldDpmdW5jdGlvbihlKXtyZXR1cm4gaVtlLnRvTG93ZXJDYXNlKCldfSxoYXM6ZnVuY3Rpb24oZSl7cmV0dXJuIGUudG9Mb3dlckNhc2UoKWluIGl9fX19O2Zvcih2YXIgbCBpbiBzLm9wZW4obi5tZXRob2R8fFwiZ2V0XCIsZSwhMCkscy5vbmxvYWQ9ZnVuY3Rpb24oKXtzLmdldEFsbFJlc3BvbnNlSGVhZGVycygpLnJlcGxhY2UoL14oLio/KTpbXlxcU1xcbl0qKFtcXHNcXFNdKj8pJC9nbSxmdW5jdGlvbihlLG4sdCl7by5wdXNoKG49bi50b0xvd2VyQ2FzZSgpKSx1LnB1c2goW24sdF0pLGlbbl09aVtuXT9pW25dK1wiLFwiK3Q6dH0pLHQoYSgpKX0scy5vbmVycm9yPXIscy53aXRoQ3JlZGVudGlhbHM9XCJpbmNsdWRlXCI9PW4uY3JlZGVudGlhbHMsbi5oZWFkZXJzKXMuc2V0UmVxdWVzdEhlYWRlcihsLG4uaGVhZGVyc1tsXSk7cy5zZW5kKG4uYm9keXx8bnVsbCl9KX07XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVuZmV0Y2guanMubWFwXHJcbiIsImltcG9ydCB7IGdldEV2ZW50U291cmNlV3JhcHBlciB9IGZyb20gJy4vZXJyb3Itb3ZlcmxheS9ldmVudHNvdXJjZSdcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaW5pdGlhbGl6ZUJ1aWxkV2F0Y2hlcigpIHtcbiAgY29uc3Qgc2hhZG93SG9zdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gIHNoYWRvd0hvc3QuaWQgPSAnX19uZXh0LWJ1aWxkLXdhdGNoZXInXG4gIC8vIE1ha2Ugc3VyZSBjb250YWluZXIgaXMgZml4ZWQgYW5kIG9uIGEgaGlnaCB6SW5kZXggc28gaXQgc2hvd3NcbiAgc2hhZG93SG9zdC5zdHlsZS5wb3NpdGlvbiA9ICdmaXhlZCdcbiAgc2hhZG93SG9zdC5zdHlsZS5ib3R0b20gPSAnMTBweCdcbiAgc2hhZG93SG9zdC5zdHlsZS5yaWdodCA9ICcyMHB4J1xuICBzaGFkb3dIb3N0LnN0eWxlLndpZHRoID0gMFxuICBzaGFkb3dIb3N0LnN0eWxlLmhlaWdodCA9IDBcbiAgc2hhZG93SG9zdC5zdHlsZS56SW5kZXggPSA5OTk5OVxuICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHNoYWRvd0hvc3QpXG5cbiAgbGV0IHNoYWRvd1Jvb3RcbiAgbGV0IHByZWZpeCA9ICcnXG5cbiAgaWYgKHNoYWRvd0hvc3QuYXR0YWNoU2hhZG93KSB7XG4gICAgc2hhZG93Um9vdCA9IHNoYWRvd0hvc3QuYXR0YWNoU2hhZG93KHsgbW9kZTogJ29wZW4nIH0pXG4gIH0gZWxzZSB7XG4gICAgLy8gSWYgYXR0YWNoU2hhZG93IGlzIHVuZGVmaW5lZCB0aGVuIHRoZSBicm93c2VyIGRvZXMgbm90IHN1cHBvcnRcbiAgICAvLyB0aGUgU2hhZG93IERPTSwgd2UgbmVlZCB0byBwcmVmaXggYWxsIHRoZSBuYW1lcyBzbyB0aGVyZVxuICAgIC8vIHdpbGwgYmUgbm8gY29uZmxpY3RzXG4gICAgc2hhZG93Um9vdCA9IHNoYWRvd0hvc3RcbiAgICBwcmVmaXggPSAnX19uZXh0LWJ1aWxkLXdhdGNoZXItJ1xuICB9XG5cbiAgLy8gQ29udGFpbmVyXG4gIGNvbnN0IGNvbnRhaW5lciA9IGNyZWF0ZUNvbnRhaW5lcihwcmVmaXgpXG4gIHNoYWRvd1Jvb3QuYXBwZW5kQ2hpbGQoY29udGFpbmVyKVxuXG4gIC8vIENTU1xuICBjb25zdCBjc3MgPSBjcmVhdGVDc3MocHJlZml4KVxuICBzaGFkb3dSb290LmFwcGVuZENoaWxkKGNzcylcblxuICAvLyBTdGF0ZVxuICBsZXQgaXNWaXNpYmxlID0gZmFsc2VcbiAgbGV0IGlzQnVpbGRpbmcgPSBmYWxzZVxuICBsZXQgdGltZW91dElkID0gbnVsbFxuXG4gIC8vIEhhbmRsZSBldmVudHNcbiAgY29uc3QgZXZ0U291cmNlID0gZ2V0RXZlbnRTb3VyY2VXcmFwcGVyKHsgcGF0aDogJy9fbmV4dC93ZWJwYWNrLWhtcicgfSlcbiAgZXZ0U291cmNlLmFkZE1lc3NhZ2VMaXN0ZW5lcigoZXZlbnQpID0+IHtcbiAgICAvLyBUaGlzIGlzIHRoZSBoZWFydGJlYXQgZXZlbnRcbiAgICBpZiAoZXZlbnQuZGF0YSA9PT0gJ1xcdUQ4M0RcXHVEQzkzJykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGhhbmRsZU1lc3NhZ2UoZXZlbnQpXG4gICAgfSBjYXRjaCB7fVxuICB9KVxuXG4gIGZ1bmN0aW9uIGhhbmRsZU1lc3NhZ2UoZXZlbnQpIHtcbiAgICBjb25zdCBvYmogPSBKU09OLnBhcnNlKGV2ZW50LmRhdGEpXG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVmYXVsdC1jYXNlXG4gICAgc3dpdGNoIChvYmouYWN0aW9uKSB7XG4gICAgICBjYXNlICdidWlsZGluZyc6XG4gICAgICAgIHRpbWVvdXRJZCAmJiBjbGVhclRpbWVvdXQodGltZW91dElkKVxuICAgICAgICBpc1Zpc2libGUgPSB0cnVlXG4gICAgICAgIGlzQnVpbGRpbmcgPSB0cnVlXG4gICAgICAgIHVwZGF0ZUNvbnRhaW5lcigpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdidWlsdCc6XG4gICAgICBjYXNlICdzeW5jJzpcbiAgICAgICAgaXNCdWlsZGluZyA9IGZhbHNlXG4gICAgICAgIC8vIFdhaXQgZm9yIHRoZSBmYWRlIG91dCB0cmFuc3Rpb24gdG8gY29tcGxldGVcbiAgICAgICAgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgaXNWaXNpYmxlID0gZmFsc2VcbiAgICAgICAgICB1cGRhdGVDb250YWluZXIoKVxuICAgICAgICB9LCAxMDApXG4gICAgICAgIHVwZGF0ZUNvbnRhaW5lcigpXG4gICAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlQ29udGFpbmVyKCkge1xuICAgIGlmIChpc0J1aWxkaW5nKSB7XG4gICAgICBjb250YWluZXIuY2xhc3NMaXN0LmFkZChgJHtwcmVmaXh9YnVpbGRpbmdgKVxuICAgIH0gZWxzZSB7XG4gICAgICBjb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZShgJHtwcmVmaXh9YnVpbGRpbmdgKVxuICAgIH1cblxuICAgIGlmIChpc1Zpc2libGUpIHtcbiAgICAgIGNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKGAke3ByZWZpeH12aXNpYmxlYClcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUoYCR7cHJlZml4fXZpc2libGVgKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDb250YWluZXIocHJlZml4KSB7XG4gIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gIGNvbnRhaW5lci5pZCA9IGAke3ByZWZpeH1jb250YWluZXJgXG4gIGNvbnRhaW5lci5pbm5lckhUTUwgPSBgXG4gICAgPGRpdiBpZD1cIiR7cHJlZml4fWljb24td3JhcHBlclwiPlxuICAgICAgPHN2ZyB2aWV3Qm94PVwiMCAwIDIyNiAyMDBcIj5cbiAgICAgICAgPGRlZnM+XG4gICAgICAgICAgPGxpbmVhckdyYWRpZW50XG4gICAgICAgICAgICB4MT1cIjExNC43MjA3NzUlXCJcbiAgICAgICAgICAgIHkxPVwiMTgxLjI4MzI0NSVcIlxuICAgICAgICAgICAgeDI9XCIzOS41Mzk5MzA2JVwiXG4gICAgICAgICAgICB5Mj1cIjEwMCVcIlxuICAgICAgICAgICAgaWQ9XCIke3ByZWZpeH1saW5lYXItZ3JhZGllbnRcIlxuICAgICAgICAgID5cbiAgICAgICAgICAgIDxzdG9wIHN0b3AtY29sb3I9XCIjRkZGRkZGXCIgb2Zmc2V0PVwiMCVcIiAvPlxuICAgICAgICAgICAgPHN0b3Agc3RvcC1jb2xvcj1cIiMwMDAwMDBcIiBvZmZzZXQ9XCIxMDAlXCIgLz5cbiAgICAgICAgICA8L2xpbmVhckdyYWRpZW50PlxuICAgICAgICA8L2RlZnM+XG4gICAgICAgIDxnIGlkPVwiJHtwcmVmaXh9aWNvbi1ncm91cFwiIGZpbGw9XCJub25lXCIgc3Ryb2tlPVwidXJsKCMke3ByZWZpeH1saW5lYXItZ3JhZGllbnQpXCIgc3Ryb2tlLXdpZHRoPVwiMThcIj5cbiAgICAgICAgICA8cGF0aCBkPVwiTTExMyw1LjA4MjE5MTE3IEw0LjI4MzkzODAxLDE5Ny41IEwyMjEuNzE2MDYyLDE5Ny41IEwxMTMsNS4wODIxOTExNyBaXCIgLz5cbiAgICAgICAgPC9nPlxuICAgICAgPC9zdmc+XG4gICAgPC9kaXY+XG4gIGBcblxuICByZXR1cm4gY29udGFpbmVyXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNzcyhwcmVmaXgpIHtcbiAgY29uc3QgY3NzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKVxuICBjc3MudGV4dENvbnRlbnQgPSBgXG4gICAgIyR7cHJlZml4fWNvbnRhaW5lciB7XG4gICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICBib3R0b206IDEwcHg7XG4gICAgICByaWdodDogMzBweDtcblxuICAgICAgYmFja2dyb3VuZDogI2ZmZjtcbiAgICAgIGNvbG9yOiAjMDAwO1xuICAgICAgZm9udDogaW5pdGlhbDtcbiAgICAgIGN1cnNvcjogaW5pdGlhbDtcbiAgICAgIGxldHRlci1zcGFjaW5nOiBpbml0aWFsO1xuICAgICAgdGV4dC1zaGFkb3c6IGluaXRpYWw7XG4gICAgICB0ZXh0LXRyYW5zZm9ybTogaW5pdGlhbDtcbiAgICAgIHZpc2liaWxpdHk6IGluaXRpYWw7XG5cbiAgICAgIHBhZGRpbmc6IDhweCAxMHB4O1xuICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgIGJveC1zaGFkb3c6IDAgMTFweCA0MHB4IDAgcmdiYSgwLCAwLCAwLCAwLjI1KSwgMCAycHggMTBweCAwIHJnYmEoMCwgMCwgMCwgMC4xMik7XG5cbiAgICAgIGRpc3BsYXk6IG5vbmU7XG4gICAgICBvcGFjaXR5OiAwO1xuICAgICAgdHJhbnNpdGlvbjogb3BhY2l0eSAwLjFzIGVhc2UsIGJvdHRvbSAwLjFzIGVhc2U7XG4gICAgICBhbmltYXRpb246ICR7cHJlZml4fWZhZGUtaW4gMC4xcyBlYXNlLWluLW91dDtcbiAgICB9XG5cbiAgICAjJHtwcmVmaXh9Y29udGFpbmVyLiR7cHJlZml4fXZpc2libGUge1xuICAgICAgZGlzcGxheTogZmxleDtcbiAgICB9XG5cbiAgICAjJHtwcmVmaXh9Y29udGFpbmVyLiR7cHJlZml4fWJ1aWxkaW5nIHtcbiAgICAgIGJvdHRvbTogMjBweDtcbiAgICAgIG9wYWNpdHk6IDE7XG4gICAgfVxuXG4gICAgIyR7cHJlZml4fWljb24td3JhcHBlciB7XG4gICAgICB3aWR0aDogMTZweDtcbiAgICAgIGhlaWdodDogMTZweDtcbiAgICB9XG5cbiAgICAjJHtwcmVmaXh9aWNvbi13cmFwcGVyID4gc3ZnIHtcbiAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgIH1cblxuICAgICMke3ByZWZpeH1pY29uLWdyb3VwIHtcbiAgICAgIGFuaW1hdGlvbjogJHtwcmVmaXh9c3Ryb2tlZGFzaCAxcyBlYXNlLWluLW91dCBib3RoIGluZmluaXRlO1xuICAgIH1cblxuICAgIEBrZXlmcmFtZXMgJHtwcmVmaXh9ZmFkZS1pbiB7XG4gICAgICBmcm9tIHtcbiAgICAgICAgYm90dG9tOiAxMHB4O1xuICAgICAgICBvcGFjaXR5OiAwO1xuICAgICAgfVxuICAgICAgdG8ge1xuICAgICAgICBib3R0b206IDIwcHg7XG4gICAgICAgIG9wYWNpdHk6IDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgQGtleWZyYW1lcyAke3ByZWZpeH1zdHJva2VkYXNoIHtcbiAgICAgIDAlIHtcbiAgICAgICAgc3Ryb2tlLWRhc2hhcnJheTogMCAyMjY7XG4gICAgICB9XG4gICAgICA4MCUsXG4gICAgICAxMDAlIHtcbiAgICAgICAgc3Ryb2tlLWRhc2hhcnJheTogNjU5IDIyNjtcbiAgICAgIH1cbiAgICB9XG4gIGBcblxuICByZXR1cm4gY3NzXG59XG4iLCJjb25zdCBldmVudENhbGxiYWNrcyA9IFtdXG5cbmZ1bmN0aW9uIEV2ZW50U291cmNlV3JhcHBlcihvcHRpb25zKSB7XG4gIHZhciBzb3VyY2VcbiAgdmFyIGxhc3RBY3Rpdml0eSA9IG5ldyBEYXRlKClcbiAgdmFyIGxpc3RlbmVycyA9IFtdXG5cbiAgaWYgKCFvcHRpb25zLnRpbWVvdXQpIHtcbiAgICBvcHRpb25zLnRpbWVvdXQgPSAyMCAqIDEwMDBcbiAgfVxuXG4gIGluaXQoKVxuICB2YXIgdGltZXIgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKG5ldyBEYXRlKCkgLSBsYXN0QWN0aXZpdHkgPiBvcHRpb25zLnRpbWVvdXQpIHtcbiAgICAgIGhhbmRsZURpc2Nvbm5lY3QoKVxuICAgIH1cbiAgfSwgb3B0aW9ucy50aW1lb3V0IC8gMilcblxuICBmdW5jdGlvbiBpbml0KCkge1xuICAgIHNvdXJjZSA9IG5ldyB3aW5kb3cuRXZlbnRTb3VyY2Uob3B0aW9ucy5wYXRoKVxuICAgIHNvdXJjZS5vbm9wZW4gPSBoYW5kbGVPbmxpbmVcbiAgICBzb3VyY2Uub25lcnJvciA9IGhhbmRsZURpc2Nvbm5lY3RcbiAgICBzb3VyY2Uub25tZXNzYWdlID0gaGFuZGxlTWVzc2FnZVxuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlT25saW5lKCkge1xuICAgIGlmIChvcHRpb25zLmxvZykgY29uc29sZS5sb2coJ1tITVJdIGNvbm5lY3RlZCcpXG4gICAgbGFzdEFjdGl2aXR5ID0gbmV3IERhdGUoKVxuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlTWVzc2FnZShldmVudCkge1xuICAgIGxhc3RBY3Rpdml0eSA9IG5ldyBEYXRlKClcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgbGlzdGVuZXJzW2ldKGV2ZW50KVxuICAgIH1cbiAgICBpZiAoZXZlbnQuZGF0YS5pbmRleE9mKCdhY3Rpb24nKSAhPT0gLTEpIHtcbiAgICAgIGV2ZW50Q2FsbGJhY2tzLmZvckVhY2goKGNiKSA9PiBjYihldmVudCkpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlRGlzY29ubmVjdCgpIHtcbiAgICBjbGVhckludGVydmFsKHRpbWVyKVxuICAgIHNvdXJjZS5jbG9zZSgpXG4gICAgc2V0VGltZW91dChpbml0LCBvcHRpb25zLnRpbWVvdXQpXG4gIH1cblxuICByZXR1cm4ge1xuICAgIGNsb3NlOiAoKSA9PiB7XG4gICAgICBjbGVhckludGVydmFsKHRpbWVyKVxuICAgICAgc291cmNlLmNsb3NlKClcbiAgICB9LFxuICAgIGFkZE1lc3NhZ2VMaXN0ZW5lcjogZnVuY3Rpb24gKGZuKSB7XG4gICAgICBsaXN0ZW5lcnMucHVzaChmbilcbiAgICB9LFxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRFdmVudFNvdXJjZVdyYXBwZXIob3B0aW9ucykge1xuICBpZiAoIW9wdGlvbnMub25kZW1hbmQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYWRkTWVzc2FnZUxpc3RlbmVyOiAoY2IpID0+IHtcbiAgICAgICAgZXZlbnRDYWxsYmFja3MucHVzaChjYilcbiAgICAgIH0sXG4gICAgfVxuICB9XG4gIHJldHVybiBFdmVudFNvdXJjZVdyYXBwZXIob3B0aW9ucylcbn1cbiIsIi8qKlxuTUlUIExpY2Vuc2VcblxuQ29weXJpZ2h0IChjKSAyMDE1LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbm9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbnRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbmNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG5jb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbkZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbk9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG5TT0ZUV0FSRS5cbiovXG4vLyBUaGlzIGZpbGUgaXMgYmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2NyZWF0ZS1yZWFjdC1hcHAvYmxvYi83YjFhMzJiZTZlYzlmOTlhNmM5YTNjNjY4MTNmM2FjMDljNDczNmI5L3BhY2thZ2VzL3JlYWN0LWRldi11dGlscy9mb3JtYXRXZWJwYWNrTWVzc2FnZXMuanNcbi8vIEl0J3MgYmVlbiBlZGl0ZWQgdG8gcmVtb3ZlIGNoYWxrIGFuZCBDUkEtc3BlY2lmaWMgbG9naWNcblxuY29uc3QgZnJpZW5kbHlTeW50YXhFcnJvckxhYmVsID0gJ1N5bnRheCBlcnJvcjonXG5cbmZ1bmN0aW9uIGlzTGlrZWx5QVN5bnRheEVycm9yKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIG1lc3NhZ2UuaW5kZXhPZihmcmllbmRseVN5bnRheEVycm9yTGFiZWwpICE9PSAtMVxufVxuXG4vLyBDbGVhbnMgdXAgd2VicGFjayBlcnJvciBtZXNzYWdlcy5cbmZ1bmN0aW9uIGZvcm1hdE1lc3NhZ2UobWVzc2FnZSkge1xuICBsZXQgbGluZXMgPSBtZXNzYWdlLnNwbGl0KCdcXG4nKVxuXG4gIC8vIFN0cmlwIFdlYnBhY2stYWRkZWQgaGVhZGVycyBvZmYgZXJyb3JzL3dhcm5pbmdzXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrL3dlYnBhY2svYmxvYi9tYXN0ZXIvbGliL01vZHVsZUVycm9yLmpzXG4gIGxpbmVzID0gbGluZXMuZmlsdGVyKChsaW5lKSA9PiAhL01vZHVsZSBbQS16IF0rXFwoZnJvbS8udGVzdChsaW5lKSlcblxuICAvLyBUcmFuc2Zvcm0gcGFyc2luZyBlcnJvciBpbnRvIHN5bnRheCBlcnJvclxuICAvLyBUT0RPOiBtb3ZlIHRoaXMgdG8gb3VyIEVTTGludCBmb3JtYXR0ZXI/XG4gIGxpbmVzID0gbGluZXMubWFwKChsaW5lKSA9PiB7XG4gICAgY29uc3QgcGFyc2luZ0Vycm9yID0gL0xpbmUgKFxcZCspOig/OihcXGQrKTopP1xccypQYXJzaW5nIGVycm9yOiAoLispJC8uZXhlYyhcbiAgICAgIGxpbmVcbiAgICApXG4gICAgaWYgKCFwYXJzaW5nRXJyb3IpIHtcbiAgICAgIHJldHVybiBsaW5lXG4gICAgfVxuICAgIGNvbnN0IFssIGVycm9yTGluZSwgZXJyb3JDb2x1bW4sIGVycm9yTWVzc2FnZV0gPSBwYXJzaW5nRXJyb3JcbiAgICByZXR1cm4gYCR7ZnJpZW5kbHlTeW50YXhFcnJvckxhYmVsfSAke2Vycm9yTWVzc2FnZX0gKCR7ZXJyb3JMaW5lfToke2Vycm9yQ29sdW1ufSlgXG4gIH0pXG5cbiAgbWVzc2FnZSA9IGxpbmVzLmpvaW4oJ1xcbicpXG4gIC8vIFNtb29zaCBzeW50YXggZXJyb3JzIChjb21tb25seSBmb3VuZCBpbiBDU1MpXG4gIG1lc3NhZ2UgPSBtZXNzYWdlLnJlcGxhY2UoXG4gICAgL1N5bnRheEVycm9yXFxzK1xcKChcXGQrKTooXFxkKylcXClcXHMqKC4rPylcXG4vZyxcbiAgICBgJHtmcmllbmRseVN5bnRheEVycm9yTGFiZWx9ICQzICgkMTokMilcXG5gXG4gIClcbiAgLy8gQ2xlYW4gdXAgZXhwb3J0IGVycm9yc1xuICBtZXNzYWdlID0gbWVzc2FnZS5yZXBsYWNlKFxuICAgIC9eLipleHBvcnQgJyguKz8pJyB3YXMgbm90IGZvdW5kIGluICcoLis/KScuKiQvZ20sXG4gICAgYEF0dGVtcHRlZCBpbXBvcnQgZXJyb3I6ICckMScgaXMgbm90IGV4cG9ydGVkIGZyb20gJyQyJy5gXG4gIClcbiAgbWVzc2FnZSA9IG1lc3NhZ2UucmVwbGFjZShcbiAgICAvXi4qZXhwb3J0ICdkZWZhdWx0JyBcXChpbXBvcnRlZCBhcyAnKC4rPyknXFwpIHdhcyBub3QgZm91bmQgaW4gJyguKz8pJy4qJC9nbSxcbiAgICBgQXR0ZW1wdGVkIGltcG9ydCBlcnJvcjogJyQyJyBkb2VzIG5vdCBjb250YWluIGEgZGVmYXVsdCBleHBvcnQgKGltcG9ydGVkIGFzICckMScpLmBcbiAgKVxuICBtZXNzYWdlID0gbWVzc2FnZS5yZXBsYWNlKFxuICAgIC9eLipleHBvcnQgJyguKz8pJyBcXChpbXBvcnRlZCBhcyAnKC4rPyknXFwpIHdhcyBub3QgZm91bmQgaW4gJyguKz8pJy4qJC9nbSxcbiAgICBgQXR0ZW1wdGVkIGltcG9ydCBlcnJvcjogJyQxJyBpcyBub3QgZXhwb3J0ZWQgZnJvbSAnJDMnIChpbXBvcnRlZCBhcyAnJDInKS5gXG4gIClcbiAgbGluZXMgPSBtZXNzYWdlLnNwbGl0KCdcXG4nKVxuXG4gIC8vIFJlbW92ZSBsZWFkaW5nIG5ld2xpbmVcbiAgaWYgKGxpbmVzLmxlbmd0aCA+IDIgJiYgbGluZXNbMV0udHJpbSgpID09PSAnJykge1xuICAgIGxpbmVzLnNwbGljZSgxLCAxKVxuICB9XG4gIC8vIENsZWFuIHVwIGZpbGUgbmFtZVxuICBsaW5lc1swXSA9IGxpbmVzWzBdLnJlcGxhY2UoL14oLiopIFxcZCs6XFxkKy1cXGQrJC8sICckMScpXG5cbiAgLy8gQ2xlYW5zIHVwIHZlcmJvc2UgXCJtb2R1bGUgbm90IGZvdW5kXCIgbWVzc2FnZXMgZm9yIGZpbGVzIGFuZCBwYWNrYWdlcy5cbiAgaWYgKGxpbmVzWzFdICYmIGxpbmVzWzFdLmluZGV4T2YoJ01vZHVsZSBub3QgZm91bmQ6ICcpID09PSAwKSB7XG4gICAgbGluZXMgPSBbXG4gICAgICBsaW5lc1swXSxcbiAgICAgIGxpbmVzWzFdXG4gICAgICAgIC5yZXBsYWNlKCdFcnJvcjogJywgJycpXG4gICAgICAgIC5yZXBsYWNlKCdNb2R1bGUgbm90IGZvdW5kOiBDYW5ub3QgZmluZCBmaWxlOicsICdDYW5ub3QgZmluZCBmaWxlOicpLFxuICAgICAgLi4ubGluZXMuc2xpY2UoMikuZmlsdGVyKChsaW5lKSA9PiBsaW5lLmluZGV4T2YoJyBAICcpICE9PSAwKSxcbiAgICBdXG4gIH1cblxuICAvLyBBZGQgaGVscGZ1bCBtZXNzYWdlIGZvciB1c2VycyB0cnlpbmcgdG8gdXNlIFNhc3MgZm9yIHRoZSBmaXJzdCB0aW1lXG4gIGlmIChsaW5lc1sxXSAmJiBsaW5lc1sxXS5tYXRjaCgvQ2Fubm90IGZpbmQgbW9kdWxlLitub2RlLXNhc3MvKSkge1xuICAgIC8vIC4vZmlsZS5tb2R1bGUuc2NzcyAoPDxsb2FkZXIgaW5mbz4+KSA9PiAuL2ZpbGUubW9kdWxlLnNjc3NcbiAgICBsaW5lc1swXSA9IGxpbmVzWzBdLnJlcGxhY2UoLyguKykgXFwoLis/KD89XFw/XFw/KS4rP1xcKS8sICckMScpXG5cbiAgICBsaW5lc1sxXSA9XG4gICAgICBcIlRvIHVzZSBOZXh0LmpzJyBidWlsdC1pbiBTYXNzIHN1cHBvcnQsIHlvdSBmaXJzdCBuZWVkIHRvIGluc3RhbGwgYHNhc3NgLlxcblwiXG4gICAgbGluZXNbMV0gKz0gJ1J1biBgbnBtIGkgc2Fzc2Agb3IgYHlhcm4gYWRkIHNhc3NgIGluc2lkZSB5b3VyIHdvcmtzcGFjZS5cXG4nXG4gICAgbGluZXNbMV0gKz0gJ1xcbkxlYXJuIG1vcmU6IGh0dHBzOi8vZXJyLnNoL25leHQuanMvaW5zdGFsbC1zYXNzJ1xuICB9XG5cbiAgbWVzc2FnZSA9IGxpbmVzLmpvaW4oJ1xcbicpXG4gIC8vIEludGVybmFsIHN0YWNrcyBhcmUgZ2VuZXJhbGx5IHVzZWxlc3Mgc28gd2Ugc3RyaXAgdGhlbS4uLiB3aXRoIHRoZVxuICAvLyBleGNlcHRpb24gb2Ygc3RhY2tzIGNvbnRhaW5pbmcgYHdlYnBhY2s6YCBiZWNhdXNlIHRoZXkncmUgbm9ybWFsbHlcbiAgLy8gZnJvbSB1c2VyIGNvZGUgZ2VuZXJhdGVkIGJ5IFdlYnBhY2suIEZvciBtb3JlIGluZm9ybWF0aW9uIHNlZVxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svY3JlYXRlLXJlYWN0LWFwcC9wdWxsLzEwNTBcbiAgbWVzc2FnZSA9IG1lc3NhZ2UucmVwbGFjZShcbiAgICAvXlxccyphdFxccygoPyF3ZWJwYWNrOikuKSo6XFxkKzpcXGQrW1xccyldKihcXG58JCkvZ20sXG4gICAgJydcbiAgKSAvLyBhdCAuLi4gLi4uOng6eVxuICBtZXNzYWdlID0gbWVzc2FnZS5yZXBsYWNlKC9eXFxzKmF0XFxzPGFub255bW91cz4oXFxufCQpL2dtLCAnJykgLy8gYXQgPGFub255bW91cz5cbiAgbGluZXMgPSBtZXNzYWdlLnNwbGl0KCdcXG4nKVxuXG4gIC8vIFJlbW92ZSBkdXBsaWNhdGVkIG5ld2xpbmVzXG4gIGxpbmVzID0gbGluZXMuZmlsdGVyKFxuICAgIChsaW5lLCBpbmRleCwgYXJyKSA9PlxuICAgICAgaW5kZXggPT09IDAgfHwgbGluZS50cmltKCkgIT09ICcnIHx8IGxpbmUudHJpbSgpICE9PSBhcnJbaW5kZXggLSAxXS50cmltKClcbiAgKVxuXG4gIC8vIFJlYXNzZW1ibGUgdGhlIG1lc3NhZ2VcbiAgbWVzc2FnZSA9IGxpbmVzLmpvaW4oJ1xcbicpXG4gIHJldHVybiBtZXNzYWdlLnRyaW0oKVxufVxuXG5mdW5jdGlvbiBmb3JtYXRXZWJwYWNrTWVzc2FnZXMoanNvbikge1xuICBjb25zdCBmb3JtYXR0ZWRFcnJvcnMgPSBqc29uLmVycm9ycy5tYXAoZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gZm9ybWF0TWVzc2FnZShtZXNzYWdlLCB0cnVlKVxuICB9KVxuICBjb25zdCBmb3JtYXR0ZWRXYXJuaW5ncyA9IGpzb24ud2FybmluZ3MubWFwKGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgcmV0dXJuIGZvcm1hdE1lc3NhZ2UobWVzc2FnZSwgZmFsc2UpXG4gIH0pXG4gIGNvbnN0IHJlc3VsdCA9IHsgZXJyb3JzOiBmb3JtYXR0ZWRFcnJvcnMsIHdhcm5pbmdzOiBmb3JtYXR0ZWRXYXJuaW5ncyB9XG4gIGlmIChyZXN1bHQuZXJyb3JzLnNvbWUoaXNMaWtlbHlBU3ludGF4RXJyb3IpKSB7XG4gICAgLy8gSWYgdGhlcmUgYXJlIGFueSBzeW50YXggZXJyb3JzLCBzaG93IGp1c3QgdGhlbS5cbiAgICByZXN1bHQuZXJyb3JzID0gcmVzdWx0LmVycm9ycy5maWx0ZXIoaXNMaWtlbHlBU3ludGF4RXJyb3IpXG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZvcm1hdFdlYnBhY2tNZXNzYWdlc1xuIiwiLyoqXG4gKiBNSVQgTGljZW5zZVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbiAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICogU09GVFdBUkUuXG4gKi9cblxuLy8gVGhpcyBmaWxlIGlzIGEgbW9kaWZpZWQgdmVyc2lvbiBvZiB0aGUgQ3JlYXRlIFJlYWN0IEFwcCBITVIgZGV2IGNsaWVudCB0aGF0XG4vLyBjYW4gYmUgZm91bmQgaGVyZTpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9jcmVhdGUtcmVhY3QtYXBwL2Jsb2IvdjMuNC4xL3BhY2thZ2VzL3JlYWN0LWRldi11dGlscy93ZWJwYWNrSG90RGV2Q2xpZW50LmpzXG5cbmltcG9ydCAqIGFzIERldk92ZXJsYXkgZnJvbSAnQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvbGliL2NsaWVudCdcbmltcG9ydCBzdHJpcEFuc2kgZnJvbSAnbmV4dC9kaXN0L2NvbXBpbGVkL3N0cmlwLWFuc2knXG5pbXBvcnQgeyBnZXRFdmVudFNvdXJjZVdyYXBwZXIgfSBmcm9tICcuL2V2ZW50c291cmNlJ1xuaW1wb3J0IGZvcm1hdFdlYnBhY2tNZXNzYWdlcyBmcm9tICcuL2Zvcm1hdC13ZWJwYWNrLW1lc3NhZ2VzJ1xuXG4vLyBUaGlzIGFsdGVybmF0aXZlIFdlYnBhY2tEZXZTZXJ2ZXIgY29tYmluZXMgdGhlIGZ1bmN0aW9uYWxpdHkgb2Y6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay93ZWJwYWNrLWRldi1zZXJ2ZXIvYmxvYi93ZWJwYWNrLTEvY2xpZW50L2luZGV4LmpzXG4vLyBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay93ZWJwYWNrL2Jsb2Ivd2VicGFjay0xL2hvdC9kZXYtc2VydmVyLmpzXG5cbi8vIEl0IG9ubHkgc3VwcG9ydHMgdGhlaXIgc2ltcGxlc3QgY29uZmlndXJhdGlvbiAoaG90IHVwZGF0ZXMgb24gc2FtZSBzZXJ2ZXIpLlxuLy8gSXQgbWFrZXMgc29tZSBvcGluaW9uYXRlZCBjaG9pY2VzIG9uIHRvcCwgbGlrZSBhZGRpbmcgYSBzeW50YXggZXJyb3Igb3ZlcmxheVxuLy8gdGhhdCBsb29rcyBzaW1pbGFyIHRvIG91ciBjb25zb2xlIG91dHB1dC4gVGhlIGVycm9yIG92ZXJsYXkgaXMgaW5zcGlyZWQgYnk6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZ2xlbmphbWluL3dlYnBhY2staG90LW1pZGRsZXdhcmVcblxubGV0IGhhZFJ1bnRpbWVFcnJvciA9IGZhbHNlXG5sZXQgY3VzdG9tSG1yRXZlbnRIYW5kbGVyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb25uZWN0KG9wdGlvbnMpIHtcbiAgRGV2T3ZlcmxheS5yZWdpc3RlcigpXG5cbiAgZ2V0RXZlbnRTb3VyY2VXcmFwcGVyKG9wdGlvbnMpLmFkZE1lc3NhZ2VMaXN0ZW5lcigoZXZlbnQpID0+IHtcbiAgICAvLyBUaGlzIGlzIHRoZSBoZWFydGJlYXQgZXZlbnRcbiAgICBpZiAoZXZlbnQuZGF0YSA9PT0gJ1xcdUQ4M0RcXHVEQzkzJykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBwcm9jZXNzTWVzc2FnZShldmVudClcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgY29uc29sZS53YXJuKCdJbnZhbGlkIEhNUiBtZXNzYWdlOiAnICsgZXZlbnQuZGF0YSArICdcXG4nICsgZXgpXG4gICAgfVxuICB9KVxuXG4gIHJldHVybiB7XG4gICAgc3Vic2NyaWJlVG9IbXJFdmVudChoYW5kbGVyKSB7XG4gICAgICBjdXN0b21IbXJFdmVudEhhbmRsZXIgPSBoYW5kbGVyXG4gICAgfSxcbiAgICBvblVucmVjb3ZlcmFibGVFcnJvcigpIHtcbiAgICAgIGhhZFJ1bnRpbWVFcnJvciA9IHRydWVcbiAgICB9LFxuICB9XG59XG5cbi8vIFJlbWVtYmVyIHNvbWUgc3RhdGUgcmVsYXRlZCB0byBob3QgbW9kdWxlIHJlcGxhY2VtZW50LlxudmFyIGlzRmlyc3RDb21waWxhdGlvbiA9IHRydWVcbnZhciBtb3N0UmVjZW50Q29tcGlsYXRpb25IYXNoID0gbnVsbFxudmFyIGhhc0NvbXBpbGVFcnJvcnMgPSBmYWxzZVxuXG5mdW5jdGlvbiBjbGVhck91dGRhdGVkRXJyb3JzKCkge1xuICAvLyBDbGVhbiB1cCBvdXRkYXRlZCBjb21waWxlIGVycm9ycywgaWYgYW55LlxuICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBjb25zb2xlLmNsZWFyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKGhhc0NvbXBpbGVFcnJvcnMpIHtcbiAgICAgIGNvbnNvbGUuY2xlYXIoKVxuICAgIH1cbiAgfVxufVxuXG4vLyBTdWNjZXNzZnVsIGNvbXBpbGF0aW9uLlxuZnVuY3Rpb24gaGFuZGxlU3VjY2VzcygpIHtcbiAgY2xlYXJPdXRkYXRlZEVycm9ycygpXG5cbiAgY29uc3QgaXNIb3RVcGRhdGUgPSAhaXNGaXJzdENvbXBpbGF0aW9uXG4gIGlzRmlyc3RDb21waWxhdGlvbiA9IGZhbHNlXG4gIGhhc0NvbXBpbGVFcnJvcnMgPSBmYWxzZVxuXG4gIC8vIEF0dGVtcHQgdG8gYXBwbHkgaG90IHVwZGF0ZXMgb3IgcmVsb2FkLlxuICBpZiAoaXNIb3RVcGRhdGUpIHtcbiAgICB0cnlBcHBseVVwZGF0ZXMoZnVuY3Rpb24gb25TdWNjZXNzZnVsSG90VXBkYXRlKGhhc1VwZGF0ZXMpIHtcbiAgICAgIC8vIE9ubHkgZGlzbWlzcyBpdCB3aGVuIHdlJ3JlIHN1cmUgaXQncyBhIGhvdCB1cGRhdGUuXG4gICAgICAvLyBPdGhlcndpc2UgaXQgd291bGQgZmxpY2tlciByaWdodCBiZWZvcmUgdGhlIHJlbG9hZC5cbiAgICAgIG9uRmFzdFJlZnJlc2goaGFzVXBkYXRlcylcbiAgICB9KVxuICB9XG59XG5cbi8vIENvbXBpbGF0aW9uIHdpdGggd2FybmluZ3MgKGUuZy4gRVNMaW50KS5cbmZ1bmN0aW9uIGhhbmRsZVdhcm5pbmdzKHdhcm5pbmdzKSB7XG4gIGNsZWFyT3V0ZGF0ZWRFcnJvcnMoKVxuXG4gIGNvbnN0IGlzSG90VXBkYXRlID0gIWlzRmlyc3RDb21waWxhdGlvblxuICBpc0ZpcnN0Q29tcGlsYXRpb24gPSBmYWxzZVxuICBoYXNDb21waWxlRXJyb3JzID0gZmFsc2VcblxuICBmdW5jdGlvbiBwcmludFdhcm5pbmdzKCkge1xuICAgIC8vIFByaW50IHdhcm5pbmdzIHRvIHRoZSBjb25zb2xlLlxuICAgIGNvbnN0IGZvcm1hdHRlZCA9IGZvcm1hdFdlYnBhY2tNZXNzYWdlcyh7XG4gICAgICB3YXJuaW5nczogd2FybmluZ3MsXG4gICAgICBlcnJvcnM6IFtdLFxuICAgIH0pXG5cbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBjb25zb2xlLndhcm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZm9ybWF0dGVkLndhcm5pbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpID09PSA1KSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgJ1RoZXJlIHdlcmUgbW9yZSB3YXJuaW5ncyBpbiBvdGhlciBmaWxlcy5cXG4nICtcbiAgICAgICAgICAgICAgJ1lvdSBjYW4gZmluZCBhIGNvbXBsZXRlIGxvZyBpbiB0aGUgdGVybWluYWwuJ1xuICAgICAgICAgIClcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUud2FybihzdHJpcEFuc2koZm9ybWF0dGVkLndhcm5pbmdzW2ldKSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcmludFdhcm5pbmdzKClcblxuICAvLyBBdHRlbXB0IHRvIGFwcGx5IGhvdCB1cGRhdGVzIG9yIHJlbG9hZC5cbiAgaWYgKGlzSG90VXBkYXRlKSB7XG4gICAgdHJ5QXBwbHlVcGRhdGVzKGZ1bmN0aW9uIG9uU3VjY2Vzc2Z1bEhvdFVwZGF0ZShoYXNVcGRhdGVzKSB7XG4gICAgICAvLyBPbmx5IGRpc21pc3MgaXQgd2hlbiB3ZSdyZSBzdXJlIGl0J3MgYSBob3QgdXBkYXRlLlxuICAgICAgLy8gT3RoZXJ3aXNlIGl0IHdvdWxkIGZsaWNrZXIgcmlnaHQgYmVmb3JlIHRoZSByZWxvYWQuXG4gICAgICBvbkZhc3RSZWZyZXNoKGhhc1VwZGF0ZXMpXG4gICAgfSlcbiAgfVxufVxuXG4vLyBDb21waWxhdGlvbiB3aXRoIGVycm9ycyAoZS5nLiBzeW50YXggZXJyb3Igb3IgbWlzc2luZyBtb2R1bGVzKS5cbmZ1bmN0aW9uIGhhbmRsZUVycm9ycyhlcnJvcnMpIHtcbiAgY2xlYXJPdXRkYXRlZEVycm9ycygpXG5cbiAgaXNGaXJzdENvbXBpbGF0aW9uID0gZmFsc2VcbiAgaGFzQ29tcGlsZUVycm9ycyA9IHRydWVcblxuICAvLyBcIk1hc3NhZ2VcIiB3ZWJwYWNrIG1lc3NhZ2VzLlxuICB2YXIgZm9ybWF0dGVkID0gZm9ybWF0V2VicGFja01lc3NhZ2VzKHtcbiAgICBlcnJvcnM6IGVycm9ycyxcbiAgICB3YXJuaW5nczogW10sXG4gIH0pXG5cbiAgLy8gT25seSBzaG93IHRoZSBmaXJzdCBlcnJvci5cbiAgRGV2T3ZlcmxheS5vbkJ1aWxkRXJyb3IoZm9ybWF0dGVkLmVycm9yc1swXSlcblxuICAvLyBBbHNvIGxvZyB0aGVtIHRvIHRoZSBjb25zb2xlLlxuICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmb3JtYXR0ZWQuZXJyb3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zb2xlLmVycm9yKHN0cmlwQW5zaShmb3JtYXR0ZWQuZXJyb3JzW2ldKSlcbiAgICB9XG4gIH1cblxuICAvLyBEbyBub3QgYXR0ZW1wdCB0byByZWxvYWQgbm93LlxuICAvLyBXZSB3aWxsIHJlbG9hZCBvbiBuZXh0IHN1Y2Nlc3MgaW5zdGVhZC5cbiAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9URVNUX01PREUpIHtcbiAgICBpZiAoc2VsZi5fX05FWFRfSE1SX0NCKSB7XG4gICAgICBzZWxmLl9fTkVYVF9ITVJfQ0IoZm9ybWF0dGVkLmVycm9yc1swXSlcbiAgICAgIHNlbGYuX19ORVhUX0hNUl9DQiA9IG51bGxcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gb25GYXN0UmVmcmVzaChoYXNVcGRhdGVzKSB7XG4gIERldk92ZXJsYXkub25CdWlsZE9rKClcbiAgaWYgKGhhc1VwZGF0ZXMpIHtcbiAgICBEZXZPdmVybGF5Lm9uUmVmcmVzaCgpXG4gIH1cblxuICBjb25zb2xlLmxvZygnW0Zhc3QgUmVmcmVzaF0gZG9uZScpXG59XG5cbi8vIFRoZXJlIGlzIGEgbmV3ZXIgdmVyc2lvbiBvZiB0aGUgY29kZSBhdmFpbGFibGUuXG5mdW5jdGlvbiBoYW5kbGVBdmFpbGFibGVIYXNoKGhhc2gpIHtcbiAgLy8gVXBkYXRlIGxhc3Qga25vd24gY29tcGlsYXRpb24gaGFzaC5cbiAgbW9zdFJlY2VudENvbXBpbGF0aW9uSGFzaCA9IGhhc2hcbn1cblxuLy8gSGFuZGxlIG1lc3NhZ2VzIGZyb20gdGhlIHNlcnZlci5cbmZ1bmN0aW9uIHByb2Nlc3NNZXNzYWdlKGUpIHtcbiAgY29uc3Qgb2JqID0gSlNPTi5wYXJzZShlLmRhdGEpXG4gIHN3aXRjaCAob2JqLmFjdGlvbikge1xuICAgIGNhc2UgJ2J1aWxkaW5nJzoge1xuICAgICAgY29uc29sZS5sb2coJ1tGYXN0IFJlZnJlc2hdIHJlYnVpbGRpbmcnKVxuICAgICAgYnJlYWtcbiAgICB9XG4gICAgY2FzZSAnYnVpbHQnOlxuICAgIGNhc2UgJ3N5bmMnOiB7XG4gICAgICBpZiAob2JqLmhhc2gpIHtcbiAgICAgICAgaGFuZGxlQXZhaWxhYmxlSGFzaChvYmouaGFzaClcbiAgICAgIH1cblxuICAgICAgY29uc3QgeyBlcnJvcnMsIHdhcm5pbmdzIH0gPSBvYmpcbiAgICAgIGNvbnN0IGhhc0Vycm9ycyA9IEJvb2xlYW4oZXJyb3JzICYmIGVycm9ycy5sZW5ndGgpXG4gICAgICBpZiAoaGFzRXJyb3JzKSB7XG4gICAgICAgIHJldHVybiBoYW5kbGVFcnJvcnMoZXJyb3JzKVxuICAgICAgfVxuXG4gICAgICBjb25zdCBoYXNXYXJuaW5ncyA9IEJvb2xlYW4od2FybmluZ3MgJiYgd2FybmluZ3MubGVuZ3RoKVxuICAgICAgaWYgKGhhc1dhcm5pbmdzKSB7XG4gICAgICAgIHJldHVybiBoYW5kbGVXYXJuaW5ncyh3YXJuaW5ncylcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGhhbmRsZVN1Y2Nlc3MoKVxuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICBpZiAoY3VzdG9tSG1yRXZlbnRIYW5kbGVyKSB7XG4gICAgICAgIGN1c3RvbUhtckV2ZW50SGFuZGxlcihvYmopXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxufVxuXG4vLyBJcyB0aGVyZSBhIG5ld2VyIHZlcnNpb24gb2YgdGhpcyBjb2RlIGF2YWlsYWJsZT9cbmZ1bmN0aW9uIGlzVXBkYXRlQXZhaWxhYmxlKCkge1xuICAvKiBnbG9iYWxzIF9fd2VicGFja19oYXNoX18gKi9cbiAgLy8gX193ZWJwYWNrX2hhc2hfXyBpcyB0aGUgaGFzaCBvZiB0aGUgY3VycmVudCBjb21waWxhdGlvbi5cbiAgLy8gSXQncyBhIGdsb2JhbCB2YXJpYWJsZSBpbmplY3RlZCBieSBXZWJwYWNrLlxuICByZXR1cm4gbW9zdFJlY2VudENvbXBpbGF0aW9uSGFzaCAhPT0gX193ZWJwYWNrX2hhc2hfX1xufVxuXG4vLyBXZWJwYWNrIGRpc2FsbG93cyB1cGRhdGVzIGluIG90aGVyIHN0YXRlcy5cbmZ1bmN0aW9uIGNhbkFwcGx5VXBkYXRlcygpIHtcbiAgcmV0dXJuIG1vZHVsZS5ob3Quc3RhdHVzKCkgPT09ICdpZGxlJ1xufVxuZnVuY3Rpb24gYWZ0ZXJBcHBseVVwZGF0ZXMoZm4pIHtcbiAgaWYgKGNhbkFwcGx5VXBkYXRlcygpKSB7XG4gICAgZm4oKVxuICB9IGVsc2Uge1xuICAgIGZ1bmN0aW9uIGhhbmRsZXIoc3RhdHVzKSB7XG4gICAgICBpZiAoc3RhdHVzID09PSAnaWRsZScpIHtcbiAgICAgICAgbW9kdWxlLmhvdC5yZW1vdmVTdGF0dXNIYW5kbGVyKGhhbmRsZXIpXG4gICAgICAgIGZuKClcbiAgICAgIH1cbiAgICB9XG4gICAgbW9kdWxlLmhvdC5hZGRTdGF0dXNIYW5kbGVyKGhhbmRsZXIpXG4gIH1cbn1cblxuLy8gQXR0ZW1wdCB0byB1cGRhdGUgY29kZSBvbiB0aGUgZmx5LCBmYWxsIGJhY2sgdG8gYSBoYXJkIHJlbG9hZC5cbmZ1bmN0aW9uIHRyeUFwcGx5VXBkYXRlcyhvbkhvdFVwZGF0ZVN1Y2Nlc3MpIHtcbiAgaWYgKCFtb2R1bGUuaG90KSB7XG4gICAgLy8gSG90TW9kdWxlUmVwbGFjZW1lbnRQbHVnaW4gaXMgbm90IGluIFdlYnBhY2sgY29uZmlndXJhdGlvbi5cbiAgICBjb25zb2xlLmVycm9yKCdIb3RNb2R1bGVSZXBsYWNlbWVudFBsdWdpbiBpcyBub3QgaW4gV2VicGFjayBjb25maWd1cmF0aW9uLicpXG4gICAgLy8gd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuICAgIHJldHVyblxuICB9XG5cbiAgaWYgKCFpc1VwZGF0ZUF2YWlsYWJsZSgpIHx8ICFjYW5BcHBseVVwZGF0ZXMoKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlQXBwbHlVcGRhdGVzKGVyciwgdXBkYXRlZE1vZHVsZXMpIHtcbiAgICBpZiAoZXJyIHx8IGhhZFJ1bnRpbWVFcnJvciB8fCAhdXBkYXRlZE1vZHVsZXMpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICdbRmFzdCBSZWZyZXNoXSBwZXJmb3JtaW5nIGZ1bGwgcmVsb2FkXFxuXFxuJyArXG4gICAgICAgICAgICBcIkZhc3QgUmVmcmVzaCB3aWxsIHBlcmZvcm0gYSBmdWxsIHJlbG9hZCB3aGVuIHlvdSBlZGl0IGEgZmlsZSB0aGF0J3MgaW1wb3J0ZWQgYnkgbW9kdWxlcyBvdXRzaWRlIG9mIHRoZSBSZWFjdCB0cmVlLlxcblwiICtcbiAgICAgICAgICAgICdZb3UgbWlnaHQgaGF2ZSBhIGZpbGUgd2hpY2ggcmVuZGVycyBhIFJlYWN0IGNvbXBvbmVudCBidXQgYWxzbyBleHBvcnRzIGEgdmFsdWUgdGhhdCBpcyBpbXBvcnRlZCBieSBhIG5vbi1SZWFjdCBjb21wb25lbnQuXFxuJyArXG4gICAgICAgICAgICAnQ29uc2lkZXIgbWlncmF0aW5nIHRoZSBub24tUmVhY3QgY29tcG9uZW50IGV4cG9ydCB0byBhIHNlcGFyYXRlIGZpbGUgYW5kIGltcG9ydGluZyBpdCBpbnRvIGJvdGggZmlsZXMuXFxuXFxuJyArXG4gICAgICAgICAgICAnSXQgaXMgYWxzbyBwb3NzaWJsZSB5b3UgYXJlIHVzaW5nIGNsYXNzIGNvbXBvbmVudHMgYXQgdGhlIHRvcC1sZXZlbCBvZiB5b3VyIGFwcGxpY2F0aW9uLCB3aGljaCBkaXNhYmxlcyBGYXN0IFJlZnJlc2guXFxuJyArXG4gICAgICAgICAgICAnRmFzdCBSZWZyZXNoIHJlcXVpcmVzIGF0IGxlYXN0IG9uZSBmdW5jdGlvbiBjb21wb25lbnQgaW4geW91ciBSZWFjdCB0cmVlLidcbiAgICAgICAgKVxuICAgICAgfSBlbHNlIGlmIChoYWRSdW50aW1lRXJyb3IpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICdbRmFzdCBSZWZyZXNoXSBwZXJmb3JtaW5nIGZ1bGwgcmVsb2FkIGJlY2F1c2UgeW91ciBhcHBsaWNhdGlvbiBoYWQgYW4gdW5yZWNvdmVyYWJsZSBlcnJvcidcbiAgICAgICAgKVxuICAgICAgfVxuICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBoYXNVcGRhdGVzID0gQm9vbGVhbih1cGRhdGVkTW9kdWxlcy5sZW5ndGgpXG4gICAgaWYgKHR5cGVvZiBvbkhvdFVwZGF0ZVN1Y2Nlc3MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIE1heWJlIHdlIHdhbnQgdG8gZG8gc29tZXRoaW5nLlxuICAgICAgb25Ib3RVcGRhdGVTdWNjZXNzKGhhc1VwZGF0ZXMpXG4gICAgfVxuXG4gICAgaWYgKGlzVXBkYXRlQXZhaWxhYmxlKCkpIHtcbiAgICAgIC8vIFdoaWxlIHdlIHdlcmUgdXBkYXRpbmcsIHRoZXJlIHdhcyBhIG5ldyB1cGRhdGUhIERvIGl0IGFnYWluLlxuICAgICAgdHJ5QXBwbHlVcGRhdGVzKGhhc1VwZGF0ZXMgPyB1bmRlZmluZWQgOiBvbkhvdFVwZGF0ZVN1Y2Nlc3MpXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfVEVTVF9NT0RFKSB7XG4gICAgICAgIGFmdGVyQXBwbHlVcGRhdGVzKCgpID0+IHtcbiAgICAgICAgICBpZiAoc2VsZi5fX05FWFRfSE1SX0NCKSB7XG4gICAgICAgICAgICBzZWxmLl9fTkVYVF9ITVJfQ0IoKVxuICAgICAgICAgICAgc2VsZi5fX05FWFRfSE1SX0NCID0gbnVsbFxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBodHRwczovL3dlYnBhY2suanMub3JnL2FwaS9ob3QtbW9kdWxlLXJlcGxhY2VtZW50LyNjaGVja1xuICBtb2R1bGUuaG90LmNoZWNrKC8qIGF1dG9BcHBseSAqLyB0cnVlKS50aGVuKFxuICAgICh1cGRhdGVkTW9kdWxlcykgPT4ge1xuICAgICAgaGFuZGxlQXBwbHlVcGRhdGVzKG51bGwsIHVwZGF0ZWRNb2R1bGVzKVxuICAgIH0sXG4gICAgKGVycikgPT4ge1xuICAgICAgaGFuZGxlQXBwbHlVcGRhdGVzKGVyciwgbnVsbClcbiAgICB9XG4gIClcbn1cbiIsIi8qIGVzbGludC1kaXNhYmxlICovXG4vLyBJbXByb3ZlZCB2ZXJzaW9uIG9mIGh0dHBzOi8vZ2l0aHViLmNvbS9ZYWZmbGUvRXZlbnRTb3VyY2UvXG4vLyBBdmFpbGFibGUgdW5kZXIgTUlUIExpY2Vuc2UgKE1JVClcbi8vIE9ubHkgdHJpZXMgdG8gc3VwcG9ydCBJRTExIGFuZCBub3RoaW5nIGJlbG93XG5pbXBvcnQgZmV0Y2ggZnJvbSAnbmV4dC9kaXN0L2J1aWxkL3BvbHlmaWxscy91bmZldGNoJ1xuXG52YXIgZG9jdW1lbnQgPSB3aW5kb3cuZG9jdW1lbnRcbnZhciBSZXNwb25zZSA9IHdpbmRvdy5SZXNwb25zZVxudmFyIFRleHREZWNvZGVyID0gd2luZG93LlRleHREZWNvZGVyXG52YXIgVGV4dEVuY29kZXIgPSB3aW5kb3cuVGV4dEVuY29kZXJcbnZhciBBYm9ydENvbnRyb2xsZXIgPSB3aW5kb3cuQWJvcnRDb250cm9sbGVyXG5cbmlmIChBYm9ydENvbnRyb2xsZXIgPT0gdW5kZWZpbmVkKSB7XG4gIEFib3J0Q29udHJvbGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnNpZ25hbCA9IG51bGxcbiAgICB0aGlzLmFib3J0ID0gZnVuY3Rpb24gKCkge31cbiAgfVxufVxuXG5mdW5jdGlvbiBUZXh0RGVjb2RlclBvbHlmaWxsKCkge1xuICB0aGlzLmJpdHNOZWVkZWQgPSAwXG4gIHRoaXMuY29kZVBvaW50ID0gMFxufVxuXG5UZXh0RGVjb2RlclBvbHlmaWxsLnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbiAob2N0ZXRzKSB7XG4gIGZ1bmN0aW9uIHZhbGlkKGNvZGVQb2ludCwgc2hpZnQsIG9jdGV0c0NvdW50KSB7XG4gICAgaWYgKG9jdGV0c0NvdW50ID09PSAxKSB7XG4gICAgICByZXR1cm4gY29kZVBvaW50ID49IDB4MDA4MCA+PiBzaGlmdCAmJiBjb2RlUG9pbnQgPDwgc2hpZnQgPD0gMHgwN2ZmXG4gICAgfVxuICAgIGlmIChvY3RldHNDb3VudCA9PT0gMikge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgKGNvZGVQb2ludCA+PSAweDA4MDAgPj4gc2hpZnQgJiYgY29kZVBvaW50IDw8IHNoaWZ0IDw9IDB4ZDdmZikgfHxcbiAgICAgICAgKGNvZGVQb2ludCA+PSAweGUwMDAgPj4gc2hpZnQgJiYgY29kZVBvaW50IDw8IHNoaWZ0IDw9IDB4ZmZmZilcbiAgICAgIClcbiAgICB9XG4gICAgaWYgKG9jdGV0c0NvdW50ID09PSAzKSB7XG4gICAgICByZXR1cm4gY29kZVBvaW50ID49IDB4MDEwMDAwID4+IHNoaWZ0ICYmIGNvZGVQb2ludCA8PCBzaGlmdCA8PSAweDEwZmZmZlxuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoKVxuICB9XG4gIGZ1bmN0aW9uIG9jdGV0c0NvdW50KGJpdHNOZWVkZWQsIGNvZGVQb2ludCkge1xuICAgIGlmIChiaXRzTmVlZGVkID09PSA2ICogMSkge1xuICAgICAgcmV0dXJuIGNvZGVQb2ludCA+PiA2ID4gMTUgPyAzIDogY29kZVBvaW50ID4gMzEgPyAyIDogMVxuICAgIH1cbiAgICBpZiAoYml0c05lZWRlZCA9PT0gNiAqIDIpIHtcbiAgICAgIHJldHVybiBjb2RlUG9pbnQgPiAxNSA/IDMgOiAyXG4gICAgfVxuICAgIGlmIChiaXRzTmVlZGVkID09PSA2ICogMykge1xuICAgICAgcmV0dXJuIDNcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKClcbiAgfVxuICB2YXIgUkVQTEFDRVIgPSAweGZmZmRcbiAgdmFyIHN0cmluZyA9ICcnXG4gIHZhciBiaXRzTmVlZGVkID0gdGhpcy5iaXRzTmVlZGVkXG4gIHZhciBjb2RlUG9pbnQgPSB0aGlzLmNvZGVQb2ludFxuICBmb3IgKHZhciBpID0gMDsgaSA8IG9jdGV0cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIHZhciBvY3RldCA9IG9jdGV0c1tpXVxuICAgIGlmIChiaXRzTmVlZGVkICE9PSAwKSB7XG4gICAgICBpZiAoXG4gICAgICAgIG9jdGV0IDwgMTI4IHx8XG4gICAgICAgIG9jdGV0ID4gMTkxIHx8XG4gICAgICAgICF2YWxpZChcbiAgICAgICAgICAoY29kZVBvaW50IDw8IDYpIHwgKG9jdGV0ICYgNjMpLFxuICAgICAgICAgIGJpdHNOZWVkZWQgLSA2LFxuICAgICAgICAgIG9jdGV0c0NvdW50KGJpdHNOZWVkZWQsIGNvZGVQb2ludClcbiAgICAgICAgKVxuICAgICAgKSB7XG4gICAgICAgIGJpdHNOZWVkZWQgPSAwXG4gICAgICAgIGNvZGVQb2ludCA9IFJFUExBQ0VSXG4gICAgICAgIHN0cmluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGVQb2ludClcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGJpdHNOZWVkZWQgPT09IDApIHtcbiAgICAgIGlmIChvY3RldCA+PSAwICYmIG9jdGV0IDw9IDEyNykge1xuICAgICAgICBiaXRzTmVlZGVkID0gMFxuICAgICAgICBjb2RlUG9pbnQgPSBvY3RldFxuICAgICAgfSBlbHNlIGlmIChvY3RldCA+PSAxOTIgJiYgb2N0ZXQgPD0gMjIzKSB7XG4gICAgICAgIGJpdHNOZWVkZWQgPSA2ICogMVxuICAgICAgICBjb2RlUG9pbnQgPSBvY3RldCAmIDMxXG4gICAgICB9IGVsc2UgaWYgKG9jdGV0ID49IDIyNCAmJiBvY3RldCA8PSAyMzkpIHtcbiAgICAgICAgYml0c05lZWRlZCA9IDYgKiAyXG4gICAgICAgIGNvZGVQb2ludCA9IG9jdGV0ICYgMTVcbiAgICAgIH0gZWxzZSBpZiAob2N0ZXQgPj0gMjQwICYmIG9jdGV0IDw9IDI0Nykge1xuICAgICAgICBiaXRzTmVlZGVkID0gNiAqIDNcbiAgICAgICAgY29kZVBvaW50ID0gb2N0ZXQgJiA3XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiaXRzTmVlZGVkID0gMFxuICAgICAgICBjb2RlUG9pbnQgPSBSRVBMQUNFUlxuICAgICAgfVxuICAgICAgaWYgKFxuICAgICAgICBiaXRzTmVlZGVkICE9PSAwICYmXG4gICAgICAgICF2YWxpZChjb2RlUG9pbnQsIGJpdHNOZWVkZWQsIG9jdGV0c0NvdW50KGJpdHNOZWVkZWQsIGNvZGVQb2ludCkpXG4gICAgICApIHtcbiAgICAgICAgYml0c05lZWRlZCA9IDBcbiAgICAgICAgY29kZVBvaW50ID0gUkVQTEFDRVJcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYml0c05lZWRlZCAtPSA2XG4gICAgICBjb2RlUG9pbnQgPSAoY29kZVBvaW50IDw8IDYpIHwgKG9jdGV0ICYgNjMpXG4gICAgfVxuICAgIGlmIChiaXRzTmVlZGVkID09PSAwKSB7XG4gICAgICBpZiAoY29kZVBvaW50IDw9IDB4ZmZmZikge1xuICAgICAgICBzdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlUG9pbnQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgweGQ4MDAgKyAoKGNvZGVQb2ludCAtIDB4ZmZmZiAtIDEpID4+IDEwKSlcbiAgICAgICAgc3RyaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoXG4gICAgICAgICAgMHhkYzAwICsgKChjb2RlUG9pbnQgLSAweGZmZmYgLSAxKSAmIDB4M2ZmKVxuICAgICAgICApXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHRoaXMuYml0c05lZWRlZCA9IGJpdHNOZWVkZWRcbiAgdGhpcy5jb2RlUG9pbnQgPSBjb2RlUG9pbnRcbiAgcmV0dXJuIHN0cmluZ1xufVxuXG4vLyBGaXJlZm94IDwgMzggdGhyb3dzIGFuIGVycm9yIHdpdGggc3RyZWFtIG9wdGlvblxudmFyIHN1cHBvcnRzU3RyZWFtT3B0aW9uID0gZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIHJldHVybiAoXG4gICAgICBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUobmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKCd0ZXN0JyksIHtcbiAgICAgICAgc3RyZWFtOiB0cnVlLFxuICAgICAgfSkgPT09ICd0ZXN0J1xuICAgIClcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmxvZyhlcnJvcilcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuLy8gSUUsIEVkZ2VcbmlmIChcbiAgVGV4dERlY29kZXIgPT0gdW5kZWZpbmVkIHx8XG4gIFRleHRFbmNvZGVyID09IHVuZGVmaW5lZCB8fFxuICAhc3VwcG9ydHNTdHJlYW1PcHRpb24oKVxuKSB7XG4gIFRleHREZWNvZGVyID0gVGV4dERlY29kZXJQb2x5ZmlsbFxufVxuXG52YXIgayA9IGZ1bmN0aW9uICgpIHt9XG5cbmZ1bmN0aW9uIFhIUldyYXBwZXIoeGhyKSB7XG4gIHRoaXMud2l0aENyZWRlbnRpYWxzID0gZmFsc2VcbiAgdGhpcy5yZXNwb25zZVR5cGUgPSAnJ1xuICB0aGlzLnJlYWR5U3RhdGUgPSAwXG4gIHRoaXMuc3RhdHVzID0gMFxuICB0aGlzLnN0YXR1c1RleHQgPSAnJ1xuICB0aGlzLnJlc3BvbnNlVGV4dCA9ICcnXG4gIHRoaXMub25wcm9ncmVzcyA9IGtcbiAgdGhpcy5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBrXG4gIHRoaXMuX2NvbnRlbnRUeXBlID0gJydcbiAgdGhpcy5feGhyID0geGhyXG4gIHRoaXMuX3NlbmRUaW1lb3V0ID0gMFxuICB0aGlzLl9hYm9ydCA9IGtcbn1cblxuWEhSV3JhcHBlci5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uIChtZXRob2QsIHVybCkge1xuICB0aGlzLl9hYm9ydCh0cnVlKVxuXG4gIHZhciB0aGF0ID0gdGhpc1xuICB2YXIgeGhyID0gdGhpcy5feGhyXG4gIHZhciBzdGF0ZSA9IDFcbiAgdmFyIHRpbWVvdXQgPSAwXG5cbiAgdGhpcy5fYWJvcnQgPSBmdW5jdGlvbiAoc2lsZW50KSB7XG4gICAgaWYgKHRoYXQuX3NlbmRUaW1lb3V0ICE9PSAwKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhhdC5fc2VuZFRpbWVvdXQpXG4gICAgICB0aGF0Ll9zZW5kVGltZW91dCA9IDBcbiAgICB9XG4gICAgaWYgKHN0YXRlID09PSAxIHx8IHN0YXRlID09PSAyIHx8IHN0YXRlID09PSAzKSB7XG4gICAgICBzdGF0ZSA9IDRcbiAgICAgIHhoci5vbmxvYWQgPSBrXG4gICAgICB4aHIub25lcnJvciA9IGtcbiAgICAgIHhoci5vbmFib3J0ID0ga1xuICAgICAgeGhyLm9ucHJvZ3Jlc3MgPSBrXG4gICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0ga1xuICAgICAgLy8gSUUgOCAtIDk6IFhEb21haW5SZXF1ZXN0I2Fib3J0KCkgZG9lcyBub3QgZmlyZSBhbnkgZXZlbnRcbiAgICAgIC8vIE9wZXJhIDwgMTA6IFhNTEh0dHBSZXF1ZXN0I2Fib3J0KCkgZG9lcyBub3QgZmlyZSBhbnkgZXZlbnRcbiAgICAgIHhoci5hYm9ydCgpXG4gICAgICBpZiAodGltZW91dCAhPT0gMCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dClcbiAgICAgICAgdGltZW91dCA9IDBcbiAgICAgIH1cbiAgICAgIGlmICghc2lsZW50KSB7XG4gICAgICAgIHRoYXQucmVhZHlTdGF0ZSA9IDRcbiAgICAgICAgdGhhdC5vbnJlYWR5c3RhdGVjaGFuZ2UoKVxuICAgICAgfVxuICAgIH1cbiAgICBzdGF0ZSA9IDBcbiAgfVxuXG4gIHZhciBvblN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChzdGF0ZSA9PT0gMSkge1xuICAgICAgLy8gc3RhdGUgPSAyO1xuICAgICAgdmFyIHN0YXR1cyA9IDBcbiAgICAgIHZhciBzdGF0dXNUZXh0ID0gJydcbiAgICAgIHZhciBjb250ZW50VHlwZSA9IHVuZGVmaW5lZFxuICAgICAgaWYgKCEoJ2NvbnRlbnRUeXBlJyBpbiB4aHIpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgc3RhdHVzID0geGhyLnN0YXR1c1xuICAgICAgICAgIHN0YXR1c1RleHQgPSB4aHIuc3RhdHVzVGV4dFxuICAgICAgICAgIGNvbnRlbnRUeXBlID0geGhyLmdldFJlc3BvbnNlSGVhZGVyKCdDb250ZW50LVR5cGUnKVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIC8vIElFIDwgMTAgdGhyb3dzIGV4Y2VwdGlvbiBmb3IgYHhoci5zdGF0dXNgIHdoZW4geGhyLnJlYWR5U3RhdGUgPT09IDIgfHwgeGhyLnJlYWR5U3RhdGUgPT09IDNcbiAgICAgICAgICAvLyBPcGVyYSA8IDExIHRocm93cyBleGNlcHRpb24gZm9yIGB4aHIuc3RhdHVzYCB3aGVuIHhoci5yZWFkeVN0YXRlID09PSAyXG4gICAgICAgICAgLy8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTI5MTIxXG4gICAgICAgICAgc3RhdHVzID0gMFxuICAgICAgICAgIHN0YXR1c1RleHQgPSAnJ1xuICAgICAgICAgIGNvbnRlbnRUeXBlID0gdW5kZWZpbmVkXG4gICAgICAgICAgLy8gRmlyZWZveCA8IDE0LCBDaHJvbWUgPywgU2FmYXJpID9cbiAgICAgICAgICAvLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Mjk2NThcbiAgICAgICAgICAvLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Nzc4NTRcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdHVzID0gMjAwXG4gICAgICAgIHN0YXR1c1RleHQgPSAnT0snXG4gICAgICAgIGNvbnRlbnRUeXBlID0geGhyLmNvbnRlbnRUeXBlXG4gICAgICB9XG4gICAgICBpZiAoc3RhdHVzICE9PSAwKSB7XG4gICAgICAgIHN0YXRlID0gMlxuICAgICAgICB0aGF0LnJlYWR5U3RhdGUgPSAyXG4gICAgICAgIHRoYXQuc3RhdHVzID0gc3RhdHVzXG4gICAgICAgIHRoYXQuc3RhdHVzVGV4dCA9IHN0YXR1c1RleHRcbiAgICAgICAgdGhhdC5fY29udGVudFR5cGUgPSBjb250ZW50VHlwZVxuICAgICAgICB0aGF0Lm9ucmVhZHlzdGF0ZWNoYW5nZSgpXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHZhciBvblByb2dyZXNzID0gZnVuY3Rpb24gKCkge1xuICAgIG9uU3RhcnQoKVxuICAgIGlmIChzdGF0ZSA9PT0gMiB8fCBzdGF0ZSA9PT0gMykge1xuICAgICAgc3RhdGUgPSAzXG4gICAgICB2YXIgcmVzcG9uc2VUZXh0ID0gJydcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlc3BvbnNlVGV4dCA9IHhoci5yZXNwb25zZVRleHRcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIC8vIElFIDggLSA5IHdpdGggWE1MSHR0cFJlcXVlc3RcbiAgICAgIH1cbiAgICAgIHRoYXQucmVhZHlTdGF0ZSA9IDNcbiAgICAgIHRoYXQucmVzcG9uc2VUZXh0ID0gcmVzcG9uc2VUZXh0XG4gICAgICB0aGF0Lm9ucHJvZ3Jlc3MoKVxuICAgIH1cbiAgfVxuICB2YXIgb25GaW5pc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gRmlyZWZveCA1MiBmaXJlcyBcInJlYWR5c3RhdGVjaGFuZ2VcIiAoeGhyLnJlYWR5U3RhdGUgPT09IDQpIHdpdGhvdXQgZmluYWwgXCJyZWFkeXN0YXRlY2hhbmdlXCIgKHhoci5yZWFkeVN0YXRlID09PSAzKVxuICAgIC8vIElFIDggZmlyZXMgXCJvbmxvYWRcIiB3aXRob3V0IFwib25wcm9ncmVzc1wiXG4gICAgb25Qcm9ncmVzcygpXG4gICAgaWYgKHN0YXRlID09PSAxIHx8IHN0YXRlID09PSAyIHx8IHN0YXRlID09PSAzKSB7XG4gICAgICBzdGF0ZSA9IDRcbiAgICAgIGlmICh0aW1lb3V0ICE9PSAwKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KVxuICAgICAgICB0aW1lb3V0ID0gMFxuICAgICAgfVxuICAgICAgdGhhdC5yZWFkeVN0YXRlID0gNFxuICAgICAgdGhhdC5vbnJlYWR5c3RhdGVjaGFuZ2UoKVxuICAgIH1cbiAgfVxuICB2YXIgb25SZWFkeVN0YXRlQ2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh4aHIgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBPcGVyYSAxMlxuICAgICAgaWYgKHhoci5yZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICAgIG9uRmluaXNoKClcbiAgICAgIH0gZWxzZSBpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDMpIHtcbiAgICAgICAgb25Qcm9ncmVzcygpXG4gICAgICB9IGVsc2UgaWYgKHhoci5yZWFkeVN0YXRlID09PSAyKSB7XG4gICAgICAgIG9uU3RhcnQoKVxuICAgICAgfVxuICAgIH1cbiAgfVxuICB2YXIgb25UaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIG9uVGltZW91dCgpXG4gICAgfSwgNTAwKVxuICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PT0gMykge1xuICAgICAgb25Qcm9ncmVzcygpXG4gICAgfVxuICB9XG5cbiAgLy8gWERvbWFpblJlcXVlc3QjYWJvcnQgcmVtb3ZlcyBvbnByb2dyZXNzLCBvbmVycm9yLCBvbmxvYWRcbiAgeGhyLm9ubG9hZCA9IG9uRmluaXNoXG4gIHhoci5vbmVycm9yID0gb25GaW5pc2hcbiAgLy8gaW1wcm9wZXIgZml4IHRvIG1hdGNoIEZpcmVmb3ggYmVoYXZpb3VyLCBidXQgaXQgaXMgYmV0dGVyIHRoYW4ganVzdCBpZ25vcmUgYWJvcnRcbiAgLy8gc2VlIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTc2ODU5NlxuICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD04ODAyMDBcbiAgLy8gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTE1MzU3MFxuICAvLyBJRSA4IGZpcmVzIFwib25sb2FkXCIgd2l0aG91dCBcIm9ucHJvZ3Jlc3NcbiAgeGhyLm9uYWJvcnQgPSBvbkZpbmlzaFxuXG4gIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTczNjcyM1xuICBpZiAoXG4gICAgISgnc2VuZEFzQmluYXJ5JyBpbiBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUpICYmXG4gICAgISgnbW96QW5vbicgaW4gWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlKVxuICApIHtcbiAgICB4aHIub25wcm9ncmVzcyA9IG9uUHJvZ3Jlc3NcbiAgfVxuXG4gIC8vIElFIDggLSA5IChYTUxIVFRQUmVxdWVzdClcbiAgLy8gT3BlcmEgPCAxMlxuICAvLyBGaXJlZm94IDwgMy41XG4gIC8vIEZpcmVmb3ggMy41IC0gMy42IC0gPyA8IDkuMFxuICAvLyBvbnByb2dyZXNzIGlzIG5vdCBmaXJlZCBzb21ldGltZXMgb3IgZGVsYXllZFxuICAvLyBzZWUgYWxzbyAjNjRcbiAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG9uUmVhZHlTdGF0ZUNoYW5nZVxuXG4gIGlmICgnY29udGVudFR5cGUnIGluIHhocikge1xuICAgIHVybCArPSAodXJsLmluZGV4T2YoJz8nKSA9PT0gLTEgPyAnPycgOiAnJicpICsgJ3BhZGRpbmc9dHJ1ZSdcbiAgfVxuICB4aHIub3BlbihtZXRob2QsIHVybCwgdHJ1ZSlcblxuICBpZiAoJ3JlYWR5U3RhdGUnIGluIHhocikge1xuICAgIC8vIHdvcmthcm91bmQgZm9yIE9wZXJhIDEyIGlzc3VlIHdpdGggXCJwcm9ncmVzc1wiIGV2ZW50c1xuICAgIC8vICM5MVxuICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIG9uVGltZW91dCgpXG4gICAgfSwgMClcbiAgfVxufVxuWEhSV3JhcHBlci5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX2Fib3J0KGZhbHNlKVxufVxuWEhSV3JhcHBlci5wcm90b3R5cGUuZ2V0UmVzcG9uc2VIZWFkZXIgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gdGhpcy5fY29udGVudFR5cGVcbn1cblhIUldyYXBwZXIucHJvdG90eXBlLnNldFJlcXVlc3RIZWFkZXIgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgdmFyIHhociA9IHRoaXMuX3hoclxuICBpZiAoJ3NldFJlcXVlc3RIZWFkZXInIGluIHhocikge1xuICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKG5hbWUsIHZhbHVlKVxuICB9XG59XG5YSFJXcmFwcGVyLnByb3RvdHlwZS5nZXRBbGxSZXNwb25zZUhlYWRlcnMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl94aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzICE9IHVuZGVmaW5lZFxuICAgID8gdGhpcy5feGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpXG4gICAgOiAnJ1xufVxuWEhSV3JhcHBlci5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gbG9hZGluZyBpbmRpY2F0b3IgaW4gU2FmYXJpIDwgPyAoNiksIENocm9tZSA8IDE0LCBGaXJlZm94XG4gIGlmIChcbiAgICAhKCdvbnRpbWVvdXQnIGluIFhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZSkgJiZcbiAgICBkb2N1bWVudCAhPSB1bmRlZmluZWQgJiZcbiAgICBkb2N1bWVudC5yZWFkeVN0YXRlICE9IHVuZGVmaW5lZCAmJlxuICAgIGRvY3VtZW50LnJlYWR5U3RhdGUgIT09ICdjb21wbGV0ZSdcbiAgKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzXG4gICAgdGhhdC5fc2VuZFRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoYXQuX3NlbmRUaW1lb3V0ID0gMFxuICAgICAgdGhhdC5zZW5kKClcbiAgICB9LCA0KVxuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIHhociA9IHRoaXMuX3hoclxuICAvLyB3aXRoQ3JlZGVudGlhbHMgc2hvdWxkIGJlIHNldCBhZnRlciBcIm9wZW5cIiBmb3IgU2FmYXJpIGFuZCBDaHJvbWUgKDwgMTkgPylcbiAgeGhyLndpdGhDcmVkZW50aWFscyA9IHRoaXMud2l0aENyZWRlbnRpYWxzXG4gIHhoci5yZXNwb25zZVR5cGUgPSB0aGlzLnJlc3BvbnNlVHlwZVxuICB0cnkge1xuICAgIC8vIHhoci5zZW5kKCk7IHRocm93cyBcIk5vdCBlbm91Z2ggYXJndW1lbnRzXCIgaW4gRmlyZWZveCAzLjBcbiAgICB4aHIuc2VuZCh1bmRlZmluZWQpXG4gIH0gY2F0Y2ggKGVycm9yMSkge1xuICAgIC8vIFNhZmFyaSA1LjEuNywgT3BlcmEgMTJcbiAgICB0aHJvdyBlcnJvcjFcbiAgfVxufVxuXG5mdW5jdGlvbiB0b0xvd2VyQ2FzZShuYW1lKSB7XG4gIHJldHVybiBuYW1lLnJlcGxhY2UoL1tBLVpdL2csIGZ1bmN0aW9uIChjKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoYy5jaGFyQ29kZUF0KDApICsgMHgyMClcbiAgfSlcbn1cblxuZnVuY3Rpb24gSGVhZGVyc1BvbHlmaWxsKGFsbCkge1xuICAvLyBHZXQgaGVhZGVyczogaW1wbGVtZW50ZWQgYWNjb3JkaW5nIHRvIG1vemlsbGEncyBleGFtcGxlIGNvZGU6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9YTUxIdHRwUmVxdWVzdC9nZXRBbGxSZXNwb25zZUhlYWRlcnMjRXhhbXBsZVxuICB2YXIgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuICB2YXIgYXJyYXkgPSBhbGwuc3BsaXQoJ1xcclxcbicpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpICs9IDEpIHtcbiAgICB2YXIgbGluZSA9IGFycmF5W2ldXG4gICAgdmFyIHBhcnRzID0gbGluZS5zcGxpdCgnOiAnKVxuICAgIHZhciBuYW1lID0gcGFydHMuc2hpZnQoKVxuICAgIHZhciB2YWx1ZSA9IHBhcnRzLmpvaW4oJzogJylcbiAgICBtYXBbdG9Mb3dlckNhc2UobmFtZSldID0gdmFsdWVcbiAgfVxuICB0aGlzLl9tYXAgPSBtYXBcbn1cbkhlYWRlcnNQb2x5ZmlsbC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIHRoaXMuX21hcFt0b0xvd2VyQ2FzZShuYW1lKV1cbn1cblxuZnVuY3Rpb24gWEhSVHJhbnNwb3J0KCkge31cblxuWEhSVHJhbnNwb3J0LnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gKFxuICB4aHIsXG4gIG9uU3RhcnRDYWxsYmFjayxcbiAgb25Qcm9ncmVzc0NhbGxiYWNrLFxuICBvbkZpbmlzaENhbGxiYWNrLFxuICB1cmwsXG4gIHdpdGhDcmVkZW50aWFscyxcbiAgaGVhZGVyc1xuKSB7XG4gIHhoci5vcGVuKCdHRVQnLCB1cmwpXG4gIHZhciBvZmZzZXQgPSAwXG4gIHhoci5vbnByb2dyZXNzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXNwb25zZVRleHQgPSB4aHIucmVzcG9uc2VUZXh0XG4gICAgdmFyIGNodW5rID0gcmVzcG9uc2VUZXh0LnNsaWNlKG9mZnNldClcbiAgICBvZmZzZXQgKz0gY2h1bmsubGVuZ3RoXG4gICAgb25Qcm9ncmVzc0NhbGxiYWNrKGNodW5rKVxuICB9XG4gIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHhoci5yZWFkeVN0YXRlID09PSAyKSB7XG4gICAgICB2YXIgc3RhdHVzID0geGhyLnN0YXR1c1xuICAgICAgdmFyIHN0YXR1c1RleHQgPSB4aHIuc3RhdHVzVGV4dFxuICAgICAgdmFyIGNvbnRlbnRUeXBlID0geGhyLmdldFJlc3BvbnNlSGVhZGVyKCdDb250ZW50LVR5cGUnKVxuICAgICAgdmFyIGhlYWRlcnMgPSB4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKClcbiAgICAgIG9uU3RhcnRDYWxsYmFjayhcbiAgICAgICAgc3RhdHVzLFxuICAgICAgICBzdGF0dXNUZXh0LFxuICAgICAgICBjb250ZW50VHlwZSxcbiAgICAgICAgbmV3IEhlYWRlcnNQb2x5ZmlsbChoZWFkZXJzKSxcbiAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHhoci5hYm9ydCgpXG4gICAgICAgIH1cbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKHhoci5yZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICBvbkZpbmlzaENhbGxiYWNrKClcbiAgICB9XG4gIH1cbiAgeGhyLndpdGhDcmVkZW50aWFscyA9IHdpdGhDcmVkZW50aWFsc1xuICB4aHIucmVzcG9uc2VUeXBlID0gJ3RleHQnXG4gIGZvciAodmFyIG5hbWUgaW4gaGVhZGVycykge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoaGVhZGVycywgbmFtZSkpIHtcbiAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKG5hbWUsIGhlYWRlcnNbbmFtZV0pXG4gICAgfVxuICB9XG4gIHhoci5zZW5kKClcbn1cblxuZnVuY3Rpb24gSGVhZGVyc1dyYXBwZXIoaGVhZGVycykge1xuICB0aGlzLl9oZWFkZXJzID0gaGVhZGVyc1xufVxuSGVhZGVyc1dyYXBwZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiB0aGlzLl9oZWFkZXJzLmdldChuYW1lKVxufVxuXG5mdW5jdGlvbiBGZXRjaFRyYW5zcG9ydCgpIHt9XG5cbkZldGNoVHJhbnNwb3J0LnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gKFxuICB4aHIsXG4gIG9uU3RhcnRDYWxsYmFjayxcbiAgb25Qcm9ncmVzc0NhbGxiYWNrLFxuICBvbkZpbmlzaENhbGxiYWNrLFxuICB1cmwsXG4gIHdpdGhDcmVkZW50aWFscyxcbiAgaGVhZGVyc1xuKSB7XG4gIHZhciBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpXG4gIHZhciBzaWduYWwgPSBjb250cm9sbGVyLnNpZ25hbCAvLyBzZWUgIzEyMFxuICB2YXIgdGV4dERlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKVxuICBmZXRjaCh1cmwsIHtcbiAgICBoZWFkZXJzOiBoZWFkZXJzLFxuICAgIGNyZWRlbnRpYWxzOiB3aXRoQ3JlZGVudGlhbHMgPyAnaW5jbHVkZScgOiAnc2FtZS1vcmlnaW4nLFxuICAgIHNpZ25hbDogc2lnbmFsLFxuICAgIGNhY2hlOiAnbm8tc3RvcmUnLFxuICB9KVxuICAgIC50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgdmFyIHJlYWRlciA9IHJlc3BvbnNlLmJvZHkuZ2V0UmVhZGVyKClcbiAgICAgIG9uU3RhcnRDYWxsYmFjayhcbiAgICAgICAgcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICByZXNwb25zZS5zdGF0dXNUZXh0LFxuICAgICAgICByZXNwb25zZS5oZWFkZXJzLmdldCgnQ29udGVudC1UeXBlJyksXG4gICAgICAgIG5ldyBIZWFkZXJzV3JhcHBlcihyZXNwb25zZS5oZWFkZXJzKSxcbiAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNvbnRyb2xsZXIuYWJvcnQoKVxuICAgICAgICAgIHJlYWRlci5jYW5jZWwoKVxuICAgICAgICB9XG4gICAgICApXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB2YXIgcmVhZE5leHRDaHVuayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZWFkZXJcbiAgICAgICAgICAgIC5yZWFkKClcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgaWYgKHJlc3VsdC5kb25lKSB7XG4gICAgICAgICAgICAgICAgLy8gTm90ZTogYnl0ZXMgaW4gdGV4dERlY29kZXIgYXJlIGlnbm9yZWRcbiAgICAgICAgICAgICAgICByZXNvbHZlKHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgY2h1bmsgPSB0ZXh0RGVjb2Rlci5kZWNvZGUocmVzdWx0LnZhbHVlLCB7IHN0cmVhbTogdHJ1ZSB9KVxuICAgICAgICAgICAgICAgIG9uUHJvZ3Jlc3NDYWxsYmFjayhjaHVuaylcbiAgICAgICAgICAgICAgICByZWFkTmV4dENodW5rKClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIFsnY2F0Y2gnXShmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgICByZWFkTmV4dENodW5rKClcbiAgICAgIH0pXG4gICAgfSlcbiAgICAudGhlbihcbiAgICAgIGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgb25GaW5pc2hDYWxsYmFjaygpXG4gICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgIH0sXG4gICAgICBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgb25GaW5pc2hDYWxsYmFjaygpXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcilcbiAgICAgIH1cbiAgICApXG59XG5cbmZ1bmN0aW9uIEV2ZW50VGFyZ2V0KCkge1xuICB0aGlzLl9saXN0ZW5lcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpXG59XG5cbmZ1bmN0aW9uIHRocm93RXJyb3IoZSkge1xuICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICB0aHJvdyBlXG4gIH0sIDApXG59XG5cbkV2ZW50VGFyZ2V0LnByb3RvdHlwZS5kaXNwYXRjaEV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIGV2ZW50LnRhcmdldCA9IHRoaXNcbiAgdmFyIHR5cGVMaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnNbZXZlbnQudHlwZV1cbiAgaWYgKHR5cGVMaXN0ZW5lcnMgIT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGxlbmd0aCA9IHR5cGVMaXN0ZW5lcnMubGVuZ3RoXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgICAgdmFyIGxpc3RlbmVyID0gdHlwZUxpc3RlbmVyc1tpXVxuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lci5oYW5kbGVFdmVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGxpc3RlbmVyLmhhbmRsZUV2ZW50KGV2ZW50KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxpc3RlbmVyLmNhbGwodGhpcywgZXZlbnQpXG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3dFcnJvcihlKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuRXZlbnRUYXJnZXQucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAodHlwZSwgbGlzdGVuZXIpIHtcbiAgdHlwZSA9IFN0cmluZyh0eXBlKVxuICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzXG4gIHZhciB0eXBlTGlzdGVuZXJzID0gbGlzdGVuZXJzW3R5cGVdXG4gIGlmICh0eXBlTGlzdGVuZXJzID09IHVuZGVmaW5lZCkge1xuICAgIHR5cGVMaXN0ZW5lcnMgPSBbXVxuICAgIGxpc3RlbmVyc1t0eXBlXSA9IHR5cGVMaXN0ZW5lcnNcbiAgfVxuICB2YXIgZm91bmQgPSBmYWxzZVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVMaXN0ZW5lcnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBpZiAodHlwZUxpc3RlbmVyc1tpXSA9PT0gbGlzdGVuZXIpIHtcbiAgICAgIGZvdW5kID0gdHJ1ZVxuICAgIH1cbiAgfVxuICBpZiAoIWZvdW5kKSB7XG4gICAgdHlwZUxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKVxuICB9XG59XG5FdmVudFRhcmdldC5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uICh0eXBlLCBsaXN0ZW5lcikge1xuICB0eXBlID0gU3RyaW5nKHR5cGUpXG4gIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnNcbiAgdmFyIHR5cGVMaXN0ZW5lcnMgPSBsaXN0ZW5lcnNbdHlwZV1cbiAgaWYgKHR5cGVMaXN0ZW5lcnMgIT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGZpbHRlcmVkID0gW11cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVMaXN0ZW5lcnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGlmICh0eXBlTGlzdGVuZXJzW2ldICE9PSBsaXN0ZW5lcikge1xuICAgICAgICBmaWx0ZXJlZC5wdXNoKHR5cGVMaXN0ZW5lcnNbaV0pXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChmaWx0ZXJlZC5sZW5ndGggPT09IDApIHtcbiAgICAgIGRlbGV0ZSBsaXN0ZW5lcnNbdHlwZV1cbiAgICB9IGVsc2Uge1xuICAgICAgbGlzdGVuZXJzW3R5cGVdID0gZmlsdGVyZWRcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gRXZlbnQodHlwZSkge1xuICB0aGlzLnR5cGUgPSB0eXBlXG4gIHRoaXMudGFyZ2V0ID0gdW5kZWZpbmVkXG59XG5cbmZ1bmN0aW9uIE1lc3NhZ2VFdmVudCh0eXBlLCBvcHRpb25zKSB7XG4gIEV2ZW50LmNhbGwodGhpcywgdHlwZSlcbiAgdGhpcy5kYXRhID0gb3B0aW9ucy5kYXRhXG4gIHRoaXMubGFzdEV2ZW50SWQgPSBvcHRpb25zLmxhc3RFdmVudElkXG59XG5cbk1lc3NhZ2VFdmVudC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEV2ZW50LnByb3RvdHlwZSlcblxuZnVuY3Rpb24gQ29ubmVjdGlvbkV2ZW50KHR5cGUsIG9wdGlvbnMpIHtcbiAgRXZlbnQuY2FsbCh0aGlzLCB0eXBlKVxuICB0aGlzLnN0YXR1cyA9IG9wdGlvbnMuc3RhdHVzXG4gIHRoaXMuc3RhdHVzVGV4dCA9IG9wdGlvbnMuc3RhdHVzVGV4dFxuICB0aGlzLmhlYWRlcnMgPSBvcHRpb25zLmhlYWRlcnNcbn1cblxuQ29ubmVjdGlvbkV2ZW50LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXZlbnQucHJvdG90eXBlKVxuXG52YXIgV0FJVElORyA9IC0xXG52YXIgQ09OTkVDVElORyA9IDBcbnZhciBPUEVOID0gMVxudmFyIENMT1NFRCA9IDJcblxudmFyIEFGVEVSX0NSID0gLTFcbnZhciBGSUVMRF9TVEFSVCA9IDBcbnZhciBGSUVMRCA9IDFcbnZhciBWQUxVRV9TVEFSVCA9IDJcbnZhciBWQUxVRSA9IDNcblxudmFyIGNvbnRlbnRUeXBlUmVnRXhwID0gL150ZXh0XFwvZXZlbnRcXC1zdHJlYW07PyhcXHMqY2hhcnNldFxcPXV0ZlxcLTgpPyQvaVxuXG52YXIgTUlOSU1VTV9EVVJBVElPTiA9IDEwMDBcbnZhciBNQVhJTVVNX0RVUkFUSU9OID0gMTgwMDAwMDBcblxudmFyIHBhcnNlRHVyYXRpb24gPSBmdW5jdGlvbiAodmFsdWUsIGRlZikge1xuICB2YXIgbiA9IHBhcnNlSW50KHZhbHVlLCAxMClcbiAgaWYgKG4gIT09IG4pIHtcbiAgICBuID0gZGVmXG4gIH1cbiAgcmV0dXJuIGNsYW1wRHVyYXRpb24obilcbn1cbnZhciBjbGFtcER1cmF0aW9uID0gZnVuY3Rpb24gKG4pIHtcbiAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KG4sIE1JTklNVU1fRFVSQVRJT04pLCBNQVhJTVVNX0RVUkFUSU9OKVxufVxuXG52YXIgZmlyZSA9IGZ1bmN0aW9uICh0aGF0LCBmLCBldmVudCkge1xuICB0cnkge1xuICAgIGlmICh0eXBlb2YgZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZi5jYWxsKHRoYXQsIGV2ZW50KVxuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93RXJyb3IoZSlcbiAgfVxufVxuXG5mdW5jdGlvbiBFdmVudFNvdXJjZVBvbHlmaWxsKHVybCwgb3B0aW9ucykge1xuICBFdmVudFRhcmdldC5jYWxsKHRoaXMpXG5cbiAgdGhpcy5vbm9wZW4gPSB1bmRlZmluZWRcbiAgdGhpcy5vbm1lc3NhZ2UgPSB1bmRlZmluZWRcbiAgdGhpcy5vbmVycm9yID0gdW5kZWZpbmVkXG5cbiAgdGhpcy51cmwgPSB1bmRlZmluZWRcbiAgdGhpcy5yZWFkeVN0YXRlID0gdW5kZWZpbmVkXG4gIHRoaXMud2l0aENyZWRlbnRpYWxzID0gdW5kZWZpbmVkXG5cbiAgdGhpcy5fY2xvc2UgPSB1bmRlZmluZWRcblxuICBzdGFydCh0aGlzLCB1cmwsIG9wdGlvbnMpXG59XG5cbnZhciBpc0ZldGNoU3VwcG9ydGVkID1cbiAgZmV0Y2ggIT0gdW5kZWZpbmVkICYmIFJlc3BvbnNlICE9IHVuZGVmaW5lZCAmJiAnYm9keScgaW4gUmVzcG9uc2UucHJvdG90eXBlXG5cbmZ1bmN0aW9uIHN0YXJ0KGVzLCB1cmwsIG9wdGlvbnMpIHtcbiAgdXJsID0gU3RyaW5nKHVybClcbiAgdmFyIHdpdGhDcmVkZW50aWFscyA9IG9wdGlvbnMgIT0gdW5kZWZpbmVkICYmIEJvb2xlYW4ob3B0aW9ucy53aXRoQ3JlZGVudGlhbHMpXG5cbiAgdmFyIGluaXRpYWxSZXRyeSA9IGNsYW1wRHVyYXRpb24oMTAwMClcbiAgdmFyIGhlYXJ0YmVhdFRpbWVvdXQgPVxuICAgIG9wdGlvbnMgIT0gdW5kZWZpbmVkICYmIG9wdGlvbnMuaGVhcnRiZWF0VGltZW91dCAhPSB1bmRlZmluZWRcbiAgICAgID8gcGFyc2VEdXJhdGlvbihvcHRpb25zLmhlYXJ0YmVhdFRpbWVvdXQsIDQ1MDAwKVxuICAgICAgOiBjbGFtcER1cmF0aW9uKDQ1MDAwKVxuXG4gIHZhciBsYXN0RXZlbnRJZCA9ICcnXG4gIHZhciByZXRyeSA9IGluaXRpYWxSZXRyeVxuICB2YXIgd2FzQWN0aXZpdHkgPSBmYWxzZVxuICB2YXIgaGVhZGVycyA9XG4gICAgb3B0aW9ucyAhPSB1bmRlZmluZWQgJiYgb3B0aW9ucy5oZWFkZXJzICE9IHVuZGVmaW5lZFxuICAgICAgPyBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9wdGlvbnMuaGVhZGVycykpXG4gICAgICA6IHVuZGVmaW5lZFxuICB2YXIgQ3VycmVudFRyYW5zcG9ydCA9XG4gICAgb3B0aW9ucyAhPSB1bmRlZmluZWQgJiYgb3B0aW9ucy5UcmFuc3BvcnQgIT0gdW5kZWZpbmVkXG4gICAgICA/IG9wdGlvbnMuVHJhbnNwb3J0XG4gICAgICA6IFhNTEh0dHBSZXF1ZXN0XG4gIHZhciB4aHIgPVxuICAgIGlzRmV0Y2hTdXBwb3J0ZWQgJiZcbiAgICAhKG9wdGlvbnMgIT0gdW5kZWZpbmVkICYmIG9wdGlvbnMuVHJhbnNwb3J0ICE9IHVuZGVmaW5lZClcbiAgICAgID8gdW5kZWZpbmVkXG4gICAgICA6IG5ldyBYSFJXcmFwcGVyKG5ldyBDdXJyZW50VHJhbnNwb3J0KCkpXG4gIHZhciB0cmFuc3BvcnQgPSB4aHIgPT0gdW5kZWZpbmVkID8gbmV3IEZldGNoVHJhbnNwb3J0KCkgOiBuZXcgWEhSVHJhbnNwb3J0KClcbiAgdmFyIGNhbmNlbEZ1bmN0aW9uID0gdW5kZWZpbmVkXG4gIHZhciB0aW1lb3V0ID0gMFxuICB2YXIgY3VycmVudFN0YXRlID0gV0FJVElOR1xuICB2YXIgZGF0YUJ1ZmZlciA9ICcnXG4gIHZhciBsYXN0RXZlbnRJZEJ1ZmZlciA9ICcnXG4gIHZhciBldmVudFR5cGVCdWZmZXIgPSAnJ1xuXG4gIHZhciB0ZXh0QnVmZmVyID0gJydcbiAgdmFyIHN0YXRlID0gRklFTERfU1RBUlRcbiAgdmFyIGZpZWxkU3RhcnQgPSAwXG4gIHZhciB2YWx1ZVN0YXJ0ID0gMFxuXG4gIHZhciBvblN0YXJ0ID0gZnVuY3Rpb24gKHN0YXR1cywgc3RhdHVzVGV4dCwgY29udGVudFR5cGUsIGhlYWRlcnMsIGNhbmNlbCkge1xuICAgIGlmIChjdXJyZW50U3RhdGUgPT09IENPTk5FQ1RJTkcpIHtcbiAgICAgIGNhbmNlbEZ1bmN0aW9uID0gY2FuY2VsXG4gICAgICBpZiAoXG4gICAgICAgIHN0YXR1cyA9PT0gMjAwICYmXG4gICAgICAgIGNvbnRlbnRUeXBlICE9IHVuZGVmaW5lZCAmJlxuICAgICAgICBjb250ZW50VHlwZVJlZ0V4cC50ZXN0KGNvbnRlbnRUeXBlKVxuICAgICAgKSB7XG4gICAgICAgIGN1cnJlbnRTdGF0ZSA9IE9QRU5cbiAgICAgICAgd2FzQWN0aXZpdHkgPSB0cnVlXG4gICAgICAgIHJldHJ5ID0gaW5pdGlhbFJldHJ5XG4gICAgICAgIGVzLnJlYWR5U3RhdGUgPSBPUEVOXG4gICAgICAgIHZhciBldmVudCA9IG5ldyBDb25uZWN0aW9uRXZlbnQoJ29wZW4nLCB7XG4gICAgICAgICAgc3RhdHVzOiBzdGF0dXMsXG4gICAgICAgICAgc3RhdHVzVGV4dDogc3RhdHVzVGV4dCxcbiAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJzLFxuICAgICAgICB9KVxuICAgICAgICBlcy5kaXNwYXRjaEV2ZW50KGV2ZW50KVxuICAgICAgICBmaXJlKGVzLCBlcy5vbm9wZW4sIGV2ZW50KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSAnJ1xuICAgICAgICBpZiAoc3RhdHVzICE9PSAyMDApIHtcbiAgICAgICAgICBpZiAoc3RhdHVzVGV4dCkge1xuICAgICAgICAgICAgc3RhdHVzVGV4dCA9IHN0YXR1c1RleHQucmVwbGFjZSgvXFxzKy9nLCAnICcpXG4gICAgICAgICAgfVxuICAgICAgICAgIG1lc3NhZ2UgPVxuICAgICAgICAgICAgXCJFdmVudFNvdXJjZSdzIHJlc3BvbnNlIGhhcyBhIHN0YXR1cyBcIiArXG4gICAgICAgICAgICBzdGF0dXMgK1xuICAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgIHN0YXR1c1RleHQgK1xuICAgICAgICAgICAgJyB0aGF0IGlzIG5vdCAyMDAuIEFib3J0aW5nIHRoZSBjb25uZWN0aW9uLidcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtZXNzYWdlID1cbiAgICAgICAgICAgIFwiRXZlbnRTb3VyY2UncyByZXNwb25zZSBoYXMgYSBDb250ZW50LVR5cGUgc3BlY2lmeWluZyBhbiB1bnN1cHBvcnRlZCB0eXBlOiBcIiArXG4gICAgICAgICAgICAoY29udGVudFR5cGUgPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgID8gJy0nXG4gICAgICAgICAgICAgIDogY29udGVudFR5cGUucmVwbGFjZSgvXFxzKy9nLCAnICcpKSArXG4gICAgICAgICAgICAnLiBBYm9ydGluZyB0aGUgY29ubmVjdGlvbi4nXG4gICAgICAgIH1cbiAgICAgICAgdGhyb3dFcnJvcihuZXcgRXJyb3IobWVzc2FnZSkpXG4gICAgICAgIGNsb3NlKClcbiAgICAgICAgdmFyIGV2ZW50ID0gbmV3IENvbm5lY3Rpb25FdmVudCgnZXJyb3InLCB7XG4gICAgICAgICAgc3RhdHVzOiBzdGF0dXMsXG4gICAgICAgICAgc3RhdHVzVGV4dDogc3RhdHVzVGV4dCxcbiAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJzLFxuICAgICAgICB9KVxuICAgICAgICBlcy5kaXNwYXRjaEV2ZW50KGV2ZW50KVxuICAgICAgICBmaXJlKGVzLCBlcy5vbmVycm9yLCBldmVudClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgb25Qcm9ncmVzcyA9IGZ1bmN0aW9uICh0ZXh0Q2h1bmspIHtcbiAgICBpZiAoY3VycmVudFN0YXRlID09PSBPUEVOKSB7XG4gICAgICB2YXIgbiA9IC0xXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHRDaHVuay5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgYyA9IHRleHRDaHVuay5jaGFyQ29kZUF0KGkpXG4gICAgICAgIGlmIChjID09PSAnXFxuJy5jaGFyQ29kZUF0KDApIHx8IGMgPT09ICdcXHInLmNoYXJDb2RlQXQoMCkpIHtcbiAgICAgICAgICBuID0gaVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgY2h1bmsgPSAobiAhPT0gLTEgPyB0ZXh0QnVmZmVyIDogJycpICsgdGV4dENodW5rLnNsaWNlKDAsIG4gKyAxKVxuICAgICAgdGV4dEJ1ZmZlciA9IChuID09PSAtMSA/IHRleHRCdWZmZXIgOiAnJykgKyB0ZXh0Q2h1bmsuc2xpY2UobiArIDEpXG4gICAgICBpZiAoY2h1bmsgIT09ICcnKSB7XG4gICAgICAgIHdhc0FjdGl2aXR5ID0gdHJ1ZVxuICAgICAgfVxuICAgICAgZm9yICh2YXIgcG9zaXRpb24gPSAwOyBwb3NpdGlvbiA8IGNodW5rLmxlbmd0aDsgcG9zaXRpb24gKz0gMSkge1xuICAgICAgICB2YXIgYyA9IGNodW5rLmNoYXJDb2RlQXQocG9zaXRpb24pXG4gICAgICAgIGlmIChzdGF0ZSA9PT0gQUZURVJfQ1IgJiYgYyA9PT0gJ1xcbicuY2hhckNvZGVBdCgwKSkge1xuICAgICAgICAgIHN0YXRlID0gRklFTERfU1RBUlRcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoc3RhdGUgPT09IEFGVEVSX0NSKSB7XG4gICAgICAgICAgICBzdGF0ZSA9IEZJRUxEX1NUQVJUXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjID09PSAnXFxyJy5jaGFyQ29kZUF0KDApIHx8IGMgPT09ICdcXG4nLmNoYXJDb2RlQXQoMCkpIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZSAhPT0gRklFTERfU1RBUlQpIHtcbiAgICAgICAgICAgICAgaWYgKHN0YXRlID09PSBGSUVMRCkge1xuICAgICAgICAgICAgICAgIHZhbHVlU3RhcnQgPSBwb3NpdGlvbiArIDFcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIgZmllbGQgPSBjaHVuay5zbGljZShmaWVsZFN0YXJ0LCB2YWx1ZVN0YXJ0IC0gMSlcbiAgICAgICAgICAgICAgdmFyIHZhbHVlID0gY2h1bmsuc2xpY2UoXG4gICAgICAgICAgICAgICAgdmFsdWVTdGFydCArXG4gICAgICAgICAgICAgICAgICAodmFsdWVTdGFydCA8IHBvc2l0aW9uICYmXG4gICAgICAgICAgICAgICAgICBjaHVuay5jaGFyQ29kZUF0KHZhbHVlU3RhcnQpID09PSAnICcuY2hhckNvZGVBdCgwKVxuICAgICAgICAgICAgICAgICAgICA/IDFcbiAgICAgICAgICAgICAgICAgICAgOiAwKSxcbiAgICAgICAgICAgICAgICBwb3NpdGlvblxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIGlmIChmaWVsZCA9PT0gJ2RhdGEnKSB7XG4gICAgICAgICAgICAgICAgZGF0YUJ1ZmZlciArPSAnXFxuJ1xuICAgICAgICAgICAgICAgIGRhdGFCdWZmZXIgKz0gdmFsdWVcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChmaWVsZCA9PT0gJ2lkJykge1xuICAgICAgICAgICAgICAgIGxhc3RFdmVudElkQnVmZmVyID0gdmFsdWVcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChmaWVsZCA9PT0gJ2V2ZW50Jykge1xuICAgICAgICAgICAgICAgIGV2ZW50VHlwZUJ1ZmZlciA9IHZhbHVlXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoZmllbGQgPT09ICdyZXRyeScpIHtcbiAgICAgICAgICAgICAgICBpbml0aWFsUmV0cnkgPSBwYXJzZUR1cmF0aW9uKHZhbHVlLCBpbml0aWFsUmV0cnkpXG4gICAgICAgICAgICAgICAgcmV0cnkgPSBpbml0aWFsUmV0cnlcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChmaWVsZCA9PT0gJ2hlYXJ0YmVhdFRpbWVvdXQnKSB7XG4gICAgICAgICAgICAgICAgaGVhcnRiZWF0VGltZW91dCA9IHBhcnNlRHVyYXRpb24odmFsdWUsIGhlYXJ0YmVhdFRpbWVvdXQpXG4gICAgICAgICAgICAgICAgaWYgKHRpbWVvdXQgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KVxuICAgICAgICAgICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBvblRpbWVvdXQoKVxuICAgICAgICAgICAgICAgICAgfSwgaGVhcnRiZWF0VGltZW91dClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGF0ZSA9PT0gRklFTERfU1RBUlQpIHtcbiAgICAgICAgICAgICAgaWYgKGRhdGFCdWZmZXIgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgbGFzdEV2ZW50SWQgPSBsYXN0RXZlbnRJZEJ1ZmZlclxuICAgICAgICAgICAgICAgIGlmIChldmVudFR5cGVCdWZmZXIgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICBldmVudFR5cGVCdWZmZXIgPSAnbWVzc2FnZSdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGV2ZW50ID0gbmV3IE1lc3NhZ2VFdmVudChldmVudFR5cGVCdWZmZXIsIHtcbiAgICAgICAgICAgICAgICAgIGRhdGE6IGRhdGFCdWZmZXIuc2xpY2UoMSksXG4gICAgICAgICAgICAgICAgICBsYXN0RXZlbnRJZDogbGFzdEV2ZW50SWRCdWZmZXIsXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICBlcy5kaXNwYXRjaEV2ZW50KGV2ZW50KVxuICAgICAgICAgICAgICAgIGlmIChldmVudFR5cGVCdWZmZXIgPT09ICdtZXNzYWdlJykge1xuICAgICAgICAgICAgICAgICAgZmlyZShlcywgZXMub25tZXNzYWdlLCBldmVudClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRTdGF0ZSA9PT0gQ0xPU0VEKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGF0YUJ1ZmZlciA9ICcnXG4gICAgICAgICAgICAgIGV2ZW50VHlwZUJ1ZmZlciA9ICcnXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGF0ZSA9IGMgPT09ICdcXHInLmNoYXJDb2RlQXQoMCkgPyBBRlRFUl9DUiA6IEZJRUxEX1NUQVJUXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZSA9PT0gRklFTERfU1RBUlQpIHtcbiAgICAgICAgICAgICAgZmllbGRTdGFydCA9IHBvc2l0aW9uXG4gICAgICAgICAgICAgIHN0YXRlID0gRklFTERcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGF0ZSA9PT0gRklFTEQpIHtcbiAgICAgICAgICAgICAgaWYgKGMgPT09ICc6Jy5jaGFyQ29kZUF0KDApKSB7XG4gICAgICAgICAgICAgICAgdmFsdWVTdGFydCA9IHBvc2l0aW9uICsgMVxuICAgICAgICAgICAgICAgIHN0YXRlID0gVkFMVUVfU1RBUlRcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gVkFMVUVfU1RBUlQpIHtcbiAgICAgICAgICAgICAgc3RhdGUgPSBWQUxVRVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBvbkZpbmlzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoY3VycmVudFN0YXRlID09PSBPUEVOIHx8IGN1cnJlbnRTdGF0ZSA9PT0gQ09OTkVDVElORykge1xuICAgICAgY3VycmVudFN0YXRlID0gV0FJVElOR1xuICAgICAgaWYgKHRpbWVvdXQgIT09IDApIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpXG4gICAgICAgIHRpbWVvdXQgPSAwXG4gICAgICB9XG4gICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIG9uVGltZW91dCgpXG4gICAgICB9LCByZXRyeSlcbiAgICAgIHJldHJ5ID0gY2xhbXBEdXJhdGlvbihNYXRoLm1pbihpbml0aWFsUmV0cnkgKiAxNiwgcmV0cnkgKiAyKSlcblxuICAgICAgZXMucmVhZHlTdGF0ZSA9IENPTk5FQ1RJTkdcbiAgICAgIHZhciBldmVudCA9IG5ldyBFdmVudCgnZXJyb3InKVxuICAgICAgZXMuZGlzcGF0Y2hFdmVudChldmVudClcbiAgICAgIGZpcmUoZXMsIGVzLm9uZXJyb3IsIGV2ZW50KVxuICAgIH1cbiAgfVxuXG4gIHZhciBjbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBjdXJyZW50U3RhdGUgPSBDTE9TRURcbiAgICBpZiAoY2FuY2VsRnVuY3Rpb24gIT0gdW5kZWZpbmVkKSB7XG4gICAgICBjYW5jZWxGdW5jdGlvbigpXG4gICAgICBjYW5jZWxGdW5jdGlvbiA9IHVuZGVmaW5lZFxuICAgIH1cbiAgICBpZiAodGltZW91dCAhPT0gMCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpXG4gICAgICB0aW1lb3V0ID0gMFxuICAgIH1cbiAgICBlcy5yZWFkeVN0YXRlID0gQ0xPU0VEXG4gIH1cblxuICB2YXIgb25UaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgIHRpbWVvdXQgPSAwXG5cbiAgICBpZiAoY3VycmVudFN0YXRlICE9PSBXQUlUSU5HKSB7XG4gICAgICBpZiAoIXdhc0FjdGl2aXR5ICYmIGNhbmNlbEZ1bmN0aW9uICE9IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvd0Vycm9yKFxuICAgICAgICAgIG5ldyBFcnJvcihcbiAgICAgICAgICAgICdObyBhY3Rpdml0eSB3aXRoaW4gJyArXG4gICAgICAgICAgICAgIGhlYXJ0YmVhdFRpbWVvdXQgK1xuICAgICAgICAgICAgICAnIG1pbGxpc2Vjb25kcy4gUmVjb25uZWN0aW5nLidcbiAgICAgICAgICApXG4gICAgICAgIClcbiAgICAgICAgY2FuY2VsRnVuY3Rpb24oKVxuICAgICAgICBjYW5jZWxGdW5jdGlvbiA9IHVuZGVmaW5lZFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2FzQWN0aXZpdHkgPSBmYWxzZVxuICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgb25UaW1lb3V0KClcbiAgICAgICAgfSwgaGVhcnRiZWF0VGltZW91dClcbiAgICAgIH1cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHdhc0FjdGl2aXR5ID0gZmFsc2VcbiAgICB0aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBvblRpbWVvdXQoKVxuICAgIH0sIGhlYXJ0YmVhdFRpbWVvdXQpXG5cbiAgICBjdXJyZW50U3RhdGUgPSBDT05ORUNUSU5HXG4gICAgZGF0YUJ1ZmZlciA9ICcnXG4gICAgZXZlbnRUeXBlQnVmZmVyID0gJydcbiAgICBsYXN0RXZlbnRJZEJ1ZmZlciA9IGxhc3RFdmVudElkXG4gICAgdGV4dEJ1ZmZlciA9ICcnXG4gICAgZmllbGRTdGFydCA9IDBcbiAgICB2YWx1ZVN0YXJ0ID0gMFxuICAgIHN0YXRlID0gRklFTERfU1RBUlRcblxuICAgIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTQyODkxNlxuICAgIC8vIFJlcXVlc3QgaGVhZGVyIGZpZWxkIExhc3QtRXZlbnQtSUQgaXMgbm90IGFsbG93ZWQgYnkgQWNjZXNzLUNvbnRyb2wtQWxsb3ctSGVhZGVycy5cbiAgICB2YXIgcmVxdWVzdFVSTCA9IHVybFxuICAgIGlmICh1cmwuc2xpY2UoMCwgNSkgIT09ICdkYXRhOicgJiYgdXJsLnNsaWNlKDAsIDUpICE9PSAnYmxvYjonKSB7XG4gICAgICBpZiAobGFzdEV2ZW50SWQgIT09ICcnKSB7XG4gICAgICAgIHJlcXVlc3RVUkwgKz1cbiAgICAgICAgICAodXJsLmluZGV4T2YoJz8nKSA9PT0gLTEgPyAnPycgOiAnJicpICtcbiAgICAgICAgICAnbGFzdEV2ZW50SWQ9JyArXG4gICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KGxhc3RFdmVudElkKVxuICAgICAgfVxuICAgIH1cbiAgICB2YXIgcmVxdWVzdEhlYWRlcnMgPSB7fVxuICAgIHJlcXVlc3RIZWFkZXJzWydBY2NlcHQnXSA9ICd0ZXh0L2V2ZW50LXN0cmVhbSdcbiAgICBpZiAoaGVhZGVycyAhPSB1bmRlZmluZWQpIHtcbiAgICAgIGZvciAodmFyIG5hbWUgaW4gaGVhZGVycykge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGhlYWRlcnMsIG5hbWUpKSB7XG4gICAgICAgICAgcmVxdWVzdEhlYWRlcnNbbmFtZV0gPSBoZWFkZXJzW25hbWVdXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHRyYW5zcG9ydC5vcGVuKFxuICAgICAgICB4aHIsXG4gICAgICAgIG9uU3RhcnQsXG4gICAgICAgIG9uUHJvZ3Jlc3MsXG4gICAgICAgIG9uRmluaXNoLFxuICAgICAgICByZXF1ZXN0VVJMLFxuICAgICAgICB3aXRoQ3JlZGVudGlhbHMsXG4gICAgICAgIHJlcXVlc3RIZWFkZXJzXG4gICAgICApXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNsb3NlKClcbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgZXMudXJsID0gdXJsXG4gIGVzLnJlYWR5U3RhdGUgPSBDT05ORUNUSU5HXG4gIGVzLndpdGhDcmVkZW50aWFscyA9IHdpdGhDcmVkZW50aWFsc1xuICBlcy5fY2xvc2UgPSBjbG9zZVxuXG4gIG9uVGltZW91dCgpXG59XG5cbkV2ZW50U291cmNlUG9seWZpbGwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFdmVudFRhcmdldC5wcm90b3R5cGUpXG5FdmVudFNvdXJjZVBvbHlmaWxsLnByb3RvdHlwZS5DT05ORUNUSU5HID0gQ09OTkVDVElOR1xuRXZlbnRTb3VyY2VQb2x5ZmlsbC5wcm90b3R5cGUuT1BFTiA9IE9QRU5cbkV2ZW50U291cmNlUG9seWZpbGwucHJvdG90eXBlLkNMT1NFRCA9IENMT1NFRFxuRXZlbnRTb3VyY2VQb2x5ZmlsbC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX2Nsb3NlKClcbn1cblxuRXZlbnRTb3VyY2VQb2x5ZmlsbC5DT05ORUNUSU5HID0gQ09OTkVDVElOR1xuRXZlbnRTb3VyY2VQb2x5ZmlsbC5PUEVOID0gT1BFTlxuRXZlbnRTb3VyY2VQb2x5ZmlsbC5DTE9TRUQgPSBDTE9TRURcbkV2ZW50U291cmNlUG9seWZpbGwucHJvdG90eXBlLndpdGhDcmVkZW50aWFscyA9IHVuZGVmaW5lZFxuXG5leHBvcnQgZGVmYXVsdCBFdmVudFNvdXJjZVBvbHlmaWxsXG4iLCJleHBvcnQgZnVuY3Rpb24gZGlzcGxheUNvbnRlbnQoY2FsbGJhY2spIHtcbiAgLy8gVGhpcyBpcyB0aGUgZmFsbGJhY2sgaGVscGVyIHRoYXQgcmVtb3ZlcyBOZXh0LmpzJyBuby1GT1VDIHN0eWxlcyB3aGVuXG4gIC8vIENTUyBtb2RlIGlzIGVuYWJsZWQuIFRoaXMgb25seSByZWFsbHkgYWN0aXZhdGVzIGlmIHlvdSBoYXZlbid0IGNyZWF0ZWRcbiAgLy8gX2FueV8gc3R5bGVzIGluIHlvdXIgYXBwbGljYXRpb24geWV0LlxuICA7KHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgc2V0VGltZW91dCkoZnVuY3Rpb24gKCkge1xuICAgIGZvciAoXG4gICAgICB2YXIgeCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLW5leHQtaGlkZS1mb3VjXScpLCBpID0geC5sZW5ndGg7XG4gICAgICBpLS07XG5cbiAgICApIHtcbiAgICAgIHhbaV0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh4W2ldKVxuICAgIH1cbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrKClcbiAgICB9XG4gIH0pXG59XG4iLCJpbXBvcnQgUm91dGVyIGZyb20gJ25leHQvcm91dGVyJ1xuaW1wb3J0IHsgc2V0dXBQaW5nLCBjdXJyZW50UGFnZSwgY2xvc2VQaW5nIH0gZnJvbSAnLi9vbi1kZW1hbmQtZW50cmllcy11dGlscydcblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgKHsgYXNzZXRQcmVmaXggfSkgPT4ge1xuICBSb3V0ZXIucmVhZHkoKCkgPT4ge1xuICAgIFJvdXRlci5ldmVudHMub24oXG4gICAgICAncm91dGVDaGFuZ2VDb21wbGV0ZScsXG4gICAgICBzZXR1cFBpbmcuYmluZCh0aGlzLCBhc3NldFByZWZpeCwgKCkgPT4gUm91dGVyLnBhdGhuYW1lKVxuICAgIClcbiAgfSlcblxuICBzZXR1cFBpbmcoYXNzZXRQcmVmaXgsICgpID0+IFJvdXRlci5wYXRobmFtZSwgY3VycmVudFBhZ2UpXG5cbiAgLy8gcHJldmVudCBITVIgY29ubmVjdGlvbiBmcm9tIGJlaW5nIGNsb3NlZCB3aGVuIHJ1bm5pbmcgdGVzdHNcbiAgaWYgKCFwcm9jZXNzLmVudi5fX05FWFRfVEVTVF9NT0RFKSB7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsIChldmVudCkgPT4ge1xuICAgICAgY29uc3Qgc3RhdGUgPSBkb2N1bWVudC52aXNpYmlsaXR5U3RhdGVcbiAgICAgIGlmIChzdGF0ZSA9PT0gJ3Zpc2libGUnKSB7XG4gICAgICAgIHNldHVwUGluZyhhc3NldFByZWZpeCwgKCkgPT4gUm91dGVyLnBhdGhuYW1lLCB0cnVlKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2xvc2VQaW5nKClcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2JlZm9yZXVubG9hZCcsICgpID0+IHtcbiAgICAgIGNsb3NlUGluZygpXG4gICAgfSlcbiAgfVxufVxuIiwiLyogZ2xvYmFsIGxvY2F0aW9uICovXG5cbmltcG9ydCBmZXRjaCBmcm9tICduZXh0L2Rpc3QvYnVpbGQvcG9seWZpbGxzL3VuZmV0Y2gnXG5pbXBvcnQgeyBnZXRFdmVudFNvdXJjZVdyYXBwZXIgfSBmcm9tICcuL2Vycm9yLW92ZXJsYXkvZXZlbnRzb3VyY2UnXG5cbmxldCBldnRTb3VyY2VcbmV4cG9ydCBsZXQgY3VycmVudFBhZ2VcblxuZXhwb3J0IGZ1bmN0aW9uIGNsb3NlUGluZygpIHtcbiAgaWYgKGV2dFNvdXJjZSkgZXZ0U291cmNlLmNsb3NlKClcbiAgZXZ0U291cmNlID0gbnVsbFxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0dXBQaW5nKGFzc2V0UHJlZml4LCBwYXRobmFtZUZuLCByZXRyeSkge1xuICBjb25zdCBwYXRobmFtZSA9IHBhdGhuYW1lRm4oKVxuXG4gIC8vIE1ha2Ugc3VyZSB0byBvbmx5IGNyZWF0ZSBuZXcgRXZlbnRTb3VyY2UgcmVxdWVzdCBpZiBwYWdlIGhhcyBjaGFuZ2VkXG4gIGlmIChwYXRobmFtZSA9PT0gY3VycmVudFBhZ2UgJiYgIXJldHJ5KSByZXR1cm5cbiAgY3VycmVudFBhZ2UgPSBwYXRobmFtZVxuICAvLyBjbG9zZSBjdXJyZW50IEV2ZW50U291cmNlIGNvbm5lY3Rpb25cbiAgY2xvc2VQaW5nKClcblxuICBjb25zdCB1cmwgPSBgJHthc3NldFByZWZpeH0vX25leHQvd2VicGFjay1obXI/cGFnZT0ke2N1cnJlbnRQYWdlfWBcbiAgZXZ0U291cmNlID0gZ2V0RXZlbnRTb3VyY2VXcmFwcGVyKHsgcGF0aDogdXJsLCB0aW1lb3V0OiA1MDAwLCBvbmRlbWFuZDogMSB9KVxuXG4gIGV2dFNvdXJjZS5hZGRNZXNzYWdlTGlzdGVuZXIoKGV2ZW50KSA9PiB7XG4gICAgaWYgKGV2ZW50LmRhdGEuaW5kZXhPZigneycpID09PSAtMSkgcmV0dXJuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHBheWxvYWQgPSBKU09OLnBhcnNlKGV2ZW50LmRhdGEpXG4gICAgICBpZiAocGF5bG9hZC5pbnZhbGlkKSB7XG4gICAgICAgIC8vIFBheWxvYWQgY2FuIGJlIGludmFsaWQgZXZlbiBpZiB0aGUgcGFnZSBkb2VzIG5vdCBleGlzdC5cbiAgICAgICAgLy8gU28sIHdlIG5lZWQgdG8gbWFrZSBzdXJlIGl0IGV4aXN0cyBiZWZvcmUgcmVsb2FkaW5nLlxuICAgICAgICBmZXRjaChsb2NhdGlvbi5ocmVmLCB7XG4gICAgICAgICAgY3JlZGVudGlhbHM6ICdzYW1lLW9yaWdpbicsXG4gICAgICAgIH0pLnRoZW4oKHBhZ2VSZXMpID0+IHtcbiAgICAgICAgICBpZiAocGFnZVJlcy5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgICAgbG9jYXRpb24ucmVsb2FkKClcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdvbi1kZW1hbmQtZW50cmllcyBmYWlsZWQgdG8gcGFyc2UgcmVzcG9uc2UnLCBlcnIpXG4gICAgfVxuICB9KVxufVxuIiwiaW1wb3J0IFJvdXRlciBmcm9tICcuLi9yb3V0ZXInXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGluaXRpYWxpemVCdWlsZFdhdGNoZXIoKSB7XG4gIGNvbnN0IHNoYWRvd0hvc3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICBzaGFkb3dIb3N0LmlkID0gJ19fbmV4dC1wcmVyZW5kZXItaW5kaWNhdG9yJ1xuICAvLyBNYWtlIHN1cmUgY29udGFpbmVyIGlzIGZpeGVkIGFuZCBvbiBhIGhpZ2ggekluZGV4IHNvIGl0IHNob3dzXG4gIHNoYWRvd0hvc3Quc3R5bGUucG9zaXRpb24gPSAnZml4ZWQnXG4gIHNoYWRvd0hvc3Quc3R5bGUuYm90dG9tID0gJzIwcHgnXG4gIHNoYWRvd0hvc3Quc3R5bGUucmlnaHQgPSAnMTBweCdcbiAgc2hhZG93SG9zdC5zdHlsZS53aWR0aCA9IDBcbiAgc2hhZG93SG9zdC5zdHlsZS5oZWlnaHQgPSAwXG4gIHNoYWRvd0hvc3Quc3R5bGUuekluZGV4ID0gOTk5OThcbiAgc2hhZG93SG9zdC5zdHlsZS50cmFuc2l0aW9uID0gJ2FsbCAxMDBtcyBlYXNlJ1xuXG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc2hhZG93SG9zdClcblxuICBsZXQgc2hhZG93Um9vdFxuICBsZXQgcHJlZml4ID0gJydcblxuICBpZiAoc2hhZG93SG9zdC5hdHRhY2hTaGFkb3cpIHtcbiAgICBzaGFkb3dSb290ID0gc2hhZG93SG9zdC5hdHRhY2hTaGFkb3coeyBtb2RlOiAnb3BlbicgfSlcbiAgfSBlbHNlIHtcbiAgICAvLyBJZiBhdHRhY2hTaGFkb3cgaXMgdW5kZWZpbmVkIHRoZW4gdGhlIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydFxuICAgIC8vIHRoZSBTaGFkb3cgRE9NLCB3ZSBuZWVkIHRvIHByZWZpeCBhbGwgdGhlIG5hbWVzIHNvIHRoZXJlXG4gICAgLy8gd2lsbCBiZSBubyBjb25mbGljdHNcbiAgICBzaGFkb3dSb290ID0gc2hhZG93SG9zdFxuICAgIHByZWZpeCA9ICdfX25leHQtcHJlcmVuZGVyLWluZGljYXRvci0nXG4gIH1cblxuICAvLyBDb250YWluZXJcbiAgY29uc3QgY29udGFpbmVyID0gY3JlYXRlQ29udGFpbmVyKHByZWZpeClcbiAgc2hhZG93Um9vdC5hcHBlbmRDaGlsZChjb250YWluZXIpXG5cbiAgLy8gQ1NTXG4gIGNvbnN0IGNzcyA9IGNyZWF0ZUNzcyhwcmVmaXgpXG4gIHNoYWRvd1Jvb3QuYXBwZW5kQ2hpbGQoY3NzKVxuXG4gIGNvbnN0IGV4cGFuZEVsID0gY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJ2EnKVxuICBjb25zdCBjbG9zZUVsID0gY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoYCMke3ByZWZpeH1jbG9zZWApXG5cbiAgLy8gU3RhdGVcbiAgY29uc3QgZGlzbWlzc0tleSA9ICdfX05FWFRfRElTTUlTU19QUkVSRU5ERVJfSU5ESUNBVE9SJ1xuICBjb25zdCBkaXNtaXNzVW50aWwgPSBwYXJzZUludCh3aW5kb3cubG9jYWxTdG9yYWdlLmdldEl0ZW0oZGlzbWlzc0tleSksIDEwKVxuICBjb25zdCBkaXNtaXNzZWQgPSBkaXNtaXNzVW50aWwgPiBuZXcgRGF0ZSgpLmdldFRpbWUoKVxuXG4gIGxldCBpc1Zpc2libGUgPSAhZGlzbWlzc2VkICYmIHdpbmRvdy5fX05FWFRfREFUQV9fLm5leHRFeHBvcnRcblxuICBmdW5jdGlvbiB1cGRhdGVDb250YWluZXIoKSB7XG4gICAgaWYgKGlzVmlzaWJsZSkge1xuICAgICAgY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoYCR7cHJlZml4fXZpc2libGVgKVxuICAgIH0gZWxzZSB7XG4gICAgICBjb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZShgJHtwcmVmaXh9dmlzaWJsZWApXG4gICAgfVxuICB9XG4gIGNvbnN0IGV4cGFuZGVkQ2xhc3MgPSBgJHtwcmVmaXh9ZXhwYW5kZWRgXG4gIGxldCB0b2dnbGVUaW1lb3V0XG5cbiAgY29uc3QgdG9nZ2xlRXhwYW5kID0gKGV4cGFuZCA9IHRydWUpID0+IHtcbiAgICBjbGVhclRpbWVvdXQodG9nZ2xlVGltZW91dClcblxuICAgIHRvZ2dsZVRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmIChleHBhbmQpIHtcbiAgICAgICAgZXhwYW5kRWwuY2xhc3NMaXN0LmFkZChleHBhbmRlZENsYXNzKVxuICAgICAgICBjbG9zZUVsLnN0eWxlLmRpc3BsYXkgPSAnZmxleCdcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV4cGFuZEVsLmNsYXNzTGlzdC5yZW1vdmUoZXhwYW5kZWRDbGFzcylcbiAgICAgICAgY2xvc2VFbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnXG4gICAgICB9XG4gICAgfSwgNTApXG4gIH1cblxuICBjbG9zZUVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgIGNvbnN0IG9uZUhvdXJBd2F5ID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgKyAxICogNjAgKiA2MCAqIDEwMDBcbiAgICB3aW5kb3cubG9jYWxTdG9yYWdlLnNldEl0ZW0oZGlzbWlzc0tleSwgb25lSG91ckF3YXkgKyAnJylcbiAgICBpc1Zpc2libGUgPSBmYWxzZVxuICAgIHVwZGF0ZUNvbnRhaW5lcigpXG4gIH0pXG4gIGNsb3NlRWwuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VlbnRlcicsICgpID0+IHRvZ2dsZUV4cGFuZCgpKVxuICBjbG9zZUVsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCAoKSA9PiB0b2dnbGVFeHBhbmQoZmFsc2UpKVxuICBleHBhbmRFbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgKCkgPT4gdG9nZ2xlRXhwYW5kKCkpXG4gIGV4cGFuZEVsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCAoKSA9PiB0b2dnbGVFeHBhbmQoZmFsc2UpKVxuXG4gIFJvdXRlci5ldmVudHMub24oJ3JvdXRlQ2hhbmdlQ29tcGxldGUnLCAoKSA9PiB7XG4gICAgaXNWaXNpYmxlID0gd2luZG93Lm5leHQuaXNQcmVyZW5kZXJlZFxuICAgIHVwZGF0ZUNvbnRhaW5lcigpXG4gIH0pXG4gIHVwZGF0ZUNvbnRhaW5lcigpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbnRhaW5lcihwcmVmaXgpIHtcbiAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgY29udGFpbmVyLmlkID0gYCR7cHJlZml4fWNvbnRhaW5lcmBcbiAgY29udGFpbmVyLmlubmVySFRNTCA9IGBcbiAgICA8YnV0dG9uIGlkPVwiJHtwcmVmaXh9Y2xvc2VcIiB0aXRsZT1cIkhpZGUgaW5kaWNhdG9yIGZvciBzZXNzaW9uXCI+XG4gICAgICA8c3Bhbj7Dlzwvc3Bhbj5cbiAgICA8L2J1dHRvbj5cbiAgICA8YSBocmVmPVwiaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MjYXV0b21hdGljLXN0YXRpYy1vcHRpbWl6YXRpb24taW5kaWNhdG9yXCIgdGFyZ2V0PVwiX2JsYW5rXCIgcmVsPVwibm9yZWZlcnJlclwiPlxuICAgICAgPGRpdiBpZD1cIiR7cHJlZml4fWljb24td3JhcHBlclwiPlxuICAgICAgICAgIDxzdmcgd2lkdGg9XCIxNVwiIGhlaWdodD1cIjIwXCIgdmlld0JveD1cIjAgMCA2MCA4MFwiIGZpbGw9XCJub25lXCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPlxuICAgICAgICAgIDxwYXRoIGQ9XCJNMzYgM0wzMC43NCA0MUg4TDM2IDNaXCIgZmlsbD1cImJsYWNrXCIvPlxuICAgICAgICAgIDxwYXRoIGQ9XCJNMjUgNzdMMzAuMjYgMzlINTNMMjUgNzdaXCIgZmlsbD1cImJsYWNrXCIvPlxuICAgICAgICAgIDxwYXRoIGQ9XCJNMTMuNSAzMy41TDUzIDM5TDQ3LjUgNDYuNUw3IDQxLjI1TDEzLjUgMzMuNVpcIiBmaWxsPVwiYmxhY2tcIi8+XG4gICAgICAgICAgPC9zdmc+XG4gICAgICAgICAgUHJlcmVuZGVyZWQgUGFnZVxuICAgICAgPC9kaXY+XG4gICAgPC9hPlxuICBgXG4gIHJldHVybiBjb250YWluZXJcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ3NzKHByZWZpeCkge1xuICBjb25zdCBjc3MgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpXG4gIGNzcy50ZXh0Q29udGVudCA9IGBcbiAgICAjJHtwcmVmaXh9Y29udGFpbmVyIHtcbiAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgIGRpc3BsYXk6IG5vbmU7XG4gICAgICBib3R0b206IDEwcHg7XG4gICAgICByaWdodDogMTVweDtcbiAgICB9XG5cbiAgICAjJHtwcmVmaXh9Y2xvc2Uge1xuICAgICAgdG9wOiAtMTBweDtcbiAgICAgIHJpZ2h0OiAtMTBweDtcbiAgICAgIGJvcmRlcjogbm9uZTtcbiAgICAgIHdpZHRoOiAxOHB4O1xuICAgICAgaGVpZ2h0OiAxOHB4O1xuICAgICAgY29sb3I6ICMzMzMzMzM7XG4gICAgICBmb250LXNpemU6IDE2cHg7XG4gICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgICBkaXNwbGF5OiBub25lO1xuICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgYmFja2dyb3VuZDogI2ZmZmZmZjtcbiAgICAgIGJvcmRlci1yYWRpdXM6IDEwMCU7XG4gICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgIH1cblxuICAgICMke3ByZWZpeH1jb250YWluZXIgYSB7XG4gICAgICBjb2xvcjogaW5oZXJpdDtcbiAgICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcbiAgICAgIHdpZHRoOiAxNXB4O1xuICAgICAgaGVpZ2h0OiAyM3B4O1xuICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcblxuICAgICAgYm9yZGVyLXJhZGl1czogM3B4O1xuICAgICAgYmFja2dyb3VuZDogI2ZmZjtcbiAgICAgIGNvbG9yOiAjMDAwO1xuICAgICAgZm9udDogaW5pdGlhbDtcbiAgICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICAgIGxldHRlci1zcGFjaW5nOiBpbml0aWFsO1xuICAgICAgdGV4dC1zaGFkb3c6IGluaXRpYWw7XG4gICAgICB0ZXh0LXRyYW5zZm9ybTogaW5pdGlhbDtcbiAgICAgIHZpc2liaWxpdHk6IGluaXRpYWw7XG4gICAgICBmb250LXNpemU6IDE0cHg7XG4gICAgICBmb250LWZhbWlseTogLWFwcGxlLXN5c3RlbSwgQmxpbmtNYWNTeXN0ZW1Gb250LCAnU2Vnb2UgVUknLCBSb2JvdG8sIE94eWdlbiwgVWJ1bnR1LCBDYW50YXJlbGwsICdPcGVuIFNhbnMnLCAnSGVsdmV0aWNhIE5ldWUnLCBzYW5zLXNlcmlmO1xuXG4gICAgICBwYWRkaW5nOiA0cHggMnB4O1xuICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgIGJveC1zaGFkb3c6IDAgMTFweCA0MHB4IDAgcmdiYSgwLCAwLCAwLCAwLjI1KSwgMCAycHggMTBweCAwIHJnYmEoMCwgMCwgMCwgMC4xMik7XG5cbiAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICB0cmFuc2l0aW9uOiBvcGFjaXR5IDAuMXMgZWFzZSwgYm90dG9tIDAuMXMgZWFzZSwgd2lkdGggMC4zcyBlYXNlO1xuICAgICAgYW5pbWF0aW9uOiAke3ByZWZpeH1mYWRlLWluIDAuMXMgZWFzZS1pbi1vdXQ7XG4gICAgfVxuXG4gICAgIyR7cHJlZml4fWljb24td3JhcHBlciB7XG4gICAgICB3aWR0aDogMTQwcHg7XG4gICAgICBoZWlnaHQ6IDIwcHg7XG4gICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgZmxleC1zaHJpbms6IDA7XG4gICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgIH1cblxuICAgICMke3ByZWZpeH1pY29uLXdyYXBwZXIgc3ZnIHtcbiAgICAgIGZsZXgtc2hyaW5rOiAwO1xuICAgICAgbWFyZ2luLXJpZ2h0OiAzcHg7XG4gICAgfVxuXG4gICAgIyR7cHJlZml4fWNvbnRhaW5lciBhLiR7cHJlZml4fWV4cGFuZGVkIHtcbiAgICAgIHdpZHRoOiAxMzVweDtcbiAgICB9XG5cbiAgICAjJHtwcmVmaXh9Y29udGFpbmVyLiR7cHJlZml4fXZpc2libGUge1xuICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgIGJvdHRvbTogMTBweDtcbiAgICAgIG9wYWNpdHk6IDE7XG4gICAgfVxuXG4gICAgQGtleWZyYW1lcyAke3ByZWZpeH1mYWRlLWluIHtcbiAgICAgIGZyb20ge1xuICAgICAgICBib3R0b206IDBweDtcbiAgICAgICAgb3BhY2l0eTogMDtcbiAgICAgIH1cbiAgICAgIHRvIHtcbiAgICAgICAgYm90dG9tOiAxMHB4O1xuICAgICAgICBvcGFjaXR5OiAxO1xuICAgICAgfVxuICAgIH1cbiAgYFxuXG4gIHJldHVybiBjc3Ncbn1cbiIsImltcG9ydCBjb25uZWN0IGZyb20gJy4vZXJyb3Itb3ZlcmxheS9ob3QtZGV2LWNsaWVudCdcblxuZXhwb3J0IGRlZmF1bHQgKHsgYXNzZXRQcmVmaXggfSkgPT4ge1xuICBjb25zdCBvcHRpb25zID0ge1xuICAgIHBhdGg6IGAke2Fzc2V0UHJlZml4fS9fbmV4dC93ZWJwYWNrLWhtcmAsXG4gIH1cblxuICBjb25zdCBkZXZDbGllbnQgPSBjb25uZWN0KG9wdGlvbnMpXG5cbiAgZGV2Q2xpZW50LnN1YnNjcmliZVRvSG1yRXZlbnQoKG9iaikgPT4ge1xuICAgIGlmIChvYmouYWN0aW9uID09PSAncmVsb2FkUGFnZScpIHtcbiAgICAgIHJldHVybiB3aW5kb3cubG9jYXRpb24ucmVsb2FkKClcbiAgICB9XG4gICAgaWYgKG9iai5hY3Rpb24gPT09ICdyZW1vdmVkUGFnZScpIHtcbiAgICAgIGNvbnN0IFtwYWdlXSA9IG9iai5kYXRhXG4gICAgICBpZiAocGFnZSA9PT0gd2luZG93Lm5leHQucm91dGVyLnBhdGhuYW1lKSB7XG4gICAgICAgIHJldHVybiB3aW5kb3cubG9jYXRpb24ucmVsb2FkKClcbiAgICAgIH1cbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBpZiAob2JqLmFjdGlvbiA9PT0gJ2FkZGVkUGFnZScpIHtcbiAgICAgIGNvbnN0IFtwYWdlXSA9IG9iai5kYXRhXG4gICAgICBpZiAoXG4gICAgICAgIHBhZ2UgPT09IHdpbmRvdy5uZXh0LnJvdXRlci5wYXRobmFtZSAmJlxuICAgICAgICB0eXBlb2Ygd2luZG93Lm5leHQucm91dGVyLmNvbXBvbmVudHNbcGFnZV0gPT09ICd1bmRlZmluZWQnXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKVxuICAgICAgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBhY3Rpb24gJyArIG9iai5hY3Rpb24pXG4gIH0pXG5cbiAgcmV0dXJuIGRldkNsaWVudFxufVxuIiwiY29uc3QgRE9NQXR0cmlidXRlTmFtZXMgPSB7XG4gIGFjY2VwdENoYXJzZXQ6ICdhY2NlcHQtY2hhcnNldCcsXG4gIGNsYXNzTmFtZTogJ2NsYXNzJyxcbiAgaHRtbEZvcjogJ2ZvcicsXG4gIGh0dHBFcXVpdjogJ2h0dHAtZXF1aXYnLFxufVxuXG5mdW5jdGlvbiByZWFjdEVsZW1lbnRUb0RPTSh7IHR5cGUsIHByb3BzIH0pIHtcbiAgY29uc3QgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHR5cGUpXG4gIGZvciAoY29uc3QgcCBpbiBwcm9wcykge1xuICAgIGlmICghcHJvcHMuaGFzT3duUHJvcGVydHkocCkpIGNvbnRpbnVlXG4gICAgaWYgKHAgPT09ICdjaGlsZHJlbicgfHwgcCA9PT0gJ2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MJykgY29udGludWVcblxuICAgIC8vIHdlIGRvbid0IHJlbmRlciB1bmRlZmluZWQgcHJvcHMgdG8gdGhlIERPTVxuICAgIGlmIChwcm9wc1twXSA9PT0gdW5kZWZpbmVkKSBjb250aW51ZVxuXG4gICAgY29uc3QgYXR0ciA9IERPTUF0dHJpYnV0ZU5hbWVzW3BdIHx8IHAudG9Mb3dlckNhc2UoKVxuICAgIGVsLnNldEF0dHJpYnV0ZShhdHRyLCBwcm9wc1twXSlcbiAgfVxuXG4gIGNvbnN0IHsgY2hpbGRyZW4sIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MIH0gPSBwcm9wc1xuICBpZiAoZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwpIHtcbiAgICBlbC5pbm5lckhUTUwgPSBkYW5nZXJvdXNseVNldElubmVySFRNTC5fX2h0bWwgfHwgJydcbiAgfSBlbHNlIGlmIChjaGlsZHJlbikge1xuICAgIGVsLnRleHRDb250ZW50ID0gdHlwZW9mIGNoaWxkcmVuID09PSAnc3RyaW5nJyA/IGNoaWxkcmVuIDogY2hpbGRyZW4uam9pbignJylcbiAgfVxuICByZXR1cm4gZWxcbn1cblxuZnVuY3Rpb24gdXBkYXRlRWxlbWVudHModHlwZSwgY29tcG9uZW50cykge1xuICBjb25zdCBoZWFkRWwgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdXG4gIGNvbnN0IGhlYWRDb3VudEVsID0gaGVhZEVsLnF1ZXJ5U2VsZWN0b3IoJ21ldGFbbmFtZT1uZXh0LWhlYWQtY291bnRdJylcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoIWhlYWRDb3VudEVsKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAnV2FybmluZzogbmV4dC1oZWFkLWNvdW50IGlzIG1pc3NpbmcuIGh0dHBzOi8vZXJyLnNoL25leHQuanMvbmV4dC1oZWFkLWNvdW50LW1pc3NpbmcnXG4gICAgICApXG4gICAgICByZXR1cm5cbiAgICB9XG4gIH1cblxuICBjb25zdCBoZWFkQ291bnQgPSBOdW1iZXIoaGVhZENvdW50RWwuY29udGVudClcbiAgY29uc3Qgb2xkVGFncyA9IFtdXG5cbiAgZm9yIChcbiAgICBsZXQgaSA9IDAsIGogPSBoZWFkQ291bnRFbC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nO1xuICAgIGkgPCBoZWFkQ291bnQ7XG4gICAgaSsrLCBqID0gai5wcmV2aW91c0VsZW1lbnRTaWJsaW5nXG4gICkge1xuICAgIGlmIChqLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gdHlwZSkge1xuICAgICAgb2xkVGFncy5wdXNoKGopXG4gICAgfVxuICB9XG4gIGNvbnN0IG5ld1RhZ3MgPSBjb21wb25lbnRzLm1hcChyZWFjdEVsZW1lbnRUb0RPTSkuZmlsdGVyKChuZXdUYWcpID0+IHtcbiAgICBmb3IgKGxldCBrID0gMCwgbGVuID0gb2xkVGFncy5sZW5ndGg7IGsgPCBsZW47IGsrKykge1xuICAgICAgY29uc3Qgb2xkVGFnID0gb2xkVGFnc1trXVxuICAgICAgaWYgKG9sZFRhZy5pc0VxdWFsTm9kZShuZXdUYWcpKSB7XG4gICAgICAgIG9sZFRhZ3Muc3BsaWNlKGssIDEpXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9KVxuXG4gIG9sZFRhZ3MuZm9yRWFjaCgodCkgPT4gdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHQpKVxuICBuZXdUYWdzLmZvckVhY2goKHQpID0+IGhlYWRFbC5pbnNlcnRCZWZvcmUodCwgaGVhZENvdW50RWwpKVxuICBoZWFkQ291bnRFbC5jb250ZW50ID0gKGhlYWRDb3VudCAtIG9sZFRhZ3MubGVuZ3RoICsgbmV3VGFncy5sZW5ndGgpLnRvU3RyaW5nKClcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaW5pdEhlYWRNYW5hZ2VyKCkge1xuICBsZXQgdXBkYXRlUHJvbWlzZSA9IG51bGxcblxuICByZXR1cm4gKGhlYWQpID0+IHtcbiAgICBjb25zdCBwcm9taXNlID0gKHVwZGF0ZVByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICAgIGlmIChwcm9taXNlICE9PSB1cGRhdGVQcm9taXNlKSByZXR1cm5cblxuICAgICAgdXBkYXRlUHJvbWlzZSA9IG51bGxcbiAgICAgIGNvbnN0IHRhZ3MgPSB7fVxuXG4gICAgICBoZWFkLmZvckVhY2goKGgpID0+IHtcbiAgICAgICAgY29uc3QgY29tcG9uZW50cyA9IHRhZ3NbaC50eXBlXSB8fCBbXVxuICAgICAgICBjb21wb25lbnRzLnB1c2goaClcbiAgICAgICAgdGFnc1toLnR5cGVdID0gY29tcG9uZW50c1xuICAgICAgfSlcblxuICAgICAgY29uc3QgdGl0bGVDb21wb25lbnQgPSB0YWdzLnRpdGxlID8gdGFncy50aXRsZVswXSA6IG51bGxcbiAgICAgIGxldCB0aXRsZSA9ICcnXG4gICAgICBpZiAodGl0bGVDb21wb25lbnQpIHtcbiAgICAgICAgY29uc3QgeyBjaGlsZHJlbiB9ID0gdGl0bGVDb21wb25lbnQucHJvcHNcbiAgICAgICAgdGl0bGUgPSB0eXBlb2YgY2hpbGRyZW4gPT09ICdzdHJpbmcnID8gY2hpbGRyZW4gOiBjaGlsZHJlbi5qb2luKCcnKVxuICAgICAgfVxuICAgICAgaWYgKHRpdGxlICE9PSBkb2N1bWVudC50aXRsZSkgZG9jdW1lbnQudGl0bGUgPSB0aXRsZVxuICAgICAgO1snbWV0YScsICdiYXNlJywgJ2xpbmsnLCAnc3R5bGUnLCAnc2NyaXB0J10uZm9yRWFjaCgodHlwZSkgPT4ge1xuICAgICAgICB1cGRhdGVFbGVtZW50cyh0eXBlLCB0YWdzW3R5cGVdIHx8IFtdKVxuICAgICAgfSlcbiAgICB9KSlcbiAgfVxufVxuIiwiLyogZ2xvYmFsIGxvY2F0aW9uICovXG5pbXBvcnQgeyBjcmVhdGVSb3V0ZXIsIG1ha2VQdWJsaWNSb3V0ZXJJbnN0YW5jZSB9IGZyb20gJ25leHQvcm91dGVyJ1xuaW1wb3J0IHsgcGFyc2UgYXMgcGFyc2VRcywgc3RyaW5naWZ5IGFzIHN0cmluZ2lmeVFzIH0gZnJvbSAncXVlcnlzdHJpbmcnXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5pbXBvcnQgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJ1xuaW1wb3J0IHsgSGVhZE1hbmFnZXJDb250ZXh0IH0gZnJvbSAnLi4vbmV4dC1zZXJ2ZXIvbGliL2hlYWQtbWFuYWdlci1jb250ZXh0J1xuaW1wb3J0IG1pdHQgZnJvbSAnLi4vbmV4dC1zZXJ2ZXIvbGliL21pdHQnXG5pbXBvcnQgeyBSb3V0ZXJDb250ZXh0IH0gZnJvbSAnLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci1jb250ZXh0J1xuaW1wb3J0IHsgaXNEeW5hbWljUm91dGUgfSBmcm9tICcuLi9uZXh0LXNlcnZlci9saWIvcm91dGVyL3V0aWxzL2lzLWR5bmFtaWMnXG5pbXBvcnQgKiBhcyBlbnZDb25maWcgZnJvbSAnLi4vbmV4dC1zZXJ2ZXIvbGliL3J1bnRpbWUtY29uZmlnJ1xuaW1wb3J0IHsgZ2V0VVJMLCBsb2FkR2V0SW5pdGlhbFByb3BzLCBTVCB9IGZyb20gJy4uL25leHQtc2VydmVyL2xpYi91dGlscydcbmltcG9ydCBpbml0SGVhZE1hbmFnZXIgZnJvbSAnLi9oZWFkLW1hbmFnZXInXG5pbXBvcnQgUGFnZUxvYWRlciBmcm9tICcuL3BhZ2UtbG9hZGVyJ1xuaW1wb3J0IG1lYXN1cmVXZWJWaXRhbHMgZnJvbSAnLi9wZXJmb3JtYW5jZS1yZWxheWVyJ1xuXG4vLy8gPHJlZmVyZW5jZSB0eXBlcz1cInJlYWN0LWRvbS9leHBlcmltZW50YWxcIiAvPlxuXG5pZiAoISgnZmluYWxseScgaW4gUHJvbWlzZS5wcm90b3R5cGUpKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1leHRlbmQtbmF0aXZlXG4gIFByb21pc2UucHJvdG90eXBlLmZpbmFsbHkgPSByZXF1aXJlKCduZXh0L2Rpc3QvYnVpbGQvcG9seWZpbGxzL2ZpbmFsbHktcG9seWZpbGwubWluJylcbn1cblxuY29uc3QgZGF0YSA9IEpTT04ucGFyc2UoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ19fTkVYVF9EQVRBX18nKS50ZXh0Q29udGVudClcbndpbmRvdy5fX05FWFRfREFUQV9fID0gZGF0YVxuXG5leHBvcnQgY29uc3QgdmVyc2lvbiA9IHByb2Nlc3MuZW52Ll9fTkVYVF9WRVJTSU9OXG5cbmNvbnN0IHtcbiAgcHJvcHMsXG4gIGVycixcbiAgcGFnZSxcbiAgcXVlcnksXG4gIGJ1aWxkSWQsXG4gIGFzc2V0UHJlZml4LFxuICBydW50aW1lQ29uZmlnLFxuICBkeW5hbWljSWRzLFxuICBpc0ZhbGxiYWNrLFxufSA9IGRhdGFcblxuY29uc3QgcHJlZml4ID0gYXNzZXRQcmVmaXggfHwgJydcblxuLy8gV2l0aCBkeW5hbWljIGFzc2V0UHJlZml4IGl0J3Mgbm8gbG9uZ2VyIHBvc3NpYmxlIHRvIHNldCBhc3NldFByZWZpeCBhdCB0aGUgYnVpbGQgdGltZVxuLy8gU28sIHRoaXMgaXMgaG93IHdlIGRvIGl0IGluIHRoZSBjbGllbnQgc2lkZSBhdCBydW50aW1lXG5fX3dlYnBhY2tfcHVibGljX3BhdGhfXyA9IGAke3ByZWZpeH0vX25leHQvYCAvL2VzbGludC1kaXNhYmxlLWxpbmVcbi8vIEluaXRpYWxpemUgbmV4dC9jb25maWcgd2l0aCB0aGUgZW52aXJvbm1lbnQgY29uZmlndXJhdGlvblxuZW52Q29uZmlnLnNldENvbmZpZyh7XG4gIHNlcnZlclJ1bnRpbWVDb25maWc6IHt9LFxuICBwdWJsaWNSdW50aW1lQ29uZmlnOiBydW50aW1lQ29uZmlnIHx8IHt9LFxufSlcblxuY29uc3QgYXNQYXRoID0gZ2V0VVJMKClcblxuY29uc3QgcGFnZUxvYWRlciA9IG5ldyBQYWdlTG9hZGVyKGJ1aWxkSWQsIHByZWZpeClcbmNvbnN0IHJlZ2lzdGVyID0gKFtyLCBmXSkgPT4gcGFnZUxvYWRlci5yZWdpc3RlclBhZ2UociwgZilcbmlmICh3aW5kb3cuX19ORVhUX1ApIHtcbiAgLy8gRGVmZXIgcGFnZSByZWdpc3RyYXRpb24gZm9yIGFub3RoZXIgdGljay4gVGhpcyB3aWxsIGluY3JlYXNlIHRoZSBvdmVyYWxsXG4gIC8vIGxhdGVuY3kgaW4gaHlkcmF0aW5nIHRoZSBwYWdlLCBidXQgcmVkdWNlIHRoZSB0b3RhbCBibG9ja2luZyB0aW1lLlxuICB3aW5kb3cuX19ORVhUX1AubWFwKChwKSA9PiBzZXRUaW1lb3V0KCgpID0+IHJlZ2lzdGVyKHApLCAwKSlcbn1cbndpbmRvdy5fX05FWFRfUCA9IFtdXG53aW5kb3cuX19ORVhUX1AucHVzaCA9IHJlZ2lzdGVyXG5cbmNvbnN0IHVwZGF0ZUhlYWQgPSBpbml0SGVhZE1hbmFnZXIoKVxuY29uc3QgYXBwRWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdfX25leHQnKVxuXG5sZXQgbGFzdEFwcFByb3BzXG5sZXQgbGFzdFJlbmRlclJlamVjdFxubGV0IHdlYnBhY2tITVJcbmV4cG9ydCBsZXQgcm91dGVyXG5sZXQgQ29tcG9uZW50XG5sZXQgQXBwLCBvblBlcmZFbnRyeVxuXG5jbGFzcyBDb250YWluZXIgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICBjb21wb25lbnREaWRDYXRjaChlcnIsIGluZm8pIHtcbiAgICB0aGlzLnByb3BzLmZuKGVyciwgaW5mbylcbiAgfVxuXG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIHRoaXMuc2Nyb2xsVG9IYXNoKClcblxuICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfUExVR0lOUykge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICBpbXBvcnQoJ25leHQtcGx1Z2luLWxvYWRlcj9taWRkbGV3YXJlPXVuc3RhYmxlLXBvc3QtaHlkcmF0aW9uIScpXG4gICAgICAgIC50aGVuKChtb2QpID0+IHtcbiAgICAgICAgICByZXR1cm4gbW9kLmRlZmF1bHQoKVxuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNhbGxpbmcgcG9zdC1oeWRyYXRpb24gZm9yIHBsdWdpbnMnLCBlcnIpXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gV2UgbmVlZCB0byByZXBsYWNlIHRoZSByb3V0ZXIgc3RhdGUgaWY6XG4gICAgLy8gLSB0aGUgcGFnZSB3YXMgKGF1dG8pIGV4cG9ydGVkIGFuZCBoYXMgYSBxdWVyeSBzdHJpbmcgb3Igc2VhcmNoIChoYXNoKVxuICAgIC8vIC0gaXQgd2FzIGF1dG8gZXhwb3J0ZWQgYW5kIGlzIGEgZHluYW1pYyByb3V0ZSAodG8gcHJvdmlkZSBwYXJhbXMpXG4gICAgLy8gLSBpZiBpdCBpcyBhIGNsaWVudC1zaWRlIHNrZWxldG9uIChmYWxsYmFjayByZW5kZXIpXG4gICAgaWYgKFxuICAgICAgcm91dGVyLmlzU3NyICYmXG4gICAgICAoaXNGYWxsYmFjayB8fFxuICAgICAgICAoZGF0YS5uZXh0RXhwb3J0ICYmXG4gICAgICAgICAgKGlzRHluYW1pY1JvdXRlKHJvdXRlci5wYXRobmFtZSkgfHwgbG9jYXRpb24uc2VhcmNoKSkgfHxcbiAgICAgICAgKHByb3BzICYmIHByb3BzLl9fTl9TU0cgJiYgbG9jYXRpb24uc2VhcmNoKSlcbiAgICApIHtcbiAgICAgIC8vIHVwZGF0ZSBxdWVyeSBvbiBtb3VudCBmb3IgZXhwb3J0ZWQgcGFnZXNcbiAgICAgIHJvdXRlci5yZXBsYWNlKFxuICAgICAgICByb3V0ZXIucGF0aG5hbWUgK1xuICAgICAgICAgICc/JyArXG4gICAgICAgICAgc3RyaW5naWZ5UXMoe1xuICAgICAgICAgICAgLi4ucm91dGVyLnF1ZXJ5LFxuICAgICAgICAgICAgLi4ucGFyc2VRcyhsb2NhdGlvbi5zZWFyY2guc3Vic3RyKDEpKSxcbiAgICAgICAgICB9KSxcbiAgICAgICAgYXNQYXRoLFxuICAgICAgICB7XG4gICAgICAgICAgLy8gV0FSTklORzogYF9oYCBpcyBhbiBpbnRlcm5hbCBvcHRpb24gZm9yIGhhbmRpbmcgTmV4dC5qc1xuICAgICAgICAgIC8vIGNsaWVudC1zaWRlIGh5ZHJhdGlvbi4gWW91ciBhcHAgc2hvdWxkIF9uZXZlcl8gdXNlIHRoaXMgcHJvcGVydHkuXG4gICAgICAgICAgLy8gSXQgbWF5IGNoYW5nZSBhdCBhbnkgdGltZSB3aXRob3V0IG5vdGljZS5cbiAgICAgICAgICBfaDogMSxcbiAgICAgICAgICAvLyBGYWxsYmFjayBwYWdlcyBtdXN0IHRyaWdnZXIgdGhlIGRhdGEgZmV0Y2gsIHNvIHRoZSB0cmFuc2l0aW9uIGlzXG4gICAgICAgICAgLy8gbm90IHNoYWxsb3cuXG4gICAgICAgICAgLy8gT3RoZXIgcGFnZXMgKHN0cmljdGx5IHVwZGF0aW5nIHF1ZXJ5KSBoYXBwZW5zIHNoYWxsb3dseSwgYXMgZGF0YVxuICAgICAgICAgIC8vIHJlcXVpcmVtZW50cyB3b3VsZCBhbHJlYWR5IGJlIHByZXNlbnQuXG4gICAgICAgICAgc2hhbGxvdzogIWlzRmFsbGJhY2ssXG4gICAgICAgIH1cbiAgICAgIClcbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX1RFU1RfTU9ERSkge1xuICAgICAgd2luZG93Ll9fTkVYVF9IWURSQVRFRCA9IHRydWVcblxuICAgICAgaWYgKHdpbmRvdy5fX05FWFRfSFlEUkFURURfQ0IpIHtcbiAgICAgICAgd2luZG93Ll9fTkVYVF9IWURSQVRFRF9DQigpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgIHRoaXMuc2Nyb2xsVG9IYXNoKClcbiAgfVxuXG4gIHNjcm9sbFRvSGFzaCgpIHtcbiAgICBsZXQgeyBoYXNoIH0gPSBsb2NhdGlvblxuICAgIGhhc2ggPSBoYXNoICYmIGhhc2guc3Vic3RyaW5nKDEpXG4gICAgaWYgKCFoYXNoKSByZXR1cm5cblxuICAgIGNvbnN0IGVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaGFzaClcbiAgICBpZiAoIWVsKSByZXR1cm5cblxuICAgIC8vIElmIHdlIGNhbGwgc2Nyb2xsSW50b1ZpZXcoKSBpbiBoZXJlIHdpdGhvdXQgYSBzZXRUaW1lb3V0XG4gICAgLy8gaXQgd29uJ3Qgc2Nyb2xsIHByb3Blcmx5LlxuICAgIHNldFRpbWVvdXQoKCkgPT4gZWwuc2Nyb2xsSW50b1ZpZXcoKSwgMClcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcmV0dXJuIHRoaXMucHJvcHMuY2hpbGRyZW5cbiAgICB9XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGNvbnN0IHsgUmVhY3REZXZPdmVybGF5IH0gPSByZXF1aXJlKCdAbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9saWIvY2xpZW50JylcbiAgICAgIHJldHVybiA8UmVhY3REZXZPdmVybGF5Pnt0aGlzLnByb3BzLmNoaWxkcmVufTwvUmVhY3REZXZPdmVybGF5PlxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgZW1pdHRlciA9IG1pdHQoKVxuXG5leHBvcnQgZGVmYXVsdCBhc3luYyAoeyB3ZWJwYWNrSE1SOiBwYXNzZWRXZWJwYWNrSE1SIH0gPSB7fSkgPT4ge1xuICAvLyBUaGlzIG1ha2VzIHN1cmUgdGhpcyBzcGVjaWZpYyBsaW5lcyBhcmUgcmVtb3ZlZCBpbiBwcm9kdWN0aW9uXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgIHdlYnBhY2tITVIgPSBwYXNzZWRXZWJwYWNrSE1SXG4gIH1cbiAgY29uc3QgeyBwYWdlOiBhcHAsIG1vZCB9ID0gYXdhaXQgcGFnZUxvYWRlci5sb2FkUGFnZVNjcmlwdCgnL19hcHAnKVxuICBBcHAgPSBhcHBcblxuICBpZiAobW9kICYmIG1vZC5yZXBvcnRXZWJWaXRhbHMpIHtcbiAgICBvblBlcmZFbnRyeSA9ICh7XG4gICAgICBpZCxcbiAgICAgIG5hbWUsXG4gICAgICBzdGFydFRpbWUsXG4gICAgICB2YWx1ZSxcbiAgICAgIGR1cmF0aW9uLFxuICAgICAgZW50cnlUeXBlLFxuICAgICAgZW50cmllcyxcbiAgICB9KSA9PiB7XG4gICAgICAvLyBDb21iaW5lcyB0aW1lc3RhbXAgd2l0aCByYW5kb20gbnVtYmVyIGZvciB1bmlxdWUgSURcbiAgICAgIGNvbnN0IHVuaXF1ZUlEID0gYCR7RGF0ZS5ub3coKX0tJHtcbiAgICAgICAgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKDllMTIgLSAxKSkgKyAxZTEyXG4gICAgICB9YFxuICAgICAgbGV0IHBlcmZTdGFydEVudHJ5XG5cbiAgICAgIGlmIChlbnRyaWVzICYmIGVudHJpZXMubGVuZ3RoKSB7XG4gICAgICAgIHBlcmZTdGFydEVudHJ5ID0gZW50cmllc1swXS5zdGFydFRpbWVcbiAgICAgIH1cblxuICAgICAgbW9kLnJlcG9ydFdlYlZpdGFscyh7XG4gICAgICAgIGlkOiBpZCB8fCB1bmlxdWVJRCxcbiAgICAgICAgbmFtZSxcbiAgICAgICAgc3RhcnRUaW1lOiBzdGFydFRpbWUgfHwgcGVyZlN0YXJ0RW50cnksXG4gICAgICAgIHZhbHVlOiB2YWx1ZSA9PSBudWxsID8gZHVyYXRpb24gOiB2YWx1ZSxcbiAgICAgICAgbGFiZWw6XG4gICAgICAgICAgZW50cnlUeXBlID09PSAnbWFyaycgfHwgZW50cnlUeXBlID09PSAnbWVhc3VyZSdcbiAgICAgICAgICAgID8gJ2N1c3RvbSdcbiAgICAgICAgICAgIDogJ3dlYi12aXRhbCcsXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIGxldCBpbml0aWFsRXJyID0gZXJyXG5cbiAgdHJ5IHtcbiAgICA7KHsgcGFnZTogQ29tcG9uZW50IH0gPSBhd2FpdCBwYWdlTG9hZGVyLmxvYWRQYWdlKHBhZ2UpKVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGNvbnN0IHsgaXNWYWxpZEVsZW1lbnRUeXBlIH0gPSByZXF1aXJlKCdyZWFjdC1pcycpXG4gICAgICBpZiAoIWlzVmFsaWRFbGVtZW50VHlwZShDb21wb25lbnQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgVGhlIGRlZmF1bHQgZXhwb3J0IGlzIG5vdCBhIFJlYWN0IENvbXBvbmVudCBpbiBwYWdlOiBcIiR7cGFnZX1cImBcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAvLyBUaGlzIGNhdGNoZXMgZXJyb3JzIGxpa2UgdGhyb3dpbmcgaW4gdGhlIHRvcCBsZXZlbCBvZiBhIG1vZHVsZVxuICAgIGluaXRpYWxFcnIgPSBlcnJvclxuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgY29uc3QgeyBnZXROb2RlRXJyb3IgfSA9IHJlcXVpcmUoJ0BuZXh0L3JlYWN0LWRldi1vdmVybGF5L2xpYi9jbGllbnQnKVxuICAgIC8vIFNlcnZlci1zaWRlIHJ1bnRpbWUgZXJyb3JzIG5lZWQgdG8gYmUgcmUtdGhyb3duIG9uIHRoZSBjbGllbnQtc2lkZSBzb1xuICAgIC8vIHRoYXQgdGhlIG92ZXJsYXkgaXMgcmVuZGVyZWQuXG4gICAgaWYgKGluaXRpYWxFcnIpIHtcbiAgICAgIGlmIChpbml0aWFsRXJyID09PSBlcnIpIHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgbGV0IGVycm9yXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIEdlbmVyYXRlIGEgbmV3IGVycm9yIG9iamVjdC4gV2UgYHRocm93YCBpdCBiZWNhdXNlIHNvbWUgYnJvd3NlcnNcbiAgICAgICAgICAgIC8vIHdpbGwgc2V0IHRoZSBgc3RhY2tgIHdoZW4gdGhyb3duLCBhbmQgd2Ugd2FudCB0byBlbnN1cmUgb3VycyBpc1xuICAgICAgICAgICAgLy8gbm90IG92ZXJyaWRkZW4gd2hlbiB3ZSByZS10aHJvdyBpdCBiZWxvdy5cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihpbml0aWFsRXJyLm1lc3NhZ2UpXG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgZXJyb3IgPSBlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXJyb3IubmFtZSA9IGluaXRpYWxFcnIubmFtZVxuICAgICAgICAgIGVycm9yLnN0YWNrID0gaW5pdGlhbEVyci5zdGFja1xuXG4gICAgICAgICAgY29uc3Qgbm9kZSA9IGdldE5vZGVFcnJvcihlcnJvcilcbiAgICAgICAgICB0aHJvdyBub2RlXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgICAvLyBXZSByZXBsYWNlZCB0aGUgc2VydmVyLXNpZGUgZXJyb3Igd2l0aCBhIGNsaWVudC1zaWRlIGVycm9yLCBhbmQgc2hvdWxkXG4gICAgICAvLyBubyBsb25nZXIgcmV3cml0ZSB0aGUgc3RhY2sgdHJhY2UgdG8gYSBOb2RlIGVycm9yLlxuICAgICAgZWxzZSB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHRocm93IGluaXRpYWxFcnJcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAod2luZG93Ll9fTkVYVF9QUkVMT0FEUkVBRFkpIHtcbiAgICBhd2FpdCB3aW5kb3cuX19ORVhUX1BSRUxPQURSRUFEWShkeW5hbWljSWRzKVxuICB9XG5cbiAgcm91dGVyID0gY3JlYXRlUm91dGVyKHBhZ2UsIHF1ZXJ5LCBhc1BhdGgsIHtcbiAgICBpbml0aWFsUHJvcHM6IHByb3BzLFxuICAgIHBhZ2VMb2FkZXIsXG4gICAgQXBwLFxuICAgIENvbXBvbmVudCxcbiAgICB3cmFwQXBwLFxuICAgIGVycjogaW5pdGlhbEVycixcbiAgICBpc0ZhbGxiYWNrLFxuICAgIHN1YnNjcmlwdGlvbjogKHsgQ29tcG9uZW50LCBwcm9wcywgZXJyIH0sIEFwcCkgPT5cbiAgICAgIHJlbmRlcih7IEFwcCwgQ29tcG9uZW50LCBwcm9wcywgZXJyIH0pLFxuICB9KVxuXG4gIC8vIGNhbGwgaW5pdC1jbGllbnQgbWlkZGxld2FyZVxuICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX1BMVUdJTlMpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICBpbXBvcnQoJ25leHQtcGx1Z2luLWxvYWRlcj9taWRkbGV3YXJlPW9uLWluaXQtY2xpZW50IScpXG4gICAgICAudGhlbigobW9kKSA9PiB7XG4gICAgICAgIHJldHVybiBtb2QuZGVmYXVsdCh7IHJvdXRlciB9KVxuICAgICAgfSlcbiAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNhbGxpbmcgY2xpZW50LWluaXQgZm9yIHBsdWdpbnMnLCBlcnIpXG4gICAgICB9KVxuICB9XG5cbiAgY29uc3QgcmVuZGVyQ3R4ID0geyBBcHAsIENvbXBvbmVudCwgcHJvcHMsIGVycjogaW5pdGlhbEVyciB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgICByZW5kZXIocmVuZGVyQ3R4KVxuICAgIHJldHVybiBlbWl0dGVyXG4gIH1cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHJldHVybiB7IGVtaXR0ZXIsIHJlbmRlciwgcmVuZGVyQ3R4IH1cbiAgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVuZGVyKHByb3BzKSB7XG4gIGlmIChwcm9wcy5lcnIpIHtcbiAgICBhd2FpdCByZW5kZXJFcnJvcihwcm9wcylcbiAgICByZXR1cm5cbiAgfVxuXG4gIHRyeSB7XG4gICAgYXdhaXQgZG9SZW5kZXIocHJvcHMpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgLy8gRW5zdXJlIHRoaXMgZXJyb3IgaXMgZGlzcGxheWVkIGluIHRoZSBvdmVybGF5IGluIGRldmVsb3BtZW50XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhyb3cgZXJyXG4gICAgICB9KVxuICAgIH1cbiAgICBhd2FpdCByZW5kZXJFcnJvcih7IC4uLnByb3BzLCBlcnIgfSlcbiAgfVxufVxuXG4vLyBUaGlzIG1ldGhvZCBoYW5kbGVzIGFsbCBydW50aW1lIGFuZCBkZWJ1ZyBlcnJvcnMuXG4vLyA0MDQgYW5kIDUwMCBlcnJvcnMgYXJlIHNwZWNpYWwga2luZCBvZiBlcnJvcnNcbi8vIGFuZCB0aGV5IGFyZSBzdGlsbCBoYW5kbGUgdmlhIHRoZSBtYWluIHJlbmRlciBtZXRob2QuXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyRXJyb3IocHJvcHMpIHtcbiAgY29uc3QgeyBBcHAsIGVyciB9ID0gcHJvcHNcblxuICAvLyBJbiBkZXZlbG9wbWVudCBydW50aW1lIGVycm9ycyBhcmUgY2F1Z2h0IGJ5IG91ciBvdmVybGF5XG4gIC8vIEluIHByb2R1Y3Rpb24gd2UgY2F0Y2ggcnVudGltZSBlcnJvcnMgdXNpbmcgY29tcG9uZW50RGlkQ2F0Y2ggd2hpY2ggd2lsbCB0cmlnZ2VyIHJlbmRlckVycm9yXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgLy8gQSBOZXh0LmpzIHJlbmRlcmluZyBydW50aW1lIGVycm9yIGlzIGFsd2F5cyB1bnJlY292ZXJhYmxlXG4gICAgLy8gRklYTUU6IGxldCdzIG1ha2UgdGhpcyByZWNvdmVyYWJsZSAoZXJyb3IgaW4gR0lQIGNsaWVudC10cmFuc2l0aW9uKVxuICAgIHdlYnBhY2tITVIub25VbnJlY292ZXJhYmxlRXJyb3IoKVxuXG4gICAgLy8gV2UgbmVlZCB0byByZW5kZXIgYW4gZW1wdHkgPEFwcD4gc28gdGhhdCB0aGUgYDxSZWFjdERldk92ZXJsYXk+YCBjYW5cbiAgICAvLyByZW5kZXIgaXRzZWxmLlxuICAgIHJldHVybiBkb1JlbmRlcih7XG4gICAgICBBcHA6ICgpID0+IG51bGwsXG4gICAgICBwcm9wczoge30sXG4gICAgICBDb21wb25lbnQ6ICgpID0+IG51bGwsXG4gICAgICBlcnI6IG51bGwsXG4gICAgfSlcbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX1BMVUdJTlMpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICBpbXBvcnQoJ25leHQtcGx1Z2luLWxvYWRlcj9taWRkbGV3YXJlPW9uLWVycm9yLWNsaWVudCEnKVxuICAgICAgLnRoZW4oKG1vZCkgPT4ge1xuICAgICAgICByZXR1cm4gbW9kLmRlZmF1bHQoeyBlcnIgfSlcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdlcnJvciBjYWxsaW5nIG9uLWVycm9yLWNsaWVudCBmb3IgcGx1Z2lucycsIGVycilcbiAgICAgIH0pXG4gIH1cblxuICAvLyBNYWtlIHN1cmUgd2UgbG9nIHRoZSBlcnJvciB0byB0aGUgY29uc29sZSwgb3RoZXJ3aXNlIHVzZXJzIGNhbid0IHRyYWNrIGRvd24gaXNzdWVzLlxuICBjb25zb2xlLmVycm9yKGVycilcbiAgcmV0dXJuIHBhZ2VMb2FkZXIubG9hZFBhZ2UoJy9fZXJyb3InKS50aGVuKCh7IHBhZ2U6IEVycm9yQ29tcG9uZW50IH0pID0+IHtcbiAgICAvLyBJbiBwcm9kdWN0aW9uIHdlIGRvIGEgbm9ybWFsIHJlbmRlciB3aXRoIHRoZSBgRXJyb3JDb21wb25lbnRgIGFzIGNvbXBvbmVudC5cbiAgICAvLyBJZiB3ZSd2ZSBnb3R0ZW4gaGVyZSB1cG9uIGluaXRpYWwgcmVuZGVyLCB3ZSBjYW4gdXNlIHRoZSBwcm9wcyBmcm9tIHRoZSBzZXJ2ZXIuXG4gICAgLy8gT3RoZXJ3aXNlLCB3ZSBuZWVkIHRvIGNhbGwgYGdldEluaXRpYWxQcm9wc2Agb24gYEFwcGAgYmVmb3JlIG1vdW50aW5nLlxuICAgIGNvbnN0IEFwcFRyZWUgPSB3cmFwQXBwKEFwcClcbiAgICBjb25zdCBhcHBDdHggPSB7XG4gICAgICBDb21wb25lbnQ6IEVycm9yQ29tcG9uZW50LFxuICAgICAgQXBwVHJlZSxcbiAgICAgIHJvdXRlcixcbiAgICAgIGN0eDogeyBlcnIsIHBhdGhuYW1lOiBwYWdlLCBxdWVyeSwgYXNQYXRoLCBBcHBUcmVlIH0sXG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoXG4gICAgICBwcm9wcy5wcm9wcyA/IHByb3BzLnByb3BzIDogbG9hZEdldEluaXRpYWxQcm9wcyhBcHAsIGFwcEN0eClcbiAgICApLnRoZW4oKGluaXRQcm9wcykgPT5cbiAgICAgIGRvUmVuZGVyKHtcbiAgICAgICAgLi4ucHJvcHMsXG4gICAgICAgIGVycixcbiAgICAgICAgQ29tcG9uZW50OiBFcnJvckNvbXBvbmVudCxcbiAgICAgICAgcHJvcHM6IGluaXRQcm9wcyxcbiAgICAgIH0pXG4gICAgKVxuICB9KVxufVxuXG4vLyBJZiBoeWRyYXRlIGRvZXMgbm90IGV4aXN0LCBlZyBpbiBwcmVhY3QuXG5sZXQgaXNJbml0aWFsUmVuZGVyID0gdHlwZW9mIFJlYWN0RE9NLmh5ZHJhdGUgPT09ICdmdW5jdGlvbidcbmxldCByZWFjdFJvb3QgPSBudWxsXG5mdW5jdGlvbiByZW5kZXJSZWFjdEVsZW1lbnQocmVhY3RFbCwgZG9tRWwpIHtcbiAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9SRUFDVF9NT0RFICE9PSAnbGVnYWN5Jykge1xuICAgIGlmICghcmVhY3RSb290KSB7XG4gICAgICBjb25zdCBvcHRzID0geyBoeWRyYXRlOiB0cnVlIH1cbiAgICAgIHJlYWN0Um9vdCA9XG4gICAgICAgIHByb2Nlc3MuZW52Ll9fTkVYVF9SRUFDVF9NT0RFID09PSAnY29uY3VycmVudCdcbiAgICAgICAgICA/IFJlYWN0RE9NLnVuc3RhYmxlX2NyZWF0ZVJvb3QoZG9tRWwsIG9wdHMpXG4gICAgICAgICAgOiBSZWFjdERPTS51bnN0YWJsZV9jcmVhdGVCbG9ja2luZ1Jvb3QoZG9tRWwsIG9wdHMpXG4gICAgfVxuICAgIHJlYWN0Um9vdC5yZW5kZXIocmVhY3RFbClcbiAgfSBlbHNlIHtcbiAgICAvLyBtYXJrIHN0YXJ0IG9mIGh5ZHJhdGUvcmVuZGVyXG4gICAgaWYgKFNUKSB7XG4gICAgICBwZXJmb3JtYW5jZS5tYXJrKCdiZWZvcmVSZW5kZXInKVxuICAgIH1cblxuICAgIC8vIFRoZSBjaGVjayBmb3IgYC5oeWRyYXRlYCBpcyB0aGVyZSB0byBzdXBwb3J0IFJlYWN0IGFsdGVybmF0aXZlcyBsaWtlIHByZWFjdFxuICAgIGlmIChpc0luaXRpYWxSZW5kZXIpIHtcbiAgICAgIFJlYWN0RE9NLmh5ZHJhdGUocmVhY3RFbCwgZG9tRWwsIG1hcmtIeWRyYXRlQ29tcGxldGUpXG4gICAgICBpc0luaXRpYWxSZW5kZXIgPSBmYWxzZVxuXG4gICAgICBpZiAob25QZXJmRW50cnkgJiYgU1QpIHtcbiAgICAgICAgbWVhc3VyZVdlYlZpdGFscyhvblBlcmZFbnRyeSlcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3RET00ucmVuZGVyKHJlYWN0RWwsIGRvbUVsLCBtYXJrUmVuZGVyQ29tcGxldGUpXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG1hcmtIeWRyYXRlQ29tcGxldGUoKSB7XG4gIGlmICghU1QpIHJldHVyblxuXG4gIHBlcmZvcm1hbmNlLm1hcmsoJ2FmdGVySHlkcmF0ZScpIC8vIG1hcmsgZW5kIG9mIGh5ZHJhdGlvblxuXG4gIHBlcmZvcm1hbmNlLm1lYXN1cmUoXG4gICAgJ05leHQuanMtYmVmb3JlLWh5ZHJhdGlvbicsXG4gICAgJ25hdmlnYXRpb25TdGFydCcsXG4gICAgJ2JlZm9yZVJlbmRlcidcbiAgKVxuICBwZXJmb3JtYW5jZS5tZWFzdXJlKCdOZXh0LmpzLWh5ZHJhdGlvbicsICdiZWZvcmVSZW5kZXInLCAnYWZ0ZXJIeWRyYXRlJylcblxuICBpZiAob25QZXJmRW50cnkpIHtcbiAgICBwZXJmb3JtYW5jZS5nZXRFbnRyaWVzQnlOYW1lKCdOZXh0LmpzLWh5ZHJhdGlvbicpLmZvckVhY2gob25QZXJmRW50cnkpXG4gIH1cbiAgY2xlYXJNYXJrcygpXG59XG5cbmZ1bmN0aW9uIG1hcmtSZW5kZXJDb21wbGV0ZSgpIHtcbiAgaWYgKCFTVCkgcmV0dXJuXG5cbiAgcGVyZm9ybWFuY2UubWFyaygnYWZ0ZXJSZW5kZXInKSAvLyBtYXJrIGVuZCBvZiByZW5kZXJcbiAgY29uc3QgbmF2U3RhcnRFbnRyaWVzID0gcGVyZm9ybWFuY2UuZ2V0RW50cmllc0J5TmFtZSgncm91dGVDaGFuZ2UnLCAnbWFyaycpXG5cbiAgaWYgKCFuYXZTdGFydEVudHJpZXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBwZXJmb3JtYW5jZS5tZWFzdXJlKFxuICAgICdOZXh0LmpzLXJvdXRlLWNoYW5nZS10by1yZW5kZXInLFxuICAgIG5hdlN0YXJ0RW50cmllc1swXS5uYW1lLFxuICAgICdiZWZvcmVSZW5kZXInXG4gIClcbiAgcGVyZm9ybWFuY2UubWVhc3VyZSgnTmV4dC5qcy1yZW5kZXInLCAnYmVmb3JlUmVuZGVyJywgJ2FmdGVyUmVuZGVyJylcbiAgaWYgKG9uUGVyZkVudHJ5KSB7XG4gICAgcGVyZm9ybWFuY2UuZ2V0RW50cmllc0J5TmFtZSgnTmV4dC5qcy1yZW5kZXInKS5mb3JFYWNoKG9uUGVyZkVudHJ5KVxuICAgIHBlcmZvcm1hbmNlXG4gICAgICAuZ2V0RW50cmllc0J5TmFtZSgnTmV4dC5qcy1yb3V0ZS1jaGFuZ2UtdG8tcmVuZGVyJylcbiAgICAgIC5mb3JFYWNoKG9uUGVyZkVudHJ5KVxuICB9XG4gIGNsZWFyTWFya3MoKVxuICA7WydOZXh0LmpzLXJvdXRlLWNoYW5nZS10by1yZW5kZXInLCAnTmV4dC5qcy1yZW5kZXInXS5mb3JFYWNoKChtZWFzdXJlKSA9PlxuICAgIHBlcmZvcm1hbmNlLmNsZWFyTWVhc3VyZXMobWVhc3VyZSlcbiAgKVxufVxuXG5mdW5jdGlvbiBjbGVhck1hcmtzKCkge1xuICA7W1xuICAgICdiZWZvcmVSZW5kZXInLFxuICAgICdhZnRlckh5ZHJhdGUnLFxuICAgICdhZnRlclJlbmRlcicsXG4gICAgJ3JvdXRlQ2hhbmdlJyxcbiAgXS5mb3JFYWNoKChtYXJrKSA9PiBwZXJmb3JtYW5jZS5jbGVhck1hcmtzKG1hcmspKVxufVxuXG5mdW5jdGlvbiBBcHBDb250YWluZXIoeyBjaGlsZHJlbiB9KSB7XG4gIHJldHVybiAoXG4gICAgPENvbnRhaW5lclxuICAgICAgZm49eyhlcnJvcikgPT5cbiAgICAgICAgcmVuZGVyRXJyb3IoeyBBcHAsIGVycjogZXJyb3IgfSkuY2F0Y2goKGVycikgPT5cbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciByZW5kZXJpbmcgcGFnZTogJywgZXJyKVxuICAgICAgICApXG4gICAgICB9XG4gICAgPlxuICAgICAgPFJvdXRlckNvbnRleHQuUHJvdmlkZXIgdmFsdWU9e21ha2VQdWJsaWNSb3V0ZXJJbnN0YW5jZShyb3V0ZXIpfT5cbiAgICAgICAgPEhlYWRNYW5hZ2VyQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17dXBkYXRlSGVhZH0+XG4gICAgICAgICAge2NoaWxkcmVufVxuICAgICAgICA8L0hlYWRNYW5hZ2VyQ29udGV4dC5Qcm92aWRlcj5cbiAgICAgIDwvUm91dGVyQ29udGV4dC5Qcm92aWRlcj5cbiAgICA8L0NvbnRhaW5lcj5cbiAgKVxufVxuXG5jb25zdCB3cmFwQXBwID0gKEFwcCkgPT4gKHByb3BzKSA9PiB7XG4gIGNvbnN0IGFwcFByb3BzID0geyAuLi5wcm9wcywgQ29tcG9uZW50LCBlcnIsIHJvdXRlciB9XG4gIHJldHVybiAoXG4gICAgPEFwcENvbnRhaW5lcj5cbiAgICAgIDxBcHAgey4uLmFwcFByb3BzfSAvPlxuICAgIDwvQXBwQ29udGFpbmVyPlxuICApXG59XG5cbmFzeW5jIGZ1bmN0aW9uIGRvUmVuZGVyKHsgQXBwLCBDb21wb25lbnQsIHByb3BzLCBlcnIgfSkge1xuICBDb21wb25lbnQgPSBDb21wb25lbnQgfHwgbGFzdEFwcFByb3BzLkNvbXBvbmVudFxuICBwcm9wcyA9IHByb3BzIHx8IGxhc3RBcHBQcm9wcy5wcm9wc1xuXG4gIGNvbnN0IGFwcFByb3BzID0geyAuLi5wcm9wcywgQ29tcG9uZW50LCBlcnIsIHJvdXRlciB9XG4gIC8vIGxhc3RBcHBQcm9wcyBoYXMgdG8gYmUgc2V0IGJlZm9yZSBSZWFjdERvbS5yZW5kZXIgdG8gYWNjb3VudCBmb3IgUmVhY3REb20gdGhyb3dpbmcgYW4gZXJyb3IuXG4gIGxhc3RBcHBQcm9wcyA9IGFwcFByb3BzXG5cbiAgbGV0IHJlc29sdmVQcm9taXNlXG4gIGNvbnN0IHJlbmRlclByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgaWYgKGxhc3RSZW5kZXJSZWplY3QpIHtcbiAgICAgIGxhc3RSZW5kZXJSZWplY3QoKVxuICAgIH1cbiAgICByZXNvbHZlUHJvbWlzZSA9ICgpID0+IHtcbiAgICAgIGxhc3RSZW5kZXJSZWplY3QgPSBudWxsXG4gICAgICByZXNvbHZlKClcbiAgICB9XG4gICAgbGFzdFJlbmRlclJlamVjdCA9ICgpID0+IHtcbiAgICAgIGxhc3RSZW5kZXJSZWplY3QgPSBudWxsXG4gICAgICByZWplY3QoKVxuICAgIH1cbiAgfSlcblxuICBjb25zdCBlbGVtID0gKFxuICAgIDxSb290IGNhbGxiYWNrPXtyZXNvbHZlUHJvbWlzZX0+XG4gICAgICA8QXBwQ29udGFpbmVyPlxuICAgICAgICA8QXBwIHsuLi5hcHBQcm9wc30gLz5cbiAgICAgIDwvQXBwQ29udGFpbmVyPlxuICAgIDwvUm9vdD5cbiAgKVxuXG4gIC8vIFdlIGNhdGNoIHJ1bnRpbWUgZXJyb3JzIHVzaW5nIGNvbXBvbmVudERpZENhdGNoIHdoaWNoIHdpbGwgdHJpZ2dlciByZW5kZXJFcnJvclxuICByZW5kZXJSZWFjdEVsZW1lbnQoXG4gICAgcHJvY2Vzcy5lbnYuX19ORVhUX1NUUklDVF9NT0RFID8gKFxuICAgICAgPFJlYWN0LlN0cmljdE1vZGU+e2VsZW19PC9SZWFjdC5TdHJpY3RNb2RlPlxuICAgICkgOiAoXG4gICAgICBlbGVtXG4gICAgKSxcbiAgICBhcHBFbGVtZW50XG4gIClcblxuICBhd2FpdCByZW5kZXJQcm9taXNlXG59XG5cbmZ1bmN0aW9uIFJvb3QoeyBjYWxsYmFjaywgY2hpbGRyZW4gfSkge1xuICAvLyBXZSB1c2UgYHVzZUxheW91dEVmZmVjdGAgdG8gZ3VhcmFudGVlIHRoZSBjYWxsYmFjayBpcyBleGVjdXRlZFxuICAvLyBhcyBzb29uIGFzIFJlYWN0IGZsdXNoZXMgdGhlIHVwZGF0ZS5cbiAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KCgpID0+IGNhbGxiYWNrKCksIFtjYWxsYmFja10pXG4gIHJldHVybiBjaGlsZHJlblxufVxuIiwiLyogZ2xvYmFscyBfX1JFUExBQ0VfTk9PUF9JTVBPUlRfXyAqL1xuaW1wb3J0IGluaXROZXh0LCAqIGFzIG5leHQgZnJvbSAnLi8nXG5pbXBvcnQgRXZlbnRTb3VyY2VQb2x5ZmlsbCBmcm9tICcuL2Rldi9ldmVudC1zb3VyY2UtcG9seWZpbGwnXG5pbXBvcnQgaW5pdE9uRGVtYW5kRW50cmllcyBmcm9tICcuL2Rldi9vbi1kZW1hbmQtZW50cmllcy1jbGllbnQnXG5pbXBvcnQgaW5pdFdlYnBhY2tITVIgZnJvbSAnLi9kZXYvd2VicGFjay1ob3QtbWlkZGxld2FyZS1jbGllbnQnXG5pbXBvcnQgaW5pdGlhbGl6ZUJ1aWxkV2F0Y2hlciBmcm9tICcuL2Rldi9kZXYtYnVpbGQtd2F0Y2hlcidcbmltcG9ydCBpbml0aWFsaXplUHJlcmVuZGVySW5kaWNhdG9yIGZyb20gJy4vZGV2L3ByZXJlbmRlci1pbmRpY2F0b3InXG5pbXBvcnQgeyBkaXNwbGF5Q29udGVudCB9IGZyb20gJy4vZGV2L2ZvdWMnXG5cbi8vIFRlbXBvcmFyeSB3b3JrYXJvdW5kIGZvciB0aGUgaXNzdWUgZGVzY3JpYmVkIGhlcmU6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vdmVyY2VsL25leHQuanMvaXNzdWVzLzM3NzUjaXNzdWVjb21tZW50LTQwNzQzODEyM1xuLy8gVGhlIHJ1bnRpbWVDaHVuayBkb2Vzbid0IGhhdmUgZHluYW1pYyBpbXBvcnQgaGFuZGxpbmcgY29kZSB3aGVuIHRoZXJlIGhhc24ndCBiZWVuIGEgZHluYW1pYyBpbXBvcnRcbi8vIFRoZSBydW50aW1lQ2h1bmsgY2FuJ3QgaG90IHJlbG9hZCBpdHNlbGYgY3VycmVudGx5IHRvIGNvcnJlY3QgaXQgd2hlbiBhZGRpbmcgcGFnZXMgdXNpbmcgb24tZGVtYW5kLWVudHJpZXNcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtZXhwcmVzc2lvbnNcbl9fUkVQTEFDRV9OT09QX0lNUE9SVF9fXG5cbi8vIFN1cHBvcnQgRXZlbnRTb3VyY2Ugb24gSW50ZXJuZXQgRXhwbG9yZXIgMTFcbmlmICghd2luZG93LkV2ZW50U291cmNlKSB7XG4gIHdpbmRvdy5FdmVudFNvdXJjZSA9IEV2ZW50U291cmNlUG9seWZpbGxcbn1cblxuY29uc3Qge1xuICBfX05FWFRfREFUQV9fOiB7IGFzc2V0UHJlZml4IH0sXG59ID0gd2luZG93XG5cbmNvbnN0IHByZWZpeCA9IGFzc2V0UHJlZml4IHx8ICcnXG5jb25zdCB3ZWJwYWNrSE1SID0gaW5pdFdlYnBhY2tITVIoeyBhc3NldFByZWZpeDogcHJlZml4IH0pXG5cbndpbmRvdy5uZXh0ID0gbmV4dFxuaW5pdE5leHQoeyB3ZWJwYWNrSE1SIH0pXG4gIC50aGVuKCh7IGVtaXR0ZXIsIHJlbmRlckN0eCwgcmVuZGVyIH0pID0+IHtcbiAgICBpbml0T25EZW1hbmRFbnRyaWVzKHsgYXNzZXRQcmVmaXg6IHByZWZpeCB9KVxuICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfQlVJTERfSU5ESUNBVE9SKSBpbml0aWFsaXplQnVpbGRXYXRjaGVyKClcbiAgICBpZiAoXG4gICAgICBwcm9jZXNzLmVudi5fX05FWFRfUFJFUkVOREVSX0lORElDQVRPUiAmJlxuICAgICAgLy8gZGlzYWJsZSBieSBkZWZhdWx0IGluIGVsZWN0cm9uXG4gICAgICAhKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiAnZWxlY3Ryb24nIGluIHByb2Nlc3MudmVyc2lvbnMpXG4gICAgKSB7XG4gICAgICBpbml0aWFsaXplUHJlcmVuZGVySW5kaWNhdG9yKClcbiAgICB9XG5cbiAgICAvLyBkZWxheSByZW5kZXJpbmcgdW50aWwgYWZ0ZXIgc3R5bGVzIGhhdmUgYmVlbiBhcHBsaWVkIGluIGRldmVsb3BtZW50XG4gICAgZGlzcGxheUNvbnRlbnQoKCkgPT4ge1xuICAgICAgcmVuZGVyKHJlbmRlckN0eClcbiAgICB9KVxuICB9KVxuICAuY2F0Y2goKGVycikgPT4ge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHdhcyBub3QgY2F1Z2h0JywgZXJyKVxuICB9KVxuIiwiaW1wb3J0IHsgcGFyc2UgfSBmcm9tICd1cmwnXG5pbXBvcnQgbWl0dCBmcm9tICcuLi9uZXh0LXNlcnZlci9saWIvbWl0dCdcbmltcG9ydCB7IGlzRHluYW1pY1JvdXRlIH0gZnJvbSAnLi8uLi9uZXh0LXNlcnZlci9saWIvcm91dGVyL3V0aWxzL2lzLWR5bmFtaWMnXG5pbXBvcnQgeyBnZXRSb3V0ZU1hdGNoZXIgfSBmcm9tICcuLy4uL25leHQtc2VydmVyL2xpYi9yb3V0ZXIvdXRpbHMvcm91dGUtbWF0Y2hlcidcbmltcG9ydCB7IGdldFJvdXRlUmVnZXggfSBmcm9tICcuLy4uL25leHQtc2VydmVyL2xpYi9yb3V0ZXIvdXRpbHMvcm91dGUtcmVnZXgnXG5pbXBvcnQgeyBkZWxCYXNlUGF0aCB9IGZyb20gJy4vLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci9yb3V0ZXInXG5cbmZ1bmN0aW9uIGhhc1JlbChyZWwsIGxpbmspIHtcbiAgdHJ5IHtcbiAgICBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGluaycpXG4gICAgcmV0dXJuIGxpbmsucmVsTGlzdC5zdXBwb3J0cyhyZWwpXG4gIH0gY2F0Y2gge31cbn1cblxuY29uc3QgcmVsUHJlZmV0Y2ggPVxuICBoYXNSZWwoJ3ByZWxvYWQnKSAmJiAhaGFzUmVsKCdwcmVmZXRjaCcpXG4gICAgPyAvLyBodHRwczovL2Nhbml1c2UuY29tLyNmZWF0PWxpbmstcmVsLXByZWxvYWRcbiAgICAgIC8vIG1hY09TIGFuZCBpT1MgKFNhZmFyaSBkb2VzIG5vdCBzdXBwb3J0IHByZWZldGNoKVxuICAgICAgJ3ByZWxvYWQnXG4gICAgOiAvLyBodHRwczovL2Nhbml1c2UuY29tLyNmZWF0PWxpbmstcmVsLXByZWZldGNoXG4gICAgICAvLyBJRSAxMSwgRWRnZSAxMissIG5lYXJseSBhbGwgZXZlcmdyZWVuXG4gICAgICAncHJlZmV0Y2gnXG5cbmNvbnN0IGhhc05vTW9kdWxlID0gJ25vTW9kdWxlJyBpbiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKVxuXG4vKiogQHBhcmFtIHtzdHJpbmd9IHJvdXRlICovXG5mdW5jdGlvbiBub3JtYWxpemVSb3V0ZShyb3V0ZSkge1xuICBpZiAocm91dGVbMF0gIT09ICcvJykge1xuICAgIHRocm93IG5ldyBFcnJvcihgUm91dGUgbmFtZSBzaG91bGQgc3RhcnQgd2l0aCBhIFwiL1wiLCBnb3QgXCIke3JvdXRlfVwiYClcbiAgfVxuICByb3V0ZSA9IHJvdXRlLnJlcGxhY2UoL1xcL2luZGV4JC8sICcvJylcblxuICBpZiAocm91dGUgPT09ICcvJykgcmV0dXJuIHJvdXRlXG4gIHJldHVybiByb3V0ZS5yZXBsYWNlKC9cXC8kLywgJycpXG59XG5cbmZ1bmN0aW9uIGFwcGVuZExpbmsoaHJlZiwgcmVsLCBhcykge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlcywgcmVqLCBsaW5rKSA9PiB7XG4gICAgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpbmsnKVxuICAgIGxpbmsuY3Jvc3NPcmlnaW4gPSBwcm9jZXNzLmNyb3NzT3JpZ2luXG4gICAgbGluay5ocmVmID0gaHJlZlxuICAgIGxpbmsucmVsID0gcmVsXG4gICAgaWYgKGFzKSBsaW5rLmFzID0gYXNcblxuICAgIGxpbmsub25sb2FkID0gcmVzXG4gICAgbGluay5vbmVycm9yID0gcmVqXG5cbiAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKGxpbmspXG4gIH0pXG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBhZ2VMb2FkZXIge1xuICBjb25zdHJ1Y3RvcihidWlsZElkLCBhc3NldFByZWZpeCkge1xuICAgIHRoaXMuYnVpbGRJZCA9IGJ1aWxkSWRcbiAgICB0aGlzLmFzc2V0UHJlZml4ID0gYXNzZXRQcmVmaXhcblxuICAgIHRoaXMucGFnZUNhY2hlID0ge31cbiAgICB0aGlzLnBhZ2VSZWdpc3RlckV2ZW50cyA9IG1pdHQoKVxuICAgIHRoaXMubG9hZGluZ1JvdXRlcyA9IHt9XG4gICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9HUkFOVUxBUl9DSFVOS1MpIHtcbiAgICAgIHRoaXMucHJvbWlzZWRCdWlsZE1hbmlmZXN0ID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgaWYgKHdpbmRvdy5fX0JVSUxEX01BTklGRVNUKSB7XG4gICAgICAgICAgcmVzb2x2ZSh3aW5kb3cuX19CVUlMRF9NQU5JRkVTVClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3aW5kb3cuX19CVUlMRF9NQU5JRkVTVF9DQiA9ICgpID0+IHtcbiAgICAgICAgICAgIHJlc29sdmUod2luZG93Ll9fQlVJTERfTUFOSUZFU1QpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgICAvKiogQHR5cGUge1Byb21pc2U8U2V0PHN0cmluZz4+fSAqL1xuICAgIHRoaXMucHJvbWlzZWRTc2dNYW5pZmVzdCA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICBpZiAod2luZG93Ll9fU1NHX01BTklGRVNUKSB7XG4gICAgICAgIHJlc29sdmUod2luZG93Ll9fU1NHX01BTklGRVNUKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2luZG93Ll9fU1NHX01BTklGRVNUX0NCID0gKCkgPT4ge1xuICAgICAgICAgIHJlc29sdmUod2luZG93Ll9fU1NHX01BTklGRVNUKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIC8vIFJldHVybnMgYSBwcm9taXNlIGZvciB0aGUgZGVwZW5kZW5jaWVzIGZvciBhIHBhcnRpY3VsYXIgcm91dGVcbiAgZ2V0RGVwZW5kZW5jaWVzKHJvdXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvbWlzZWRCdWlsZE1hbmlmZXN0LnRoZW4oXG4gICAgICAobWFuKSA9PlxuICAgICAgICAobWFuW3JvdXRlXSAmJlxuICAgICAgICAgIG1hbltyb3V0ZV0ubWFwKFxuICAgICAgICAgICAgKHVybCkgPT4gYCR7dGhpcy5hc3NldFByZWZpeH0vX25leHQvJHtlbmNvZGVVUkkodXJsKX1gXG4gICAgICAgICAgKSkgfHxcbiAgICAgICAgW11cbiAgICApXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGhyZWYgdGhlIHJvdXRlIGhyZWYgKGZpbGUtc3lzdGVtIHBhdGgpXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhc1BhdGggdGhlIFVSTCBhcyBzaG93biBpbiBicm93c2VyICh2aXJ0dWFsIHBhdGgpOyB1c2VkIGZvciBkeW5hbWljIHJvdXRlc1xuICAgKi9cbiAgZ2V0RGF0YUhyZWYoaHJlZiwgYXNQYXRoKSB7XG4gICAgY29uc3QgZ2V0SHJlZkZvclNsdWcgPSAoLyoqIEB0eXBlIHN0cmluZyAqLyBwYXRoKSA9PiB7XG4gICAgICBwYXRoID0gZGVsQmFzZVBhdGgocGF0aClcbiAgICAgIHJldHVybiBgJHt0aGlzLmFzc2V0UHJlZml4fS9fbmV4dC9kYXRhLyR7dGhpcy5idWlsZElkfSR7XG4gICAgICAgIHBhdGggPT09ICcvJyA/ICcvaW5kZXgnIDogcGF0aFxuICAgICAgfS5qc29uYFxuICAgIH1cblxuICAgIGNvbnN0IHsgcGF0aG5hbWU6IGhyZWZQYXRobmFtZSwgcXVlcnkgfSA9IHBhcnNlKGhyZWYsIHRydWUpXG4gICAgY29uc3QgeyBwYXRobmFtZTogYXNQYXRobmFtZSB9ID0gcGFyc2UoYXNQYXRoKVxuXG4gICAgY29uc3Qgcm91dGUgPSBub3JtYWxpemVSb3V0ZShocmVmUGF0aG5hbWUpXG5cbiAgICBsZXQgaXNEeW5hbWljID0gaXNEeW5hbWljUm91dGUocm91dGUpLFxuICAgICAgaW50ZXJwb2xhdGVkUm91dGVcbiAgICBpZiAoaXNEeW5hbWljKSB7XG4gICAgICBjb25zdCBkeW5hbWljUmVnZXggPSBnZXRSb3V0ZVJlZ2V4KHJvdXRlKVxuICAgICAgY29uc3QgZHluYW1pY0dyb3VwcyA9IGR5bmFtaWNSZWdleC5ncm91cHNcbiAgICAgIGNvbnN0IGR5bmFtaWNNYXRjaGVzID1cbiAgICAgICAgLy8gVHJ5IHRvIG1hdGNoIHRoZSBkeW5hbWljIHJvdXRlIGFnYWluc3QgdGhlIGFzUGF0aFxuICAgICAgICBnZXRSb3V0ZU1hdGNoZXIoZHluYW1pY1JlZ2V4KShhc1BhdGhuYW1lKSB8fFxuICAgICAgICAvLyBGYWxsIGJhY2sgdG8gcmVhZGluZyB0aGUgdmFsdWVzIGZyb20gdGhlIGhyZWZcbiAgICAgICAgLy8gVE9ETzogc2hvdWxkIHRoaXMgdGFrZSBwcmlvcml0eTsgYWxzbyBuZWVkIHRvIGNoYW5nZSBpbiB0aGUgcm91dGVyLlxuICAgICAgICBxdWVyeVxuXG4gICAgICBpbnRlcnBvbGF0ZWRSb3V0ZSA9IHJvdXRlXG4gICAgICBpZiAoXG4gICAgICAgICFPYmplY3Qua2V5cyhkeW5hbWljR3JvdXBzKS5ldmVyeSgocGFyYW0pID0+IHtcbiAgICAgICAgICBsZXQgdmFsdWUgPSBkeW5hbWljTWF0Y2hlc1twYXJhbV1cbiAgICAgICAgICBjb25zdCByZXBlYXQgPSBkeW5hbWljR3JvdXBzW3BhcmFtXS5yZXBlYXRcblxuICAgICAgICAgIC8vIHN1cHBvcnQgc2luZ2xlLWxldmVsIGNhdGNoLWFsbFxuICAgICAgICAgIC8vIFRPRE86IG1vcmUgcm9idXN0IGhhbmRsaW5nIGZvciB1c2VyLWVycm9yIChwYXNzaW5nIGAvYClcbiAgICAgICAgICBpZiAocmVwZWF0ICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSkgdmFsdWUgPSBbdmFsdWVdXG5cbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgcGFyYW0gaW4gZHluYW1pY01hdGNoZXMgJiZcbiAgICAgICAgICAgIC8vIEludGVycG9sYXRlIGdyb3VwIGludG8gZGF0YSBVUkwgaWYgcHJlc2VudFxuICAgICAgICAgICAgKGludGVycG9sYXRlZFJvdXRlID0gaW50ZXJwb2xhdGVkUm91dGUucmVwbGFjZShcbiAgICAgICAgICAgICAgYFske3JlcGVhdCA/ICcuLi4nIDogJyd9JHtwYXJhbX1dYCxcbiAgICAgICAgICAgICAgcmVwZWF0XG4gICAgICAgICAgICAgICAgPyB2YWx1ZS5tYXAoZW5jb2RlVVJJQ29tcG9uZW50KS5qb2luKCcvJylcbiAgICAgICAgICAgICAgICA6IGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSlcbiAgICAgICAgICAgICkpXG4gICAgICAgICAgKVxuICAgICAgICB9KVxuICAgICAgKSB7XG4gICAgICAgIGludGVycG9sYXRlZFJvdXRlID0gJycgLy8gZGlkIG5vdCBzYXRpc2Z5IGFsbCByZXF1aXJlbWVudHNcblxuICAgICAgICAvLyBuLmIuIFdlIGlnbm9yZSB0aGlzIGVycm9yIGJlY2F1c2Ugd2UgaGFuZGxlIHdhcm5pbmcgZm9yIHRoaXMgY2FzZSBpblxuICAgICAgICAvLyBkZXZlbG9wbWVudCBpbiB0aGUgYDxMaW5rPmAgY29tcG9uZW50IGRpcmVjdGx5LlxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBpc0R5bmFtaWNcbiAgICAgID8gaW50ZXJwb2xhdGVkUm91dGUgJiYgZ2V0SHJlZkZvclNsdWcoaW50ZXJwb2xhdGVkUm91dGUpXG4gICAgICA6IGdldEhyZWZGb3JTbHVnKHJvdXRlKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBocmVmIHRoZSByb3V0ZSBocmVmIChmaWxlLXN5c3RlbSBwYXRoKVxuICAgKiBAcGFyYW0ge3N0cmluZ30gYXNQYXRoIHRoZSBVUkwgYXMgc2hvd24gaW4gYnJvd3NlciAodmlydHVhbCBwYXRoKTsgdXNlZCBmb3IgZHluYW1pYyByb3V0ZXNcbiAgICovXG4gIHByZWZldGNoRGF0YShocmVmLCBhc1BhdGgpIHtcbiAgICBjb25zdCB7IHBhdGhuYW1lOiBocmVmUGF0aG5hbWUgfSA9IHBhcnNlKGhyZWYsIHRydWUpXG4gICAgY29uc3Qgcm91dGUgPSBub3JtYWxpemVSb3V0ZShocmVmUGF0aG5hbWUpXG4gICAgcmV0dXJuIHRoaXMucHJvbWlzZWRTc2dNYW5pZmVzdC50aGVuKFxuICAgICAgKHMsIF9kYXRhSHJlZikgPT5cbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIHJvdXRlIHJlcXVpcmVzIGEgZGF0YSBmaWxlXG4gICAgICAgIHMuaGFzKHJvdXRlKSAmJlxuICAgICAgICAvLyBUcnkgdG8gZ2VuZXJhdGUgZGF0YSBocmVmLCBub29wIHdoZW4gZmFsc3lcbiAgICAgICAgKF9kYXRhSHJlZiA9IHRoaXMuZ2V0RGF0YUhyZWYoaHJlZiwgYXNQYXRoKSkgJiZcbiAgICAgICAgLy8gbm9vcCB3aGVuIGRhdGEgaGFzIGFscmVhZHkgYmVlbiBwcmVmZXRjaGVkIChkZWR1cGUpXG4gICAgICAgICFkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFxuICAgICAgICAgIGBsaW5rW3JlbD1cIiR7cmVsUHJlZmV0Y2h9XCJdW2hyZWZePVwiJHtfZGF0YUhyZWZ9XCJdYFxuICAgICAgICApICYmXG4gICAgICAgIC8vIEluamVjdCB0aGUgYDxsaW5rIHJlbD1wcmVmZXRjaD5gIHRhZyBmb3IgYWJvdmUgY29tcHV0ZWQgYGhyZWZgLlxuICAgICAgICBhcHBlbmRMaW5rKF9kYXRhSHJlZiwgcmVsUHJlZmV0Y2gsICdmZXRjaCcpXG4gICAgKVxuICB9XG5cbiAgbG9hZFBhZ2Uocm91dGUpIHtcbiAgICByZXR1cm4gdGhpcy5sb2FkUGFnZVNjcmlwdChyb3V0ZSlcbiAgfVxuXG4gIGxvYWRQYWdlU2NyaXB0KHJvdXRlKSB7XG4gICAgcm91dGUgPSBub3JtYWxpemVSb3V0ZShyb3V0ZSlcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBmaXJlID0gKHsgZXJyb3IsIHBhZ2UsIG1vZCB9KSA9PiB7XG4gICAgICAgIHRoaXMucGFnZVJlZ2lzdGVyRXZlbnRzLm9mZihyb3V0ZSwgZmlyZSlcbiAgICAgICAgZGVsZXRlIHRoaXMubG9hZGluZ1JvdXRlc1tyb3V0ZV1cblxuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICByZWplY3QoZXJyb3IpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzb2x2ZSh7IHBhZ2UsIG1vZCB9KVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHRoZXJlJ3MgYSBjYWNoZWQgdmVyc2lvbiBvZiB0aGUgcGFnZSwgbGV0J3MgdXNlIGl0LlxuICAgICAgY29uc3QgY2FjaGVkUGFnZSA9IHRoaXMucGFnZUNhY2hlW3JvdXRlXVxuICAgICAgaWYgKGNhY2hlZFBhZ2UpIHtcbiAgICAgICAgY29uc3QgeyBlcnJvciwgcGFnZSwgbW9kIH0gPSBjYWNoZWRQYWdlXG4gICAgICAgIGVycm9yID8gcmVqZWN0KGVycm9yKSA6IHJlc29sdmUoeyBwYWdlLCBtb2QgfSlcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIFJlZ2lzdGVyIGEgbGlzdGVuZXIgdG8gZ2V0IHRoZSBwYWdlXG4gICAgICB0aGlzLnBhZ2VSZWdpc3RlckV2ZW50cy5vbihyb3V0ZSwgZmlyZSlcblxuICAgICAgLy8gSWYgdGhlIHBhZ2UgaXMgbG9hZGluZyB2aWEgU1NSLCB3ZSBuZWVkIHRvIHdhaXQgZm9yIGl0XG4gICAgICAvLyByYXRoZXIgZG93bmxvYWRpbmcgaXQgYWdhaW4uXG4gICAgICBpZiAoZG9jdW1lbnQucXVlcnlTZWxlY3Rvcihgc2NyaXB0W2RhdGEtbmV4dC1wYWdlPVwiJHtyb3V0ZX1cIl1gKSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLmxvYWRpbmdSb3V0ZXNbcm91dGVdKSB7XG4gICAgICAgIHRoaXMubG9hZGluZ1JvdXRlc1tyb3V0ZV0gPSB0cnVlXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfR1JBTlVMQVJfQ0hVTktTKSB7XG4gICAgICAgICAgdGhpcy5nZXREZXBlbmRlbmNpZXMocm91dGUpLnRoZW4oKGRlcHMpID0+IHtcbiAgICAgICAgICAgIGRlcHMuZm9yRWFjaCgoZCkgPT4ge1xuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgL1xcLmpzJC8udGVzdChkKSAmJlxuICAgICAgICAgICAgICAgICFkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGBzY3JpcHRbc3JjXj1cIiR7ZH1cIl1gKVxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvYWRTY3JpcHQoZCwgcm91dGUsIGZhbHNlKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAvXFwuY3NzJC8udGVzdChkKSAmJlxuICAgICAgICAgICAgICAgICFkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGBsaW5rW3JlbD1zdHlsZXNoZWV0XVtocmVmXj1cIiR7ZH1cIl1gKVxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBhcHBlbmRMaW5rKGQsICdzdHlsZXNoZWV0JykuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgLy8gRklYTUU6IGhhbmRsZSBmYWlsdXJlXG4gICAgICAgICAgICAgICAgICAvLyBSaWdodCBub3csIHRoaXMgaXMgbmVlZGVkIHRvIHByZXZlbnQgYW4gdW5oYW5kbGVkIHJlamVjdGlvbi5cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgdGhpcy5sb2FkUm91dGUocm91dGUpXG4gICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmxvYWRSb3V0ZShyb3V0ZSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBsb2FkUm91dGUocm91dGUpIHtcbiAgICByb3V0ZSA9IG5vcm1hbGl6ZVJvdXRlKHJvdXRlKVxuICAgIGxldCBzY3JpcHRSb3V0ZSA9IHJvdXRlID09PSAnLycgPyAnL2luZGV4LmpzJyA6IGAke3JvdXRlfS5qc2BcblxuICAgIGNvbnN0IHVybCA9IGAke3RoaXMuYXNzZXRQcmVmaXh9L19uZXh0L3N0YXRpYy8ke2VuY29kZVVSSUNvbXBvbmVudChcbiAgICAgIHRoaXMuYnVpbGRJZFxuICAgICl9L3BhZ2VzJHtlbmNvZGVVUkkoc2NyaXB0Um91dGUpfWBcbiAgICB0aGlzLmxvYWRTY3JpcHQodXJsLCByb3V0ZSwgdHJ1ZSlcbiAgfVxuXG4gIGxvYWRTY3JpcHQodXJsLCByb3V0ZSwgaXNQYWdlKSB7XG4gICAgY29uc3Qgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0JylcbiAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX01PREVSTl9CVUlMRCAmJiBoYXNOb01vZHVsZSkge1xuICAgICAgc2NyaXB0LnR5cGUgPSAnbW9kdWxlJ1xuICAgICAgLy8gT25seSBwYWdlIGJ1bmRsZSBzY3JpcHRzIG5lZWQgdG8gaGF2ZSAubW9kdWxlIGFkZGVkIHRvIHVybCxcbiAgICAgIC8vIGRlcGVuZGVuY2llcyBhbHJlYWR5IGhhdmUgaXQgYWRkZWQgZHVyaW5nIGJ1aWxkIG1hbmlmZXN0IGNyZWF0aW9uXG4gICAgICBpZiAoaXNQYWdlKSB1cmwgPSB1cmwucmVwbGFjZSgvXFwuanMkLywgJy5tb2R1bGUuanMnKVxuICAgIH1cbiAgICBzY3JpcHQuY3Jvc3NPcmlnaW4gPSBwcm9jZXNzLmNyb3NzT3JpZ2luXG4gICAgc2NyaXB0LnNyYyA9IHVybFxuICAgIHNjcmlwdC5vbmVycm9yID0gKCkgPT4ge1xuICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYEVycm9yIGxvYWRpbmcgc2NyaXB0ICR7dXJsfWApXG4gICAgICBlcnJvci5jb2RlID0gJ1BBR0VfTE9BRF9FUlJPUidcbiAgICAgIHRoaXMucGFnZVJlZ2lzdGVyRXZlbnRzLmVtaXQocm91dGUsIHsgZXJyb3IgfSlcbiAgICB9XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzY3JpcHQpXG4gIH1cblxuICAvLyBUaGlzIG1ldGhvZCBpZiBjYWxsZWQgYnkgdGhlIHJvdXRlIGNvZGUuXG4gIHJlZ2lzdGVyUGFnZShyb3V0ZSwgcmVnRm4pIHtcbiAgICBjb25zdCByZWdpc3RlciA9ICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG1vZCA9IHJlZ0ZuKClcbiAgICAgICAgY29uc3QgcGFnZURhdGEgPSB7IHBhZ2U6IG1vZC5kZWZhdWx0IHx8IG1vZCwgbW9kIH1cbiAgICAgICAgdGhpcy5wYWdlQ2FjaGVbcm91dGVdID0gcGFnZURhdGFcbiAgICAgICAgdGhpcy5wYWdlUmVnaXN0ZXJFdmVudHMuZW1pdChyb3V0ZSwgcGFnZURhdGEpXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICB0aGlzLnBhZ2VDYWNoZVtyb3V0ZV0gPSB7IGVycm9yIH1cbiAgICAgICAgdGhpcy5wYWdlUmVnaXN0ZXJFdmVudHMuZW1pdChyb3V0ZSwgeyBlcnJvciB9KVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvLyBXYWl0IGZvciB3ZWJwYWNrIHRvIGJlY29tZSBpZGxlIGlmIGl0J3Mgbm90LlxuICAgICAgLy8gTW9yZSBpbmZvOiBodHRwczovL2dpdGh1Yi5jb20vdmVyY2VsL25leHQuanMvcHVsbC8xNTExXG4gICAgICBpZiAobW9kdWxlLmhvdCAmJiBtb2R1bGUuaG90LnN0YXR1cygpICE9PSAnaWRsZScpIHtcbiAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgYFdhaXRpbmcgZm9yIHdlYnBhY2sgdG8gYmVjb21lIFwiaWRsZVwiIHRvIGluaXRpYWxpemUgdGhlIHBhZ2U6IFwiJHtyb3V0ZX1cImBcbiAgICAgICAgKVxuXG4gICAgICAgIGNvbnN0IGNoZWNrID0gKHN0YXR1cykgPT4ge1xuICAgICAgICAgIGlmIChzdGF0dXMgPT09ICdpZGxlJykge1xuICAgICAgICAgICAgbW9kdWxlLmhvdC5yZW1vdmVTdGF0dXNIYW5kbGVyKGNoZWNrKVxuICAgICAgICAgICAgcmVnaXN0ZXIoKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBtb2R1bGUuaG90LnN0YXR1cyhjaGVjaylcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmVnaXN0ZXIoKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByb3V0ZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlcGVuZGVuY3ldXG4gICAqL1xuICBwcmVmZXRjaChyb3V0ZSwgaXNEZXBlbmRlbmN5KSB7XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL0dvb2dsZUNocm9tZUxhYnMvcXVpY2tsaW5rL2Jsb2IvNDUzYTY2MWZhMWZhOTQwZTJkMmUwNDQ0NTIzOThlMzhjNjdhOThmYi9zcmMvaW5kZXgubWpzI0wxMTUtTDExOFxuICAgIC8vIExpY2Vuc2U6IEFwYWNoZSAyLjBcbiAgICBsZXQgY25cbiAgICBpZiAoKGNuID0gbmF2aWdhdG9yLmNvbm5lY3Rpb24pKSB7XG4gICAgICAvLyBEb24ndCBwcmVmZXRjaCBpZiB1c2luZyAyRyBvciBpZiBTYXZlLURhdGEgaXMgZW5hYmxlZC5cbiAgICAgIGlmIChjbi5zYXZlRGF0YSB8fCAvMmcvLnRlc3QoY24uZWZmZWN0aXZlVHlwZSkpIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgIH1cblxuICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgIGxldCB1cmxcbiAgICBpZiAoaXNEZXBlbmRlbmN5KSB7XG4gICAgICB1cmwgPSByb3V0ZVxuICAgIH0gZWxzZSB7XG4gICAgICByb3V0ZSA9IG5vcm1hbGl6ZVJvdXRlKHJvdXRlKVxuXG4gICAgICBsZXQgc2NyaXB0Um91dGUgPSBgJHtyb3V0ZSA9PT0gJy8nID8gJy9pbmRleCcgOiByb3V0ZX0uanNgXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX01PREVSTl9CVUlMRCAmJiBoYXNOb01vZHVsZSkge1xuICAgICAgICBzY3JpcHRSb3V0ZSA9IHNjcmlwdFJvdXRlLnJlcGxhY2UoL1xcLmpzJC8sICcubW9kdWxlLmpzJylcbiAgICAgIH1cblxuICAgICAgdXJsID0gYCR7dGhpcy5hc3NldFByZWZpeH0vX25leHQvc3RhdGljLyR7ZW5jb2RlVVJJQ29tcG9uZW50KFxuICAgICAgICB0aGlzLmJ1aWxkSWRcbiAgICAgICl9L3BhZ2VzJHtlbmNvZGVVUkkoc2NyaXB0Um91dGUpfWBcbiAgICB9XG5cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoXG4gICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFxuICAgICAgICBgbGlua1tyZWw9XCIke3JlbFByZWZldGNofVwiXVtocmVmXj1cIiR7dXJsfVwiXSwgc2NyaXB0W2RhdGEtbmV4dC1wYWdlPVwiJHtyb3V0ZX1cIl1gXG4gICAgICApXG4gICAgICAgID8gW11cbiAgICAgICAgOiBbXG4gICAgICAgICAgICBhcHBlbmRMaW5rKFxuICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICAgIHJlbFByZWZldGNoLFxuICAgICAgICAgICAgICB1cmwubWF0Y2goL1xcLmNzcyQvKSA/ICdzdHlsZScgOiAnc2NyaXB0J1xuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIHByb2Nlc3MuZW52Ll9fTkVYVF9HUkFOVUxBUl9DSFVOS1MgJiZcbiAgICAgICAgICAgICAgIWlzRGVwZW5kZW5jeSAmJlxuICAgICAgICAgICAgICB0aGlzLmdldERlcGVuZGVuY2llcyhyb3V0ZSkudGhlbigodXJscykgPT5cbiAgICAgICAgICAgICAgICBQcm9taXNlLmFsbCh1cmxzLm1hcCgodXJsKSA9PiB0aGlzLnByZWZldGNoKHVybCwgdHJ1ZSkpKVxuICAgICAgICAgICAgICApLFxuICAgICAgICAgIF1cbiAgICApLnRoZW4oXG4gICAgICAvLyBkbyBub3QgcmV0dXJuIGFueSBkYXRhXG4gICAgICAoKSA9PiB7fSxcbiAgICAgIC8vIHN3YWxsb3cgcHJlZmV0Y2ggZXJyb3JzXG4gICAgICAoKSA9PiB7fVxuICAgIClcbiAgfVxufVxuIiwiaW1wb3J0IHsgZ2V0Q0xTLCBnZXRGSUQsIGdldEZDUCwgZ2V0TENQLCBnZXRUVEZCIH0gZnJvbSAnd2ViLXZpdGFscydcblxuZXhwb3J0IGRlZmF1bHQgKG9uUGVyZkVudHJ5KSA9PiB7XG4gIGdldENMUyhvblBlcmZFbnRyeSlcbiAgZ2V0RklEKG9uUGVyZkVudHJ5KVxuICBnZXRGQ1Aob25QZXJmRW50cnkpXG4gIGdldExDUChvblBlcmZFbnRyeSlcbiAgZ2V0VFRGQihvblBlcmZFbnRyeSlcbn1cbiIsIi8qIGdsb2JhbCB3aW5kb3cgKi9cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcbmltcG9ydCBSb3V0ZXIsIHsgTmV4dFJvdXRlciB9IGZyb20gJy4uL25leHQtc2VydmVyL2xpYi9yb3V0ZXIvcm91dGVyJ1xuaW1wb3J0IHsgUm91dGVyQ29udGV4dCB9IGZyb20gJy4uL25leHQtc2VydmVyL2xpYi9yb3V0ZXItY29udGV4dCdcblxudHlwZSBDbGFzc0FyZ3VtZW50czxUPiA9IFQgZXh0ZW5kcyBuZXcgKC4uLmFyZ3M6IGluZmVyIFUpID0+IGFueSA/IFUgOiBhbnlcblxudHlwZSBSb3V0ZXJBcmdzID0gQ2xhc3NBcmd1bWVudHM8dHlwZW9mIFJvdXRlcj5cblxudHlwZSBTaW5nbGV0b25Sb3V0ZXJCYXNlID0ge1xuICByb3V0ZXI6IFJvdXRlciB8IG51bGxcbiAgcmVhZHlDYWxsYmFja3M6IEFycmF5PCgpID0+IGFueT5cbiAgcmVhZHkoY2I6ICgpID0+IGFueSk6IHZvaWRcbn1cblxuZXhwb3J0IHsgUm91dGVyLCBOZXh0Um91dGVyIH1cblxuZXhwb3J0IHR5cGUgU2luZ2xldG9uUm91dGVyID0gU2luZ2xldG9uUm91dGVyQmFzZSAmIE5leHRSb3V0ZXJcblxuY29uc3Qgc2luZ2xldG9uUm91dGVyOiBTaW5nbGV0b25Sb3V0ZXJCYXNlID0ge1xuICByb3V0ZXI6IG51bGwsIC8vIGhvbGRzIHRoZSBhY3R1YWwgcm91dGVyIGluc3RhbmNlXG4gIHJlYWR5Q2FsbGJhY2tzOiBbXSxcbiAgcmVhZHkoY2I6ICgpID0+IHZvaWQpIHtcbiAgICBpZiAodGhpcy5yb3V0ZXIpIHJldHVybiBjYigpXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzLnJlYWR5Q2FsbGJhY2tzLnB1c2goY2IpXG4gICAgfVxuICB9LFxufVxuXG4vLyBDcmVhdGUgcHVibGljIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMgb2YgdGhlIHJvdXRlciBpbiB0aGUgc2luZ2xldG9uUm91dGVyXG5jb25zdCB1cmxQcm9wZXJ0eUZpZWxkcyA9IFtcbiAgJ3BhdGhuYW1lJyxcbiAgJ3JvdXRlJyxcbiAgJ3F1ZXJ5JyxcbiAgJ2FzUGF0aCcsXG4gICdjb21wb25lbnRzJyxcbiAgJ2lzRmFsbGJhY2snLFxuICAnYmFzZVBhdGgnLFxuXVxuY29uc3Qgcm91dGVyRXZlbnRzID0gW1xuICAncm91dGVDaGFuZ2VTdGFydCcsXG4gICdiZWZvcmVIaXN0b3J5Q2hhbmdlJyxcbiAgJ3JvdXRlQ2hhbmdlQ29tcGxldGUnLFxuICAncm91dGVDaGFuZ2VFcnJvcicsXG4gICdoYXNoQ2hhbmdlU3RhcnQnLFxuICAnaGFzaENoYW5nZUNvbXBsZXRlJyxcbl1cbmNvbnN0IGNvcmVNZXRob2RGaWVsZHMgPSBbXG4gICdwdXNoJyxcbiAgJ3JlcGxhY2UnLFxuICAncmVsb2FkJyxcbiAgJ2JhY2snLFxuICAncHJlZmV0Y2gnLFxuICAnYmVmb3JlUG9wU3RhdGUnLFxuXVxuXG4vLyBFdmVudHMgaXMgYSBzdGF0aWMgcHJvcGVydHkgb24gdGhlIHJvdXRlciwgdGhlIHJvdXRlciBkb2Vzbid0IGhhdmUgdG8gYmUgaW5pdGlhbGl6ZWQgdG8gdXNlIGl0XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc2luZ2xldG9uUm91dGVyLCAnZXZlbnRzJywge1xuICBnZXQoKSB7XG4gICAgcmV0dXJuIFJvdXRlci5ldmVudHNcbiAgfSxcbn0pXG5cbnVybFByb3BlcnR5RmllbGRzLmZvckVhY2goKGZpZWxkKSA9PiB7XG4gIC8vIEhlcmUgd2UgbmVlZCB0byB1c2UgT2JqZWN0LmRlZmluZVByb3BlcnR5IGJlY2F1c2UsIHdlIG5lZWQgdG8gcmV0dXJuXG4gIC8vIHRoZSBwcm9wZXJ0eSBhc3NpZ25lZCB0byB0aGUgYWN0dWFsIHJvdXRlclxuICAvLyBUaGUgdmFsdWUgbWlnaHQgZ2V0IGNoYW5nZWQgYXMgd2UgY2hhbmdlIHJvdXRlcyBhbmQgdGhpcyBpcyB0aGVcbiAgLy8gcHJvcGVyIHdheSB0byBhY2Nlc3MgaXRcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNpbmdsZXRvblJvdXRlciwgZmllbGQsIHtcbiAgICBnZXQoKSB7XG4gICAgICBjb25zdCByb3V0ZXIgPSBnZXRSb3V0ZXIoKSBhcyBhbnlcbiAgICAgIHJldHVybiByb3V0ZXJbZmllbGRdIGFzIHN0cmluZ1xuICAgIH0sXG4gIH0pXG59KVxuXG5jb3JlTWV0aG9kRmllbGRzLmZvckVhY2goKGZpZWxkKSA9PiB7XG4gIC8vIFdlIGRvbid0IHJlYWxseSBrbm93IHRoZSB0eXBlcyBoZXJlLCBzbyB3ZSBhZGQgdGhlbSBsYXRlciBpbnN0ZWFkXG4gIDsoc2luZ2xldG9uUm91dGVyIGFzIGFueSlbZmllbGRdID0gKC4uLmFyZ3M6IGFueVtdKSA9PiB7XG4gICAgY29uc3Qgcm91dGVyID0gZ2V0Um91dGVyKCkgYXMgYW55XG4gICAgcmV0dXJuIHJvdXRlcltmaWVsZF0oLi4uYXJncylcbiAgfVxufSlcblxucm91dGVyRXZlbnRzLmZvckVhY2goKGV2ZW50KSA9PiB7XG4gIHNpbmdsZXRvblJvdXRlci5yZWFkeSgoKSA9PiB7XG4gICAgUm91dGVyLmV2ZW50cy5vbihldmVudCwgKC4uLmFyZ3MpID0+IHtcbiAgICAgIGNvbnN0IGV2ZW50RmllbGQgPSBgb24ke2V2ZW50LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpfSR7ZXZlbnQuc3Vic3RyaW5nKFxuICAgICAgICAxXG4gICAgICApfWBcbiAgICAgIGNvbnN0IF9zaW5nbGV0b25Sb3V0ZXIgPSBzaW5nbGV0b25Sb3V0ZXIgYXMgYW55XG4gICAgICBpZiAoX3NpbmdsZXRvblJvdXRlcltldmVudEZpZWxkXSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIF9zaW5nbGV0b25Sb3V0ZXJbZXZlbnRGaWVsZF0oLi4uYXJncylcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWNvbnNvbGVcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciB3aGVuIHJ1bm5pbmcgdGhlIFJvdXRlciBldmVudDogJHtldmVudEZpZWxkfWApXG4gICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWNvbnNvbGVcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGAke2Vyci5tZXNzYWdlfVxcbiR7ZXJyLnN0YWNrfWApXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuICB9KVxufSlcblxuZnVuY3Rpb24gZ2V0Um91dGVyKCk6IFJvdXRlciB7XG4gIGlmICghc2luZ2xldG9uUm91dGVyLnJvdXRlcikge1xuICAgIGNvbnN0IG1lc3NhZ2UgPVxuICAgICAgJ05vIHJvdXRlciBpbnN0YW5jZSBmb3VuZC5cXG4nICtcbiAgICAgICdZb3Ugc2hvdWxkIG9ubHkgdXNlIFwibmV4dC9yb3V0ZXJcIiBpbnNpZGUgdGhlIGNsaWVudCBzaWRlIG9mIHlvdXIgYXBwLlxcbidcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSlcbiAgfVxuICByZXR1cm4gc2luZ2xldG9uUm91dGVyLnJvdXRlclxufVxuXG4vLyBFeHBvcnQgdGhlIHNpbmdsZXRvblJvdXRlciBhbmQgdGhpcyBpcyB0aGUgcHVibGljIEFQSS5cbmV4cG9ydCBkZWZhdWx0IHNpbmdsZXRvblJvdXRlciBhcyBTaW5nbGV0b25Sb3V0ZXJcblxuLy8gUmVleHBvcnQgdGhlIHdpdGhSb3V0ZSBIT0NcbmV4cG9ydCB7IGRlZmF1bHQgYXMgd2l0aFJvdXRlciB9IGZyb20gJy4vd2l0aC1yb3V0ZXInXG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VSb3V0ZXIoKTogTmV4dFJvdXRlciB7XG4gIHJldHVybiBSZWFjdC51c2VDb250ZXh0KFJvdXRlckNvbnRleHQpXG59XG5cbi8vIElOVEVSTkFMIEFQSVNcbi8vIC0tLS0tLS0tLS0tLS1cbi8vIChkbyBub3QgdXNlIGZvbGxvd2luZyBleHBvcnRzIGluc2lkZSB0aGUgYXBwKVxuXG4vLyBDcmVhdGUgYSByb3V0ZXIgYW5kIGFzc2lnbiBpdCBhcyB0aGUgc2luZ2xldG9uIGluc3RhbmNlLlxuLy8gVGhpcyBpcyB1c2VkIGluIGNsaWVudCBzaWRlIHdoZW4gd2UgYXJlIGluaXRpbGl6aW5nIHRoZSBhcHAuXG4vLyBUaGlzIHNob3VsZCAqKm5vdCoqIHVzZSBpbnNpZGUgdGhlIHNlcnZlci5cbmV4cG9ydCBjb25zdCBjcmVhdGVSb3V0ZXIgPSAoLi4uYXJnczogUm91dGVyQXJncyk6IFJvdXRlciA9PiB7XG4gIHNpbmdsZXRvblJvdXRlci5yb3V0ZXIgPSBuZXcgUm91dGVyKC4uLmFyZ3MpXG4gIHNpbmdsZXRvblJvdXRlci5yZWFkeUNhbGxiYWNrcy5mb3JFYWNoKChjYikgPT4gY2IoKSlcbiAgc2luZ2xldG9uUm91dGVyLnJlYWR5Q2FsbGJhY2tzID0gW11cblxuICByZXR1cm4gc2luZ2xldG9uUm91dGVyLnJvdXRlclxufVxuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gY3JlYXRlIHRoZSBgd2l0aFJvdXRlcmAgcm91dGVyIGluc3RhbmNlXG5leHBvcnQgZnVuY3Rpb24gbWFrZVB1YmxpY1JvdXRlckluc3RhbmNlKHJvdXRlcjogUm91dGVyKTogTmV4dFJvdXRlciB7XG4gIGNvbnN0IF9yb3V0ZXIgPSByb3V0ZXIgYXMgYW55XG4gIGNvbnN0IGluc3RhbmNlID0ge30gYXMgYW55XG5cbiAgZm9yIChjb25zdCBwcm9wZXJ0eSBvZiB1cmxQcm9wZXJ0eUZpZWxkcykge1xuICAgIGlmICh0eXBlb2YgX3JvdXRlcltwcm9wZXJ0eV0gPT09ICdvYmplY3QnKSB7XG4gICAgICBpbnN0YW5jZVtwcm9wZXJ0eV0gPSBPYmplY3QuYXNzaWduKHt9LCBfcm91dGVyW3Byb3BlcnR5XSkgLy8gbWFrZXMgc3VyZSBxdWVyeSBpcyBub3Qgc3RhdGVmdWxcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgaW5zdGFuY2VbcHJvcGVydHldID0gX3JvdXRlcltwcm9wZXJ0eV1cbiAgfVxuXG4gIC8vIEV2ZW50cyBpcyBhIHN0YXRpYyBwcm9wZXJ0eSBvbiB0aGUgcm91dGVyLCB0aGUgcm91dGVyIGRvZXNuJ3QgaGF2ZSB0byBiZSBpbml0aWFsaXplZCB0byB1c2UgaXRcbiAgaW5zdGFuY2UuZXZlbnRzID0gUm91dGVyLmV2ZW50c1xuXG4gIGNvcmVNZXRob2RGaWVsZHMuZm9yRWFjaCgoZmllbGQpID0+IHtcbiAgICBpbnN0YW5jZVtmaWVsZF0gPSAoLi4uYXJnczogYW55W10pID0+IHtcbiAgICAgIHJldHVybiBfcm91dGVyW2ZpZWxkXSguLi5hcmdzKVxuICAgIH1cbiAgfSlcblxuICByZXR1cm4gaW5zdGFuY2Vcbn1cbiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcbmltcG9ydCB7IE5leHRDb21wb25lbnRUeXBlLCBOZXh0UGFnZUNvbnRleHQgfSBmcm9tICcuLi9uZXh0LXNlcnZlci9saWIvdXRpbHMnXG5pbXBvcnQgeyBOZXh0Um91dGVyLCB1c2VSb3V0ZXIgfSBmcm9tICcuL3JvdXRlcidcblxuZXhwb3J0IHR5cGUgV2l0aFJvdXRlclByb3BzID0ge1xuICByb3V0ZXI6IE5leHRSb3V0ZXJcbn1cblxuZXhwb3J0IHR5cGUgRXhjbHVkZVJvdXRlclByb3BzPFA+ID0gUGljazxcbiAgUCxcbiAgRXhjbHVkZTxrZXlvZiBQLCBrZXlvZiBXaXRoUm91dGVyUHJvcHM+XG4+XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHdpdGhSb3V0ZXI8XG4gIFAgZXh0ZW5kcyBXaXRoUm91dGVyUHJvcHMsXG4gIEMgPSBOZXh0UGFnZUNvbnRleHRcbj4oXG4gIENvbXBvc2VkQ29tcG9uZW50OiBOZXh0Q29tcG9uZW50VHlwZTxDLCBhbnksIFA+XG4pOiBSZWFjdC5Db21wb25lbnRUeXBlPEV4Y2x1ZGVSb3V0ZXJQcm9wczxQPj4ge1xuICBmdW5jdGlvbiBXaXRoUm91dGVyV3JhcHBlcihwcm9wczogYW55KSB7XG4gICAgcmV0dXJuIDxDb21wb3NlZENvbXBvbmVudCByb3V0ZXI9e3VzZVJvdXRlcigpfSB7Li4ucHJvcHN9IC8+XG4gIH1cblxuICBXaXRoUm91dGVyV3JhcHBlci5nZXRJbml0aWFsUHJvcHMgPSBDb21wb3NlZENvbXBvbmVudC5nZXRJbml0aWFsUHJvcHNcbiAgLy8gVGhpcyBpcyBuZWVkZWQgdG8gYWxsb3cgY2hlY2tpbmcgZm9yIGN1c3RvbSBnZXRJbml0aWFsUHJvcHMgaW4gX2FwcFxuICA7KFdpdGhSb3V0ZXJXcmFwcGVyIGFzIGFueSkub3JpZ0dldEluaXRpYWxQcm9wcyA9IChDb21wb3NlZENvbXBvbmVudCBhcyBhbnkpLm9yaWdHZXRJbml0aWFsUHJvcHNcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjb25zdCBuYW1lID1cbiAgICAgIENvbXBvc2VkQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvc2VkQ29tcG9uZW50Lm5hbWUgfHwgJ1Vua25vd24nXG4gICAgV2l0aFJvdXRlcldyYXBwZXIuZGlzcGxheU5hbWUgPSBgd2l0aFJvdXRlcigke25hbWV9KWBcbiAgfVxuXG4gIHJldHVybiBXaXRoUm91dGVyV3JhcHBlclxufVxuIiwibW9kdWxlLmV4cG9ydHM9ZnVuY3Rpb24oZSxyKXtcInVzZSBzdHJpY3RcIjt2YXIgdD17fTtmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKHIpe2lmKHRbcl0pe3JldHVybiB0W3JdLmV4cG9ydHN9dmFyIG49dFtyXT17aTpyLGw6ZmFsc2UsZXhwb3J0czp7fX07ZVtyXS5jYWxsKG4uZXhwb3J0cyxuLG4uZXhwb3J0cyxfX3dlYnBhY2tfcmVxdWlyZV9fKTtuLmw9dHJ1ZTtyZXR1cm4gbi5leHBvcnRzfV9fd2VicGFja19yZXF1aXJlX18uYWI9X19kaXJuYW1lK1wiL1wiO2Z1bmN0aW9uIHN0YXJ0dXAoKXtyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyg4NTUpfXJldHVybiBzdGFydHVwKCl9KHs4NDk6ZnVuY3Rpb24oZSl7XCJ1c2Ugc3RyaWN0XCI7ZS5leHBvcnRzPSgoe29ubHlGaXJzdDplPWZhbHNlfT17fSk9Pntjb25zdCByPVtcIltcXFxcdTAwMUJcXFxcdTAwOUJdW1tcXFxcXSgpIzs/XSooPzooPzooPzpbYS16QS1aXFxcXGRdKig/OjtbLWEtekEtWlxcXFxkXFxcXC8jJi46PT8lQH5fXSopKik/XFxcXHUwMDA3KVwiLFwiKD86KD86XFxcXGR7MSw0fSg/OjtcXFxcZHswLDR9KSopP1tcXFxcZEEtUFItVFpjZi1udHFyeT0+PH5dKSlcIl0uam9pbihcInxcIik7cmV0dXJuIG5ldyBSZWdFeHAocixlP3VuZGVmaW5lZDpcImdcIil9KX0sODU1OmZ1bmN0aW9uKGUscix0KXtcInVzZSBzdHJpY3RcIjtjb25zdCBuPXQoODQ5KTtlLmV4cG9ydHM9KGU9PnR5cGVvZiBlPT09XCJzdHJpbmdcIj9lLnJlcGxhY2UobigpLFwiXCIpOmUpfX0pOyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcblxuZXhwb3J0IGNvbnN0IEhlYWRNYW5hZ2VyQ29udGV4dDogUmVhY3QuQ29udGV4dDxhbnk+ID0gUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKVxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBIZWFkTWFuYWdlckNvbnRleHQuZGlzcGxheU5hbWUgPSAnSGVhZE1hbmFnZXJDb250ZXh0J1xufVxuIiwiLypcbk1JVCBMaWNlbnNlXG5cbkNvcHlyaWdodCAoYykgSmFzb24gTWlsbGVyIChodHRwczovL2phc29uZm9ybWF0LmNvbS8pXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiovXG5cbi8vIFRoaXMgZmlsZSBpcyBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vZGV2ZWxvcGl0L21pdHQvYmxvYi92MS4xLjMvc3JjL2luZGV4LmpzXG4vLyBJdCdzIGJlZW4gZWRpdGVkIGZvciB0aGUgbmVlZHMgb2YgdGhpcyBzY3JpcHRcbi8vIFNlZSB0aGUgTElDRU5TRSBhdCB0aGUgdG9wIG9mIHRoZSBmaWxlXG5cbnR5cGUgSGFuZGxlciA9ICguLi5ldnRzOiBhbnlbXSkgPT4gdm9pZFxuXG5leHBvcnQgdHlwZSBNaXR0RW1pdHRlciA9IHtcbiAgb24odHlwZTogc3RyaW5nLCBoYW5kbGVyOiBIYW5kbGVyKTogdm9pZFxuICBvZmYodHlwZTogc3RyaW5nLCBoYW5kbGVyOiBIYW5kbGVyKTogdm9pZFxuICBlbWl0KHR5cGU6IHN0cmluZywgLi4uZXZ0czogYW55W10pOiB2b2lkXG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG1pdHQoKTogTWl0dEVtaXR0ZXIge1xuICBjb25zdCBhbGw6IHsgW3M6IHN0cmluZ106IEhhbmRsZXJbXSB9ID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuXG4gIHJldHVybiB7XG4gICAgb24odHlwZTogc3RyaW5nLCBoYW5kbGVyOiBIYW5kbGVyKSB7XG4gICAgICA7KGFsbFt0eXBlXSB8fCAoYWxsW3R5cGVdID0gW10pKS5wdXNoKGhhbmRsZXIpXG4gICAgfSxcblxuICAgIG9mZih0eXBlOiBzdHJpbmcsIGhhbmRsZXI6IEhhbmRsZXIpIHtcbiAgICAgIGlmIChhbGxbdHlwZV0pIHtcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWJpdHdpc2VcbiAgICAgICAgYWxsW3R5cGVdLnNwbGljZShhbGxbdHlwZV0uaW5kZXhPZihoYW5kbGVyKSA+Pj4gMCwgMSlcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZW1pdCh0eXBlOiBzdHJpbmcsIC4uLmV2dHM6IGFueVtdKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgYXJyYXktY2FsbGJhY2stcmV0dXJuXG4gICAgICA7KGFsbFt0eXBlXSB8fCBbXSkuc2xpY2UoKS5tYXAoKGhhbmRsZXI6IEhhbmRsZXIpID0+IHtcbiAgICAgICAgaGFuZGxlciguLi5ldnRzKVxuICAgICAgfSlcbiAgICB9LFxuICB9XG59XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBOZXh0Um91dGVyIH0gZnJvbSAnLi9yb3V0ZXIvcm91dGVyJ1xuXG5leHBvcnQgY29uc3QgUm91dGVyQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQ8TmV4dFJvdXRlcj4obnVsbCBhcyBhbnkpXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIFJvdXRlckNvbnRleHQuZGlzcGxheU5hbWUgPSAnUm91dGVyQ29udGV4dCdcbn1cbiIsIi8qIGdsb2JhbCBfX05FWFRfREFUQV9fICovXG4vLyB0c2xpbnQ6ZGlzYWJsZTpuby1jb25zb2xlXG5pbXBvcnQgeyBQYXJzZWRVcmxRdWVyeSB9IGZyb20gJ3F1ZXJ5c3RyaW5nJ1xuaW1wb3J0IHsgQ29tcG9uZW50VHlwZSB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgcGFyc2UsIFVybE9iamVjdCB9IGZyb20gJ3VybCdcbmltcG9ydCBtaXR0LCB7IE1pdHRFbWl0dGVyIH0gZnJvbSAnLi4vbWl0dCdcbmltcG9ydCB7XG4gIEFwcENvbnRleHRUeXBlLFxuICBmb3JtYXRXaXRoVmFsaWRhdGlvbixcbiAgZ2V0VVJMLFxuICBsb2FkR2V0SW5pdGlhbFByb3BzLFxuICBOZXh0UGFnZUNvbnRleHQsXG4gIFNULFxufSBmcm9tICcuLi91dGlscydcbmltcG9ydCB7IGlzRHluYW1pY1JvdXRlIH0gZnJvbSAnLi91dGlscy9pcy1keW5hbWljJ1xuaW1wb3J0IHsgZ2V0Um91dGVNYXRjaGVyIH0gZnJvbSAnLi91dGlscy9yb3V0ZS1tYXRjaGVyJ1xuaW1wb3J0IHsgZ2V0Um91dGVSZWdleCB9IGZyb20gJy4vdXRpbHMvcm91dGUtcmVnZXgnXG5cbmNvbnN0IGJhc2VQYXRoID0gKHByb2Nlc3MuZW52Ll9fTkVYVF9ST1VURVJfQkFTRVBBVEggYXMgc3RyaW5nKSB8fCAnJ1xuXG5leHBvcnQgZnVuY3Rpb24gYWRkQmFzZVBhdGgocGF0aDogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIHBhdGguaW5kZXhPZihiYXNlUGF0aCkgIT09IDAgPyBiYXNlUGF0aCArIHBhdGggOiBwYXRoXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWxCYXNlUGF0aChwYXRoOiBzdHJpbmcpOiBzdHJpbmcge1xuICByZXR1cm4gcGF0aC5pbmRleE9mKGJhc2VQYXRoKSA9PT0gMFxuICAgID8gcGF0aC5zdWJzdHIoYmFzZVBhdGgubGVuZ3RoKSB8fCAnLydcbiAgICA6IHBhdGhcbn1cblxuZnVuY3Rpb24gdG9Sb3V0ZShwYXRoOiBzdHJpbmcpOiBzdHJpbmcge1xuICByZXR1cm4gcGF0aC5yZXBsYWNlKC9cXC8kLywgJycpIHx8ICcvJ1xufVxuXG5jb25zdCBwcmVwYXJlUm91dGUgPSAocGF0aDogc3RyaW5nKSA9PlxuICB0b1JvdXRlKCFwYXRoIHx8IHBhdGggPT09ICcvJyA/ICcvaW5kZXgnIDogcGF0aClcblxudHlwZSBVcmwgPSBVcmxPYmplY3QgfCBzdHJpbmdcblxudHlwZSBDb21wb25lbnRSZXMgPSB7IHBhZ2U6IENvbXBvbmVudFR5cGU7IG1vZDogYW55IH1cblxuZXhwb3J0IHR5cGUgQmFzZVJvdXRlciA9IHtcbiAgcm91dGU6IHN0cmluZ1xuICBwYXRobmFtZTogc3RyaW5nXG4gIHF1ZXJ5OiBQYXJzZWRVcmxRdWVyeVxuICBhc1BhdGg6IHN0cmluZ1xuICBiYXNlUGF0aDogc3RyaW5nXG59XG5cbmV4cG9ydCB0eXBlIE5leHRSb3V0ZXIgPSBCYXNlUm91dGVyICZcbiAgUGljazxcbiAgICBSb3V0ZXIsXG4gICAgfCAncHVzaCdcbiAgICB8ICdyZXBsYWNlJ1xuICAgIHwgJ3JlbG9hZCdcbiAgICB8ICdiYWNrJ1xuICAgIHwgJ3ByZWZldGNoJ1xuICAgIHwgJ2JlZm9yZVBvcFN0YXRlJ1xuICAgIHwgJ2V2ZW50cydcbiAgICB8ICdpc0ZhbGxiYWNrJ1xuICA+XG5cbmV4cG9ydCB0eXBlIFByZWZldGNoT3B0aW9ucyA9IHtcbiAgcHJpb3JpdHk/OiBib29sZWFuXG59XG5cbnR5cGUgUm91dGVJbmZvID0ge1xuICBDb21wb25lbnQ6IENvbXBvbmVudFR5cGVcbiAgX19OX1NTRz86IGJvb2xlYW5cbiAgX19OX1NTUD86IGJvb2xlYW5cbiAgcHJvcHM/OiBhbnlcbiAgZXJyPzogRXJyb3JcbiAgZXJyb3I/OiBhbnlcbn1cblxudHlwZSBTdWJzY3JpcHRpb24gPSAoZGF0YTogUm91dGVJbmZvLCBBcHA/OiBDb21wb25lbnRUeXBlKSA9PiBQcm9taXNlPHZvaWQ+XG5cbnR5cGUgQmVmb3JlUG9wU3RhdGVDYWxsYmFjayA9IChzdGF0ZTogYW55KSA9PiBib29sZWFuXG5cbnR5cGUgQ29tcG9uZW50TG9hZENhbmNlbCA9ICgoKSA9PiB2b2lkKSB8IG51bGxcblxudHlwZSBIaXN0b3J5TWV0aG9kID0gJ3JlcGxhY2VTdGF0ZScgfCAncHVzaFN0YXRlJ1xuXG5mdW5jdGlvbiBmZXRjaE5leHREYXRhKFxuICBwYXRobmFtZTogc3RyaW5nLFxuICBxdWVyeTogUGFyc2VkVXJsUXVlcnkgfCBudWxsLFxuICBpc1NlcnZlclJlbmRlcjogYm9vbGVhbixcbiAgY2I/OiAoLi4uYXJnczogYW55KSA9PiBhbnlcbikge1xuICBsZXQgYXR0ZW1wdHMgPSBpc1NlcnZlclJlbmRlciA/IDMgOiAxXG4gIGZ1bmN0aW9uIGdldFJlc3BvbnNlKCk6IFByb21pc2U8YW55PiB7XG4gICAgcmV0dXJuIGZldGNoKFxuICAgICAgZm9ybWF0V2l0aFZhbGlkYXRpb24oe1xuICAgICAgICBwYXRobmFtZTogYWRkQmFzZVBhdGgoXG4gICAgICAgICAgLy8gQHRzLWlnbm9yZSBfX05FWFRfREFUQV9fXG4gICAgICAgICAgYC9fbmV4dC9kYXRhLyR7X19ORVhUX0RBVEFfXy5idWlsZElkfSR7ZGVsQmFzZVBhdGgocGF0aG5hbWUpfS5qc29uYFxuICAgICAgICApLFxuICAgICAgICBxdWVyeSxcbiAgICAgIH0pLFxuICAgICAge1xuICAgICAgICAvLyBDb29raWVzIGFyZSByZXF1aXJlZCB0byBiZSBwcmVzZW50IGZvciBOZXh0LmpzJyBTU0cgXCJQcmV2aWV3IE1vZGVcIi5cbiAgICAgICAgLy8gQ29va2llcyBtYXkgYWxzbyBiZSByZXF1aXJlZCBmb3IgYGdldFNlcnZlclNpZGVQcm9wc2AuXG4gICAgICAgIC8vXG4gICAgICAgIC8vID4gYGZldGNoYCB3b27igJl0IHNlbmQgY29va2llcywgdW5sZXNzIHlvdSBzZXQgdGhlIGNyZWRlbnRpYWxzIGluaXRcbiAgICAgICAgLy8gPiBvcHRpb24uXG4gICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9GZXRjaF9BUEkvVXNpbmdfRmV0Y2hcbiAgICAgICAgLy9cbiAgICAgICAgLy8gPiBGb3IgbWF4aW11bSBicm93c2VyIGNvbXBhdGliaWxpdHkgd2hlbiBpdCBjb21lcyB0byBzZW5kaW5nICZcbiAgICAgICAgLy8gPiByZWNlaXZpbmcgY29va2llcywgYWx3YXlzIHN1cHBseSB0aGUgYGNyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nYFxuICAgICAgICAvLyA+IG9wdGlvbiBpbnN0ZWFkIG9mIHJlbHlpbmcgb24gdGhlIGRlZmF1bHQuXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9naXRodWIvZmV0Y2gjY2F2ZWF0c1xuICAgICAgICBjcmVkZW50aWFsczogJ3NhbWUtb3JpZ2luJyxcbiAgICAgIH1cbiAgICApLnRoZW4oKHJlcykgPT4ge1xuICAgICAgaWYgKCFyZXMub2spIHtcbiAgICAgICAgaWYgKC0tYXR0ZW1wdHMgPiAwICYmIHJlcy5zdGF0dXMgPj0gNTAwKSB7XG4gICAgICAgICAgcmV0dXJuIGdldFJlc3BvbnNlKClcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBsb2FkIHN0YXRpYyBwcm9wc2ApXG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzLmpzb24oKVxuICAgIH0pXG4gIH1cblxuICByZXR1cm4gZ2V0UmVzcG9uc2UoKVxuICAgIC50aGVuKChkYXRhKSA9PiB7XG4gICAgICByZXR1cm4gY2IgPyBjYihkYXRhKSA6IGRhdGFcbiAgICB9KVxuICAgIC5jYXRjaCgoZXJyOiBFcnJvcikgPT4ge1xuICAgICAgLy8gV2Ugc2hvdWxkIG9ubHkgdHJpZ2dlciBhIHNlcnZlci1zaWRlIHRyYW5zaXRpb24gaWYgdGhpcyB3YXMgY2F1c2VkXG4gICAgICAvLyBvbiBhIGNsaWVudC1zaWRlIHRyYW5zaXRpb24uIE90aGVyd2lzZSwgd2UnZCBnZXQgaW50byBhbiBpbmZpbml0ZVxuICAgICAgLy8gbG9vcC5cbiAgICAgIGlmICghaXNTZXJ2ZXJSZW5kZXIpIHtcbiAgICAgICAgOyhlcnIgYXMgYW55KS5jb2RlID0gJ1BBR0VfTE9BRF9FUlJPUidcbiAgICAgIH1cbiAgICAgIHRocm93IGVyclxuICAgIH0pXG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJvdXRlciBpbXBsZW1lbnRzIEJhc2VSb3V0ZXIge1xuICByb3V0ZTogc3RyaW5nXG4gIHBhdGhuYW1lOiBzdHJpbmdcbiAgcXVlcnk6IFBhcnNlZFVybFF1ZXJ5XG4gIGFzUGF0aDogc3RyaW5nXG4gIGJhc2VQYXRoOiBzdHJpbmdcblxuICAvKipcbiAgICogTWFwIG9mIGFsbCBjb21wb25lbnRzIGxvYWRlZCBpbiBgUm91dGVyYFxuICAgKi9cbiAgY29tcG9uZW50czogeyBbcGF0aG5hbWU6IHN0cmluZ106IFJvdXRlSW5mbyB9XG4gIC8vIFN0YXRpYyBEYXRhIENhY2hlXG4gIHNkYzogeyBbYXNQYXRoOiBzdHJpbmddOiBvYmplY3QgfSA9IHt9XG4gIHN1YjogU3Vic2NyaXB0aW9uXG4gIGNsYzogQ29tcG9uZW50TG9hZENhbmNlbFxuICBwYWdlTG9hZGVyOiBhbnlcbiAgX2JwczogQmVmb3JlUG9wU3RhdGVDYWxsYmFjayB8IHVuZGVmaW5lZFxuICBldmVudHM6IE1pdHRFbWl0dGVyXG4gIF93cmFwQXBwOiAoQXBwOiBDb21wb25lbnRUeXBlKSA9PiBhbnlcbiAgaXNTc3I6IGJvb2xlYW5cbiAgaXNGYWxsYmFjazogYm9vbGVhblxuXG4gIHN0YXRpYyBldmVudHM6IE1pdHRFbWl0dGVyID0gbWl0dCgpXG5cbiAgY29uc3RydWN0b3IoXG4gICAgcGF0aG5hbWU6IHN0cmluZyxcbiAgICBxdWVyeTogUGFyc2VkVXJsUXVlcnksXG4gICAgYXM6IHN0cmluZyxcbiAgICB7XG4gICAgICBpbml0aWFsUHJvcHMsXG4gICAgICBwYWdlTG9hZGVyLFxuICAgICAgQXBwLFxuICAgICAgd3JhcEFwcCxcbiAgICAgIENvbXBvbmVudCxcbiAgICAgIGVycixcbiAgICAgIHN1YnNjcmlwdGlvbixcbiAgICAgIGlzRmFsbGJhY2ssXG4gICAgfToge1xuICAgICAgc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb25cbiAgICAgIGluaXRpYWxQcm9wczogYW55XG4gICAgICBwYWdlTG9hZGVyOiBhbnlcbiAgICAgIENvbXBvbmVudDogQ29tcG9uZW50VHlwZVxuICAgICAgQXBwOiBDb21wb25lbnRUeXBlXG4gICAgICB3cmFwQXBwOiAoQXBwOiBDb21wb25lbnRUeXBlKSA9PiBhbnlcbiAgICAgIGVycj86IEVycm9yXG4gICAgICBpc0ZhbGxiYWNrOiBib29sZWFuXG4gICAgfVxuICApIHtcbiAgICAvLyByZXByZXNlbnRzIHRoZSBjdXJyZW50IGNvbXBvbmVudCBrZXlcbiAgICB0aGlzLnJvdXRlID0gdG9Sb3V0ZShwYXRobmFtZSlcblxuICAgIC8vIHNldCB1cCB0aGUgY29tcG9uZW50IGNhY2hlIChieSByb3V0ZSBrZXlzKVxuICAgIHRoaXMuY29tcG9uZW50cyA9IHt9XG4gICAgLy8gV2Ugc2hvdWxkIG5vdCBrZWVwIHRoZSBjYWNoZSwgaWYgdGhlcmUncyBhbiBlcnJvclxuICAgIC8vIE90aGVyd2lzZSwgdGhpcyBjYXVzZSBpc3N1ZXMgd2hlbiB3aGVuIGdvaW5nIGJhY2sgYW5kXG4gICAgLy8gY29tZSBhZ2FpbiB0byB0aGUgZXJyb3JlZCBwYWdlLlxuICAgIGlmIChwYXRobmFtZSAhPT0gJy9fZXJyb3InKSB7XG4gICAgICB0aGlzLmNvbXBvbmVudHNbdGhpcy5yb3V0ZV0gPSB7XG4gICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgcHJvcHM6IGluaXRpYWxQcm9wcyxcbiAgICAgICAgZXJyLFxuICAgICAgICBfX05fU1NHOiBpbml0aWFsUHJvcHMgJiYgaW5pdGlhbFByb3BzLl9fTl9TU0csXG4gICAgICAgIF9fTl9TU1A6IGluaXRpYWxQcm9wcyAmJiBpbml0aWFsUHJvcHMuX19OX1NTUCxcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmNvbXBvbmVudHNbJy9fYXBwJ10gPSB7IENvbXBvbmVudDogQXBwIH1cblxuICAgIC8vIEJhY2t3YXJkcyBjb21wYXQgZm9yIFJvdXRlci5yb3V0ZXIuZXZlbnRzXG4gICAgLy8gVE9ETzogU2hvdWxkIGJlIHJlbW92ZSB0aGUgZm9sbG93aW5nIG1ham9yIHZlcnNpb24gYXMgaXQgd2FzIG5ldmVyIGRvY3VtZW50ZWRcbiAgICB0aGlzLmV2ZW50cyA9IFJvdXRlci5ldmVudHNcblxuICAgIHRoaXMucGFnZUxvYWRlciA9IHBhZ2VMb2FkZXJcbiAgICB0aGlzLnBhdGhuYW1lID0gcGF0aG5hbWVcbiAgICB0aGlzLnF1ZXJ5ID0gcXVlcnlcbiAgICAvLyBpZiBhdXRvIHByZXJlbmRlcmVkIGFuZCBkeW5hbWljIHJvdXRlIHdhaXQgdG8gdXBkYXRlIGFzUGF0aFxuICAgIC8vIHVudGlsIGFmdGVyIG1vdW50IHRvIHByZXZlbnQgaHlkcmF0aW9uIG1pc21hdGNoXG4gICAgdGhpcy5hc1BhdGggPVxuICAgICAgLy8gQHRzLWlnbm9yZSB0aGlzIGlzIHRlbXBvcmFyaWx5IGdsb2JhbCAoYXR0YWNoZWQgdG8gd2luZG93KVxuICAgICAgaXNEeW5hbWljUm91dGUocGF0aG5hbWUpICYmIF9fTkVYVF9EQVRBX18uYXV0b0V4cG9ydCA/IHBhdGhuYW1lIDogYXNcbiAgICB0aGlzLmJhc2VQYXRoID0gYmFzZVBhdGhcbiAgICB0aGlzLnN1YiA9IHN1YnNjcmlwdGlvblxuICAgIHRoaXMuY2xjID0gbnVsbFxuICAgIHRoaXMuX3dyYXBBcHAgPSB3cmFwQXBwXG4gICAgLy8gbWFrZSBzdXJlIHRvIGlnbm9yZSBleHRyYSBwb3BTdGF0ZSBpbiBzYWZhcmkgb24gbmF2aWdhdGluZ1xuICAgIC8vIGJhY2sgZnJvbSBleHRlcm5hbCBzaXRlXG4gICAgdGhpcy5pc1NzciA9IHRydWVcblxuICAgIHRoaXMuaXNGYWxsYmFjayA9IGlzRmFsbGJhY2tcblxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gbWFrZSBzdXJlIFwiYXNcIiBkb2Vzbid0IHN0YXJ0IHdpdGggZG91YmxlIHNsYXNoZXMgb3IgZWxzZSBpdCBjYW5cbiAgICAgIC8vIHRocm93IGFuIGVycm9yIGFzIGl0J3MgY29uc2lkZXJlZCBpbnZhbGlkXG4gICAgICBpZiAoYXMuc3Vic3RyKDAsIDIpICE9PSAnLy8nKSB7XG4gICAgICAgIC8vIGluIG9yZGVyIGZvciBgZS5zdGF0ZWAgdG8gd29yayBvbiB0aGUgYG9ucG9wc3RhdGVgIGV2ZW50XG4gICAgICAgIC8vIHdlIGhhdmUgdG8gcmVnaXN0ZXIgdGhlIGluaXRpYWwgcm91dGUgdXBvbiBpbml0aWFsaXphdGlvblxuICAgICAgICB0aGlzLmNoYW5nZVN0YXRlKFxuICAgICAgICAgICdyZXBsYWNlU3RhdGUnLFxuICAgICAgICAgIGZvcm1hdFdpdGhWYWxpZGF0aW9uKHsgcGF0aG5hbWUsIHF1ZXJ5IH0pLFxuICAgICAgICAgIGFzXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BvcHN0YXRlJywgdGhpcy5vblBvcFN0YXRlKVxuICAgIH1cbiAgfVxuXG4gIC8vIEBkZXByZWNhdGVkIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IGV2ZW4gdGhvdWdoIGl0J3MgYSBwcml2YXRlIG1ldGhvZC5cbiAgc3RhdGljIF9yZXdyaXRlVXJsRm9yTmV4dEV4cG9ydCh1cmw6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9FWFBPUlRfVFJBSUxJTkdfU0xBU0gpIHtcbiAgICAgIGNvbnN0IHJld3JpdGVVcmxGb3JOZXh0RXhwb3J0ID0gcmVxdWlyZSgnLi9yZXdyaXRlLXVybC1mb3ItZXhwb3J0JylcbiAgICAgICAgLnJld3JpdGVVcmxGb3JOZXh0RXhwb3J0XG4gICAgICByZXR1cm4gcmV3cml0ZVVybEZvck5leHRFeHBvcnQodXJsKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdXJsXG4gICAgfVxuICB9XG5cbiAgb25Qb3BTdGF0ZSA9IChlOiBQb3BTdGF0ZUV2ZW50KTogdm9pZCA9PiB7XG4gICAgaWYgKCFlLnN0YXRlKSB7XG4gICAgICAvLyBXZSBnZXQgc3RhdGUgYXMgdW5kZWZpbmVkIGZvciB0d28gcmVhc29ucy5cbiAgICAgIC8vICAxLiBXaXRoIG9sZGVyIHNhZmFyaSAoPCA4KSBhbmQgb2xkZXIgY2hyb21lICg8IDM0KVxuICAgICAgLy8gIDIuIFdoZW4gdGhlIFVSTCBjaGFuZ2VkIHdpdGggI1xuICAgICAgLy9cbiAgICAgIC8vIEluIHRoZSBib3RoIGNhc2VzLCB3ZSBkb24ndCBuZWVkIHRvIHByb2NlZWQgYW5kIGNoYW5nZSB0aGUgcm91dGUuXG4gICAgICAvLyAoYXMgaXQncyBhbHJlYWR5IGNoYW5nZWQpXG4gICAgICAvLyBCdXQgd2UgY2FuIHNpbXBseSByZXBsYWNlIHRoZSBzdGF0ZSB3aXRoIHRoZSBuZXcgY2hhbmdlcy5cbiAgICAgIC8vIEFjdHVhbGx5LCBmb3IgKDEpIHdlIGRvbid0IG5lZWQgdG8gbm90aGluZy4gQnV0IGl0J3MgaGFyZCB0byBkZXRlY3QgdGhhdCBldmVudC5cbiAgICAgIC8vIFNvLCBkb2luZyB0aGUgZm9sbG93aW5nIGZvciAoMSkgZG9lcyBubyBoYXJtLlxuICAgICAgY29uc3QgeyBwYXRobmFtZSwgcXVlcnkgfSA9IHRoaXNcbiAgICAgIHRoaXMuY2hhbmdlU3RhdGUoXG4gICAgICAgICdyZXBsYWNlU3RhdGUnLFxuICAgICAgICBmb3JtYXRXaXRoVmFsaWRhdGlvbih7IHBhdGhuYW1lLCBxdWVyeSB9KSxcbiAgICAgICAgZ2V0VVJMKClcbiAgICAgIClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIE1ha2Ugc3VyZSB3ZSBkb24ndCByZS1yZW5kZXIgb24gaW5pdGlhbCBsb2FkLFxuICAgIC8vIGNhbiBiZSBjYXVzZWQgYnkgbmF2aWdhdGluZyBiYWNrIGZyb20gYW4gZXh0ZXJuYWwgc2l0ZVxuICAgIGlmIChcbiAgICAgIGUuc3RhdGUgJiZcbiAgICAgIHRoaXMuaXNTc3IgJiZcbiAgICAgIGUuc3RhdGUuYXMgPT09IHRoaXMuYXNQYXRoICYmXG4gICAgICBwYXJzZShlLnN0YXRlLnVybCkucGF0aG5hbWUgPT09IHRoaXMucGF0aG5hbWVcbiAgICApIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIElmIHRoZSBkb3duc3RyZWFtIGFwcGxpY2F0aW9uIHJldHVybnMgZmFsc3ksIHJldHVybi5cbiAgICAvLyBUaGV5IHdpbGwgdGhlbiBiZSByZXNwb25zaWJsZSBmb3IgaGFuZGxpbmcgdGhlIGV2ZW50LlxuICAgIGlmICh0aGlzLl9icHMgJiYgIXRoaXMuX2JwcyhlLnN0YXRlKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgeyB1cmwsIGFzLCBvcHRpb25zIH0gPSBlLnN0YXRlXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICh0eXBlb2YgdXJsID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgYXMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAnYHBvcHN0YXRlYCBldmVudCB0cmlnZ2VyZWQgYnV0IGBldmVudC5zdGF0ZWAgZGlkIG5vdCBoYXZlIGB1cmxgIG9yIGBhc2AgaHR0cHM6Ly9lcnIuc2gvdmVyY2VsL25leHQuanMvcG9wc3RhdGUtc3RhdGUtZW1wdHknXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5yZXBsYWNlKHVybCwgYXMsIG9wdGlvbnMpXG4gIH1cblxuICB1cGRhdGUocm91dGU6IHN0cmluZywgbW9kOiBhbnkpIHtcbiAgICBjb25zdCBDb21wb25lbnQ6IENvbXBvbmVudFR5cGUgPSBtb2QuZGVmYXVsdCB8fCBtb2RcbiAgICBjb25zdCBkYXRhID0gdGhpcy5jb21wb25lbnRzW3JvdXRlXVxuICAgIGlmICghZGF0YSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgdXBkYXRlIHVuYXZhaWxhYmxlIHJvdXRlOiAke3JvdXRlfWApXG4gICAgfVxuXG4gICAgY29uc3QgbmV3RGF0YSA9IE9iamVjdC5hc3NpZ24oe30sIGRhdGEsIHtcbiAgICAgIENvbXBvbmVudCxcbiAgICAgIF9fTl9TU0c6IG1vZC5fX05fU1NHLFxuICAgICAgX19OX1NTUDogbW9kLl9fTl9TU1AsXG4gICAgfSlcbiAgICB0aGlzLmNvbXBvbmVudHNbcm91dGVdID0gbmV3RGF0YVxuXG4gICAgLy8gcGFnZXMvX2FwcC5qcyB1cGRhdGVkXG4gICAgaWYgKHJvdXRlID09PSAnL19hcHAnKSB7XG4gICAgICB0aGlzLm5vdGlmeSh0aGlzLmNvbXBvbmVudHNbdGhpcy5yb3V0ZV0pXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAocm91dGUgPT09IHRoaXMucm91dGUpIHtcbiAgICAgIHRoaXMubm90aWZ5KG5ld0RhdGEpXG4gICAgfVxuICB9XG5cbiAgcmVsb2FkKCk6IHZvaWQge1xuICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKVxuICB9XG5cbiAgLyoqXG4gICAqIEdvIGJhY2sgaW4gaGlzdG9yeVxuICAgKi9cbiAgYmFjaygpIHtcbiAgICB3aW5kb3cuaGlzdG9yeS5iYWNrKClcbiAgfVxuXG4gIC8qKlxuICAgKiBQZXJmb3JtcyBhIGBwdXNoU3RhdGVgIHdpdGggYXJndW1lbnRzXG4gICAqIEBwYXJhbSB1cmwgb2YgdGhlIHJvdXRlXG4gICAqIEBwYXJhbSBhcyBtYXNrcyBgdXJsYCBmb3IgdGhlIGJyb3dzZXJcbiAgICogQHBhcmFtIG9wdGlvbnMgb2JqZWN0IHlvdSBjYW4gZGVmaW5lIGBzaGFsbG93YCBhbmQgb3RoZXIgb3B0aW9uc1xuICAgKi9cbiAgcHVzaCh1cmw6IFVybCwgYXM6IFVybCA9IHVybCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhbmdlKCdwdXNoU3RhdGUnLCB1cmwsIGFzLCBvcHRpb25zKVxuICB9XG5cbiAgLyoqXG4gICAqIFBlcmZvcm1zIGEgYHJlcGxhY2VTdGF0ZWAgd2l0aCBhcmd1bWVudHNcbiAgICogQHBhcmFtIHVybCBvZiB0aGUgcm91dGVcbiAgICogQHBhcmFtIGFzIG1hc2tzIGB1cmxgIGZvciB0aGUgYnJvd3NlclxuICAgKiBAcGFyYW0gb3B0aW9ucyBvYmplY3QgeW91IGNhbiBkZWZpbmUgYHNoYWxsb3dgIGFuZCBvdGhlciBvcHRpb25zXG4gICAqL1xuICByZXBsYWNlKHVybDogVXJsLCBhczogVXJsID0gdXJsLCBvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5jaGFuZ2UoJ3JlcGxhY2VTdGF0ZScsIHVybCwgYXMsIG9wdGlvbnMpXG4gIH1cblxuICBjaGFuZ2UoXG4gICAgbWV0aG9kOiBIaXN0b3J5TWV0aG9kLFxuICAgIF91cmw6IFVybCxcbiAgICBfYXM6IFVybCxcbiAgICBvcHRpb25zOiBhbnlcbiAgKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGlmICghb3B0aW9ucy5faCkge1xuICAgICAgICB0aGlzLmlzU3NyID0gZmFsc2VcbiAgICAgIH1cbiAgICAgIC8vIG1hcmtpbmcgcm91dGUgY2hhbmdlcyBhcyBhIG5hdmlnYXRpb24gc3RhcnQgZW50cnlcbiAgICAgIGlmIChTVCkge1xuICAgICAgICBwZXJmb3JtYW5jZS5tYXJrKCdyb3V0ZUNoYW5nZScpXG4gICAgICB9XG5cbiAgICAgIC8vIElmIHVybCBhbmQgYXMgcHJvdmlkZWQgYXMgYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uLFxuICAgICAgLy8gd2UnbGwgZm9ybWF0IHRoZW0gaW50byB0aGUgc3RyaW5nIHZlcnNpb24gaGVyZS5cbiAgICAgIGxldCB1cmwgPSB0eXBlb2YgX3VybCA9PT0gJ29iamVjdCcgPyBmb3JtYXRXaXRoVmFsaWRhdGlvbihfdXJsKSA6IF91cmxcbiAgICAgIGxldCBhcyA9IHR5cGVvZiBfYXMgPT09ICdvYmplY3QnID8gZm9ybWF0V2l0aFZhbGlkYXRpb24oX2FzKSA6IF9hc1xuXG4gICAgICB1cmwgPSBhZGRCYXNlUGF0aCh1cmwpXG4gICAgICBhcyA9IGFkZEJhc2VQYXRoKGFzKVxuXG4gICAgICAvLyBBZGQgdGhlIGVuZGluZyBzbGFzaCB0byB0aGUgcGF0aHMuIFNvLCB3ZSBjYW4gc2VydmUgdGhlXG4gICAgICAvLyBcIjxwYWdlPi9pbmRleC5odG1sXCIgZGlyZWN0bHkgZm9yIHRoZSBTU1IgcGFnZS5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfRVhQT1JUX1RSQUlMSU5HX1NMQVNIKSB7XG4gICAgICAgIGNvbnN0IHJld3JpdGVVcmxGb3JOZXh0RXhwb3J0ID0gcmVxdWlyZSgnLi9yZXdyaXRlLXVybC1mb3ItZXhwb3J0JylcbiAgICAgICAgICAucmV3cml0ZVVybEZvck5leHRFeHBvcnRcbiAgICAgICAgLy8gQHRzLWlnbm9yZSB0aGlzIGlzIHRlbXBvcmFyaWx5IGdsb2JhbCAoYXR0YWNoZWQgdG8gd2luZG93KVxuICAgICAgICBpZiAoX19ORVhUX0RBVEFfXy5uZXh0RXhwb3J0KSB7XG4gICAgICAgICAgYXMgPSByZXdyaXRlVXJsRm9yTmV4dEV4cG9ydChhcylcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLmFib3J0Q29tcG9uZW50TG9hZChhcylcblxuICAgICAgLy8gSWYgdGhlIHVybCBjaGFuZ2UgaXMgb25seSByZWxhdGVkIHRvIGEgaGFzaCBjaGFuZ2VcbiAgICAgIC8vIFdlIHNob3VsZCBub3QgcHJvY2VlZC4gV2Ugc2hvdWxkIG9ubHkgY2hhbmdlIHRoZSBzdGF0ZS5cblxuICAgICAgLy8gV0FSTklORzogYF9oYCBpcyBhbiBpbnRlcm5hbCBvcHRpb24gZm9yIGhhbmRpbmcgTmV4dC5qcyBjbGllbnQtc2lkZVxuICAgICAgLy8gaHlkcmF0aW9uLiBZb3VyIGFwcCBzaG91bGQgX25ldmVyXyB1c2UgdGhpcyBwcm9wZXJ0eS4gSXQgbWF5IGNoYW5nZSBhdFxuICAgICAgLy8gYW55IHRpbWUgd2l0aG91dCBub3RpY2UuXG4gICAgICBpZiAoIW9wdGlvbnMuX2ggJiYgdGhpcy5vbmx5QUhhc2hDaGFuZ2UoYXMpKSB7XG4gICAgICAgIHRoaXMuYXNQYXRoID0gYXNcbiAgICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KCdoYXNoQ2hhbmdlU3RhcnQnLCBhcylcbiAgICAgICAgdGhpcy5jaGFuZ2VTdGF0ZShtZXRob2QsIHVybCwgYXMsIG9wdGlvbnMpXG4gICAgICAgIHRoaXMuc2Nyb2xsVG9IYXNoKGFzKVxuICAgICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoJ2hhc2hDaGFuZ2VDb21wbGV0ZScsIGFzKVxuICAgICAgICByZXR1cm4gcmVzb2x2ZSh0cnVlKVxuICAgICAgfVxuXG4gICAgICBjb25zdCB7IHBhdGhuYW1lLCBxdWVyeSwgcHJvdG9jb2wgfSA9IHBhcnNlKHVybCwgdHJ1ZSlcblxuICAgICAgaWYgKCFwYXRobmFtZSB8fCBwcm90b2NvbCkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBJbnZhbGlkIGhyZWYgcGFzc2VkIHRvIHJvdXRlcjogJHt1cmx9IGh0dHBzOi8vZXJyLnNoL3ZlcmNlbC9uZXh0LmpzL2ludmFsaWQtaHJlZi1wYXNzZWRgXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNvbHZlKGZhbHNlKVxuICAgICAgfVxuXG4gICAgICAvLyBJZiBhc2tlZCB0byBjaGFuZ2UgdGhlIGN1cnJlbnQgVVJMIHdlIHNob3VsZCByZWxvYWQgdGhlIGN1cnJlbnQgcGFnZVxuICAgICAgLy8gKG5vdCBsb2NhdGlvbi5yZWxvYWQoKSBidXQgcmVsb2FkIGdldEluaXRpYWxQcm9wcyBhbmQgb3RoZXIgTmV4dC5qcyBzdHVmZnMpXG4gICAgICAvLyBXZSBhbHNvIG5lZWQgdG8gc2V0IHRoZSBtZXRob2QgPSByZXBsYWNlU3RhdGUgYWx3YXlzXG4gICAgICAvLyBhcyB0aGlzIHNob3VsZCBub3QgZ28gaW50byB0aGUgaGlzdG9yeSAoVGhhdCdzIGhvdyBicm93c2VycyB3b3JrKVxuICAgICAgLy8gV2Ugc2hvdWxkIGNvbXBhcmUgdGhlIG5ldyBhc1BhdGggdG8gdGhlIGN1cnJlbnQgYXNQYXRoLCBub3QgdGhlIHVybFxuICAgICAgaWYgKCF0aGlzLnVybElzTmV3KGFzKSkge1xuICAgICAgICBtZXRob2QgPSAncmVwbGFjZVN0YXRlJ1xuICAgICAgfVxuXG4gICAgICBjb25zdCByb3V0ZSA9IHRvUm91dGUocGF0aG5hbWUpXG4gICAgICBjb25zdCB7IHNoYWxsb3cgPSBmYWxzZSB9ID0gb3B0aW9uc1xuXG4gICAgICBpZiAoaXNEeW5hbWljUm91dGUocm91dGUpKSB7XG4gICAgICAgIGNvbnN0IHsgcGF0aG5hbWU6IGFzUGF0aG5hbWUgfSA9IHBhcnNlKGFzKVxuICAgICAgICBjb25zdCByb3V0ZVJlZ2V4ID0gZ2V0Um91dGVSZWdleChyb3V0ZSlcbiAgICAgICAgY29uc3Qgcm91dGVNYXRjaCA9IGdldFJvdXRlTWF0Y2hlcihyb3V0ZVJlZ2V4KShhc1BhdGhuYW1lKVxuICAgICAgICBpZiAoIXJvdXRlTWF0Y2gpIHtcbiAgICAgICAgICBjb25zdCBtaXNzaW5nUGFyYW1zID0gT2JqZWN0LmtleXMocm91dGVSZWdleC5ncm91cHMpLmZpbHRlcihcbiAgICAgICAgICAgIChwYXJhbSkgPT4gIXF1ZXJ5W3BhcmFtXVxuICAgICAgICAgIClcblxuICAgICAgICAgIGlmIChtaXNzaW5nUGFyYW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgICBgTWlzbWF0Y2hpbmcgXFxgYXNcXGAgYW5kIFxcYGhyZWZcXGAgZmFpbGVkIHRvIG1hbnVhbGx5IHByb3ZpZGUgYCArXG4gICAgICAgICAgICAgICAgICBgdGhlIHBhcmFtczogJHttaXNzaW5nUGFyYW1zLmpvaW4oXG4gICAgICAgICAgICAgICAgICAgICcsICdcbiAgICAgICAgICAgICAgICAgICl9IGluIHRoZSBcXGBocmVmXFxgJ3MgXFxgcXVlcnlcXGBgXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlamVjdChcbiAgICAgICAgICAgICAgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIGBUaGUgcHJvdmlkZWQgXFxgYXNcXGAgdmFsdWUgKCR7YXNQYXRobmFtZX0pIGlzIGluY29tcGF0aWJsZSB3aXRoIHRoZSBcXGBocmVmXFxgIHZhbHVlICgke3JvdXRlfSkuIGAgK1xuICAgICAgICAgICAgICAgICAgYFJlYWQgbW9yZTogaHR0cHM6Ly9lcnIuc2gvdmVyY2VsL25leHQuanMvaW5jb21wYXRpYmxlLWhyZWYtYXNgXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gTWVyZ2UgcGFyYW1zIGludG8gYHF1ZXJ5YCwgb3ZlcndyaXRpbmcgYW55IHNwZWNpZmllZCBpbiBzZWFyY2hcbiAgICAgICAgICBPYmplY3QuYXNzaWduKHF1ZXJ5LCByb3V0ZU1hdGNoKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgncm91dGVDaGFuZ2VTdGFydCcsIGFzKVxuXG4gICAgICAvLyBJZiBzaGFsbG93IGlzIHRydWUgYW5kIHRoZSByb3V0ZSBleGlzdHMgaW4gdGhlIHJvdXRlciBjYWNoZSB3ZSByZXVzZSB0aGUgcHJldmlvdXMgcmVzdWx0XG4gICAgICB0aGlzLmdldFJvdXRlSW5mbyhyb3V0ZSwgcGF0aG5hbWUsIHF1ZXJ5LCBhcywgc2hhbGxvdykudGhlbihcbiAgICAgICAgKHJvdXRlSW5mbykgPT4ge1xuICAgICAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IHJvdXRlSW5mb1xuXG4gICAgICAgICAgaWYgKGVycm9yICYmIGVycm9yLmNhbmNlbGxlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoZmFsc2UpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KCdiZWZvcmVIaXN0b3J5Q2hhbmdlJywgYXMpXG4gICAgICAgICAgdGhpcy5jaGFuZ2VTdGF0ZShtZXRob2QsIHVybCwgYXMsIG9wdGlvbnMpXG5cbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgY29uc3QgYXBwQ29tcDogYW55ID0gdGhpcy5jb21wb25lbnRzWycvX2FwcCddLkNvbXBvbmVudFxuICAgICAgICAgICAgOyh3aW5kb3cgYXMgYW55KS5uZXh0LmlzUHJlcmVuZGVyZWQgPVxuICAgICAgICAgICAgICBhcHBDb21wLmdldEluaXRpYWxQcm9wcyA9PT0gYXBwQ29tcC5vcmlnR2V0SW5pdGlhbFByb3BzICYmXG4gICAgICAgICAgICAgICEocm91dGVJbmZvLkNvbXBvbmVudCBhcyBhbnkpLmdldEluaXRpYWxQcm9wc1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuc2V0KHJvdXRlLCBwYXRobmFtZSwgcXVlcnksIGFzLCByb3V0ZUluZm8pLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgncm91dGVDaGFuZ2VFcnJvcicsIGVycm9yLCBhcylcbiAgICAgICAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KCdyb3V0ZUNoYW5nZUNvbXBsZXRlJywgYXMpXG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSh0cnVlKVxuICAgICAgICAgIH0pXG4gICAgICAgIH0sXG4gICAgICAgIHJlamVjdFxuICAgICAgKVxuICAgIH0pXG4gIH1cblxuICBjaGFuZ2VTdGF0ZShcbiAgICBtZXRob2Q6IEhpc3RvcnlNZXRob2QsXG4gICAgdXJsOiBzdHJpbmcsXG4gICAgYXM6IHN0cmluZyxcbiAgICBvcHRpb25zID0ge31cbiAgKTogdm9pZCB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICh0eXBlb2Ygd2luZG93Lmhpc3RvcnkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYFdhcm5pbmc6IHdpbmRvdy5oaXN0b3J5IGlzIG5vdCBhdmFpbGFibGUuYClcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2Ygd2luZG93Lmhpc3RvcnlbbWV0aG9kXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgV2FybmluZzogd2luZG93Lmhpc3RvcnkuJHttZXRob2R9IGlzIG5vdCBhdmFpbGFibGVgKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobWV0aG9kICE9PSAncHVzaFN0YXRlJyB8fCBnZXRVUkwoKSAhPT0gYXMpIHtcbiAgICAgIHdpbmRvdy5oaXN0b3J5W21ldGhvZF0oXG4gICAgICAgIHtcbiAgICAgICAgICB1cmwsXG4gICAgICAgICAgYXMsXG4gICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgfSxcbiAgICAgICAgLy8gTW9zdCBicm93c2VycyBjdXJyZW50bHkgaWdub3JlcyB0aGlzIHBhcmFtZXRlciwgYWx0aG91Z2ggdGhleSBtYXkgdXNlIGl0IGluIHRoZSBmdXR1cmUuXG4gICAgICAgIC8vIFBhc3NpbmcgdGhlIGVtcHR5IHN0cmluZyBoZXJlIHNob3VsZCBiZSBzYWZlIGFnYWluc3QgZnV0dXJlIGNoYW5nZXMgdG8gdGhlIG1ldGhvZC5cbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0hpc3RvcnkvcmVwbGFjZVN0YXRlXG4gICAgICAgICcnLFxuICAgICAgICBhc1xuICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIGdldFJvdXRlSW5mbyhcbiAgICByb3V0ZTogc3RyaW5nLFxuICAgIHBhdGhuYW1lOiBzdHJpbmcsXG4gICAgcXVlcnk6IGFueSxcbiAgICBhczogc3RyaW5nLFxuICAgIHNoYWxsb3c6IGJvb2xlYW4gPSBmYWxzZVxuICApOiBQcm9taXNlPFJvdXRlSW5mbz4ge1xuICAgIGNvbnN0IGNhY2hlZFJvdXRlSW5mbyA9IHRoaXMuY29tcG9uZW50c1tyb3V0ZV1cblxuICAgIC8vIElmIHRoZXJlIGlzIGEgc2hhbGxvdyByb3V0ZSB0cmFuc2l0aW9uIHBvc3NpYmxlXG4gICAgLy8gSWYgdGhlIHJvdXRlIGlzIGFscmVhZHkgcmVuZGVyZWQgb24gdGhlIHNjcmVlbi5cbiAgICBpZiAoc2hhbGxvdyAmJiBjYWNoZWRSb3V0ZUluZm8gJiYgdGhpcy5yb3V0ZSA9PT0gcm91dGUpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoY2FjaGVkUm91dGVJbmZvKVxuICAgIH1cblxuICAgIGNvbnN0IGhhbmRsZUVycm9yID0gKFxuICAgICAgZXJyOiBFcnJvciAmIHsgY29kZTogYW55OyBjYW5jZWxsZWQ6IGJvb2xlYW4gfSxcbiAgICAgIGxvYWRFcnJvckZhaWw/OiBib29sZWFuXG4gICAgKSA9PiB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgaWYgKGVyci5jb2RlID09PSAnUEFHRV9MT0FEX0VSUk9SJyB8fCBsb2FkRXJyb3JGYWlsKSB7XG4gICAgICAgICAgLy8gSWYgd2UgY2FuJ3QgbG9hZCB0aGUgcGFnZSBpdCBjb3VsZCBiZSBvbmUgb2YgZm9sbG93aW5nIHJlYXNvbnNcbiAgICAgICAgICAvLyAgMS4gUGFnZSBkb2Vzbid0IGV4aXN0c1xuICAgICAgICAgIC8vICAyLiBQYWdlIGRvZXMgZXhpc3QgaW4gYSBkaWZmZXJlbnQgem9uZVxuICAgICAgICAgIC8vICAzLiBJbnRlcm5hbCBlcnJvciB3aGlsZSBsb2FkaW5nIHRoZSBwYWdlXG5cbiAgICAgICAgICAvLyBTbywgZG9pbmcgYSBoYXJkIHJlbG9hZCBpcyB0aGUgcHJvcGVyIHdheSB0byBkZWFsIHdpdGggdGhpcy5cbiAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IGFzXG5cbiAgICAgICAgICAvLyBDaGFuZ2luZyB0aGUgVVJMIGRvZXNuJ3QgYmxvY2sgZXhlY3V0aW5nIHRoZSBjdXJyZW50IGNvZGUgcGF0aC5cbiAgICAgICAgICAvLyBTbywgd2UgbmVlZCB0byBtYXJrIGl0IGFzIGEgY2FuY2VsbGVkIGVycm9yIGFuZCBzdG9wIHRoZSByb3V0aW5nIGxvZ2ljLlxuICAgICAgICAgIGVyci5jYW5jZWxsZWQgPSB0cnVlXG4gICAgICAgICAgLy8gQHRzLWlnbm9yZSBUT0RPOiBmaXggdGhlIGNvbnRyb2wgZmxvdyBoZXJlXG4gICAgICAgICAgcmV0dXJuIHJlc29sdmUoeyBlcnJvcjogZXJyIH0pXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyLmNhbmNlbGxlZCkge1xuICAgICAgICAgIC8vIEB0cy1pZ25vcmUgVE9ETzogZml4IHRoZSBjb250cm9sIGZsb3cgaGVyZVxuICAgICAgICAgIHJldHVybiByZXNvbHZlKHsgZXJyb3I6IGVyciB9KVxuICAgICAgICB9XG5cbiAgICAgICAgcmVzb2x2ZShcbiAgICAgICAgICB0aGlzLmZldGNoQ29tcG9uZW50KCcvX2Vycm9yJylcbiAgICAgICAgICAgIC50aGVuKChyZXMpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgeyBwYWdlOiBDb21wb25lbnQgfSA9IHJlc1xuICAgICAgICAgICAgICBjb25zdCByb3V0ZUluZm86IFJvdXRlSW5mbyA9IHsgQ29tcG9uZW50LCBlcnIgfVxuICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmdldEluaXRpYWxQcm9wcyhDb21wb25lbnQsIHtcbiAgICAgICAgICAgICAgICAgIGVycixcbiAgICAgICAgICAgICAgICAgIHBhdGhuYW1lLFxuICAgICAgICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgICAgICAgfSBhcyBhbnkpLnRoZW4oXG4gICAgICAgICAgICAgICAgICAocHJvcHMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcm91dGVJbmZvLnByb3BzID0gcHJvcHNcbiAgICAgICAgICAgICAgICAgICAgcm91dGVJbmZvLmVycm9yID0gZXJyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUocm91dGVJbmZvKVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIChnaXBFcnIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAnRXJyb3IgaW4gZXJyb3IgcGFnZSBgZ2V0SW5pdGlhbFByb3BzYDogJyxcbiAgICAgICAgICAgICAgICAgICAgICBnaXBFcnJcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICByb3V0ZUluZm8uZXJyb3IgPSBlcnJcbiAgICAgICAgICAgICAgICAgICAgcm91dGVJbmZvLnByb3BzID0ge31cbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyb3V0ZUluZm8pXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICB9KSBhcyBQcm9taXNlPFJvdXRlSW5mbz5cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goKGVycikgPT4gaGFuZGxlRXJyb3IoZXJyLCB0cnVlKSlcbiAgICAgICAgKVxuICAgICAgfSkgYXMgUHJvbWlzZTxSb3V0ZUluZm8+XG4gICAgfVxuXG4gICAgcmV0dXJuIChuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAoY2FjaGVkUm91dGVJbmZvKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlKGNhY2hlZFJvdXRlSW5mbylcbiAgICAgIH1cblxuICAgICAgdGhpcy5mZXRjaENvbXBvbmVudChyb3V0ZSkudGhlbihcbiAgICAgICAgKHJlcykgPT5cbiAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgIENvbXBvbmVudDogcmVzLnBhZ2UsXG4gICAgICAgICAgICBfX05fU1NHOiByZXMubW9kLl9fTl9TU0csXG4gICAgICAgICAgICBfX05fU1NQOiByZXMubW9kLl9fTl9TU1AsXG4gICAgICAgICAgfSksXG4gICAgICAgIHJlamVjdFxuICAgICAgKVxuICAgIH0pIGFzIFByb21pc2U8Um91dGVJbmZvPilcbiAgICAgIC50aGVuKChyb3V0ZUluZm86IFJvdXRlSW5mbykgPT4ge1xuICAgICAgICBjb25zdCB7IENvbXBvbmVudCwgX19OX1NTRywgX19OX1NTUCB9ID0gcm91dGVJbmZvXG5cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBjb25zdCB7IGlzVmFsaWRFbGVtZW50VHlwZSB9ID0gcmVxdWlyZSgncmVhY3QtaXMnKVxuICAgICAgICAgIGlmICghaXNWYWxpZEVsZW1lbnRUeXBlKENvbXBvbmVudCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgYFRoZSBkZWZhdWx0IGV4cG9ydCBpcyBub3QgYSBSZWFjdCBDb21wb25lbnQgaW4gcGFnZTogXCIke3BhdGhuYW1lfVwiYFxuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9nZXREYXRhPFJvdXRlSW5mbz4oKCkgPT5cbiAgICAgICAgICBfX05fU1NHXG4gICAgICAgICAgICA/IHRoaXMuX2dldFN0YXRpY0RhdGEoYXMpXG4gICAgICAgICAgICA6IF9fTl9TU1BcbiAgICAgICAgICAgID8gdGhpcy5fZ2V0U2VydmVyRGF0YShhcylcbiAgICAgICAgICAgIDogdGhpcy5nZXRJbml0aWFsUHJvcHMoXG4gICAgICAgICAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICAgICAgICAgIC8vIHdlIHByb3ZpZGUgQXBwVHJlZSBsYXRlciBzbyB0aGlzIG5lZWRzIHRvIGJlIGBhbnlgXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgICAgICAgICAgICBxdWVyeSxcbiAgICAgICAgICAgICAgICAgIGFzUGF0aDogYXMsXG4gICAgICAgICAgICAgICAgfSBhcyBhbnlcbiAgICAgICAgICAgICAgKVxuICAgICAgICApLnRoZW4oKHByb3BzKSA9PiB7XG4gICAgICAgICAgcm91dGVJbmZvLnByb3BzID0gcHJvcHNcbiAgICAgICAgICB0aGlzLmNvbXBvbmVudHNbcm91dGVdID0gcm91dGVJbmZvXG4gICAgICAgICAgcmV0dXJuIHJvdXRlSW5mb1xuICAgICAgICB9KVxuICAgICAgfSlcbiAgICAgIC5jYXRjaChoYW5kbGVFcnJvcilcbiAgfVxuXG4gIHNldChcbiAgICByb3V0ZTogc3RyaW5nLFxuICAgIHBhdGhuYW1lOiBzdHJpbmcsXG4gICAgcXVlcnk6IGFueSxcbiAgICBhczogc3RyaW5nLFxuICAgIGRhdGE6IFJvdXRlSW5mb1xuICApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0aGlzLmlzRmFsbGJhY2sgPSBmYWxzZVxuXG4gICAgdGhpcy5yb3V0ZSA9IHJvdXRlXG4gICAgdGhpcy5wYXRobmFtZSA9IHBhdGhuYW1lXG4gICAgdGhpcy5xdWVyeSA9IHF1ZXJ5XG4gICAgdGhpcy5hc1BhdGggPSBhc1xuICAgIHJldHVybiB0aGlzLm5vdGlmeShkYXRhKVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIHRvIGV4ZWN1dGUgYmVmb3JlIHJlcGxhY2luZyByb3V0ZXIgc3RhdGVcbiAgICogQHBhcmFtIGNiIGNhbGxiYWNrIHRvIGJlIGV4ZWN1dGVkXG4gICAqL1xuICBiZWZvcmVQb3BTdGF0ZShjYjogQmVmb3JlUG9wU3RhdGVDYWxsYmFjaykge1xuICAgIHRoaXMuX2JwcyA9IGNiXG4gIH1cblxuICBvbmx5QUhhc2hDaGFuZ2UoYXM6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIGlmICghdGhpcy5hc1BhdGgpIHJldHVybiBmYWxzZVxuICAgIGNvbnN0IFtvbGRVcmxOb0hhc2gsIG9sZEhhc2hdID0gdGhpcy5hc1BhdGguc3BsaXQoJyMnKVxuICAgIGNvbnN0IFtuZXdVcmxOb0hhc2gsIG5ld0hhc2hdID0gYXMuc3BsaXQoJyMnKVxuXG4gICAgLy8gTWFrZXMgc3VyZSB3ZSBzY3JvbGwgdG8gdGhlIHByb3ZpZGVkIGhhc2ggaWYgdGhlIHVybC9oYXNoIGFyZSB0aGUgc2FtZVxuICAgIGlmIChuZXdIYXNoICYmIG9sZFVybE5vSGFzaCA9PT0gbmV3VXJsTm9IYXNoICYmIG9sZEhhc2ggPT09IG5ld0hhc2gpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIHVybHMgYXJlIGNoYW5nZSwgdGhlcmUncyBtb3JlIHRoYW4gYSBoYXNoIGNoYW5nZVxuICAgIGlmIChvbGRVcmxOb0hhc2ggIT09IG5ld1VybE5vSGFzaCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIGhhc2ggaGFzIGNoYW5nZWQsIHRoZW4gaXQncyBhIGhhc2ggb25seSBjaGFuZ2UuXG4gICAgLy8gVGhpcyBjaGVjayBpcyBuZWNlc3NhcnkgdG8gaGFuZGxlIGJvdGggdGhlIGVudGVyIGFuZFxuICAgIC8vIGxlYXZlIGhhc2ggPT09ICcnIGNhc2VzLiBUaGUgaWRlbnRpdHkgY2FzZSBmYWxscyB0aHJvdWdoXG4gICAgLy8gYW5kIGlzIHRyZWF0ZWQgYXMgYSBuZXh0IHJlbG9hZC5cbiAgICByZXR1cm4gb2xkSGFzaCAhPT0gbmV3SGFzaFxuICB9XG5cbiAgc2Nyb2xsVG9IYXNoKGFzOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBjb25zdCBbLCBoYXNoXSA9IGFzLnNwbGl0KCcjJylcbiAgICAvLyBTY3JvbGwgdG8gdG9wIGlmIHRoZSBoYXNoIGlzIGp1c3QgYCNgIHdpdGggbm8gdmFsdWVcbiAgICBpZiAoaGFzaCA9PT0gJycpIHtcbiAgICAgIHdpbmRvdy5zY3JvbGxUbygwLCAwKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gRmlyc3Qgd2UgY2hlY2sgaWYgdGhlIGVsZW1lbnQgYnkgaWQgaXMgZm91bmRcbiAgICBjb25zdCBpZEVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaGFzaClcbiAgICBpZiAoaWRFbCkge1xuICAgICAgaWRFbC5zY3JvbGxJbnRvVmlldygpXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgLy8gSWYgdGhlcmUncyBubyBlbGVtZW50IHdpdGggdGhlIGlkLCB3ZSBjaGVjayB0aGUgYG5hbWVgIHByb3BlcnR5XG4gICAgLy8gVG8gbWlycm9yIGJyb3dzZXJzXG4gICAgY29uc3QgbmFtZUVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUoaGFzaClbMF1cbiAgICBpZiAobmFtZUVsKSB7XG4gICAgICBuYW1lRWwuc2Nyb2xsSW50b1ZpZXcoKVxuICAgIH1cbiAgfVxuXG4gIHVybElzTmV3KGFzUGF0aDogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuYXNQYXRoICE9PSBhc1BhdGhcbiAgfVxuXG4gIC8qKlxuICAgKiBQcmVmZXRjaCBwYWdlIGNvZGUsIHlvdSBtYXkgd2FpdCBmb3IgdGhlIGRhdGEgZHVyaW5nIHBhZ2UgcmVuZGVyaW5nLlxuICAgKiBUaGlzIGZlYXR1cmUgb25seSB3b3JrcyBpbiBwcm9kdWN0aW9uIVxuICAgKiBAcGFyYW0gdXJsIHRoZSBocmVmIG9mIHByZWZldGNoZWQgcGFnZVxuICAgKiBAcGFyYW0gYXNQYXRoIHRoZSBhcyBwYXRoIG9mIHRoZSBwcmVmZXRjaGVkIHBhZ2VcbiAgICovXG4gIHByZWZldGNoKFxuICAgIHVybDogc3RyaW5nLFxuICAgIGFzUGF0aDogc3RyaW5nID0gdXJsLFxuICAgIG9wdGlvbnM6IFByZWZldGNoT3B0aW9ucyA9IHt9XG4gICk6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCB7IHBhdGhuYW1lLCBwcm90b2NvbCB9ID0gcGFyc2UodXJsKVxuXG4gICAgICBpZiAoIXBhdGhuYW1lIHx8IHByb3RvY29sKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYEludmFsaWQgaHJlZiBwYXNzZWQgdG8gcm91dGVyOiAke3VybH0gaHR0cHM6Ly9lcnIuc2gvdmVyY2VsL25leHQuanMvaW52YWxpZC1ocmVmLXBhc3NlZGBcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIFByZWZldGNoIGlzIG5vdCBzdXBwb3J0ZWQgaW4gZGV2ZWxvcG1lbnQgbW9kZSBiZWNhdXNlIGl0IHdvdWxkIHRyaWdnZXIgb24tZGVtYW5kLWVudHJpZXNcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgY29uc3Qgcm91dGUgPSBkZWxCYXNlUGF0aCh0b1JvdXRlKHBhdGhuYW1lKSlcbiAgICAgIFByb21pc2UuYWxsKFtcbiAgICAgICAgdGhpcy5wYWdlTG9hZGVyLnByZWZldGNoRGF0YSh1cmwsIGRlbEJhc2VQYXRoKGFzUGF0aCkpLFxuICAgICAgICB0aGlzLnBhZ2VMb2FkZXJbb3B0aW9ucy5wcmlvcml0eSA/ICdsb2FkUGFnZScgOiAncHJlZmV0Y2gnXShyb3V0ZSksXG4gICAgICBdKS50aGVuKCgpID0+IHJlc29sdmUoKSwgcmVqZWN0KVxuICAgIH0pXG4gIH1cblxuICBhc3luYyBmZXRjaENvbXBvbmVudChyb3V0ZTogc3RyaW5nKTogUHJvbWlzZTxDb21wb25lbnRSZXM+IHtcbiAgICBsZXQgY2FuY2VsbGVkID0gZmFsc2VcbiAgICBjb25zdCBjYW5jZWwgPSAodGhpcy5jbGMgPSAoKSA9PiB7XG4gICAgICBjYW5jZWxsZWQgPSB0cnVlXG4gICAgfSlcbiAgICByb3V0ZSA9IGRlbEJhc2VQYXRoKHJvdXRlKVxuXG4gICAgY29uc3QgY29tcG9uZW50UmVzdWx0ID0gYXdhaXQgdGhpcy5wYWdlTG9hZGVyLmxvYWRQYWdlKHJvdXRlKVxuXG4gICAgaWYgKGNhbmNlbGxlZCkge1xuICAgICAgY29uc3QgZXJyb3I6IGFueSA9IG5ldyBFcnJvcihcbiAgICAgICAgYEFib3J0IGZldGNoaW5nIGNvbXBvbmVudCBmb3Igcm91dGU6IFwiJHtyb3V0ZX1cImBcbiAgICAgIClcbiAgICAgIGVycm9yLmNhbmNlbGxlZCA9IHRydWVcbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuXG4gICAgaWYgKGNhbmNlbCA9PT0gdGhpcy5jbGMpIHtcbiAgICAgIHRoaXMuY2xjID0gbnVsbFxuICAgIH1cblxuICAgIHJldHVybiBjb21wb25lbnRSZXN1bHRcbiAgfVxuXG4gIF9nZXREYXRhPFQ+KGZuOiAoKSA9PiBQcm9taXNlPFQ+KTogUHJvbWlzZTxUPiB7XG4gICAgbGV0IGNhbmNlbGxlZCA9IGZhbHNlXG4gICAgY29uc3QgY2FuY2VsID0gKCkgPT4ge1xuICAgICAgY2FuY2VsbGVkID0gdHJ1ZVxuICAgIH1cbiAgICB0aGlzLmNsYyA9IGNhbmNlbFxuICAgIHJldHVybiBmbigpLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgIGlmIChjYW5jZWwgPT09IHRoaXMuY2xjKSB7XG4gICAgICAgIHRoaXMuY2xjID0gbnVsbFxuICAgICAgfVxuXG4gICAgICBpZiAoY2FuY2VsbGVkKSB7XG4gICAgICAgIGNvbnN0IGVycjogYW55ID0gbmV3IEVycm9yKCdMb2FkaW5nIGluaXRpYWwgcHJvcHMgY2FuY2VsbGVkJylcbiAgICAgICAgZXJyLmNhbmNlbGxlZCA9IHRydWVcbiAgICAgICAgdGhyb3cgZXJyXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkYXRhXG4gICAgfSlcbiAgfVxuXG4gIF9nZXRTdGF0aWNEYXRhID0gKGFzUGF0aDogc3RyaW5nKTogUHJvbWlzZTxvYmplY3Q+ID0+IHtcbiAgICBjb25zdCBwYXRobmFtZSA9IHByZXBhcmVSb3V0ZShwYXJzZShhc1BhdGgpLnBhdGhuYW1lISlcblxuICAgIHJldHVybiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nICYmIHRoaXMuc2RjW3BhdGhuYW1lXVxuICAgICAgPyBQcm9taXNlLnJlc29sdmUodGhpcy5zZGNbcGF0aG5hbWVdKVxuICAgICAgOiBmZXRjaE5leHREYXRhKFxuICAgICAgICAgIHBhdGhuYW1lLFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgdGhpcy5pc1NzcixcbiAgICAgICAgICAoZGF0YSkgPT4gKHRoaXMuc2RjW3BhdGhuYW1lXSA9IGRhdGEpXG4gICAgICAgIClcbiAgfVxuXG4gIF9nZXRTZXJ2ZXJEYXRhID0gKGFzUGF0aDogc3RyaW5nKTogUHJvbWlzZTxvYmplY3Q+ID0+IHtcbiAgICBsZXQgeyBwYXRobmFtZSwgcXVlcnkgfSA9IHBhcnNlKGFzUGF0aCwgdHJ1ZSlcbiAgICBwYXRobmFtZSA9IHByZXBhcmVSb3V0ZShwYXRobmFtZSEpXG4gICAgcmV0dXJuIGZldGNoTmV4dERhdGEocGF0aG5hbWUsIHF1ZXJ5LCB0aGlzLmlzU3NyKVxuICB9XG5cbiAgZ2V0SW5pdGlhbFByb3BzKFxuICAgIENvbXBvbmVudDogQ29tcG9uZW50VHlwZSxcbiAgICBjdHg6IE5leHRQYWdlQ29udGV4dFxuICApOiBQcm9taXNlPGFueT4ge1xuICAgIGNvbnN0IHsgQ29tcG9uZW50OiBBcHAgfSA9IHRoaXMuY29tcG9uZW50c1snL19hcHAnXVxuICAgIGNvbnN0IEFwcFRyZWUgPSB0aGlzLl93cmFwQXBwKEFwcClcbiAgICBjdHguQXBwVHJlZSA9IEFwcFRyZWVcbiAgICByZXR1cm4gbG9hZEdldEluaXRpYWxQcm9wczxBcHBDb250ZXh0VHlwZTxSb3V0ZXI+PihBcHAsIHtcbiAgICAgIEFwcFRyZWUsXG4gICAgICBDb21wb25lbnQsXG4gICAgICByb3V0ZXI6IHRoaXMsXG4gICAgICBjdHgsXG4gICAgfSlcbiAgfVxuXG4gIGFib3J0Q29tcG9uZW50TG9hZChhczogc3RyaW5nKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuY2xjKSB7XG4gICAgICBjb25zdCBlID0gbmV3IEVycm9yKCdSb3V0ZSBDYW5jZWxsZWQnKVxuICAgICAgOyhlIGFzIGFueSkuY2FuY2VsbGVkID0gdHJ1ZVxuICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KCdyb3V0ZUNoYW5nZUVycm9yJywgZSwgYXMpXG4gICAgICB0aGlzLmNsYygpXG4gICAgICB0aGlzLmNsYyA9IG51bGxcbiAgICB9XG4gIH1cblxuICBub3RpZnkoZGF0YTogUm91dGVJbmZvKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgcmV0dXJuIHRoaXMuc3ViKGRhdGEsIHRoaXMuY29tcG9uZW50c1snL19hcHAnXS5Db21wb25lbnQpXG4gIH1cbn1cbiIsIi8vIElkZW50aWZ5IC9bcGFyYW1dLyBpbiByb3V0ZSBzdHJpbmdcbmNvbnN0IFRFU1RfUk9VVEUgPSAvXFwvXFxbW14vXSs/XFxdKD89XFwvfCQpL1xuXG5leHBvcnQgZnVuY3Rpb24gaXNEeW5hbWljUm91dGUocm91dGU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICByZXR1cm4gVEVTVF9ST1VURS50ZXN0KHJvdXRlKVxufVxuIiwiaW1wb3J0IHsgZ2V0Um91dGVSZWdleCB9IGZyb20gJy4vcm91dGUtcmVnZXgnXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSb3V0ZU1hdGNoZXIocm91dGVSZWdleDogUmV0dXJuVHlwZTx0eXBlb2YgZ2V0Um91dGVSZWdleD4pIHtcbiAgY29uc3QgeyByZSwgZ3JvdXBzIH0gPSByb3V0ZVJlZ2V4XG4gIHJldHVybiAocGF0aG5hbWU6IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQpID0+IHtcbiAgICBjb25zdCByb3V0ZU1hdGNoID0gcmUuZXhlYyhwYXRobmFtZSEpXG4gICAgaWYgKCFyb3V0ZU1hdGNoKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBjb25zdCBkZWNvZGUgPSAocGFyYW06IHN0cmluZykgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChwYXJhbSlcbiAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgY29uc3QgZXJyOiBFcnJvciAmIHsgY29kZT86IHN0cmluZyB9ID0gbmV3IEVycm9yKFxuICAgICAgICAgICdmYWlsZWQgdG8gZGVjb2RlIHBhcmFtJ1xuICAgICAgICApXG4gICAgICAgIGVyci5jb2RlID0gJ0RFQ09ERV9GQUlMRUQnXG4gICAgICAgIHRocm93IGVyclxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBwYXJhbXM6IHsgW3BhcmFtTmFtZTogc3RyaW5nXTogc3RyaW5nIHwgc3RyaW5nW10gfSA9IHt9XG5cbiAgICBPYmplY3Qua2V5cyhncm91cHMpLmZvckVhY2goKHNsdWdOYW1lOiBzdHJpbmcpID0+IHtcbiAgICAgIGNvbnN0IGcgPSBncm91cHNbc2x1Z05hbWVdXG4gICAgICBjb25zdCBtID0gcm91dGVNYXRjaFtnLnBvc11cbiAgICAgIGlmIChtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcGFyYW1zW3NsdWdOYW1lXSA9IH5tLmluZGV4T2YoJy8nKVxuICAgICAgICAgID8gbS5zcGxpdCgnLycpLm1hcCgoZW50cnkpID0+IGRlY29kZShlbnRyeSkpXG4gICAgICAgICAgOiBnLnJlcGVhdFxuICAgICAgICAgID8gW2RlY29kZShtKV1cbiAgICAgICAgICA6IGRlY29kZShtKVxuICAgICAgfVxuICAgIH0pXG4gICAgcmV0dXJuIHBhcmFtc1xuICB9XG59XG4iLCIvLyB0aGlzIGlzbid0IGltcG9ydGluZyB0aGUgZXNjYXBlLXN0cmluZy1yZWdleCBtb2R1bGVcbi8vIHRvIHJlZHVjZSBieXRlc1xuZnVuY3Rpb24gZXNjYXBlUmVnZXgoc3RyOiBzdHJpbmcpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9bfFxcXFx7fSgpW1xcXV4kKyo/Li1dL2csICdcXFxcJCYnKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Um91dGVSZWdleChcbiAgbm9ybWFsaXplZFJvdXRlOiBzdHJpbmdcbik6IHtcbiAgcmU6IFJlZ0V4cFxuICBuYW1lZFJlZ2V4Pzogc3RyaW5nXG4gIGdyb3VwczogeyBbZ3JvdXBOYW1lOiBzdHJpbmddOiB7IHBvczogbnVtYmVyOyByZXBlYXQ6IGJvb2xlYW4gfSB9XG59IHtcbiAgLy8gRXNjYXBlIGFsbCBjaGFyYWN0ZXJzIHRoYXQgY291bGQgYmUgY29uc2lkZXJlZCBSZWdFeFxuICBjb25zdCBlc2NhcGVkUm91dGUgPSBlc2NhcGVSZWdleChub3JtYWxpemVkUm91dGUucmVwbGFjZSgvXFwvJC8sICcnKSB8fCAnLycpXG5cbiAgY29uc3QgZ3JvdXBzOiB7IFtncm91cE5hbWU6IHN0cmluZ106IHsgcG9zOiBudW1iZXI7IHJlcGVhdDogYm9vbGVhbiB9IH0gPSB7fVxuICBsZXQgZ3JvdXBJbmRleCA9IDFcblxuICBjb25zdCBwYXJhbWV0ZXJpemVkUm91dGUgPSBlc2NhcGVkUm91dGUucmVwbGFjZShcbiAgICAvXFwvXFxcXFxcWyhbXi9dKz8pXFxcXFxcXSg/PVxcL3wkKS9nLFxuICAgIChfLCAkMSkgPT4ge1xuICAgICAgY29uc3QgaXNPcHRpb25hbCA9IC9eXFxcXFxcWy4qXFxcXFxcXSQvLnRlc3QoJDEpXG4gICAgICBpZiAoaXNPcHRpb25hbCkge1xuICAgICAgICAkMSA9ICQxLnNsaWNlKDIsIC0yKVxuICAgICAgfVxuICAgICAgY29uc3QgaXNDYXRjaEFsbCA9IC9eKFxcXFxcXC4pezN9Ly50ZXN0KCQxKVxuICAgICAgaWYgKGlzQ2F0Y2hBbGwpIHtcbiAgICAgICAgJDEgPSAkMS5zbGljZSg2KVxuICAgICAgfVxuICAgICAgZ3JvdXBzW1xuICAgICAgICAkMVxuICAgICAgICAgIC8vIFVuLWVzY2FwZSBrZXlcbiAgICAgICAgICAucmVwbGFjZSgvXFxcXChbfFxcXFx7fSgpW1xcXV4kKyo/Li1dKS9nLCAnJDEnKVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VxdWVuY2VzXG4gICAgICBdID0geyBwb3M6IGdyb3VwSW5kZXgrKywgcmVwZWF0OiBpc0NhdGNoQWxsIH1cbiAgICAgIHJldHVybiBpc0NhdGNoQWxsID8gKGlzT3B0aW9uYWwgPyAnKD86LyguKz8pKT8nIDogJy8oLis/KScpIDogJy8oW14vXSs/KSdcbiAgICB9XG4gIClcblxuICBsZXQgbmFtZWRQYXJhbWV0ZXJpemVkUm91dGU6IHN0cmluZyB8IHVuZGVmaW5lZFxuXG4gIC8vIGRlYWQgY29kZSBlbGltaW5hdGUgZm9yIGJyb3dzZXIgc2luY2UgaXQncyBvbmx5IG5lZWRlZFxuICAvLyB3aGlsZSBnZW5lcmF0aW5nIHJvdXRlcy1tYW5pZmVzdFxuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBuYW1lZFBhcmFtZXRlcml6ZWRSb3V0ZSA9IGVzY2FwZWRSb3V0ZS5yZXBsYWNlKFxuICAgICAgL1xcL1xcXFxcXFsoW14vXSs/KVxcXFxcXF0oPz1cXC98JCkvZyxcbiAgICAgIChfLCAkMSkgPT4ge1xuICAgICAgICBjb25zdCBpc0NhdGNoQWxsID0gL14oXFxcXFxcLil7M30vLnRlc3QoJDEpXG4gICAgICAgIGNvbnN0IGtleSA9ICQxXG4gICAgICAgICAgLy8gVW4tZXNjYXBlIGtleVxuICAgICAgICAgIC5yZXBsYWNlKC9cXFxcKFt8XFxcXHt9KClbXFxdXiQrKj8uLV0pL2csICckMScpXG4gICAgICAgICAgLnJlcGxhY2UoL15cXC57M30vLCAnJylcblxuICAgICAgICByZXR1cm4gaXNDYXRjaEFsbFxuICAgICAgICAgID8gYC8oPzwke2VzY2FwZVJlZ2V4KGtleSl9Pi4rPylgXG4gICAgICAgICAgOiBgLyg/PCR7ZXNjYXBlUmVnZXgoa2V5KX0+W14vXSs/KWBcbiAgICAgIH1cbiAgICApXG4gIH1cblxuICByZXR1cm4ge1xuICAgIHJlOiBuZXcgUmVnRXhwKCdeJyArIHBhcmFtZXRlcml6ZWRSb3V0ZSArICcoPzovKT8kJywgJ2knKSxcbiAgICBncm91cHMsXG4gICAgbmFtZWRSZWdleDogbmFtZWRQYXJhbWV0ZXJpemVkUm91dGVcbiAgICAgID8gYF4ke25hbWVkUGFyYW1ldGVyaXplZFJvdXRlfSg/Oi8pPyRgXG4gICAgICA6IHVuZGVmaW5lZCxcbiAgfVxufVxuIiwibGV0IHJ1bnRpbWVDb25maWc6IGFueVxuXG5leHBvcnQgZGVmYXVsdCAoKSA9PiB7XG4gIHJldHVybiBydW50aW1lQ29uZmlnXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRDb25maWcoY29uZmlnVmFsdWU6IGFueSk6IHZvaWQge1xuICBydW50aW1lQ29uZmlnID0gY29uZmlnVmFsdWVcbn1cbiIsImltcG9ydCB7IEluY29taW5nTWVzc2FnZSwgU2VydmVyUmVzcG9uc2UgfSBmcm9tICdodHRwJ1xuaW1wb3J0IHsgUGFyc2VkVXJsUXVlcnkgfSBmcm9tICdxdWVyeXN0cmluZydcbmltcG9ydCB7IENvbXBvbmVudFR5cGUgfSBmcm9tICdyZWFjdCdcbmltcG9ydCB7IGZvcm1hdCwgVVJMRm9ybWF0T3B0aW9ucywgVXJsT2JqZWN0IH0gZnJvbSAndXJsJ1xuaW1wb3J0IHsgTWFuaWZlc3RJdGVtIH0gZnJvbSAnLi4vc2VydmVyL2xvYWQtY29tcG9uZW50cydcbmltcG9ydCB7IE5leHRSb3V0ZXIgfSBmcm9tICcuL3JvdXRlci9yb3V0ZXInXG5pbXBvcnQgeyBFbnYgfSBmcm9tICcuLi8uLi9saWIvbG9hZC1lbnYtY29uZmlnJ1xuXG4vKipcbiAqIFR5cGVzIHVzZWQgYnkgYm90aCBuZXh0IGFuZCBuZXh0LXNlcnZlclxuICovXG5cbmV4cG9ydCB0eXBlIE5leHRDb21wb25lbnRUeXBlPFxuICBDIGV4dGVuZHMgQmFzZUNvbnRleHQgPSBOZXh0UGFnZUNvbnRleHQsXG4gIElQID0ge30sXG4gIFAgPSB7fVxuPiA9IENvbXBvbmVudFR5cGU8UD4gJiB7XG4gIC8qKlxuICAgKiBVc2VkIGZvciBpbml0aWFsIHBhZ2UgbG9hZCBkYXRhIHBvcHVsYXRpb24uIERhdGEgcmV0dXJuZWQgZnJvbSBgZ2V0SW5pdGlhbFByb3BzYCBpcyBzZXJpYWxpemVkIHdoZW4gc2VydmVyIHJlbmRlcmVkLlxuICAgKiBNYWtlIHN1cmUgdG8gcmV0dXJuIHBsYWluIGBPYmplY3RgIHdpdGhvdXQgdXNpbmcgYERhdGVgLCBgTWFwYCwgYFNldGAuXG4gICAqIEBwYXJhbSBjdHggQ29udGV4dCBvZiBgcGFnZWBcbiAgICovXG4gIGdldEluaXRpYWxQcm9wcz8oY29udGV4dDogQyk6IElQIHwgUHJvbWlzZTxJUD5cbn1cblxuZXhwb3J0IHR5cGUgRG9jdW1lbnRUeXBlID0gTmV4dENvbXBvbmVudFR5cGU8XG4gIERvY3VtZW50Q29udGV4dCxcbiAgRG9jdW1lbnRJbml0aWFsUHJvcHMsXG4gIERvY3VtZW50UHJvcHNcbj4gJiB7XG4gIHJlbmRlckRvY3VtZW50KFxuICAgIERvY3VtZW50OiBEb2N1bWVudFR5cGUsXG4gICAgcHJvcHM6IERvY3VtZW50UHJvcHNcbiAgKTogUmVhY3QuUmVhY3RFbGVtZW50XG59XG5cbmV4cG9ydCB0eXBlIEFwcFR5cGUgPSBOZXh0Q29tcG9uZW50VHlwZTxcbiAgQXBwQ29udGV4dFR5cGUsXG4gIEFwcEluaXRpYWxQcm9wcyxcbiAgQXBwUHJvcHNUeXBlXG4+XG5cbmV4cG9ydCB0eXBlIEFwcFRyZWVUeXBlID0gQ29tcG9uZW50VHlwZTxcbiAgQXBwSW5pdGlhbFByb3BzICYgeyBbbmFtZTogc3RyaW5nXTogYW55IH1cbj5cblxuZXhwb3J0IHR5cGUgRW5oYW5jZXI8Qz4gPSAoQ29tcG9uZW50OiBDKSA9PiBDXG5cbmV4cG9ydCB0eXBlIENvbXBvbmVudHNFbmhhbmNlciA9XG4gIHwge1xuICAgICAgZW5oYW5jZUFwcD86IEVuaGFuY2VyPEFwcFR5cGU+XG4gICAgICBlbmhhbmNlQ29tcG9uZW50PzogRW5oYW5jZXI8TmV4dENvbXBvbmVudFR5cGU+XG4gICAgfVxuICB8IEVuaGFuY2VyPE5leHRDb21wb25lbnRUeXBlPlxuXG5leHBvcnQgdHlwZSBSZW5kZXJQYWdlUmVzdWx0ID0ge1xuICBodG1sOiBzdHJpbmdcbiAgaGVhZD86IEFycmF5PEpTWC5FbGVtZW50IHwgbnVsbD5cbn1cblxuZXhwb3J0IHR5cGUgUmVuZGVyUGFnZSA9IChcbiAgb3B0aW9ucz86IENvbXBvbmVudHNFbmhhbmNlclxuKSA9PiBSZW5kZXJQYWdlUmVzdWx0IHwgUHJvbWlzZTxSZW5kZXJQYWdlUmVzdWx0PlxuXG5leHBvcnQgdHlwZSBCYXNlQ29udGV4dCA9IHtcbiAgcmVzPzogU2VydmVyUmVzcG9uc2VcbiAgW2s6IHN0cmluZ106IGFueVxufVxuXG5leHBvcnQgdHlwZSBORVhUX0RBVEEgPSB7XG4gIHByb3BzOiBhbnlcbiAgcGFnZTogc3RyaW5nXG4gIHF1ZXJ5OiBQYXJzZWRVcmxRdWVyeVxuICBidWlsZElkOiBzdHJpbmdcbiAgYXNzZXRQcmVmaXg/OiBzdHJpbmdcbiAgcnVudGltZUNvbmZpZz86IHsgW2tleTogc3RyaW5nXTogYW55IH1cbiAgbmV4dEV4cG9ydD86IGJvb2xlYW5cbiAgYXV0b0V4cG9ydD86IGJvb2xlYW5cbiAgaXNGYWxsYmFjaz86IGJvb2xlYW5cbiAgZHluYW1pY0lkcz86IHN0cmluZ1tdXG4gIGVycj86IEVycm9yICYgeyBzdGF0dXNDb2RlPzogbnVtYmVyIH1cbiAgZ3NwPzogYm9vbGVhblxuICBnc3NwPzogYm9vbGVhblxuICBjdXN0b21TZXJ2ZXI/OiBib29sZWFuXG4gIGdpcD86IGJvb2xlYW5cbiAgYXBwR2lwPzogYm9vbGVhblxufVxuXG4vKipcbiAqIGBOZXh0YCBjb250ZXh0XG4gKi9cbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZSBpbnRlcmZhY2UtbmFtZVxuZXhwb3J0IGludGVyZmFjZSBOZXh0UGFnZUNvbnRleHQge1xuICAvKipcbiAgICogRXJyb3Igb2JqZWN0IGlmIGVuY291bnRlcmVkIGR1cmluZyByZW5kZXJpbmdcbiAgICovXG4gIGVycj86IChFcnJvciAmIHsgc3RhdHVzQ29kZT86IG51bWJlciB9KSB8IG51bGxcbiAgLyoqXG4gICAqIGBIVFRQYCByZXF1ZXN0IG9iamVjdC5cbiAgICovXG4gIHJlcT86IEluY29taW5nTWVzc2FnZVxuICAvKipcbiAgICogYEhUVFBgIHJlc3BvbnNlIG9iamVjdC5cbiAgICovXG4gIHJlcz86IFNlcnZlclJlc3BvbnNlXG4gIC8qKlxuICAgKiBQYXRoIHNlY3Rpb24gb2YgYFVSTGAuXG4gICAqL1xuICBwYXRobmFtZTogc3RyaW5nXG4gIC8qKlxuICAgKiBRdWVyeSBzdHJpbmcgc2VjdGlvbiBvZiBgVVJMYCBwYXJzZWQgYXMgYW4gb2JqZWN0LlxuICAgKi9cbiAgcXVlcnk6IFBhcnNlZFVybFF1ZXJ5XG4gIC8qKlxuICAgKiBgU3RyaW5nYCBvZiB0aGUgYWN0dWFsIHBhdGggaW5jbHVkaW5nIHF1ZXJ5LlxuICAgKi9cbiAgYXNQYXRoPzogc3RyaW5nXG4gIC8qKlxuICAgKiBgQ29tcG9uZW50YCB0aGUgdHJlZSBvZiB0aGUgQXBwIHRvIHVzZSBpZiBuZWVkaW5nIHRvIHJlbmRlciBzZXBhcmF0ZWx5XG4gICAqL1xuICBBcHBUcmVlOiBBcHBUcmVlVHlwZVxufVxuXG5leHBvcnQgdHlwZSBBcHBDb250ZXh0VHlwZTxSIGV4dGVuZHMgTmV4dFJvdXRlciA9IE5leHRSb3V0ZXI+ID0ge1xuICBDb21wb25lbnQ6IE5leHRDb21wb25lbnRUeXBlPE5leHRQYWdlQ29udGV4dD5cbiAgQXBwVHJlZTogQXBwVHJlZVR5cGVcbiAgY3R4OiBOZXh0UGFnZUNvbnRleHRcbiAgcm91dGVyOiBSXG59XG5cbmV4cG9ydCB0eXBlIEFwcEluaXRpYWxQcm9wcyA9IHtcbiAgcGFnZVByb3BzOiBhbnlcbn1cblxuZXhwb3J0IHR5cGUgQXBwUHJvcHNUeXBlPFxuICBSIGV4dGVuZHMgTmV4dFJvdXRlciA9IE5leHRSb3V0ZXIsXG4gIFAgPSB7fVxuPiA9IEFwcEluaXRpYWxQcm9wcyAmIHtcbiAgQ29tcG9uZW50OiBOZXh0Q29tcG9uZW50VHlwZTxOZXh0UGFnZUNvbnRleHQsIGFueSwgUD5cbiAgcm91dGVyOiBSXG4gIF9fTl9TU0c/OiBib29sZWFuXG4gIF9fTl9TU1A/OiBib29sZWFuXG59XG5cbmV4cG9ydCB0eXBlIERvY3VtZW50Q29udGV4dCA9IE5leHRQYWdlQ29udGV4dCAmIHtcbiAgcmVuZGVyUGFnZTogUmVuZGVyUGFnZVxufVxuXG5leHBvcnQgdHlwZSBEb2N1bWVudEluaXRpYWxQcm9wcyA9IFJlbmRlclBhZ2VSZXN1bHQgJiB7XG4gIHN0eWxlcz86IFJlYWN0LlJlYWN0RWxlbWVudFtdIHwgUmVhY3QuUmVhY3RGcmFnbWVudFxufVxuXG5leHBvcnQgdHlwZSBEb2N1bWVudFByb3BzID0gRG9jdW1lbnRJbml0aWFsUHJvcHMgJiB7XG4gIF9fTkVYVF9EQVRBX186IE5FWFRfREFUQVxuICBkYW5nZXJvdXNBc1BhdGg6IHN0cmluZ1xuICBhbXBQYXRoOiBzdHJpbmdcbiAgaW5BbXBNb2RlOiBib29sZWFuXG4gIGh5YnJpZEFtcDogYm9vbGVhblxuICBzdGF0aWNNYXJrdXA6IGJvb2xlYW5cbiAgaXNEZXZlbG9wbWVudDogYm9vbGVhblxuICBkZXZGaWxlczogc3RyaW5nW11cbiAgZmlsZXM6IHN0cmluZ1tdXG4gIGxvd1ByaW9yaXR5RmlsZXM6IHN0cmluZ1tdXG4gIHBvbHlmaWxsRmlsZXM6IHN0cmluZ1tdXG4gIGR5bmFtaWNJbXBvcnRzOiBNYW5pZmVzdEl0ZW1bXVxuICBhc3NldFByZWZpeD86IHN0cmluZ1xuICBjYW5vbmljYWxCYXNlOiBzdHJpbmdcbiAgaHRtbFByb3BzOiBhbnlcbiAgYm9keVRhZ3M6IGFueVtdXG4gIGhlYWRUYWdzOiBhbnlbXVxuICB1bnN0YWJsZV9ydW50aW1lSlM/OiBmYWxzZVxufVxuXG4vKipcbiAqIE5leHQgYEFQSWAgcm91dGUgcmVxdWVzdFxuICovXG5leHBvcnQgaW50ZXJmYWNlIE5leHRBcGlSZXF1ZXN0IGV4dGVuZHMgSW5jb21pbmdNZXNzYWdlIHtcbiAgLyoqXG4gICAqIE9iamVjdCBvZiBgcXVlcnlgIHZhbHVlcyBmcm9tIHVybFxuICAgKi9cbiAgcXVlcnk6IHtcbiAgICBba2V5OiBzdHJpbmddOiBzdHJpbmcgfCBzdHJpbmdbXVxuICB9XG4gIC8qKlxuICAgKiBPYmplY3Qgb2YgYGNvb2tpZXNgIGZyb20gaGVhZGVyXG4gICAqL1xuICBjb29raWVzOiB7XG4gICAgW2tleTogc3RyaW5nXTogc3RyaW5nXG4gIH1cblxuICBib2R5OiBhbnlcblxuICBlbnY6IEVudlxufVxuXG4vKipcbiAqIFNlbmQgYm9keSBvZiByZXNwb25zZVxuICovXG50eXBlIFNlbmQ8VD4gPSAoYm9keTogVCkgPT4gdm9pZFxuXG4vKipcbiAqIE5leHQgYEFQSWAgcm91dGUgcmVzcG9uc2VcbiAqL1xuZXhwb3J0IHR5cGUgTmV4dEFwaVJlc3BvbnNlPFQgPSBhbnk+ID0gU2VydmVyUmVzcG9uc2UgJiB7XG4gIC8qKlxuICAgKiBTZW5kIGRhdGEgYGFueWAgZGF0YSBpbiByZXNwb25zZVxuICAgKi9cbiAgc2VuZDogU2VuZDxUPlxuICAvKipcbiAgICogU2VuZCBkYXRhIGBqc29uYCBkYXRhIGluIHJlc3BvbnNlXG4gICAqL1xuICBqc29uOiBTZW5kPFQ+XG4gIHN0YXR1czogKHN0YXR1c0NvZGU6IG51bWJlcikgPT4gTmV4dEFwaVJlc3BvbnNlPFQ+XG5cbiAgLyoqXG4gICAqIFNldCBwcmV2aWV3IGRhdGEgZm9yIE5leHQuanMnIHByZXJlbmRlciBtb2RlXG4gICAqL1xuICBzZXRQcmV2aWV3RGF0YTogKFxuICAgIGRhdGE6IG9iamVjdCB8IHN0cmluZyxcbiAgICBvcHRpb25zPzoge1xuICAgICAgLyoqXG4gICAgICAgKiBTcGVjaWZpZXMgdGhlIG51bWJlciAoaW4gc2Vjb25kcykgZm9yIHRoZSBwcmV2aWV3IHNlc3Npb24gdG8gbGFzdCBmb3IuXG4gICAgICAgKiBUaGUgZ2l2ZW4gbnVtYmVyIHdpbGwgYmUgY29udmVydGVkIHRvIGFuIGludGVnZXIgYnkgcm91bmRpbmcgZG93bi5cbiAgICAgICAqIEJ5IGRlZmF1bHQsIG5vIG1heGltdW0gYWdlIGlzIHNldCBhbmQgdGhlIHByZXZpZXcgc2Vzc2lvbiBmaW5pc2hlc1xuICAgICAgICogd2hlbiB0aGUgY2xpZW50IHNodXRzIGRvd24gKGJyb3dzZXIgaXMgY2xvc2VkKS5cbiAgICAgICAqL1xuICAgICAgbWF4QWdlPzogbnVtYmVyXG4gICAgfVxuICApID0+IE5leHRBcGlSZXNwb25zZTxUPlxuICBjbGVhclByZXZpZXdEYXRhOiAoKSA9PiBOZXh0QXBpUmVzcG9uc2U8VD5cbn1cblxuLyoqXG4gKiBOZXh0IGBBUElgIHJvdXRlIGhhbmRsZXJcbiAqL1xuZXhwb3J0IHR5cGUgTmV4dEFwaUhhbmRsZXI8VCA9IGFueT4gPSAoXG4gIHJlcTogTmV4dEFwaVJlcXVlc3QsXG4gIHJlczogTmV4dEFwaVJlc3BvbnNlPFQ+XG4pID0+IHZvaWQgfCBQcm9taXNlPHZvaWQ+XG5cbi8qKlxuICogVXRpbHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4ZWNPbmNlPFQgZXh0ZW5kcyAoLi4uYXJnczogYW55W10pID0+IFJldHVyblR5cGU8VD4+KFxuICBmbjogVFxuKTogVCB7XG4gIGxldCB1c2VkID0gZmFsc2VcbiAgbGV0IHJlc3VsdDogUmV0dXJuVHlwZTxUPlxuXG4gIHJldHVybiAoKC4uLmFyZ3M6IGFueVtdKSA9PiB7XG4gICAgaWYgKCF1c2VkKSB7XG4gICAgICB1c2VkID0gdHJ1ZVxuICAgICAgcmVzdWx0ID0gZm4oLi4uYXJncylcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9KSBhcyBUXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRMb2NhdGlvbk9yaWdpbigpIHtcbiAgY29uc3QgeyBwcm90b2NvbCwgaG9zdG5hbWUsIHBvcnQgfSA9IHdpbmRvdy5sb2NhdGlvblxuICByZXR1cm4gYCR7cHJvdG9jb2x9Ly8ke2hvc3RuYW1lfSR7cG9ydCA/ICc6JyArIHBvcnQgOiAnJ31gXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRVUkwoKSB7XG4gIGNvbnN0IHsgaHJlZiB9ID0gd2luZG93LmxvY2F0aW9uXG4gIGNvbnN0IG9yaWdpbiA9IGdldExvY2F0aW9uT3JpZ2luKClcbiAgcmV0dXJuIGhyZWYuc3Vic3RyaW5nKG9yaWdpbi5sZW5ndGgpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXREaXNwbGF5TmFtZTxQPihDb21wb25lbnQ6IENvbXBvbmVudFR5cGU8UD4pIHtcbiAgcmV0dXJuIHR5cGVvZiBDb21wb25lbnQgPT09ICdzdHJpbmcnXG4gICAgPyBDb21wb25lbnRcbiAgICA6IENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZSB8fCAnVW5rbm93bidcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzUmVzU2VudChyZXM6IFNlcnZlclJlc3BvbnNlKSB7XG4gIHJldHVybiByZXMuZmluaXNoZWQgfHwgcmVzLmhlYWRlcnNTZW50XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBsb2FkR2V0SW5pdGlhbFByb3BzPFxuICBDIGV4dGVuZHMgQmFzZUNvbnRleHQsXG4gIElQID0ge30sXG4gIFAgPSB7fVxuPihBcHA6IE5leHRDb21wb25lbnRUeXBlPEMsIElQLCBQPiwgY3R4OiBDKTogUHJvbWlzZTxJUD4ge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmIChBcHAucHJvdG90eXBlPy5nZXRJbml0aWFsUHJvcHMpIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgXCIke2dldERpc3BsYXlOYW1lKFxuICAgICAgICBBcHBcbiAgICAgICl9LmdldEluaXRpYWxQcm9wcygpXCIgaXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBtZXRob2QgLSB2aXNpdCBodHRwczovL2Vyci5zaC92ZXJjZWwvbmV4dC5qcy9nZXQtaW5pdGlhbC1wcm9wcy1hcy1hbi1pbnN0YW5jZS1tZXRob2QgZm9yIG1vcmUgaW5mb3JtYXRpb24uYFxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpXG4gICAgfVxuICB9XG4gIC8vIHdoZW4gY2FsbGVkIGZyb20gX2FwcCBgY3R4YCBpcyBuZXN0ZWQgaW4gYGN0eGBcbiAgY29uc3QgcmVzID0gY3R4LnJlcyB8fCAoY3R4LmN0eCAmJiBjdHguY3R4LnJlcylcblxuICBpZiAoIUFwcC5nZXRJbml0aWFsUHJvcHMpIHtcbiAgICBpZiAoY3R4LmN0eCAmJiBjdHguQ29tcG9uZW50KSB7XG4gICAgICAvLyBAdHMtaWdub3JlIHBhZ2VQcm9wcyBkZWZhdWx0XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYWdlUHJvcHM6IGF3YWl0IGxvYWRHZXRJbml0aWFsUHJvcHMoY3R4LkNvbXBvbmVudCwgY3R4LmN0eCksXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7fSBhcyBJUFxuICB9XG5cbiAgY29uc3QgcHJvcHMgPSBhd2FpdCBBcHAuZ2V0SW5pdGlhbFByb3BzKGN0eClcblxuICBpZiAocmVzICYmIGlzUmVzU2VudChyZXMpKSB7XG4gICAgcmV0dXJuIHByb3BzXG4gIH1cblxuICBpZiAoIXByb3BzKSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IGBcIiR7Z2V0RGlzcGxheU5hbWUoXG4gICAgICBBcHBcbiAgICApfS5nZXRJbml0aWFsUHJvcHMoKVwiIHNob3VsZCByZXNvbHZlIHRvIGFuIG9iamVjdC4gQnV0IGZvdW5kIFwiJHtwcm9wc31cIiBpbnN0ZWFkLmBcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSlcbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKE9iamVjdC5rZXlzKHByb3BzKS5sZW5ndGggPT09IDAgJiYgIWN0eC5jdHgpIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgYCR7Z2V0RGlzcGxheU5hbWUoXG4gICAgICAgICAgQXBwXG4gICAgICAgICl9IHJldHVybmVkIGFuIGVtcHR5IG9iamVjdCBmcm9tIFxcYGdldEluaXRpYWxQcm9wc1xcYC4gVGhpcyBkZS1vcHRpbWl6ZXMgYW5kIHByZXZlbnRzIGF1dG9tYXRpYyBzdGF0aWMgb3B0aW1pemF0aW9uLiBodHRwczovL2Vyci5zaC92ZXJjZWwvbmV4dC5qcy9lbXB0eS1vYmplY3QtZ2V0SW5pdGlhbFByb3BzYFxuICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwcm9wc1xufVxuXG5leHBvcnQgY29uc3QgdXJsT2JqZWN0S2V5cyA9IFtcbiAgJ2F1dGgnLFxuICAnaGFzaCcsXG4gICdob3N0JyxcbiAgJ2hvc3RuYW1lJyxcbiAgJ2hyZWYnLFxuICAncGF0aCcsXG4gICdwYXRobmFtZScsXG4gICdwb3J0JyxcbiAgJ3Byb3RvY29sJyxcbiAgJ3F1ZXJ5JyxcbiAgJ3NlYXJjaCcsXG4gICdzbGFzaGVzJyxcbl1cblxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdFdpdGhWYWxpZGF0aW9uKFxuICB1cmw6IFVybE9iamVjdCxcbiAgb3B0aW9ucz86IFVSTEZvcm1hdE9wdGlvbnNcbik6IHN0cmluZyB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgIGlmICh1cmwgIT09IG51bGwgJiYgdHlwZW9mIHVybCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIE9iamVjdC5rZXlzKHVybCkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgIGlmICh1cmxPYmplY3RLZXlzLmluZGV4T2Yoa2V5KSA9PT0gLTEpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICBgVW5rbm93biBrZXkgcGFzc2VkIHZpYSB1cmxPYmplY3QgaW50byB1cmwuZm9ybWF0OiAke2tleX1gXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmb3JtYXQodXJsIGFzIFVSTCwgb3B0aW9ucylcbn1cblxuZXhwb3J0IGNvbnN0IFNQID0gdHlwZW9mIHBlcmZvcm1hbmNlICE9PSAndW5kZWZpbmVkJ1xuZXhwb3J0IGNvbnN0IFNUID1cbiAgU1AgJiZcbiAgdHlwZW9mIHBlcmZvcm1hbmNlLm1hcmsgPT09ICdmdW5jdGlvbicgJiZcbiAgdHlwZW9mIHBlcmZvcm1hbmNlLm1lYXN1cmUgPT09ICdmdW5jdGlvbidcbiIsIi8qIVxyXG4gKiBQbGF0Zm9ybS5qcyA8aHR0cHM6Ly9tdGhzLmJlL3BsYXRmb3JtPlxyXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE2IEJlbmphbWluIFRhbiA8aHR0cHM6Ly9kZW1vbmVhdXguZ2l0aHViLmlvLz5cclxuICogQ29weXJpZ2h0IDIwMTEtMjAxMyBKb2huLURhdmlkIERhbHRvbiA8aHR0cDovL2FsbHlvdWNhbmxlZXQuY29tLz5cclxuICogQXZhaWxhYmxlIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL210aHMuYmUvbWl0PlxyXG4gKi9cclxuOyhmdW5jdGlvbigpIHtcclxuICAndXNlIHN0cmljdCc7XHJcblxyXG4gIC8qKiBVc2VkIHRvIGRldGVybWluZSBpZiB2YWx1ZXMgYXJlIG9mIHRoZSBsYW5ndWFnZSB0eXBlIGBPYmplY3RgLiAqL1xyXG4gIHZhciBvYmplY3RUeXBlcyA9IHtcclxuICAgICdmdW5jdGlvbic6IHRydWUsXHJcbiAgICAnb2JqZWN0JzogdHJ1ZVxyXG4gIH07XHJcblxyXG4gIC8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xyXG4gIHZhciByb290ID0gKG9iamVjdFR5cGVzW3R5cGVvZiB3aW5kb3ddICYmIHdpbmRvdykgfHwgdGhpcztcclxuXHJcbiAgLyoqIEJhY2t1cCBwb3NzaWJsZSBnbG9iYWwgb2JqZWN0LiAqL1xyXG4gIHZhciBvbGRSb290ID0gcm9vdDtcclxuXHJcbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cclxuICB2YXIgZnJlZUV4cG9ydHMgPSBvYmplY3RUeXBlc1t0eXBlb2YgZXhwb3J0c10gJiYgZXhwb3J0cztcclxuXHJcbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xyXG4gIHZhciBmcmVlTW9kdWxlID0gb2JqZWN0VHlwZXNbdHlwZW9mIG1vZHVsZV0gJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xyXG5cclxuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzIG9yIEJyb3dzZXJpZmllZCBjb2RlIGFuZCB1c2UgaXQgYXMgYHJvb3RgLiAqL1xyXG4gIHZhciBmcmVlR2xvYmFsID0gZnJlZUV4cG9ydHMgJiYgZnJlZU1vZHVsZSAmJiB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbDtcclxuICBpZiAoZnJlZUdsb2JhbCAmJiAoZnJlZUdsb2JhbC5nbG9iYWwgPT09IGZyZWVHbG9iYWwgfHwgZnJlZUdsb2JhbC53aW5kb3cgPT09IGZyZWVHbG9iYWwgfHwgZnJlZUdsb2JhbC5zZWxmID09PSBmcmVlR2xvYmFsKSkge1xyXG4gICAgcm9vdCA9IGZyZWVHbG9iYWw7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBVc2VkIGFzIHRoZSBtYXhpbXVtIGxlbmd0aCBvZiBhbiBhcnJheS1saWtlIG9iamVjdC5cclxuICAgKiBTZWUgdGhlIFtFUzYgc3BlY10oaHR0cDovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtdG9sZW5ndGgpXHJcbiAgICogZm9yIG1vcmUgZGV0YWlscy5cclxuICAgKi9cclxuICB2YXIgbWF4U2FmZUludGVnZXIgPSBNYXRoLnBvdygyLCA1MykgLSAxO1xyXG5cclxuICAvKiogUmVndWxhciBleHByZXNzaW9uIHRvIGRldGVjdCBPcGVyYS4gKi9cclxuICB2YXIgcmVPcGVyYSA9IC9cXGJPcGVyYS87XHJcblxyXG4gIC8qKiBQb3NzaWJsZSBnbG9iYWwgb2JqZWN0LiAqL1xyXG4gIHZhciB0aGlzQmluZGluZyA9IHRoaXM7XHJcblxyXG4gIC8qKiBVc2VkIGZvciBuYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMuICovXHJcbiAgdmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcclxuXHJcbiAgLyoqIFVzZWQgdG8gY2hlY2sgZm9yIG93biBwcm9wZXJ0aWVzIG9mIGFuIG9iamVjdC4gKi9cclxuICB2YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcclxuXHJcbiAgLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgaW50ZXJuYWwgYFtbQ2xhc3NdXWAgb2YgdmFsdWVzLiAqL1xyXG4gIHZhciB0b1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xyXG5cclxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuXHJcbiAgLyoqXHJcbiAgICogQ2FwaXRhbGl6ZXMgYSBzdHJpbmcgdmFsdWUuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjYXBpdGFsaXplLlxyXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBjYXBpdGFsaXplZCBzdHJpbmcuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gY2FwaXRhbGl6ZShzdHJpbmcpIHtcclxuICAgIHN0cmluZyA9IFN0cmluZyhzdHJpbmcpO1xyXG4gICAgcmV0dXJuIHN0cmluZy5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0cmluZy5zbGljZSgxKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEEgdXRpbGl0eSBmdW5jdGlvbiB0byBjbGVhbiB1cCB0aGUgT1MgbmFtZS5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9zIFRoZSBPUyBuYW1lIHRvIGNsZWFuIHVwLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbcGF0dGVybl0gQSBgUmVnRXhwYCBwYXR0ZXJuIG1hdGNoaW5nIHRoZSBPUyBuYW1lLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbbGFiZWxdIEEgbGFiZWwgZm9yIHRoZSBPUy5cclxuICAgKi9cclxuICBmdW5jdGlvbiBjbGVhbnVwT1Mob3MsIHBhdHRlcm4sIGxhYmVsKSB7XHJcbiAgICAvLyBQbGF0Zm9ybSB0b2tlbnMgYXJlIGRlZmluZWQgYXQ6XHJcbiAgICAvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvbXM1Mzc1MDMoVlMuODUpLmFzcHhcclxuICAgIC8vIGh0dHA6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMDgxMTIyMDUzOTUwL2h0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9tczUzNzUwMyhWUy44NSkuYXNweFxyXG4gICAgdmFyIGRhdGEgPSB7XHJcbiAgICAgICcxMC4wJzogJzEwJyxcclxuICAgICAgJzYuNCc6ICAnMTAgVGVjaG5pY2FsIFByZXZpZXcnLFxyXG4gICAgICAnNi4zJzogICc4LjEnLFxyXG4gICAgICAnNi4yJzogICc4JyxcclxuICAgICAgJzYuMSc6ICAnU2VydmVyIDIwMDggUjIgLyA3JyxcclxuICAgICAgJzYuMCc6ICAnU2VydmVyIDIwMDggLyBWaXN0YScsXHJcbiAgICAgICc1LjInOiAgJ1NlcnZlciAyMDAzIC8gWFAgNjQtYml0JyxcclxuICAgICAgJzUuMSc6ICAnWFAnLFxyXG4gICAgICAnNS4wMSc6ICcyMDAwIFNQMScsXHJcbiAgICAgICc1LjAnOiAgJzIwMDAnLFxyXG4gICAgICAnNC4wJzogICdOVCcsXHJcbiAgICAgICc0LjkwJzogJ01FJ1xyXG4gICAgfTtcclxuICAgIC8vIERldGVjdCBXaW5kb3dzIHZlcnNpb24gZnJvbSBwbGF0Zm9ybSB0b2tlbnMuXHJcbiAgICBpZiAocGF0dGVybiAmJiBsYWJlbCAmJiAvXldpbi9pLnRlc3Qob3MpICYmICEvXldpbmRvd3MgUGhvbmUgL2kudGVzdChvcykgJiZcclxuICAgICAgICAoZGF0YSA9IGRhdGFbL1tcXGQuXSskLy5leGVjKG9zKV0pKSB7XHJcbiAgICAgIG9zID0gJ1dpbmRvd3MgJyArIGRhdGE7XHJcbiAgICB9XHJcbiAgICAvLyBDb3JyZWN0IGNoYXJhY3RlciBjYXNlIGFuZCBjbGVhbnVwIHN0cmluZy5cclxuICAgIG9zID0gU3RyaW5nKG9zKTtcclxuXHJcbiAgICBpZiAocGF0dGVybiAmJiBsYWJlbCkge1xyXG4gICAgICBvcyA9IG9zLnJlcGxhY2UoUmVnRXhwKHBhdHRlcm4sICdpJyksIGxhYmVsKTtcclxuICAgIH1cclxuXHJcbiAgICBvcyA9IGZvcm1hdChcclxuICAgICAgb3MucmVwbGFjZSgvIGNlJC9pLCAnIENFJylcclxuICAgICAgICAucmVwbGFjZSgvXFxiaHB3L2ksICd3ZWInKVxyXG4gICAgICAgIC5yZXBsYWNlKC9cXGJNYWNpbnRvc2hcXGIvLCAnTWFjIE9TJylcclxuICAgICAgICAucmVwbGFjZSgvX1Bvd2VyUENcXGIvaSwgJyBPUycpXHJcbiAgICAgICAgLnJlcGxhY2UoL1xcYihPUyBYKSBbXiBcXGRdKy9pLCAnJDEnKVxyXG4gICAgICAgIC5yZXBsYWNlKC9cXGJNYWMgKE9TIFgpXFxiLywgJyQxJylcclxuICAgICAgICAucmVwbGFjZSgvXFwvKFxcZCkvLCAnICQxJylcclxuICAgICAgICAucmVwbGFjZSgvXy9nLCAnLicpXHJcbiAgICAgICAgLnJlcGxhY2UoLyg/OiBCZVBDfFsgLl0qZmNbIFxcZC5dKykkL2ksICcnKVxyXG4gICAgICAgIC5yZXBsYWNlKC9cXGJ4ODZcXC42NFxcYi9naSwgJ3g4Nl82NCcpXHJcbiAgICAgICAgLnJlcGxhY2UoL1xcYihXaW5kb3dzIFBob25lKSBPU1xcYi8sICckMScpXHJcbiAgICAgICAgLnJlcGxhY2UoL1xcYihDaHJvbWUgT1MgXFx3KykgW1xcZC5dK1xcYi8sICckMScpXHJcbiAgICAgICAgLnNwbGl0KCcgb24gJylbMF1cclxuICAgICk7XHJcblxyXG4gICAgcmV0dXJuIG9zO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQW4gaXRlcmF0aW9uIHV0aWxpdHkgZm9yIGFycmF5cyBhbmQgb2JqZWN0cy5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlciBpdGVyYXRpb24uXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gZWFjaChvYmplY3QsIGNhbGxiYWNrKSB7XHJcbiAgICB2YXIgaW5kZXggPSAtMSxcclxuICAgICAgICBsZW5ndGggPSBvYmplY3QgPyBvYmplY3QubGVuZ3RoIDogMDtcclxuXHJcbiAgICBpZiAodHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJyAmJiBsZW5ndGggPiAtMSAmJiBsZW5ndGggPD0gbWF4U2FmZUludGVnZXIpIHtcclxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcclxuICAgICAgICBjYWxsYmFjayhvYmplY3RbaW5kZXhdLCBpbmRleCwgb2JqZWN0KTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZm9yT3duKG9iamVjdCwgY2FsbGJhY2spO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVHJpbSBhbmQgY29uZGl0aW9uYWxseSBjYXBpdGFsaXplIHN0cmluZyB2YWx1ZXMuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBmb3JtYXQuXHJcbiAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGZvcm1hdHRlZCBzdHJpbmcuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gZm9ybWF0KHN0cmluZykge1xyXG4gICAgc3RyaW5nID0gdHJpbShzdHJpbmcpO1xyXG4gICAgcmV0dXJuIC9eKD86d2ViT1N8aSg/Ok9TfFApKS8udGVzdChzdHJpbmcpXHJcbiAgICAgID8gc3RyaW5nXHJcbiAgICAgIDogY2FwaXRhbGl6ZShzdHJpbmcpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSXRlcmF0ZXMgb3ZlciBhbiBvYmplY3QncyBvd24gcHJvcGVydGllcywgZXhlY3V0aW5nIHRoZSBgY2FsbGJhY2tgIGZvciBlYWNoLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiBleGVjdXRlZCBwZXIgb3duIHByb3BlcnR5LlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGZvck93bihvYmplY3QsIGNhbGxiYWNrKSB7XHJcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XHJcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkge1xyXG4gICAgICAgIGNhbGxiYWNrKG9iamVjdFtrZXldLCBrZXksIG9iamVjdCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgdGhlIGludGVybmFsIGBbW0NsYXNzXV1gIG9mIGEgdmFsdWUuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlLlxyXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBgW1tDbGFzc11dYC5cclxuICAgKi9cclxuICBmdW5jdGlvbiBnZXRDbGFzc09mKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdmFsdWUgPT0gbnVsbFxyXG4gICAgICA/IGNhcGl0YWxpemUodmFsdWUpXHJcbiAgICAgIDogdG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSG9zdCBvYmplY3RzIGNhbiByZXR1cm4gdHlwZSB2YWx1ZXMgdGhhdCBhcmUgZGlmZmVyZW50IGZyb20gdGhlaXIgYWN0dWFsXHJcbiAgICogZGF0YSB0eXBlLiBUaGUgb2JqZWN0cyB3ZSBhcmUgY29uY2VybmVkIHdpdGggdXN1YWxseSByZXR1cm4gbm9uLXByaW1pdGl2ZVxyXG4gICAqIHR5cGVzIG9mIFwib2JqZWN0XCIsIFwiZnVuY3Rpb25cIiwgb3IgXCJ1bmtub3duXCIuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7Kn0gb2JqZWN0IFRoZSBvd25lciBvZiB0aGUgcHJvcGVydHkuXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFRoZSBwcm9wZXJ0eSB0byBjaGVjay5cclxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHByb3BlcnR5IHZhbHVlIGlzIGEgbm9uLXByaW1pdGl2ZSwgZWxzZSBgZmFsc2VgLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGlzSG9zdFR5cGUob2JqZWN0LCBwcm9wZXJ0eSkge1xyXG4gICAgdmFyIHR5cGUgPSBvYmplY3QgIT0gbnVsbCA/IHR5cGVvZiBvYmplY3RbcHJvcGVydHldIDogJ251bWJlcic7XHJcbiAgICByZXR1cm4gIS9eKD86Ym9vbGVhbnxudW1iZXJ8c3RyaW5nfHVuZGVmaW5lZCkkLy50ZXN0KHR5cGUpICYmXHJcbiAgICAgICh0eXBlID09ICdvYmplY3QnID8gISFvYmplY3RbcHJvcGVydHldIDogdHJ1ZSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBQcmVwYXJlcyBhIHN0cmluZyBmb3IgdXNlIGluIGEgYFJlZ0V4cGAgYnkgbWFraW5nIGh5cGhlbnMgYW5kIHNwYWNlcyBvcHRpb25hbC5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIHF1YWxpZnkuXHJcbiAgICogQHJldHVybnMge3N0cmluZ30gVGhlIHF1YWxpZmllZCBzdHJpbmcuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gcXVhbGlmeShzdHJpbmcpIHtcclxuICAgIHJldHVybiBTdHJpbmcoc3RyaW5nKS5yZXBsYWNlKC8oWyAtXSkoPyEkKS9nLCAnJDE/Jyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBIGJhcmUtYm9uZXMgYEFycmF5I3JlZHVjZWAgbGlrZSB1dGlsaXR5IGZ1bmN0aW9uLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyIGl0ZXJhdGlvbi5cclxuICAgKiBAcmV0dXJucyB7Kn0gVGhlIGFjY3VtdWxhdGVkIHJlc3VsdC5cclxuICAgKi9cclxuICBmdW5jdGlvbiByZWR1Y2UoYXJyYXksIGNhbGxiYWNrKSB7XHJcbiAgICB2YXIgYWNjdW11bGF0b3IgPSBudWxsO1xyXG4gICAgZWFjaChhcnJheSwgZnVuY3Rpb24odmFsdWUsIGluZGV4KSB7XHJcbiAgICAgIGFjY3VtdWxhdG9yID0gY2FsbGJhY2soYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgYXJyYXkpO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gYWNjdW11bGF0b3I7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZW1vdmVzIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2UgZnJvbSBhIHN0cmluZy5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIHRyaW0uXHJcbiAgICogQHJldHVybnMge3N0cmluZ30gVGhlIHRyaW1tZWQgc3RyaW5nLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIHRyaW0oc3RyaW5nKSB7XHJcbiAgICByZXR1cm4gU3RyaW5nKHN0cmluZykucmVwbGFjZSgvXiArfCArJC9nLCAnJyk7XHJcbiAgfVxyXG5cclxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhIG5ldyBwbGF0Zm9ybSBvYmplY3QuXHJcbiAgICpcclxuICAgKiBAbWVtYmVyT2YgcGxhdGZvcm1cclxuICAgKiBAcGFyYW0ge09iamVjdHxzdHJpbmd9IFt1YT1uYXZpZ2F0b3IudXNlckFnZW50XSBUaGUgdXNlciBhZ2VudCBzdHJpbmcgb3JcclxuICAgKiAgY29udGV4dCBvYmplY3QuXHJcbiAgICogQHJldHVybnMge09iamVjdH0gQSBwbGF0Zm9ybSBvYmplY3QuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gcGFyc2UodWEpIHtcclxuXHJcbiAgICAvKiogVGhlIGVudmlyb25tZW50IGNvbnRleHQgb2JqZWN0LiAqL1xyXG4gICAgdmFyIGNvbnRleHQgPSByb290O1xyXG5cclxuICAgIC8qKiBVc2VkIHRvIGZsYWcgd2hlbiBhIGN1c3RvbSBjb250ZXh0IGlzIHByb3ZpZGVkLiAqL1xyXG4gICAgdmFyIGlzQ3VzdG9tQ29udGV4dCA9IHVhICYmIHR5cGVvZiB1YSA9PSAnb2JqZWN0JyAmJiBnZXRDbGFzc09mKHVhKSAhPSAnU3RyaW5nJztcclxuXHJcbiAgICAvLyBKdWdnbGUgYXJndW1lbnRzLlxyXG4gICAgaWYgKGlzQ3VzdG9tQ29udGV4dCkge1xyXG4gICAgICBjb250ZXh0ID0gdWE7XHJcbiAgICAgIHVhID0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICAvKiogQnJvd3NlciBuYXZpZ2F0b3Igb2JqZWN0LiAqL1xyXG4gICAgdmFyIG5hdiA9IGNvbnRleHQubmF2aWdhdG9yIHx8IHt9O1xyXG5cclxuICAgIC8qKiBCcm93c2VyIHVzZXIgYWdlbnQgc3RyaW5nLiAqL1xyXG4gICAgdmFyIHVzZXJBZ2VudCA9IG5hdi51c2VyQWdlbnQgfHwgJyc7XHJcblxyXG4gICAgdWEgfHwgKHVhID0gdXNlckFnZW50KTtcclxuXHJcbiAgICAvKiogVXNlZCB0byBmbGFnIHdoZW4gYHRoaXNCaW5kaW5nYCBpcyB0aGUgW01vZHVsZVNjb3BlXS4gKi9cclxuICAgIHZhciBpc01vZHVsZVNjb3BlID0gaXNDdXN0b21Db250ZXh0IHx8IHRoaXNCaW5kaW5nID09IG9sZFJvb3Q7XHJcblxyXG4gICAgLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGJyb3dzZXIgaXMgbGlrZSBDaHJvbWUuICovXHJcbiAgICB2YXIgbGlrZUNocm9tZSA9IGlzQ3VzdG9tQ29udGV4dFxyXG4gICAgICA/ICEhbmF2Lmxpa2VDaHJvbWVcclxuICAgICAgOiAvXFxiQ2hyb21lXFxiLy50ZXN0KHVhKSAmJiAhL2ludGVybmFsfFxcbi9pLnRlc3QodG9TdHJpbmcudG9TdHJpbmcoKSk7XHJcblxyXG4gICAgLyoqIEludGVybmFsIGBbW0NsYXNzXV1gIHZhbHVlIHNob3J0Y3V0cy4gKi9cclxuICAgIHZhciBvYmplY3RDbGFzcyA9ICdPYmplY3QnLFxyXG4gICAgICAgIGFpclJ1bnRpbWVDbGFzcyA9IGlzQ3VzdG9tQ29udGV4dCA/IG9iamVjdENsYXNzIDogJ1NjcmlwdEJyaWRnaW5nUHJveHlPYmplY3QnLFxyXG4gICAgICAgIGVudmlyb0NsYXNzID0gaXNDdXN0b21Db250ZXh0ID8gb2JqZWN0Q2xhc3MgOiAnRW52aXJvbm1lbnQnLFxyXG4gICAgICAgIGphdmFDbGFzcyA9IChpc0N1c3RvbUNvbnRleHQgJiYgY29udGV4dC5qYXZhKSA/ICdKYXZhUGFja2FnZScgOiBnZXRDbGFzc09mKGNvbnRleHQuamF2YSksXHJcbiAgICAgICAgcGhhbnRvbUNsYXNzID0gaXNDdXN0b21Db250ZXh0ID8gb2JqZWN0Q2xhc3MgOiAnUnVudGltZU9iamVjdCc7XHJcblxyXG4gICAgLyoqIERldGVjdCBKYXZhIGVudmlyb25tZW50cy4gKi9cclxuICAgIHZhciBqYXZhID0gL1xcYkphdmEvLnRlc3QoamF2YUNsYXNzKSAmJiBjb250ZXh0LmphdmE7XHJcblxyXG4gICAgLyoqIERldGVjdCBSaGluby4gKi9cclxuICAgIHZhciByaGlubyA9IGphdmEgJiYgZ2V0Q2xhc3NPZihjb250ZXh0LmVudmlyb25tZW50KSA9PSBlbnZpcm9DbGFzcztcclxuXHJcbiAgICAvKiogQSBjaGFyYWN0ZXIgdG8gcmVwcmVzZW50IGFscGhhLiAqL1xyXG4gICAgdmFyIGFscGhhID0gamF2YSA/ICdhJyA6ICdcXHUwM2IxJztcclxuXHJcbiAgICAvKiogQSBjaGFyYWN0ZXIgdG8gcmVwcmVzZW50IGJldGEuICovXHJcbiAgICB2YXIgYmV0YSA9IGphdmEgPyAnYicgOiAnXFx1MDNiMic7XHJcblxyXG4gICAgLyoqIEJyb3dzZXIgZG9jdW1lbnQgb2JqZWN0LiAqL1xyXG4gICAgdmFyIGRvYyA9IGNvbnRleHQuZG9jdW1lbnQgfHwge307XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZXRlY3QgT3BlcmEgYnJvd3NlciAoUHJlc3RvLWJhc2VkKS5cclxuICAgICAqIGh0dHA6Ly93d3cuaG93dG9jcmVhdGUuY28udWsvb3BlcmFTdHVmZi9vcGVyYU9iamVjdC5odG1sXHJcbiAgICAgKiBodHRwOi8vZGV2Lm9wZXJhLmNvbS9hcnRpY2xlcy92aWV3L29wZXJhLW1pbmktd2ViLWNvbnRlbnQtYXV0aG9yaW5nLWd1aWRlbGluZXMvI29wZXJhbWluaVxyXG4gICAgICovXHJcbiAgICB2YXIgb3BlcmEgPSBjb250ZXh0Lm9wZXJhbWluaSB8fCBjb250ZXh0Lm9wZXJhO1xyXG5cclxuICAgIC8qKiBPcGVyYSBgW1tDbGFzc11dYC4gKi9cclxuICAgIHZhciBvcGVyYUNsYXNzID0gcmVPcGVyYS50ZXN0KG9wZXJhQ2xhc3MgPSAoaXNDdXN0b21Db250ZXh0ICYmIG9wZXJhKSA/IG9wZXJhWydbW0NsYXNzXV0nXSA6IGdldENsYXNzT2Yob3BlcmEpKVxyXG4gICAgICA/IG9wZXJhQ2xhc3NcclxuICAgICAgOiAob3BlcmEgPSBudWxsKTtcclxuXHJcbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcblxyXG4gICAgLyoqIFRlbXBvcmFyeSB2YXJpYWJsZSB1c2VkIG92ZXIgdGhlIHNjcmlwdCdzIGxpZmV0aW1lLiAqL1xyXG4gICAgdmFyIGRhdGE7XHJcblxyXG4gICAgLyoqIFRoZSBDUFUgYXJjaGl0ZWN0dXJlLiAqL1xyXG4gICAgdmFyIGFyY2ggPSB1YTtcclxuXHJcbiAgICAvKiogUGxhdGZvcm0gZGVzY3JpcHRpb24gYXJyYXkuICovXHJcbiAgICB2YXIgZGVzY3JpcHRpb24gPSBbXTtcclxuXHJcbiAgICAvKiogUGxhdGZvcm0gYWxwaGEvYmV0YSBpbmRpY2F0b3IuICovXHJcbiAgICB2YXIgcHJlcmVsZWFzZSA9IG51bGw7XHJcblxyXG4gICAgLyoqIEEgZmxhZyB0byBpbmRpY2F0ZSB0aGF0IGVudmlyb25tZW50IGZlYXR1cmVzIHNob3VsZCBiZSB1c2VkIHRvIHJlc29sdmUgdGhlIHBsYXRmb3JtLiAqL1xyXG4gICAgdmFyIHVzZUZlYXR1cmVzID0gdWEgPT0gdXNlckFnZW50O1xyXG5cclxuICAgIC8qKiBUaGUgYnJvd3Nlci9lbnZpcm9ubWVudCB2ZXJzaW9uLiAqL1xyXG4gICAgdmFyIHZlcnNpb24gPSB1c2VGZWF0dXJlcyAmJiBvcGVyYSAmJiB0eXBlb2Ygb3BlcmEudmVyc2lvbiA9PSAnZnVuY3Rpb24nICYmIG9wZXJhLnZlcnNpb24oKTtcclxuXHJcbiAgICAvKiogQSBmbGFnIHRvIGluZGljYXRlIGlmIHRoZSBPUyBlbmRzIHdpdGggXCIvIFZlcnNpb25cIiAqL1xyXG4gICAgdmFyIGlzU3BlY2lhbENhc2VkT1M7XHJcblxyXG4gICAgLyogRGV0ZWN0YWJsZSBsYXlvdXQgZW5naW5lcyAob3JkZXIgaXMgaW1wb3J0YW50KS4gKi9cclxuICAgIHZhciBsYXlvdXQgPSBnZXRMYXlvdXQoW1xyXG4gICAgICB7ICdsYWJlbCc6ICdFZGdlSFRNTCcsICdwYXR0ZXJuJzogJ0VkZ2UnIH0sXHJcbiAgICAgICdUcmlkZW50JyxcclxuICAgICAgeyAnbGFiZWwnOiAnV2ViS2l0JywgJ3BhdHRlcm4nOiAnQXBwbGVXZWJLaXQnIH0sXHJcbiAgICAgICdpQ2FiJyxcclxuICAgICAgJ1ByZXN0bycsXHJcbiAgICAgICdOZXRGcm9udCcsXHJcbiAgICAgICdUYXNtYW4nLFxyXG4gICAgICAnS0hUTUwnLFxyXG4gICAgICAnR2Vja28nXHJcbiAgICBdKTtcclxuXHJcbiAgICAvKiBEZXRlY3RhYmxlIGJyb3dzZXIgbmFtZXMgKG9yZGVyIGlzIGltcG9ydGFudCkuICovXHJcbiAgICB2YXIgbmFtZSA9IGdldE5hbWUoW1xyXG4gICAgICAnQWRvYmUgQUlSJyxcclxuICAgICAgJ0Fyb3JhJyxcclxuICAgICAgJ0F2YW50IEJyb3dzZXInLFxyXG4gICAgICAnQnJlYWNoJyxcclxuICAgICAgJ0NhbWlubycsXHJcbiAgICAgICdFcGlwaGFueScsXHJcbiAgICAgICdGZW5uZWMnLFxyXG4gICAgICAnRmxvY2snLFxyXG4gICAgICAnR2FsZW9uJyxcclxuICAgICAgJ0dyZWVuQnJvd3NlcicsXHJcbiAgICAgICdpQ2FiJyxcclxuICAgICAgJ0ljZXdlYXNlbCcsXHJcbiAgICAgICdLLU1lbGVvbicsXHJcbiAgICAgICdLb25xdWVyb3InLFxyXG4gICAgICAnTHVuYXNjYXBlJyxcclxuICAgICAgJ01heHRob24nLFxyXG4gICAgICB7ICdsYWJlbCc6ICdNaWNyb3NvZnQgRWRnZScsICdwYXR0ZXJuJzogJ0VkZ2UnIH0sXHJcbiAgICAgICdNaWRvcmknLFxyXG4gICAgICAnTm9vayBCcm93c2VyJyxcclxuICAgICAgJ1BhbGVNb29uJyxcclxuICAgICAgJ1BoYW50b21KUycsXHJcbiAgICAgICdSYXZlbicsXHJcbiAgICAgICdSZWtvbnEnLFxyXG4gICAgICAnUm9ja01lbHQnLFxyXG4gICAgICAnU2VhTW9ua2V5JyxcclxuICAgICAgeyAnbGFiZWwnOiAnU2lsaycsICdwYXR0ZXJuJzogJyg/OkNsb3VkOXxTaWxrLUFjY2VsZXJhdGVkKScgfSxcclxuICAgICAgJ1NsZWlwbmlyJyxcclxuICAgICAgJ1NsaW1Ccm93c2VyJyxcclxuICAgICAgeyAnbGFiZWwnOiAnU1JXYXJlIElyb24nLCAncGF0dGVybic6ICdJcm9uJyB9LFxyXG4gICAgICAnU3VucmlzZScsXHJcbiAgICAgICdTd2lmdGZveCcsXHJcbiAgICAgICdXZWJQb3NpdGl2ZScsXHJcbiAgICAgICdPcGVyYSBNaW5pJyxcclxuICAgICAgeyAnbGFiZWwnOiAnT3BlcmEgTWluaScsICdwYXR0ZXJuJzogJ09QaU9TJyB9LFxyXG4gICAgICAnT3BlcmEnLFxyXG4gICAgICB7ICdsYWJlbCc6ICdPcGVyYScsICdwYXR0ZXJuJzogJ09QUicgfSxcclxuICAgICAgJ0Nocm9tZScsXHJcbiAgICAgIHsgJ2xhYmVsJzogJ0Nocm9tZSBNb2JpbGUnLCAncGF0dGVybic6ICcoPzpDcmlPU3xDck1vKScgfSxcclxuICAgICAgeyAnbGFiZWwnOiAnRmlyZWZveCcsICdwYXR0ZXJuJzogJyg/OkZpcmVmb3h8TWluZWZpZWxkKScgfSxcclxuICAgICAgeyAnbGFiZWwnOiAnRmlyZWZveCBmb3IgaU9TJywgJ3BhdHRlcm4nOiAnRnhpT1MnIH0sXHJcbiAgICAgIHsgJ2xhYmVsJzogJ0lFJywgJ3BhdHRlcm4nOiAnSUVNb2JpbGUnIH0sXHJcbiAgICAgIHsgJ2xhYmVsJzogJ0lFJywgJ3BhdHRlcm4nOiAnTVNJRScgfSxcclxuICAgICAgJ1NhZmFyaSdcclxuICAgIF0pO1xyXG5cclxuICAgIC8qIERldGVjdGFibGUgcHJvZHVjdHMgKG9yZGVyIGlzIGltcG9ydGFudCkuICovXHJcbiAgICB2YXIgcHJvZHVjdCA9IGdldFByb2R1Y3QoW1xyXG4gICAgICB7ICdsYWJlbCc6ICdCbGFja0JlcnJ5JywgJ3BhdHRlcm4nOiAnQkIxMCcgfSxcclxuICAgICAgJ0JsYWNrQmVycnknLFxyXG4gICAgICB7ICdsYWJlbCc6ICdHYWxheHkgUycsICdwYXR0ZXJuJzogJ0dULUk5MDAwJyB9LFxyXG4gICAgICB7ICdsYWJlbCc6ICdHYWxheHkgUzInLCAncGF0dGVybic6ICdHVC1JOTEwMCcgfSxcclxuICAgICAgeyAnbGFiZWwnOiAnR2FsYXh5IFMzJywgJ3BhdHRlcm4nOiAnR1QtSTkzMDAnIH0sXHJcbiAgICAgIHsgJ2xhYmVsJzogJ0dhbGF4eSBTNCcsICdwYXR0ZXJuJzogJ0dULUk5NTAwJyB9LFxyXG4gICAgICAnR29vZ2xlIFRWJyxcclxuICAgICAgJ0x1bWlhJyxcclxuICAgICAgJ2lQYWQnLFxyXG4gICAgICAnaVBvZCcsXHJcbiAgICAgICdpUGhvbmUnLFxyXG4gICAgICAnS2luZGxlJyxcclxuICAgICAgeyAnbGFiZWwnOiAnS2luZGxlIEZpcmUnLCAncGF0dGVybic6ICcoPzpDbG91ZDl8U2lsay1BY2NlbGVyYXRlZCknIH0sXHJcbiAgICAgICdOZXh1cycsXHJcbiAgICAgICdOb29rJyxcclxuICAgICAgJ1BsYXlCb29rJyxcclxuICAgICAgJ1BsYXlTdGF0aW9uIDMnLFxyXG4gICAgICAnUGxheVN0YXRpb24gNCcsXHJcbiAgICAgICdQbGF5U3RhdGlvbiBWaXRhJyxcclxuICAgICAgJ1RvdWNoUGFkJyxcclxuICAgICAgJ1RyYW5zZm9ybWVyJyxcclxuICAgICAgeyAnbGFiZWwnOiAnV2lpIFUnLCAncGF0dGVybic6ICdXaWlVJyB9LFxyXG4gICAgICAnV2lpJyxcclxuICAgICAgJ1hib3ggT25lJyxcclxuICAgICAgeyAnbGFiZWwnOiAnWGJveCAzNjAnLCAncGF0dGVybic6ICdYYm94JyB9LFxyXG4gICAgICAnWG9vbSdcclxuICAgIF0pO1xyXG5cclxuICAgIC8qIERldGVjdGFibGUgbWFudWZhY3R1cmVycy4gKi9cclxuICAgIHZhciBtYW51ZmFjdHVyZXIgPSBnZXRNYW51ZmFjdHVyZXIoe1xyXG4gICAgICAnQXBwbGUnOiB7ICdpUGFkJzogMSwgJ2lQaG9uZSc6IDEsICdpUG9kJzogMSB9LFxyXG4gICAgICAnQXJjaG9zJzoge30sXHJcbiAgICAgICdBbWF6b24nOiB7ICdLaW5kbGUnOiAxLCAnS2luZGxlIEZpcmUnOiAxIH0sXHJcbiAgICAgICdBc3VzJzogeyAnVHJhbnNmb3JtZXInOiAxIH0sXHJcbiAgICAgICdCYXJuZXMgJiBOb2JsZSc6IHsgJ05vb2snOiAxIH0sXHJcbiAgICAgICdCbGFja0JlcnJ5JzogeyAnUGxheUJvb2snOiAxIH0sXHJcbiAgICAgICdHb29nbGUnOiB7ICdHb29nbGUgVFYnOiAxLCAnTmV4dXMnOiAxIH0sXHJcbiAgICAgICdIUCc6IHsgJ1RvdWNoUGFkJzogMSB9LFxyXG4gICAgICAnSFRDJzoge30sXHJcbiAgICAgICdMRyc6IHt9LFxyXG4gICAgICAnTWljcm9zb2Z0JzogeyAnWGJveCc6IDEsICdYYm94IE9uZSc6IDEgfSxcclxuICAgICAgJ01vdG9yb2xhJzogeyAnWG9vbSc6IDEgfSxcclxuICAgICAgJ05pbnRlbmRvJzogeyAnV2lpIFUnOiAxLCAgJ1dpaSc6IDEgfSxcclxuICAgICAgJ05va2lhJzogeyAnTHVtaWEnOiAxIH0sXHJcbiAgICAgICdTYW1zdW5nJzogeyAnR2FsYXh5IFMnOiAxLCAnR2FsYXh5IFMyJzogMSwgJ0dhbGF4eSBTMyc6IDEsICdHYWxheHkgUzQnOiAxIH0sXHJcbiAgICAgICdTb255JzogeyAnUGxheVN0YXRpb24gNCc6IDEsICdQbGF5U3RhdGlvbiAzJzogMSwgJ1BsYXlTdGF0aW9uIFZpdGEnOiAxIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8qIERldGVjdGFibGUgb3BlcmF0aW5nIHN5c3RlbXMgKG9yZGVyIGlzIGltcG9ydGFudCkuICovXHJcbiAgICB2YXIgb3MgPSBnZXRPUyhbXHJcbiAgICAgICdXaW5kb3dzIFBob25lJyxcclxuICAgICAgJ0FuZHJvaWQnLFxyXG4gICAgICAnQ2VudE9TJyxcclxuICAgICAgeyAnbGFiZWwnOiAnQ2hyb21lIE9TJywgJ3BhdHRlcm4nOiAnQ3JPUycgfSxcclxuICAgICAgJ0RlYmlhbicsXHJcbiAgICAgICdGZWRvcmEnLFxyXG4gICAgICAnRnJlZUJTRCcsXHJcbiAgICAgICdHZW50b28nLFxyXG4gICAgICAnSGFpa3UnLFxyXG4gICAgICAnS3VidW50dScsXHJcbiAgICAgICdMaW51eCBNaW50JyxcclxuICAgICAgJ09wZW5CU0QnLFxyXG4gICAgICAnUmVkIEhhdCcsXHJcbiAgICAgICdTdVNFJyxcclxuICAgICAgJ1VidW50dScsXHJcbiAgICAgICdYdWJ1bnR1JyxcclxuICAgICAgJ0N5Z3dpbicsXHJcbiAgICAgICdTeW1iaWFuIE9TJyxcclxuICAgICAgJ2hwd09TJyxcclxuICAgICAgJ3dlYk9TICcsXHJcbiAgICAgICd3ZWJPUycsXHJcbiAgICAgICdUYWJsZXQgT1MnLFxyXG4gICAgICAnTGludXgnLFxyXG4gICAgICAnTWFjIE9TIFgnLFxyXG4gICAgICAnTWFjaW50b3NoJyxcclxuICAgICAgJ01hYycsXHJcbiAgICAgICdXaW5kb3dzIDk4OycsXHJcbiAgICAgICdXaW5kb3dzICdcclxuICAgIF0pO1xyXG5cclxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIFBpY2tzIHRoZSBsYXlvdXQgZW5naW5lIGZyb20gYW4gYXJyYXkgb2YgZ3Vlc3Nlcy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gZ3Vlc3NlcyBBbiBhcnJheSBvZiBndWVzc2VzLlxyXG4gICAgICogQHJldHVybnMge251bGx8c3RyaW5nfSBUaGUgZGV0ZWN0ZWQgbGF5b3V0IGVuZ2luZS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZ2V0TGF5b3V0KGd1ZXNzZXMpIHtcclxuICAgICAgcmV0dXJuIHJlZHVjZShndWVzc2VzLCBmdW5jdGlvbihyZXN1bHQsIGd1ZXNzKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdCB8fCBSZWdFeHAoJ1xcXFxiJyArIChcclxuICAgICAgICAgIGd1ZXNzLnBhdHRlcm4gfHwgcXVhbGlmeShndWVzcylcclxuICAgICAgICApICsgJ1xcXFxiJywgJ2knKS5leGVjKHVhKSAmJiAoZ3Vlc3MubGFiZWwgfHwgZ3Vlc3MpO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFBpY2tzIHRoZSBtYW51ZmFjdHVyZXIgZnJvbSBhbiBhcnJheSBvZiBndWVzc2VzLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBndWVzc2VzIEFuIG9iamVjdCBvZiBndWVzc2VzLlxyXG4gICAgICogQHJldHVybnMge251bGx8c3RyaW5nfSBUaGUgZGV0ZWN0ZWQgbWFudWZhY3R1cmVyLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBnZXRNYW51ZmFjdHVyZXIoZ3Vlc3Nlcykge1xyXG4gICAgICByZXR1cm4gcmVkdWNlKGd1ZXNzZXMsIGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xyXG4gICAgICAgIC8vIExvb2t1cCB0aGUgbWFudWZhY3R1cmVyIGJ5IHByb2R1Y3Qgb3Igc2NhbiB0aGUgVUEgZm9yIHRoZSBtYW51ZmFjdHVyZXIuXHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdCB8fCAoXHJcbiAgICAgICAgICB2YWx1ZVtwcm9kdWN0XSB8fFxyXG4gICAgICAgICAgdmFsdWVbL15bYS16XSsoPzogK1thLXpdK1xcYikqL2kuZXhlYyhwcm9kdWN0KV0gfHxcclxuICAgICAgICAgIFJlZ0V4cCgnXFxcXGInICsgcXVhbGlmeShrZXkpICsgJyg/OlxcXFxifFxcXFx3KlxcXFxkKScsICdpJykuZXhlYyh1YSlcclxuICAgICAgICApICYmIGtleTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQaWNrcyB0aGUgYnJvd3NlciBuYW1lIGZyb20gYW4gYXJyYXkgb2YgZ3Vlc3Nlcy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gZ3Vlc3NlcyBBbiBhcnJheSBvZiBndWVzc2VzLlxyXG4gICAgICogQHJldHVybnMge251bGx8c3RyaW5nfSBUaGUgZGV0ZWN0ZWQgYnJvd3NlciBuYW1lLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBnZXROYW1lKGd1ZXNzZXMpIHtcclxuICAgICAgcmV0dXJuIHJlZHVjZShndWVzc2VzLCBmdW5jdGlvbihyZXN1bHQsIGd1ZXNzKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdCB8fCBSZWdFeHAoJ1xcXFxiJyArIChcclxuICAgICAgICAgIGd1ZXNzLnBhdHRlcm4gfHwgcXVhbGlmeShndWVzcylcclxuICAgICAgICApICsgJ1xcXFxiJywgJ2knKS5leGVjKHVhKSAmJiAoZ3Vlc3MubGFiZWwgfHwgZ3Vlc3MpO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFBpY2tzIHRoZSBPUyBuYW1lIGZyb20gYW4gYXJyYXkgb2YgZ3Vlc3Nlcy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gZ3Vlc3NlcyBBbiBhcnJheSBvZiBndWVzc2VzLlxyXG4gICAgICogQHJldHVybnMge251bGx8c3RyaW5nfSBUaGUgZGV0ZWN0ZWQgT1MgbmFtZS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZ2V0T1MoZ3Vlc3Nlcykge1xyXG4gICAgICByZXR1cm4gcmVkdWNlKGd1ZXNzZXMsIGZ1bmN0aW9uKHJlc3VsdCwgZ3Vlc3MpIHtcclxuICAgICAgICB2YXIgcGF0dGVybiA9IGd1ZXNzLnBhdHRlcm4gfHwgcXVhbGlmeShndWVzcyk7XHJcbiAgICAgICAgaWYgKCFyZXN1bHQgJiYgKHJlc3VsdCA9XHJcbiAgICAgICAgICAgICAgUmVnRXhwKCdcXFxcYicgKyBwYXR0ZXJuICsgJyg/Oi9bXFxcXGQuXSt8WyBcXFxcdy5dKiknLCAnaScpLmV4ZWModWEpXHJcbiAgICAgICAgICAgICkpIHtcclxuICAgICAgICAgIHJlc3VsdCA9IGNsZWFudXBPUyhyZXN1bHQsIHBhdHRlcm4sIGd1ZXNzLmxhYmVsIHx8IGd1ZXNzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQaWNrcyB0aGUgcHJvZHVjdCBuYW1lIGZyb20gYW4gYXJyYXkgb2YgZ3Vlc3Nlcy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gZ3Vlc3NlcyBBbiBhcnJheSBvZiBndWVzc2VzLlxyXG4gICAgICogQHJldHVybnMge251bGx8c3RyaW5nfSBUaGUgZGV0ZWN0ZWQgcHJvZHVjdCBuYW1lLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBnZXRQcm9kdWN0KGd1ZXNzZXMpIHtcclxuICAgICAgcmV0dXJuIHJlZHVjZShndWVzc2VzLCBmdW5jdGlvbihyZXN1bHQsIGd1ZXNzKSB7XHJcbiAgICAgICAgdmFyIHBhdHRlcm4gPSBndWVzcy5wYXR0ZXJuIHx8IHF1YWxpZnkoZ3Vlc3MpO1xyXG4gICAgICAgIGlmICghcmVzdWx0ICYmIChyZXN1bHQgPVxyXG4gICAgICAgICAgICAgIFJlZ0V4cCgnXFxcXGInICsgcGF0dGVybiArICcgKlxcXFxkK1suXFxcXHdfXSonLCAnaScpLmV4ZWModWEpIHx8XHJcbiAgICAgICAgICAgICAgUmVnRXhwKCdcXFxcYicgKyBwYXR0ZXJuICsgJyg/OjsgKig/OlthLXpdK1tfLV0pP1thLXpdK1xcXFxkK3xbXiAoKTstXSopJywgJ2knKS5leGVjKHVhKVxyXG4gICAgICAgICAgICApKSB7XHJcbiAgICAgICAgICAvLyBTcGxpdCBieSBmb3J3YXJkIHNsYXNoIGFuZCBhcHBlbmQgcHJvZHVjdCB2ZXJzaW9uIGlmIG5lZWRlZC5cclxuICAgICAgICAgIGlmICgocmVzdWx0ID0gU3RyaW5nKChndWVzcy5sYWJlbCAmJiAhUmVnRXhwKHBhdHRlcm4sICdpJykudGVzdChndWVzcy5sYWJlbCkpID8gZ3Vlc3MubGFiZWwgOiByZXN1bHQpLnNwbGl0KCcvJykpWzFdICYmICEvW1xcZC5dKy8udGVzdChyZXN1bHRbMF0pKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdFswXSArPSAnICcgKyByZXN1bHRbMV07XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICAvLyBDb3JyZWN0IGNoYXJhY3RlciBjYXNlIGFuZCBjbGVhbnVwIHN0cmluZy5cclxuICAgICAgICAgIGd1ZXNzID0gZ3Vlc3MubGFiZWwgfHwgZ3Vlc3M7XHJcbiAgICAgICAgICByZXN1bHQgPSBmb3JtYXQocmVzdWx0WzBdXHJcbiAgICAgICAgICAgIC5yZXBsYWNlKFJlZ0V4cChwYXR0ZXJuLCAnaScpLCBndWVzcylcclxuICAgICAgICAgICAgLnJlcGxhY2UoUmVnRXhwKCc7ICooPzonICsgZ3Vlc3MgKyAnW18tXSk/JywgJ2knKSwgJyAnKVxyXG4gICAgICAgICAgICAucmVwbGFjZShSZWdFeHAoJygnICsgZ3Vlc3MgKyAnKVstXy5dPyhcXFxcdyknLCAnaScpLCAnJDEgJDInKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVzb2x2ZXMgdGhlIHZlcnNpb24gdXNpbmcgYW4gYXJyYXkgb2YgVUEgcGF0dGVybnMuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhdHRlcm5zIEFuIGFycmF5IG9mIFVBIHBhdHRlcm5zLlxyXG4gICAgICogQHJldHVybnMge251bGx8c3RyaW5nfSBUaGUgZGV0ZWN0ZWQgdmVyc2lvbi5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZ2V0VmVyc2lvbihwYXR0ZXJucykge1xyXG4gICAgICByZXR1cm4gcmVkdWNlKHBhdHRlcm5zLCBmdW5jdGlvbihyZXN1bHQsIHBhdHRlcm4pIHtcclxuICAgICAgICByZXR1cm4gcmVzdWx0IHx8IChSZWdFeHAocGF0dGVybiArXHJcbiAgICAgICAgICAnKD86LVtcXFxcZC5dKy98KD86IGZvciBbXFxcXHctXSspP1sgLy1dKShbXFxcXGQuXStbXiAoKTsvXy1dKiknLCAnaScpLmV4ZWModWEpIHx8IDApWzFdIHx8IG51bGw7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBgcGxhdGZvcm0uZGVzY3JpcHRpb25gIHdoZW4gdGhlIHBsYXRmb3JtIG9iamVjdCBpcyBjb2VyY2VkIHRvIGEgc3RyaW5nLlxyXG4gICAgICpcclxuICAgICAqIEBuYW1lIHRvU3RyaW5nXHJcbiAgICAgKiBAbWVtYmVyT2YgcGxhdGZvcm1cclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgYHBsYXRmb3JtLmRlc2NyaXB0aW9uYCBpZiBhdmFpbGFibGUsIGVsc2UgYW4gZW1wdHkgc3RyaW5nLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiB0b1N0cmluZ1BsYXRmb3JtKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5kZXNjcmlwdGlvbiB8fCAnJztcclxuICAgIH1cclxuXHJcbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcblxyXG4gICAgLy8gQ29udmVydCBsYXlvdXQgdG8gYW4gYXJyYXkgc28gd2UgY2FuIGFkZCBleHRyYSBkZXRhaWxzLlxyXG4gICAgbGF5b3V0ICYmIChsYXlvdXQgPSBbbGF5b3V0XSk7XHJcblxyXG4gICAgLy8gRGV0ZWN0IHByb2R1Y3QgbmFtZXMgdGhhdCBjb250YWluIHRoZWlyIG1hbnVmYWN0dXJlcidzIG5hbWUuXHJcbiAgICBpZiAobWFudWZhY3R1cmVyICYmICFwcm9kdWN0KSB7XHJcbiAgICAgIHByb2R1Y3QgPSBnZXRQcm9kdWN0KFttYW51ZmFjdHVyZXJdKTtcclxuICAgIH1cclxuICAgIC8vIENsZWFuIHVwIEdvb2dsZSBUVi5cclxuICAgIGlmICgoZGF0YSA9IC9cXGJHb29nbGUgVFZcXGIvLmV4ZWMocHJvZHVjdCkpKSB7XHJcbiAgICAgIHByb2R1Y3QgPSBkYXRhWzBdO1xyXG4gICAgfVxyXG4gICAgLy8gRGV0ZWN0IHNpbXVsYXRvcnMuXHJcbiAgICBpZiAoL1xcYlNpbXVsYXRvclxcYi9pLnRlc3QodWEpKSB7XHJcbiAgICAgIHByb2R1Y3QgPSAocHJvZHVjdCA/IHByb2R1Y3QgKyAnICcgOiAnJykgKyAnU2ltdWxhdG9yJztcclxuICAgIH1cclxuICAgIC8vIERldGVjdCBPcGVyYSBNaW5pIDgrIHJ1bm5pbmcgaW4gVHVyYm8vVW5jb21wcmVzc2VkIG1vZGUgb24gaU9TLlxyXG4gICAgaWYgKG5hbWUgPT0gJ09wZXJhIE1pbmknICYmIC9cXGJPUGlPU1xcYi8udGVzdCh1YSkpIHtcclxuICAgICAgZGVzY3JpcHRpb24ucHVzaCgncnVubmluZyBpbiBUdXJiby9VbmNvbXByZXNzZWQgbW9kZScpO1xyXG4gICAgfVxyXG4gICAgLy8gRGV0ZWN0IElFIE1vYmlsZSAxMS5cclxuICAgIGlmIChuYW1lID09ICdJRScgJiYgL1xcYmxpa2UgaVBob25lIE9TXFxiLy50ZXN0KHVhKSkge1xyXG4gICAgICBkYXRhID0gcGFyc2UodWEucmVwbGFjZSgvbGlrZSBpUGhvbmUgT1MvLCAnJykpO1xyXG4gICAgICBtYW51ZmFjdHVyZXIgPSBkYXRhLm1hbnVmYWN0dXJlcjtcclxuICAgICAgcHJvZHVjdCA9IGRhdGEucHJvZHVjdDtcclxuICAgIH1cclxuICAgIC8vIERldGVjdCBpT1MuXHJcbiAgICBlbHNlIGlmICgvXmlQLy50ZXN0KHByb2R1Y3QpKSB7XHJcbiAgICAgIG5hbWUgfHwgKG5hbWUgPSAnU2FmYXJpJyk7XHJcbiAgICAgIG9zID0gJ2lPUycgKyAoKGRhdGEgPSAvIE9TIChbXFxkX10rKS9pLmV4ZWModWEpKVxyXG4gICAgICAgID8gJyAnICsgZGF0YVsxXS5yZXBsYWNlKC9fL2csICcuJylcclxuICAgICAgICA6ICcnKTtcclxuICAgIH1cclxuICAgIC8vIERldGVjdCBLdWJ1bnR1LlxyXG4gICAgZWxzZSBpZiAobmFtZSA9PSAnS29ucXVlcm9yJyAmJiAhL2J1bnR1L2kudGVzdChvcykpIHtcclxuICAgICAgb3MgPSAnS3VidW50dSc7XHJcbiAgICB9XHJcbiAgICAvLyBEZXRlY3QgQW5kcm9pZCBicm93c2Vycy5cclxuICAgIGVsc2UgaWYgKChtYW51ZmFjdHVyZXIgJiYgbWFudWZhY3R1cmVyICE9ICdHb29nbGUnICYmXHJcbiAgICAgICAgKCgvQ2hyb21lLy50ZXN0KG5hbWUpICYmICEvXFxiTW9iaWxlIFNhZmFyaVxcYi9pLnRlc3QodWEpKSB8fCAvXFxiVml0YVxcYi8udGVzdChwcm9kdWN0KSkpIHx8XHJcbiAgICAgICAgKC9cXGJBbmRyb2lkXFxiLy50ZXN0KG9zKSAmJiAvXkNocm9tZS8udGVzdChuYW1lKSAmJiAvXFxiVmVyc2lvblxcLy9pLnRlc3QodWEpKSkge1xyXG4gICAgICBuYW1lID0gJ0FuZHJvaWQgQnJvd3Nlcic7XHJcbiAgICAgIG9zID0gL1xcYkFuZHJvaWRcXGIvLnRlc3Qob3MpID8gb3MgOiAnQW5kcm9pZCc7XHJcbiAgICB9XHJcbiAgICAvLyBEZXRlY3QgU2lsayBkZXNrdG9wL2FjY2VsZXJhdGVkIG1vZGVzLlxyXG4gICAgZWxzZSBpZiAobmFtZSA9PSAnU2lsaycpIHtcclxuICAgICAgaWYgKCEvXFxiTW9iaS9pLnRlc3QodWEpKSB7XHJcbiAgICAgICAgb3MgPSAnQW5kcm9pZCc7XHJcbiAgICAgICAgZGVzY3JpcHRpb24udW5zaGlmdCgnZGVza3RvcCBtb2RlJyk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKC9BY2NlbGVyYXRlZCAqPSAqdHJ1ZS9pLnRlc3QodWEpKSB7XHJcbiAgICAgICAgZGVzY3JpcHRpb24udW5zaGlmdCgnYWNjZWxlcmF0ZWQnKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gRGV0ZWN0IFBhbGVNb29uIGlkZW50aWZ5aW5nIGFzIEZpcmVmb3guXHJcbiAgICBlbHNlIGlmIChuYW1lID09ICdQYWxlTW9vbicgJiYgKGRhdGEgPSAvXFxiRmlyZWZveFxcLyhbXFxkLl0rKVxcYi8uZXhlYyh1YSkpKSB7XHJcbiAgICAgIGRlc2NyaXB0aW9uLnB1c2goJ2lkZW50aWZ5aW5nIGFzIEZpcmVmb3ggJyArIGRhdGFbMV0pO1xyXG4gICAgfVxyXG4gICAgLy8gRGV0ZWN0IEZpcmVmb3ggT1MgYW5kIHByb2R1Y3RzIHJ1bm5pbmcgRmlyZWZveC5cclxuICAgIGVsc2UgaWYgKG5hbWUgPT0gJ0ZpcmVmb3gnICYmIChkYXRhID0gL1xcYihNb2JpbGV8VGFibGV0fFRWKVxcYi9pLmV4ZWModWEpKSkge1xyXG4gICAgICBvcyB8fCAob3MgPSAnRmlyZWZveCBPUycpO1xyXG4gICAgICBwcm9kdWN0IHx8IChwcm9kdWN0ID0gZGF0YVsxXSk7XHJcbiAgICB9XHJcbiAgICAvLyBEZXRlY3QgZmFsc2UgcG9zaXRpdmVzIGZvciBGaXJlZm94L1NhZmFyaS5cclxuICAgIGVsc2UgaWYgKCFuYW1lIHx8IChkYXRhID0gIS9cXGJNaW5lZmllbGRcXGIvaS50ZXN0KHVhKSAmJiAvXFxiKD86RmlyZWZveHxTYWZhcmkpXFxiLy5leGVjKG5hbWUpKSkge1xyXG4gICAgICAvLyBFc2NhcGUgdGhlIGAvYCBmb3IgRmlyZWZveCAxLlxyXG4gICAgICBpZiAobmFtZSAmJiAhcHJvZHVjdCAmJiAvW1xcLyxdfF5bXihdKz9cXCkvLnRlc3QodWEuc2xpY2UodWEuaW5kZXhPZihkYXRhICsgJy8nKSArIDgpKSkge1xyXG4gICAgICAgIC8vIENsZWFyIG5hbWUgb2YgZmFsc2UgcG9zaXRpdmVzLlxyXG4gICAgICAgIG5hbWUgPSBudWxsO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIFJlYXNzaWduIGEgZ2VuZXJpYyBuYW1lLlxyXG4gICAgICBpZiAoKGRhdGEgPSBwcm9kdWN0IHx8IG1hbnVmYWN0dXJlciB8fCBvcykgJiZcclxuICAgICAgICAgIChwcm9kdWN0IHx8IG1hbnVmYWN0dXJlciB8fCAvXFxiKD86QW5kcm9pZHxTeW1iaWFuIE9TfFRhYmxldCBPU3x3ZWJPUylcXGIvLnRlc3Qob3MpKSkge1xyXG4gICAgICAgIG5hbWUgPSAvW2Etel0rKD86IEhhdCk/L2kuZXhlYygvXFxiQW5kcm9pZFxcYi8udGVzdChvcykgPyBvcyA6IGRhdGEpICsgJyBCcm93c2VyJztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gRGV0ZWN0IG5vbi1PcGVyYSAoUHJlc3RvLWJhc2VkKSB2ZXJzaW9ucyAob3JkZXIgaXMgaW1wb3J0YW50KS5cclxuICAgIGlmICghdmVyc2lvbikge1xyXG4gICAgICB2ZXJzaW9uID0gZ2V0VmVyc2lvbihbXHJcbiAgICAgICAgJyg/OkNsb3VkOXxDcmlPU3xDck1vfEVkZ2V8RnhpT1N8SUVNb2JpbGV8SXJvbnxPcGVyYSA/TWluaXxPUGlPU3xPUFJ8UmF2ZW58U2lsayg/IS9bXFxcXGQuXSskKSknLFxyXG4gICAgICAgICdWZXJzaW9uJyxcclxuICAgICAgICBxdWFsaWZ5KG5hbWUpLFxyXG4gICAgICAgICcoPzpGaXJlZm94fE1pbmVmaWVsZHxOZXRGcm9udCknXHJcbiAgICAgIF0pO1xyXG4gICAgfVxyXG4gICAgLy8gRGV0ZWN0IHN0dWJib3JuIGxheW91dCBlbmdpbmVzLlxyXG4gICAgaWYgKChkYXRhID1cclxuICAgICAgICAgIGxheW91dCA9PSAnaUNhYicgJiYgcGFyc2VGbG9hdCh2ZXJzaW9uKSA+IDMgJiYgJ1dlYktpdCcgfHxcclxuICAgICAgICAgIC9cXGJPcGVyYVxcYi8udGVzdChuYW1lKSAmJiAoL1xcYk9QUlxcYi8udGVzdCh1YSkgPyAnQmxpbmsnIDogJ1ByZXN0bycpIHx8XHJcbiAgICAgICAgICAvXFxiKD86TWlkb3JpfE5vb2t8U2FmYXJpKVxcYi9pLnRlc3QodWEpICYmICEvXig/OlRyaWRlbnR8RWRnZUhUTUwpJC8udGVzdChsYXlvdXQpICYmICdXZWJLaXQnIHx8XHJcbiAgICAgICAgICAhbGF5b3V0ICYmIC9cXGJNU0lFXFxiL2kudGVzdCh1YSkgJiYgKG9zID09ICdNYWMgT1MnID8gJ1Rhc21hbicgOiAnVHJpZGVudCcpIHx8XHJcbiAgICAgICAgICBsYXlvdXQgPT0gJ1dlYktpdCcgJiYgL1xcYlBsYXlTdGF0aW9uXFxiKD8hIFZpdGFcXGIpL2kudGVzdChuYW1lKSAmJiAnTmV0RnJvbnQnXHJcbiAgICAgICAgKSkge1xyXG4gICAgICBsYXlvdXQgPSBbZGF0YV07XHJcbiAgICB9XHJcbiAgICAvLyBEZXRlY3QgV2luZG93cyBQaG9uZSA3IGRlc2t0b3AgbW9kZS5cclxuICAgIGlmIChuYW1lID09ICdJRScgJiYgKGRhdGEgPSAoLzsgKig/OlhCTFdQfFp1bmVXUCkoXFxkKykvaS5leGVjKHVhKSB8fCAwKVsxXSkpIHtcclxuICAgICAgbmFtZSArPSAnIE1vYmlsZSc7XHJcbiAgICAgIG9zID0gJ1dpbmRvd3MgUGhvbmUgJyArICgvXFwrJC8udGVzdChkYXRhKSA/IGRhdGEgOiBkYXRhICsgJy54Jyk7XHJcbiAgICAgIGRlc2NyaXB0aW9uLnVuc2hpZnQoJ2Rlc2t0b3AgbW9kZScpO1xyXG4gICAgfVxyXG4gICAgLy8gRGV0ZWN0IFdpbmRvd3MgUGhvbmUgOC54IGRlc2t0b3AgbW9kZS5cclxuICAgIGVsc2UgaWYgKC9cXGJXUERlc2t0b3BcXGIvaS50ZXN0KHVhKSkge1xyXG4gICAgICBuYW1lID0gJ0lFIE1vYmlsZSc7XHJcbiAgICAgIG9zID0gJ1dpbmRvd3MgUGhvbmUgOC54JztcclxuICAgICAgZGVzY3JpcHRpb24udW5zaGlmdCgnZGVza3RvcCBtb2RlJyk7XHJcbiAgICAgIHZlcnNpb24gfHwgKHZlcnNpb24gPSAoL1xcYnJ2OihbXFxkLl0rKS8uZXhlYyh1YSkgfHwgMClbMV0pO1xyXG4gICAgfVxyXG4gICAgLy8gRGV0ZWN0IElFIDExLlxyXG4gICAgZWxzZSBpZiAobmFtZSAhPSAnSUUnICYmIGxheW91dCA9PSAnVHJpZGVudCcgJiYgKGRhdGEgPSAvXFxicnY6KFtcXGQuXSspLy5leGVjKHVhKSkpIHtcclxuICAgICAgaWYgKG5hbWUpIHtcclxuICAgICAgICBkZXNjcmlwdGlvbi5wdXNoKCdpZGVudGlmeWluZyBhcyAnICsgbmFtZSArICh2ZXJzaW9uID8gJyAnICsgdmVyc2lvbiA6ICcnKSk7XHJcbiAgICAgIH1cclxuICAgICAgbmFtZSA9ICdJRSc7XHJcbiAgICAgIHZlcnNpb24gPSBkYXRhWzFdO1xyXG4gICAgfVxyXG4gICAgLy8gTGV2ZXJhZ2UgZW52aXJvbm1lbnQgZmVhdHVyZXMuXHJcbiAgICBpZiAodXNlRmVhdHVyZXMpIHtcclxuICAgICAgLy8gRGV0ZWN0IHNlcnZlci1zaWRlIGVudmlyb25tZW50cy5cclxuICAgICAgLy8gUmhpbm8gaGFzIGEgZ2xvYmFsIGZ1bmN0aW9uIHdoaWxlIG90aGVycyBoYXZlIGEgZ2xvYmFsIG9iamVjdC5cclxuICAgICAgaWYgKGlzSG9zdFR5cGUoY29udGV4dCwgJ2dsb2JhbCcpKSB7XHJcbiAgICAgICAgaWYgKGphdmEpIHtcclxuICAgICAgICAgIGRhdGEgPSBqYXZhLmxhbmcuU3lzdGVtO1xyXG4gICAgICAgICAgYXJjaCA9IGRhdGEuZ2V0UHJvcGVydHkoJ29zLmFyY2gnKTtcclxuICAgICAgICAgIG9zID0gb3MgfHwgZGF0YS5nZXRQcm9wZXJ0eSgnb3MubmFtZScpICsgJyAnICsgZGF0YS5nZXRQcm9wZXJ0eSgnb3MudmVyc2lvbicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNNb2R1bGVTY29wZSAmJiBpc0hvc3RUeXBlKGNvbnRleHQsICdzeXN0ZW0nKSAmJiAoZGF0YSA9IFtjb250ZXh0LnN5c3RlbV0pWzBdKSB7XHJcbiAgICAgICAgICBvcyB8fCAob3MgPSBkYXRhWzBdLm9zIHx8IG51bGwpO1xyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgZGF0YVsxXSA9IGNvbnRleHQucmVxdWlyZSgncmluZ28vZW5naW5lJykudmVyc2lvbjtcclxuICAgICAgICAgICAgdmVyc2lvbiA9IGRhdGFbMV0uam9pbignLicpO1xyXG4gICAgICAgICAgICBuYW1lID0gJ1JpbmdvSlMnO1xyXG4gICAgICAgICAgfSBjYXRjaChlKSB7XHJcbiAgICAgICAgICAgIGlmIChkYXRhWzBdLmdsb2JhbC5zeXN0ZW0gPT0gY29udGV4dC5zeXN0ZW0pIHtcclxuICAgICAgICAgICAgICBuYW1lID0gJ05hcndoYWwnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKFxyXG4gICAgICAgICAgdHlwZW9mIGNvbnRleHQucHJvY2VzcyA9PSAnb2JqZWN0JyAmJiAhY29udGV4dC5wcm9jZXNzLmJyb3dzZXIgJiZcclxuICAgICAgICAgIChkYXRhID0gY29udGV4dC5wcm9jZXNzKVxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgbmFtZSA9ICdOb2RlLmpzJztcclxuICAgICAgICAgIGFyY2ggPSBkYXRhLmFyY2g7XHJcbiAgICAgICAgICBvcyA9IGRhdGEucGxhdGZvcm07XHJcbiAgICAgICAgICB2ZXJzaW9uID0gL1tcXGQuXSsvLmV4ZWMoZGF0YS52ZXJzaW9uKVswXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocmhpbm8pIHtcclxuICAgICAgICAgIG5hbWUgPSAnUmhpbm8nO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICAvLyBEZXRlY3QgQWRvYmUgQUlSLlxyXG4gICAgICBlbHNlIGlmIChnZXRDbGFzc09mKChkYXRhID0gY29udGV4dC5ydW50aW1lKSkgPT0gYWlyUnVudGltZUNsYXNzKSB7XHJcbiAgICAgICAgbmFtZSA9ICdBZG9iZSBBSVInO1xyXG4gICAgICAgIG9zID0gZGF0YS5mbGFzaC5zeXN0ZW0uQ2FwYWJpbGl0aWVzLm9zO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIERldGVjdCBQaGFudG9tSlMuXHJcbiAgICAgIGVsc2UgaWYgKGdldENsYXNzT2YoKGRhdGEgPSBjb250ZXh0LnBoYW50b20pKSA9PSBwaGFudG9tQ2xhc3MpIHtcclxuICAgICAgICBuYW1lID0gJ1BoYW50b21KUyc7XHJcbiAgICAgICAgdmVyc2lvbiA9IChkYXRhID0gZGF0YS52ZXJzaW9uIHx8IG51bGwpICYmIChkYXRhLm1ham9yICsgJy4nICsgZGF0YS5taW5vciArICcuJyArIGRhdGEucGF0Y2gpO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIERldGVjdCBJRSBjb21wYXRpYmlsaXR5IG1vZGVzLlxyXG4gICAgICBlbHNlIGlmICh0eXBlb2YgZG9jLmRvY3VtZW50TW9kZSA9PSAnbnVtYmVyJyAmJiAoZGF0YSA9IC9cXGJUcmlkZW50XFwvKFxcZCspL2kuZXhlYyh1YSkpKSB7XHJcbiAgICAgICAgLy8gV2UncmUgaW4gY29tcGF0aWJpbGl0eSBtb2RlIHdoZW4gdGhlIFRyaWRlbnQgdmVyc2lvbiArIDQgZG9lc24ndFxyXG4gICAgICAgIC8vIGVxdWFsIHRoZSBkb2N1bWVudCBtb2RlLlxyXG4gICAgICAgIHZlcnNpb24gPSBbdmVyc2lvbiwgZG9jLmRvY3VtZW50TW9kZV07XHJcbiAgICAgICAgaWYgKChkYXRhID0gK2RhdGFbMV0gKyA0KSAhPSB2ZXJzaW9uWzFdKSB7XHJcbiAgICAgICAgICBkZXNjcmlwdGlvbi5wdXNoKCdJRSAnICsgdmVyc2lvblsxXSArICcgbW9kZScpO1xyXG4gICAgICAgICAgbGF5b3V0ICYmIChsYXlvdXRbMV0gPSAnJyk7XHJcbiAgICAgICAgICB2ZXJzaW9uWzFdID0gZGF0YTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmVyc2lvbiA9IG5hbWUgPT0gJ0lFJyA/IFN0cmluZyh2ZXJzaW9uWzFdLnRvRml4ZWQoMSkpIDogdmVyc2lvblswXTtcclxuICAgICAgfVxyXG4gICAgICBvcyA9IG9zICYmIGZvcm1hdChvcyk7XHJcbiAgICB9XHJcbiAgICAvLyBEZXRlY3QgcHJlcmVsZWFzZSBwaGFzZXMuXHJcbiAgICBpZiAodmVyc2lvbiAmJiAoZGF0YSA9XHJcbiAgICAgICAgICAvKD86W2FiXXxkcHxwcmV8W2FiXVxcZCtwcmUpKD86XFxkK1xcKz8pPyQvaS5leGVjKHZlcnNpb24pIHx8XHJcbiAgICAgICAgICAvKD86YWxwaGF8YmV0YSkoPzogP1xcZCk/L2kuZXhlYyh1YSArICc7JyArICh1c2VGZWF0dXJlcyAmJiBuYXYuYXBwTWlub3JWZXJzaW9uKSkgfHxcclxuICAgICAgICAgIC9cXGJNaW5lZmllbGRcXGIvaS50ZXN0KHVhKSAmJiAnYSdcclxuICAgICAgICApKSB7XHJcbiAgICAgIHByZXJlbGVhc2UgPSAvYi9pLnRlc3QoZGF0YSkgPyAnYmV0YScgOiAnYWxwaGEnO1xyXG4gICAgICB2ZXJzaW9uID0gdmVyc2lvbi5yZXBsYWNlKFJlZ0V4cChkYXRhICsgJ1xcXFwrPyQnKSwgJycpICtcclxuICAgICAgICAocHJlcmVsZWFzZSA9PSAnYmV0YScgPyBiZXRhIDogYWxwaGEpICsgKC9cXGQrXFwrPy8uZXhlYyhkYXRhKSB8fCAnJyk7XHJcbiAgICB9XHJcbiAgICAvLyBEZXRlY3QgRmlyZWZveCBNb2JpbGUuXHJcbiAgICBpZiAobmFtZSA9PSAnRmVubmVjJyB8fCBuYW1lID09ICdGaXJlZm94JyAmJiAvXFxiKD86QW5kcm9pZHxGaXJlZm94IE9TKVxcYi8udGVzdChvcykpIHtcclxuICAgICAgbmFtZSA9ICdGaXJlZm94IE1vYmlsZSc7XHJcbiAgICB9XHJcbiAgICAvLyBPYnNjdXJlIE1heHRob24ncyB1bnJlbGlhYmxlIHZlcnNpb24uXHJcbiAgICBlbHNlIGlmIChuYW1lID09ICdNYXh0aG9uJyAmJiB2ZXJzaW9uKSB7XHJcbiAgICAgIHZlcnNpb24gPSB2ZXJzaW9uLnJlcGxhY2UoL1xcLltcXGQuXSsvLCAnLngnKTtcclxuICAgIH1cclxuICAgIC8vIERldGVjdCBYYm94IDM2MCBhbmQgWGJveCBPbmUuXHJcbiAgICBlbHNlIGlmICgvXFxiWGJveFxcYi9pLnRlc3QocHJvZHVjdCkpIHtcclxuICAgICAgb3MgPSBudWxsO1xyXG4gICAgICBpZiAocHJvZHVjdCA9PSAnWGJveCAzNjAnICYmIC9cXGJJRU1vYmlsZVxcYi8udGVzdCh1YSkpIHtcclxuICAgICAgICBkZXNjcmlwdGlvbi51bnNoaWZ0KCdtb2JpbGUgbW9kZScpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBBZGQgbW9iaWxlIHBvc3RmaXguXHJcbiAgICBlbHNlIGlmICgoL14oPzpDaHJvbWV8SUV8T3BlcmEpJC8udGVzdChuYW1lKSB8fCBuYW1lICYmICFwcm9kdWN0ICYmICEvQnJvd3NlcnxNb2JpLy50ZXN0KG5hbWUpKSAmJlxyXG4gICAgICAgIChvcyA9PSAnV2luZG93cyBDRScgfHwgL01vYmkvaS50ZXN0KHVhKSkpIHtcclxuICAgICAgbmFtZSArPSAnIE1vYmlsZSc7XHJcbiAgICB9XHJcbiAgICAvLyBEZXRlY3QgSUUgcGxhdGZvcm0gcHJldmlldy5cclxuICAgIGVsc2UgaWYgKG5hbWUgPT0gJ0lFJyAmJiB1c2VGZWF0dXJlcyAmJiBjb250ZXh0LmV4dGVybmFsID09PSBudWxsKSB7XHJcbiAgICAgIGRlc2NyaXB0aW9uLnVuc2hpZnQoJ3BsYXRmb3JtIHByZXZpZXcnKTtcclxuICAgIH1cclxuICAgIC8vIERldGVjdCBCbGFja0JlcnJ5IE9TIHZlcnNpb24uXHJcbiAgICAvLyBodHRwOi8vZG9jcy5ibGFja2JlcnJ5LmNvbS9lbi9kZXZlbG9wZXJzL2RlbGl2ZXJhYmxlcy8xODE2OS9IVFRQX2hlYWRlcnNfc2VudF9ieV9CQl9Ccm93c2VyXzEyMzQ5MTFfMTEuanNwXHJcbiAgICBlbHNlIGlmICgoL1xcYkJsYWNrQmVycnlcXGIvLnRlc3QocHJvZHVjdCkgfHwgL1xcYkJCMTBcXGIvLnRlc3QodWEpKSAmJiAoZGF0YSA9XHJcbiAgICAgICAgICAoUmVnRXhwKHByb2R1Y3QucmVwbGFjZSgvICsvZywgJyAqJykgKyAnLyhbLlxcXFxkXSspJywgJ2knKS5leGVjKHVhKSB8fCAwKVsxXSB8fFxyXG4gICAgICAgICAgdmVyc2lvblxyXG4gICAgICAgICkpIHtcclxuICAgICAgZGF0YSA9IFtkYXRhLCAvQkIxMC8udGVzdCh1YSldO1xyXG4gICAgICBvcyA9IChkYXRhWzFdID8gKHByb2R1Y3QgPSBudWxsLCBtYW51ZmFjdHVyZXIgPSAnQmxhY2tCZXJyeScpIDogJ0RldmljZSBTb2Z0d2FyZScpICsgJyAnICsgZGF0YVswXTtcclxuICAgICAgdmVyc2lvbiA9IG51bGw7XHJcbiAgICB9XHJcbiAgICAvLyBEZXRlY3QgT3BlcmEgaWRlbnRpZnlpbmcvbWFza2luZyBpdHNlbGYgYXMgYW5vdGhlciBicm93c2VyLlxyXG4gICAgLy8gaHR0cDovL3d3dy5vcGVyYS5jb20vc3VwcG9ydC9rYi92aWV3Lzg0My9cclxuICAgIGVsc2UgaWYgKHRoaXMgIT0gZm9yT3duICYmIHByb2R1Y3QgIT0gJ1dpaScgJiYgKFxyXG4gICAgICAgICAgKHVzZUZlYXR1cmVzICYmIG9wZXJhKSB8fFxyXG4gICAgICAgICAgKC9PcGVyYS8udGVzdChuYW1lKSAmJiAvXFxiKD86TVNJRXxGaXJlZm94KVxcYi9pLnRlc3QodWEpKSB8fFxyXG4gICAgICAgICAgKG5hbWUgPT0gJ0ZpcmVmb3gnICYmIC9cXGJPUyBYICg/OlxcZCtcXC4pezIsfS8udGVzdChvcykpIHx8XHJcbiAgICAgICAgICAobmFtZSA9PSAnSUUnICYmIChcclxuICAgICAgICAgICAgKG9zICYmICEvXldpbi8udGVzdChvcykgJiYgdmVyc2lvbiA+IDUuNSkgfHxcclxuICAgICAgICAgICAgL1xcYldpbmRvd3MgWFBcXGIvLnRlc3Qob3MpICYmIHZlcnNpb24gPiA4IHx8XHJcbiAgICAgICAgICAgIHZlcnNpb24gPT0gOCAmJiAhL1xcYlRyaWRlbnRcXGIvLnRlc3QodWEpXHJcbiAgICAgICAgICApKVxyXG4gICAgICAgICkgJiYgIXJlT3BlcmEudGVzdCgoZGF0YSA9IHBhcnNlLmNhbGwoZm9yT3duLCB1YS5yZXBsYWNlKHJlT3BlcmEsICcnKSArICc7JykpKSAmJiBkYXRhLm5hbWUpIHtcclxuICAgICAgLy8gV2hlbiBcImlkZW50aWZ5aW5nXCIsIHRoZSBVQSBjb250YWlucyBib3RoIE9wZXJhIGFuZCB0aGUgb3RoZXIgYnJvd3NlcidzIG5hbWUuXHJcbiAgICAgIGRhdGEgPSAnaW5nIGFzICcgKyBkYXRhLm5hbWUgKyAoKGRhdGEgPSBkYXRhLnZlcnNpb24pID8gJyAnICsgZGF0YSA6ICcnKTtcclxuICAgICAgaWYgKHJlT3BlcmEudGVzdChuYW1lKSkge1xyXG4gICAgICAgIGlmICgvXFxiSUVcXGIvLnRlc3QoZGF0YSkgJiYgb3MgPT0gJ01hYyBPUycpIHtcclxuICAgICAgICAgIG9zID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGF0YSA9ICdpZGVudGlmeScgKyBkYXRhO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIFdoZW4gXCJtYXNraW5nXCIsIHRoZSBVQSBjb250YWlucyBvbmx5IHRoZSBvdGhlciBicm93c2VyJ3MgbmFtZS5cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgZGF0YSA9ICdtYXNrJyArIGRhdGE7XHJcbiAgICAgICAgaWYgKG9wZXJhQ2xhc3MpIHtcclxuICAgICAgICAgIG5hbWUgPSBmb3JtYXQob3BlcmFDbGFzcy5yZXBsYWNlKC8oW2Etel0pKFtBLVpdKS9nLCAnJDEgJDInKSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIG5hbWUgPSAnT3BlcmEnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoL1xcYklFXFxiLy50ZXN0KGRhdGEpKSB7XHJcbiAgICAgICAgICBvcyA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdXNlRmVhdHVyZXMpIHtcclxuICAgICAgICAgIHZlcnNpb24gPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBsYXlvdXQgPSBbJ1ByZXN0byddO1xyXG4gICAgICBkZXNjcmlwdGlvbi5wdXNoKGRhdGEpO1xyXG4gICAgfVxyXG4gICAgLy8gRGV0ZWN0IFdlYktpdCBOaWdodGx5IGFuZCBhcHByb3hpbWF0ZSBDaHJvbWUvU2FmYXJpIHZlcnNpb25zLlxyXG4gICAgaWYgKChkYXRhID0gKC9cXGJBcHBsZVdlYktpdFxcLyhbXFxkLl0rXFwrPykvaS5leGVjKHVhKSB8fCAwKVsxXSkpIHtcclxuICAgICAgLy8gQ29ycmVjdCBidWlsZCBudW1iZXIgZm9yIG51bWVyaWMgY29tcGFyaXNvbi5cclxuICAgICAgLy8gKGUuZy4gXCI1MzIuNVwiIGJlY29tZXMgXCI1MzIuMDVcIilcclxuICAgICAgZGF0YSA9IFtwYXJzZUZsb2F0KGRhdGEucmVwbGFjZSgvXFwuKFxcZCkkLywgJy4wJDEnKSksIGRhdGFdO1xyXG4gICAgICAvLyBOaWdodGx5IGJ1aWxkcyBhcmUgcG9zdGZpeGVkIHdpdGggYSBcIitcIi5cclxuICAgICAgaWYgKG5hbWUgPT0gJ1NhZmFyaScgJiYgZGF0YVsxXS5zbGljZSgtMSkgPT0gJysnKSB7XHJcbiAgICAgICAgbmFtZSA9ICdXZWJLaXQgTmlnaHRseSc7XHJcbiAgICAgICAgcHJlcmVsZWFzZSA9ICdhbHBoYSc7XHJcbiAgICAgICAgdmVyc2lvbiA9IGRhdGFbMV0uc2xpY2UoMCwgLTEpO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIENsZWFyIGluY29ycmVjdCBicm93c2VyIHZlcnNpb25zLlxyXG4gICAgICBlbHNlIGlmICh2ZXJzaW9uID09IGRhdGFbMV0gfHxcclxuICAgICAgICAgIHZlcnNpb24gPT0gKGRhdGFbMl0gPSAoL1xcYlNhZmFyaVxcLyhbXFxkLl0rXFwrPykvaS5leGVjKHVhKSB8fCAwKVsxXSkpIHtcclxuICAgICAgICB2ZXJzaW9uID0gbnVsbDtcclxuICAgICAgfVxyXG4gICAgICAvLyBVc2UgdGhlIGZ1bGwgQ2hyb21lIHZlcnNpb24gd2hlbiBhdmFpbGFibGUuXHJcbiAgICAgIGRhdGFbMV0gPSAoL1xcYkNocm9tZVxcLyhbXFxkLl0rKS9pLmV4ZWModWEpIHx8IDApWzFdO1xyXG4gICAgICAvLyBEZXRlY3QgQmxpbmsgbGF5b3V0IGVuZ2luZS5cclxuICAgICAgaWYgKGRhdGFbMF0gPT0gNTM3LjM2ICYmIGRhdGFbMl0gPT0gNTM3LjM2ICYmIHBhcnNlRmxvYXQoZGF0YVsxXSkgPj0gMjggJiYgbGF5b3V0ID09ICdXZWJLaXQnKSB7XHJcbiAgICAgICAgbGF5b3V0ID0gWydCbGluayddO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIERldGVjdCBKYXZhU2NyaXB0Q29yZS5cclxuICAgICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy82NzY4NDc0L2hvdy1jYW4taS1kZXRlY3Qtd2hpY2gtamF2YXNjcmlwdC1lbmdpbmUtdjgtb3ItanNjLWlzLXVzZWQtYXQtcnVudGltZS1pbi1hbmRyb2lcclxuICAgICAgaWYgKCF1c2VGZWF0dXJlcyB8fCAoIWxpa2VDaHJvbWUgJiYgIWRhdGFbMV0pKSB7XHJcbiAgICAgICAgbGF5b3V0ICYmIChsYXlvdXRbMV0gPSAnbGlrZSBTYWZhcmknKTtcclxuICAgICAgICBkYXRhID0gKGRhdGEgPSBkYXRhWzBdLCBkYXRhIDwgNDAwID8gMSA6IGRhdGEgPCA1MDAgPyAyIDogZGF0YSA8IDUyNiA/IDMgOiBkYXRhIDwgNTMzID8gNCA6IGRhdGEgPCA1MzQgPyAnNCsnIDogZGF0YSA8IDUzNSA/IDUgOiBkYXRhIDwgNTM3ID8gNiA6IGRhdGEgPCA1MzggPyA3IDogZGF0YSA8IDYwMSA/IDggOiAnOCcpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGxheW91dCAmJiAobGF5b3V0WzFdID0gJ2xpa2UgQ2hyb21lJyk7XHJcbiAgICAgICAgZGF0YSA9IGRhdGFbMV0gfHwgKGRhdGEgPSBkYXRhWzBdLCBkYXRhIDwgNTMwID8gMSA6IGRhdGEgPCA1MzIgPyAyIDogZGF0YSA8IDUzMi4wNSA/IDMgOiBkYXRhIDwgNTMzID8gNCA6IGRhdGEgPCA1MzQuMDMgPyA1IDogZGF0YSA8IDUzNC4wNyA/IDYgOiBkYXRhIDwgNTM0LjEwID8gNyA6IGRhdGEgPCA1MzQuMTMgPyA4IDogZGF0YSA8IDUzNC4xNiA/IDkgOiBkYXRhIDwgNTM0LjI0ID8gMTAgOiBkYXRhIDwgNTM0LjMwID8gMTEgOiBkYXRhIDwgNTM1LjAxID8gMTIgOiBkYXRhIDwgNTM1LjAyID8gJzEzKycgOiBkYXRhIDwgNTM1LjA3ID8gMTUgOiBkYXRhIDwgNTM1LjExID8gMTYgOiBkYXRhIDwgNTM1LjE5ID8gMTcgOiBkYXRhIDwgNTM2LjA1ID8gMTggOiBkYXRhIDwgNTM2LjEwID8gMTkgOiBkYXRhIDwgNTM3LjAxID8gMjAgOiBkYXRhIDwgNTM3LjExID8gJzIxKycgOiBkYXRhIDwgNTM3LjEzID8gMjMgOiBkYXRhIDwgNTM3LjE4ID8gMjQgOiBkYXRhIDwgNTM3LjI0ID8gMjUgOiBkYXRhIDwgNTM3LjM2ID8gMjYgOiBsYXlvdXQgIT0gJ0JsaW5rJyA/ICcyNycgOiAnMjgnKTtcclxuICAgICAgfVxyXG4gICAgICAvLyBBZGQgdGhlIHBvc3RmaXggb2YgXCIueFwiIG9yIFwiK1wiIGZvciBhcHByb3hpbWF0ZSB2ZXJzaW9ucy5cclxuICAgICAgbGF5b3V0ICYmIChsYXlvdXRbMV0gKz0gJyAnICsgKGRhdGEgKz0gdHlwZW9mIGRhdGEgPT0gJ251bWJlcicgPyAnLngnIDogL1suK10vLnRlc3QoZGF0YSkgPyAnJyA6ICcrJykpO1xyXG4gICAgICAvLyBPYnNjdXJlIHZlcnNpb24gZm9yIHNvbWUgU2FmYXJpIDEtMiByZWxlYXNlcy5cclxuICAgICAgaWYgKG5hbWUgPT0gJ1NhZmFyaScgJiYgKCF2ZXJzaW9uIHx8IHBhcnNlSW50KHZlcnNpb24pID4gNDUpKSB7XHJcbiAgICAgICAgdmVyc2lvbiA9IGRhdGE7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIERldGVjdCBPcGVyYSBkZXNrdG9wIG1vZGVzLlxyXG4gICAgaWYgKG5hbWUgPT0gJ09wZXJhJyAmJiAgKGRhdGEgPSAvXFxiemJvdnx6dmF2JC8uZXhlYyhvcykpKSB7XHJcbiAgICAgIG5hbWUgKz0gJyAnO1xyXG4gICAgICBkZXNjcmlwdGlvbi51bnNoaWZ0KCdkZXNrdG9wIG1vZGUnKTtcclxuICAgICAgaWYgKGRhdGEgPT0gJ3p2YXYnKSB7XHJcbiAgICAgICAgbmFtZSArPSAnTWluaSc7XHJcbiAgICAgICAgdmVyc2lvbiA9IG51bGw7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbmFtZSArPSAnTW9iaWxlJztcclxuICAgICAgfVxyXG4gICAgICBvcyA9IG9zLnJlcGxhY2UoUmVnRXhwKCcgKicgKyBkYXRhICsgJyQnKSwgJycpO1xyXG4gICAgfVxyXG4gICAgLy8gRGV0ZWN0IENocm9tZSBkZXNrdG9wIG1vZGUuXHJcbiAgICBlbHNlIGlmIChuYW1lID09ICdTYWZhcmknICYmIC9cXGJDaHJvbWVcXGIvLmV4ZWMobGF5b3V0ICYmIGxheW91dFsxXSkpIHtcclxuICAgICAgZGVzY3JpcHRpb24udW5zaGlmdCgnZGVza3RvcCBtb2RlJyk7XHJcbiAgICAgIG5hbWUgPSAnQ2hyb21lIE1vYmlsZSc7XHJcbiAgICAgIHZlcnNpb24gPSBudWxsO1xyXG5cclxuICAgICAgaWYgKC9cXGJPUyBYXFxiLy50ZXN0KG9zKSkge1xyXG4gICAgICAgIG1hbnVmYWN0dXJlciA9ICdBcHBsZSc7XHJcbiAgICAgICAgb3MgPSAnaU9TIDQuMysnO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIG9zID0gbnVsbDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gU3RyaXAgaW5jb3JyZWN0IE9TIHZlcnNpb25zLlxyXG4gICAgaWYgKHZlcnNpb24gJiYgdmVyc2lvbi5pbmRleE9mKChkYXRhID0gL1tcXGQuXSskLy5leGVjKG9zKSkpID09IDAgJiZcclxuICAgICAgICB1YS5pbmRleE9mKCcvJyArIGRhdGEgKyAnLScpID4gLTEpIHtcclxuICAgICAgb3MgPSB0cmltKG9zLnJlcGxhY2UoZGF0YSwgJycpKTtcclxuICAgIH1cclxuICAgIC8vIEFkZCBsYXlvdXQgZW5naW5lLlxyXG4gICAgaWYgKGxheW91dCAmJiAhL1xcYig/OkF2YW50fE5vb2spXFxiLy50ZXN0KG5hbWUpICYmIChcclxuICAgICAgICAvQnJvd3NlcnxMdW5hc2NhcGV8TWF4dGhvbi8udGVzdChuYW1lKSB8fFxyXG4gICAgICAgIG5hbWUgIT0gJ1NhZmFyaScgJiYgL15pT1MvLnRlc3Qob3MpICYmIC9cXGJTYWZhcmlcXGIvLnRlc3QobGF5b3V0WzFdKSB8fFxyXG4gICAgICAgIC9eKD86QWRvYmV8QXJvcmF8QnJlYWNofE1pZG9yaXxPcGVyYXxQaGFudG9tfFJla29ucXxSb2NrfFNsZWlwbmlyfFdlYikvLnRlc3QobmFtZSkgJiYgbGF5b3V0WzFdKSkge1xyXG4gICAgICAvLyBEb24ndCBhZGQgbGF5b3V0IGRldGFpbHMgdG8gZGVzY3JpcHRpb24gaWYgdGhleSBhcmUgZmFsc2V5LlxyXG4gICAgICAoZGF0YSA9IGxheW91dFtsYXlvdXQubGVuZ3RoIC0gMV0pICYmIGRlc2NyaXB0aW9uLnB1c2goZGF0YSk7XHJcbiAgICB9XHJcbiAgICAvLyBDb21iaW5lIGNvbnRleHR1YWwgaW5mb3JtYXRpb24uXHJcbiAgICBpZiAoZGVzY3JpcHRpb24ubGVuZ3RoKSB7XHJcbiAgICAgIGRlc2NyaXB0aW9uID0gWycoJyArIGRlc2NyaXB0aW9uLmpvaW4oJzsgJykgKyAnKSddO1xyXG4gICAgfVxyXG4gICAgLy8gQXBwZW5kIG1hbnVmYWN0dXJlciB0byBkZXNjcmlwdGlvbi5cclxuICAgIGlmIChtYW51ZmFjdHVyZXIgJiYgcHJvZHVjdCAmJiBwcm9kdWN0LmluZGV4T2YobWFudWZhY3R1cmVyKSA8IDApIHtcclxuICAgICAgZGVzY3JpcHRpb24ucHVzaCgnb24gJyArIG1hbnVmYWN0dXJlcik7XHJcbiAgICB9XHJcbiAgICAvLyBBcHBlbmQgcHJvZHVjdCB0byBkZXNjcmlwdGlvbi5cclxuICAgIGlmIChwcm9kdWN0KSB7XHJcbiAgICAgIGRlc2NyaXB0aW9uLnB1c2goKC9eb24gLy50ZXN0KGRlc2NyaXB0aW9uW2Rlc2NyaXB0aW9uLmxlbmd0aCAtIDFdKSA/ICcnIDogJ29uICcpICsgcHJvZHVjdCk7XHJcbiAgICB9XHJcbiAgICAvLyBQYXJzZSB0aGUgT1MgaW50byBhbiBvYmplY3QuXHJcbiAgICBpZiAob3MpIHtcclxuICAgICAgZGF0YSA9IC8gKFtcXGQuK10rKSQvLmV4ZWMob3MpO1xyXG4gICAgICBpc1NwZWNpYWxDYXNlZE9TID0gZGF0YSAmJiBvcy5jaGFyQXQob3MubGVuZ3RoIC0gZGF0YVswXS5sZW5ndGggLSAxKSA9PSAnLyc7XHJcbiAgICAgIG9zID0ge1xyXG4gICAgICAgICdhcmNoaXRlY3R1cmUnOiAzMixcclxuICAgICAgICAnZmFtaWx5JzogKGRhdGEgJiYgIWlzU3BlY2lhbENhc2VkT1MpID8gb3MucmVwbGFjZShkYXRhWzBdLCAnJykgOiBvcyxcclxuICAgICAgICAndmVyc2lvbic6IGRhdGEgPyBkYXRhWzFdIDogbnVsbCxcclxuICAgICAgICAndG9TdHJpbmcnOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIHZhciB2ZXJzaW9uID0gdGhpcy52ZXJzaW9uO1xyXG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmFtaWx5ICsgKCh2ZXJzaW9uICYmICFpc1NwZWNpYWxDYXNlZE9TKSA/ICcgJyArIHZlcnNpb24gOiAnJykgKyAodGhpcy5hcmNoaXRlY3R1cmUgPT0gNjQgPyAnIDY0LWJpdCcgOiAnJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gICAgLy8gQWRkIGJyb3dzZXIvT1MgYXJjaGl0ZWN0dXJlLlxyXG4gICAgaWYgKChkYXRhID0gL1xcYig/OkFNRHxJQXxXaW58V09XfHg4Nl98eCk2NFxcYi9pLmV4ZWMoYXJjaCkpICYmICEvXFxiaTY4NlxcYi9pLnRlc3QoYXJjaCkpIHtcclxuICAgICAgaWYgKG9zKSB7XHJcbiAgICAgICAgb3MuYXJjaGl0ZWN0dXJlID0gNjQ7XHJcbiAgICAgICAgb3MuZmFtaWx5ID0gb3MuZmFtaWx5LnJlcGxhY2UoUmVnRXhwKCcgKicgKyBkYXRhKSwgJycpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChcclxuICAgICAgICAgIG5hbWUgJiYgKC9cXGJXT1c2NFxcYi9pLnRlc3QodWEpIHx8XHJcbiAgICAgICAgICAodXNlRmVhdHVyZXMgJiYgL1xcdyg/Ojg2fDMyKSQvLnRlc3QobmF2LmNwdUNsYXNzIHx8IG5hdi5wbGF0Zm9ybSkgJiYgIS9cXGJXaW42NDsgeDY0XFxiL2kudGVzdCh1YSkpKVxyXG4gICAgICApIHtcclxuICAgICAgICBkZXNjcmlwdGlvbi51bnNoaWZ0KCczMi1iaXQnKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gQ2hyb21lIDM5IGFuZCBhYm92ZSBvbiBPUyBYIGlzIGFsd2F5cyA2NC1iaXQuXHJcbiAgICBlbHNlIGlmIChcclxuICAgICAgICBvcyAmJiAvXk9TIFgvLnRlc3Qob3MuZmFtaWx5KSAmJlxyXG4gICAgICAgIG5hbWUgPT0gJ0Nocm9tZScgJiYgcGFyc2VGbG9hdCh2ZXJzaW9uKSA+PSAzOVxyXG4gICAgKSB7XHJcbiAgICAgIG9zLmFyY2hpdGVjdHVyZSA9IDY0O1xyXG4gICAgfVxyXG5cclxuICAgIHVhIHx8ICh1YSA9IG51bGwpO1xyXG5cclxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBwbGF0Zm9ybSBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogQG5hbWUgcGxhdGZvcm1cclxuICAgICAqIEB0eXBlIE9iamVjdFxyXG4gICAgICovXHJcbiAgICB2YXIgcGxhdGZvcm0gPSB7fTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBwbGF0Zm9ybSBkZXNjcmlwdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyT2YgcGxhdGZvcm1cclxuICAgICAqIEB0eXBlIHN0cmluZ3xudWxsXHJcbiAgICAgKi9cclxuICAgIHBsYXRmb3JtLmRlc2NyaXB0aW9uID0gdWE7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgYnJvd3NlcidzIGxheW91dCBlbmdpbmUuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlck9mIHBsYXRmb3JtXHJcbiAgICAgKiBAdHlwZSBzdHJpbmd8bnVsbFxyXG4gICAgICovXHJcbiAgICBwbGF0Zm9ybS5sYXlvdXQgPSBsYXlvdXQgJiYgbGF5b3V0WzBdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIHByb2R1Y3QncyBtYW51ZmFjdHVyZXIuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlck9mIHBsYXRmb3JtXHJcbiAgICAgKiBAdHlwZSBzdHJpbmd8bnVsbFxyXG4gICAgICovXHJcbiAgICBwbGF0Zm9ybS5tYW51ZmFjdHVyZXIgPSBtYW51ZmFjdHVyZXI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgYnJvd3Nlci9lbnZpcm9ubWVudC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyT2YgcGxhdGZvcm1cclxuICAgICAqIEB0eXBlIHN0cmluZ3xudWxsXHJcbiAgICAgKi9cclxuICAgIHBsYXRmb3JtLm5hbWUgPSBuYW1lO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGFscGhhL2JldGEgcmVsZWFzZSBpbmRpY2F0b3IuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlck9mIHBsYXRmb3JtXHJcbiAgICAgKiBAdHlwZSBzdHJpbmd8bnVsbFxyXG4gICAgICovXHJcbiAgICBwbGF0Zm9ybS5wcmVyZWxlYXNlID0gcHJlcmVsZWFzZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBuYW1lIG9mIHRoZSBwcm9kdWN0IGhvc3RpbmcgdGhlIGJyb3dzZXIuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlck9mIHBsYXRmb3JtXHJcbiAgICAgKiBAdHlwZSBzdHJpbmd8bnVsbFxyXG4gICAgICovXHJcbiAgICBwbGF0Zm9ybS5wcm9kdWN0ID0gcHJvZHVjdDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBicm93c2VyJ3MgdXNlciBhZ2VudCBzdHJpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlck9mIHBsYXRmb3JtXHJcbiAgICAgKiBAdHlwZSBzdHJpbmd8bnVsbFxyXG4gICAgICovXHJcbiAgICBwbGF0Zm9ybS51YSA9IHVhO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGJyb3dzZXIvZW52aXJvbm1lbnQgdmVyc2lvbi5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyT2YgcGxhdGZvcm1cclxuICAgICAqIEB0eXBlIHN0cmluZ3xudWxsXHJcbiAgICAgKi9cclxuICAgIHBsYXRmb3JtLnZlcnNpb24gPSBuYW1lICYmIHZlcnNpb247XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgb3BlcmF0aW5nIHN5c3RlbS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyT2YgcGxhdGZvcm1cclxuICAgICAqIEB0eXBlIE9iamVjdFxyXG4gICAgICovXHJcbiAgICBwbGF0Zm9ybS5vcyA9IG9zIHx8IHtcclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBUaGUgQ1BVIGFyY2hpdGVjdHVyZSB0aGUgT1MgaXMgYnVpbHQgZm9yLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBAbWVtYmVyT2YgcGxhdGZvcm0ub3NcclxuICAgICAgICogQHR5cGUgbnVtYmVyfG51bGxcclxuICAgICAgICovXHJcbiAgICAgICdhcmNoaXRlY3R1cmUnOiBudWxsLFxyXG5cclxuICAgICAgLyoqXHJcbiAgICAgICAqIFRoZSBmYW1pbHkgb2YgdGhlIE9TLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBDb21tb24gdmFsdWVzIGluY2x1ZGU6XHJcbiAgICAgICAqIFwiV2luZG93c1wiLCBcIldpbmRvd3MgU2VydmVyIDIwMDggUjIgLyA3XCIsIFwiV2luZG93cyBTZXJ2ZXIgMjAwOCAvIFZpc3RhXCIsXHJcbiAgICAgICAqIFwiV2luZG93cyBYUFwiLCBcIk9TIFhcIiwgXCJVYnVudHVcIiwgXCJEZWJpYW5cIiwgXCJGZWRvcmFcIiwgXCJSZWQgSGF0XCIsIFwiU3VTRVwiLFxyXG4gICAgICAgKiBcIkFuZHJvaWRcIiwgXCJpT1NcIiBhbmQgXCJXaW5kb3dzIFBob25lXCJcclxuICAgICAgICpcclxuICAgICAgICogQG1lbWJlck9mIHBsYXRmb3JtLm9zXHJcbiAgICAgICAqIEB0eXBlIHN0cmluZ3xudWxsXHJcbiAgICAgICAqL1xyXG4gICAgICAnZmFtaWx5JzogbnVsbCxcclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBUaGUgdmVyc2lvbiBvZiB0aGUgT1MuXHJcbiAgICAgICAqXHJcbiAgICAgICAqIEBtZW1iZXJPZiBwbGF0Zm9ybS5vc1xyXG4gICAgICAgKiBAdHlwZSBzdHJpbmd8bnVsbFxyXG4gICAgICAgKi9cclxuICAgICAgJ3ZlcnNpb24nOiBudWxsLFxyXG5cclxuICAgICAgLyoqXHJcbiAgICAgICAqIFJldHVybnMgdGhlIE9TIHN0cmluZy5cclxuICAgICAgICpcclxuICAgICAgICogQG1lbWJlck9mIHBsYXRmb3JtLm9zXHJcbiAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBPUyBzdHJpbmcuXHJcbiAgICAgICAqL1xyXG4gICAgICAndG9TdHJpbmcnOiBmdW5jdGlvbigpIHsgcmV0dXJuICdudWxsJzsgfVxyXG4gICAgfTtcclxuXHJcbiAgICBwbGF0Zm9ybS5wYXJzZSA9IHBhcnNlO1xyXG4gICAgcGxhdGZvcm0udG9TdHJpbmcgPSB0b1N0cmluZ1BsYXRmb3JtO1xyXG5cclxuICAgIGlmIChwbGF0Zm9ybS52ZXJzaW9uKSB7XHJcbiAgICAgIGRlc2NyaXB0aW9uLnVuc2hpZnQodmVyc2lvbik7XHJcbiAgICB9XHJcbiAgICBpZiAocGxhdGZvcm0ubmFtZSkge1xyXG4gICAgICBkZXNjcmlwdGlvbi51bnNoaWZ0KG5hbWUpO1xyXG4gICAgfVxyXG4gICAgaWYgKG9zICYmIG5hbWUgJiYgIShvcyA9PSBTdHJpbmcob3MpLnNwbGl0KCcgJylbMF0gJiYgKG9zID09IG5hbWUuc3BsaXQoJyAnKVswXSB8fCBwcm9kdWN0KSkpIHtcclxuICAgICAgZGVzY3JpcHRpb24ucHVzaChwcm9kdWN0ID8gJygnICsgb3MgKyAnKScgOiAnb24gJyArIG9zKTtcclxuICAgIH1cclxuICAgIGlmIChkZXNjcmlwdGlvbi5sZW5ndGgpIHtcclxuICAgICAgcGxhdGZvcm0uZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbi5qb2luKCcgJyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcGxhdGZvcm07XHJcbiAgfVxyXG5cclxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuXHJcbiAgLy8gRXhwb3J0IHBsYXRmb3JtLlxyXG4gIHZhciBwbGF0Zm9ybSA9IHBhcnNlKCk7XHJcblxyXG4gIC8vIFNvbWUgQU1EIGJ1aWxkIG9wdGltaXplcnMsIGxpa2Ugci5qcywgY2hlY2sgZm9yIGNvbmRpdGlvbiBwYXR0ZXJucyBsaWtlIHRoZSBmb2xsb3dpbmc6XHJcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JyAmJiBkZWZpbmUuYW1kKSB7XHJcbiAgICAvLyBFeHBvc2UgcGxhdGZvcm0gb24gdGhlIGdsb2JhbCBvYmplY3QgdG8gcHJldmVudCBlcnJvcnMgd2hlbiBwbGF0Zm9ybSBpc1xyXG4gICAgLy8gbG9hZGVkIGJ5IGEgc2NyaXB0IHRhZyBpbiB0aGUgcHJlc2VuY2Ugb2YgYW4gQU1EIGxvYWRlci5cclxuICAgIC8vIFNlZSBodHRwOi8vcmVxdWlyZWpzLm9yZy9kb2NzL2Vycm9ycy5odG1sI21pc21hdGNoIGZvciBtb3JlIGRldGFpbHMuXHJcbiAgICByb290LnBsYXRmb3JtID0gcGxhdGZvcm07XHJcblxyXG4gICAgLy8gRGVmaW5lIGFzIGFuIGFub255bW91cyBtb2R1bGUgc28gcGxhdGZvcm0gY2FuIGJlIGFsaWFzZWQgdGhyb3VnaCBwYXRoIG1hcHBpbmcuXHJcbiAgICBkZWZpbmUoZnVuY3Rpb24oKSB7XHJcbiAgICAgIHJldHVybiBwbGF0Zm9ybTtcclxuICAgIH0pO1xyXG4gIH1cclxuICAvLyBDaGVjayBmb3IgYGV4cG9ydHNgIGFmdGVyIGBkZWZpbmVgIGluIGNhc2UgYSBidWlsZCBvcHRpbWl6ZXIgYWRkcyBhbiBgZXhwb3J0c2Agb2JqZWN0LlxyXG4gIGVsc2UgaWYgKGZyZWVFeHBvcnRzICYmIGZyZWVNb2R1bGUpIHtcclxuICAgIC8vIEV4cG9ydCBmb3IgQ29tbW9uSlMgc3VwcG9ydC5cclxuICAgIGZvck93bihwbGF0Zm9ybSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xyXG4gICAgICBmcmVlRXhwb3J0c1trZXldID0gdmFsdWU7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgZWxzZSB7XHJcbiAgICAvLyBFeHBvcnQgdG8gdGhlIGdsb2JhbCBvYmplY3QuXHJcbiAgICByb290LnBsYXRmb3JtID0gcGxhdGZvcm07XHJcbiAgfVxyXG59LmNhbGwodGhpcykpO1xyXG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xyXG5cclxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XHJcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xyXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXHJcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXHJcblxyXG52YXIgY2FjaGVkU2V0VGltZW91dDtcclxudmFyIGNhY2hlZENsZWFyVGltZW91dDtcclxuXHJcbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcclxufVxyXG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XHJcbn1cclxuKGZ1bmN0aW9uICgpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xyXG4gICAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcclxuICAgIH1cclxuICAgIHRyeSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XHJcbiAgICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XHJcbiAgICB9XHJcbn0gKCkpXHJcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XHJcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xyXG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xyXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XHJcbiAgICB9XHJcbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxyXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XHJcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XHJcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcclxuICAgIH1cclxuICAgIHRyeSB7XHJcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xyXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XHJcbiAgICB9IGNhdGNoKGUpe1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxyXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XHJcbiAgICAgICAgfSBjYXRjaChlKXtcclxuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG59XHJcbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcclxuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xyXG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xyXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcclxuICAgIH1cclxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcclxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xyXG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcclxuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XHJcbiAgICB9XHJcbiAgICB0cnkge1xyXG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcclxuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XHJcbiAgICB9IGNhdGNoIChlKXtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XHJcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpe1xyXG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cclxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxyXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxuXHJcbn1cclxudmFyIHF1ZXVlID0gW107XHJcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xyXG52YXIgY3VycmVudFF1ZXVlO1xyXG52YXIgcXVldWVJbmRleCA9IC0xO1xyXG5cclxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xyXG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcclxuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XHJcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xyXG4gICAgfVxyXG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xyXG4gICAgICAgIGRyYWluUXVldWUoKTtcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcclxuICAgIGlmIChkcmFpbmluZykge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xyXG4gICAgZHJhaW5pbmcgPSB0cnVlO1xyXG5cclxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XHJcbiAgICB3aGlsZShsZW4pIHtcclxuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcclxuICAgICAgICBxdWV1ZSA9IFtdO1xyXG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcclxuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcclxuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XHJcbiAgICB9XHJcbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xyXG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcclxuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcclxufVxyXG5cclxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcclxuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcclxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XHJcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xyXG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXHJcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xyXG4gICAgdGhpcy5mdW4gPSBmdW47XHJcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XHJcbn1cclxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XHJcbn07XHJcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XHJcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XHJcbnByb2Nlc3MuZW52ID0ge307XHJcbnByb2Nlc3MuYXJndiA9IFtdO1xyXG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcclxucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xyXG5cclxuZnVuY3Rpb24gbm9vcCgpIHt9XHJcblxyXG5wcm9jZXNzLm9uID0gbm9vcDtcclxucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XHJcbnByb2Nlc3Mub25jZSA9IG5vb3A7XHJcbnByb2Nlc3Mub2ZmID0gbm9vcDtcclxucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XHJcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcclxucHJvY2Vzcy5lbWl0ID0gbm9vcDtcclxucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xyXG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xyXG5cclxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxyXG5cclxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcclxufTtcclxuXHJcbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XHJcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xyXG59O1xyXG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xyXG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cclxuLy9cclxuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcclxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxyXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcclxuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxyXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XHJcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxyXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcclxuLy9cclxuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcclxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXHJcbi8vXHJcbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1NcclxuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxyXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXHJcbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxyXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1JcclxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxyXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuLy8gSWYgb2JqLmhhc093blByb3BlcnR5IGhhcyBiZWVuIG92ZXJyaWRkZW4sIHRoZW4gY2FsbGluZ1xyXG4vLyBvYmouaGFzT3duUHJvcGVydHkocHJvcCkgd2lsbCBicmVhay5cclxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vam95ZW50L25vZGUvaXNzdWVzLzE3MDdcclxuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XHJcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHFzLCBzZXAsIGVxLCBvcHRpb25zKSB7XHJcbiAgc2VwID0gc2VwIHx8ICcmJztcclxuICBlcSA9IGVxIHx8ICc9JztcclxuICB2YXIgb2JqID0ge307XHJcblxyXG4gIGlmICh0eXBlb2YgcXMgIT09ICdzdHJpbmcnIHx8IHFzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgcmV0dXJuIG9iajtcclxuICB9XHJcblxyXG4gIHZhciByZWdleHAgPSAvXFwrL2c7XHJcbiAgcXMgPSBxcy5zcGxpdChzZXApO1xyXG5cclxuICB2YXIgbWF4S2V5cyA9IDEwMDA7XHJcbiAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMubWF4S2V5cyA9PT0gJ251bWJlcicpIHtcclxuICAgIG1heEtleXMgPSBvcHRpb25zLm1heEtleXM7XHJcbiAgfVxyXG5cclxuICB2YXIgbGVuID0gcXMubGVuZ3RoO1xyXG4gIC8vIG1heEtleXMgPD0gMCBtZWFucyB0aGF0IHdlIHNob3VsZCBub3QgbGltaXQga2V5cyBjb3VudFxyXG4gIGlmIChtYXhLZXlzID4gMCAmJiBsZW4gPiBtYXhLZXlzKSB7XHJcbiAgICBsZW4gPSBtYXhLZXlzO1xyXG4gIH1cclxuXHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xyXG4gICAgdmFyIHggPSBxc1tpXS5yZXBsYWNlKHJlZ2V4cCwgJyUyMCcpLFxyXG4gICAgICAgIGlkeCA9IHguaW5kZXhPZihlcSksXHJcbiAgICAgICAga3N0ciwgdnN0ciwgaywgdjtcclxuXHJcbiAgICBpZiAoaWR4ID49IDApIHtcclxuICAgICAga3N0ciA9IHguc3Vic3RyKDAsIGlkeCk7XHJcbiAgICAgIHZzdHIgPSB4LnN1YnN0cihpZHggKyAxKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGtzdHIgPSB4O1xyXG4gICAgICB2c3RyID0gJyc7XHJcbiAgICB9XHJcblxyXG4gICAgayA9IGRlY29kZVVSSUNvbXBvbmVudChrc3RyKTtcclxuICAgIHYgPSBkZWNvZGVVUklDb21wb25lbnQodnN0cik7XHJcblxyXG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eShvYmosIGspKSB7XHJcbiAgICAgIG9ialtrXSA9IHY7XHJcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkob2JqW2tdKSkge1xyXG4gICAgICBvYmpba10ucHVzaCh2KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIG9ialtrXSA9IFtvYmpba10sIHZdO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIG9iajtcclxufTtcclxuXHJcbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeHMpIHtcclxuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcclxufTtcclxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXHJcbi8vXHJcbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXHJcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcclxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXHJcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcclxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxyXG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcclxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XHJcbi8vXHJcbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXHJcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG4vL1xyXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXHJcbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcclxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxyXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcclxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXHJcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcclxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBzdHJpbmdpZnlQcmltaXRpdmUgPSBmdW5jdGlvbih2KSB7XHJcbiAgc3dpdGNoICh0eXBlb2Ygdikge1xyXG4gICAgY2FzZSAnc3RyaW5nJzpcclxuICAgICAgcmV0dXJuIHY7XHJcblxyXG4gICAgY2FzZSAnYm9vbGVhbic6XHJcbiAgICAgIHJldHVybiB2ID8gJ3RydWUnIDogJ2ZhbHNlJztcclxuXHJcbiAgICBjYXNlICdudW1iZXInOlxyXG4gICAgICByZXR1cm4gaXNGaW5pdGUodikgPyB2IDogJyc7XHJcblxyXG4gICAgZGVmYXVsdDpcclxuICAgICAgcmV0dXJuICcnO1xyXG4gIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqLCBzZXAsIGVxLCBuYW1lKSB7XHJcbiAgc2VwID0gc2VwIHx8ICcmJztcclxuICBlcSA9IGVxIHx8ICc9JztcclxuICBpZiAob2JqID09PSBudWxsKSB7XHJcbiAgICBvYmogPSB1bmRlZmluZWQ7XHJcbiAgfVxyXG5cclxuICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcclxuICAgIHJldHVybiBtYXAob2JqZWN0S2V5cyhvYmopLCBmdW5jdGlvbihrKSB7XHJcbiAgICAgIHZhciBrcyA9IGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUoaykpICsgZXE7XHJcbiAgICAgIGlmIChpc0FycmF5KG9ialtrXSkpIHtcclxuICAgICAgICByZXR1cm4gbWFwKG9ialtrXSwgZnVuY3Rpb24odikge1xyXG4gICAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZSh2KSk7XHJcbiAgICAgICAgfSkuam9pbihzZXApO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqW2tdKSk7XHJcbiAgICAgIH1cclxuICAgIH0pLmpvaW4oc2VwKTtcclxuXHJcbiAgfVxyXG5cclxuICBpZiAoIW5hbWUpIHJldHVybiAnJztcclxuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShuYW1lKSkgKyBlcSArXHJcbiAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqKSk7XHJcbn07XHJcblxyXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHhzKSB7XHJcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSc7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBtYXAgKHhzLCBmKSB7XHJcbiAgaWYgKHhzLm1hcCkgcmV0dXJuIHhzLm1hcChmKTtcclxuICB2YXIgcmVzID0gW107XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xyXG4gICAgcmVzLnB1c2goZih4c1tpXSwgaSkpO1xyXG4gIH1cclxuICByZXR1cm4gcmVzO1xyXG59XHJcblxyXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcclxuICB2YXIgcmVzID0gW107XHJcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xyXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHJlcy5wdXNoKGtleSk7XHJcbiAgfVxyXG4gIHJldHVybiByZXM7XHJcbn07XHJcbiIsIid1c2Ugc3RyaWN0JztcclxuXHJcbmV4cG9ydHMuZGVjb2RlID0gZXhwb3J0cy5wYXJzZSA9IHJlcXVpcmUoJy4vZGVjb2RlJyk7XHJcbmV4cG9ydHMuZW5jb2RlID0gZXhwb3J0cy5zdHJpbmdpZnkgPSByZXF1aXJlKCcuL2VuY29kZScpO1xyXG4iLCJtb2R1bGUuZXhwb3J0cyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBkbGwtcmVmZXJlbmNlIGRsbF9hMGVhODE5NmU4NjliOWI0NDI1ZSAqLyBcImRsbC1yZWZlcmVuY2UgZGxsX2EwZWE4MTk2ZTg2OWI5YjQ0MjVlXCIpKShcIi4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9pbmRleC5qc1wiKTsiLCIvKiogQGxpY2Vuc2UgUmVhY3QgdjE2LjEzLjFcclxuICogcmVhY3QtaXMuZGV2ZWxvcG1lbnQuanNcclxuICpcclxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcblxyXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XHJcbiAgKGZ1bmN0aW9uKCkge1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy4gSWYgdGhlcmUgaXMgbm8gbmF0aXZlIFN5bWJvbFxyXG4vLyBub3IgcG9seWZpbGwsIHRoZW4gYSBwbGFpbiBudW1iZXIgaXMgdXNlZCBmb3IgcGVyZm9ybWFuY2UuXHJcbnZhciBoYXNTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5mb3I7XHJcbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgOiAweGVhYzc7XHJcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnBvcnRhbCcpIDogMHhlYWNhO1xyXG52YXIgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmZyYWdtZW50JykgOiAweGVhY2I7XHJcbnZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3Quc3RyaWN0X21vZGUnKSA6IDB4ZWFjYztcclxudmFyIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5wcm9maWxlcicpIDogMHhlYWQyO1xyXG52YXIgUkVBQ1RfUFJPVklERVJfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnByb3ZpZGVyJykgOiAweGVhY2Q7XHJcbnZhciBSRUFDVF9DT05URVhUX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5jb250ZXh0JykgOiAweGVhY2U7IC8vIFRPRE86IFdlIGRvbid0IHVzZSBBc3luY01vZGUgb3IgQ29uY3VycmVudE1vZGUgYW55bW9yZS4gVGhleSB3ZXJlIHRlbXBvcmFyeVxyXG4vLyAodW5zdGFibGUpIEFQSXMgdGhhdCBoYXZlIGJlZW4gcmVtb3ZlZC4gQ2FuIHdlIHJlbW92ZSB0aGUgc3ltYm9scz9cclxuXHJcbnZhciBSRUFDVF9BU1lOQ19NT0RFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5hc3luY19tb2RlJykgOiAweGVhY2Y7XHJcbnZhciBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbmN1cnJlbnRfbW9kZScpIDogMHhlYWNmO1xyXG52YXIgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmZvcndhcmRfcmVmJykgOiAweGVhZDA7XHJcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2UnKSA6IDB4ZWFkMTtcclxudmFyIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlX2xpc3QnKSA6IDB4ZWFkODtcclxudmFyIFJFQUNUX01FTU9fVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0Lm1lbW8nKSA6IDB4ZWFkMztcclxudmFyIFJFQUNUX0xBWllfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmxhenknKSA6IDB4ZWFkNDtcclxudmFyIFJFQUNUX0JMT0NLX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5ibG9jaycpIDogMHhlYWQ5O1xyXG52YXIgUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmZ1bmRhbWVudGFsJykgOiAweGVhZDU7XHJcbnZhciBSRUFDVF9SRVNQT05ERVJfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnJlc3BvbmRlcicpIDogMHhlYWQ2O1xyXG52YXIgUkVBQ1RfU0NPUEVfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnNjb3BlJykgOiAweGVhZDc7XHJcblxyXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkge1xyXG4gIHJldHVybiB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgfHwgLy8gTm90ZTogaXRzIHR5cGVvZiBtaWdodCBiZSBvdGhlciB0aGFuICdzeW1ib2wnIG9yICdudW1iZXInIGlmIGl0J3MgYSBwb2x5ZmlsbC5cclxuICB0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUkVTUE9OREVSX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfU0NPUEVfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9CTE9DS19UWVBFKTtcclxufVxyXG5cclxuZnVuY3Rpb24gdHlwZU9mKG9iamVjdCkge1xyXG4gIGlmICh0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwpIHtcclxuICAgIHZhciAkJHR5cGVvZiA9IG9iamVjdC4kJHR5cGVvZjtcclxuXHJcbiAgICBzd2l0Y2ggKCQkdHlwZW9mKSB7XHJcbiAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxyXG4gICAgICAgIHZhciB0eXBlID0gb2JqZWN0LnR5cGU7XHJcblxyXG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xyXG4gICAgICAgICAgY2FzZSBSRUFDVF9BU1lOQ19NT0RFX1RZUEU6XHJcbiAgICAgICAgICBjYXNlIFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFOlxyXG4gICAgICAgICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxyXG4gICAgICAgICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxyXG4gICAgICAgICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxyXG4gICAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxyXG4gICAgICAgICAgICByZXR1cm4gdHlwZTtcclxuXHJcbiAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICB2YXIgJCR0eXBlb2ZUeXBlID0gdHlwZSAmJiB0eXBlLiQkdHlwZW9mO1xyXG5cclxuICAgICAgICAgICAgc3dpdGNoICgkJHR5cGVvZlR5cGUpIHtcclxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcclxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XHJcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XHJcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XHJcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICQkdHlwZW9mVHlwZTtcclxuXHJcbiAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHJldHVybiAkJHR5cGVvZjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxyXG4gICAgICAgIHJldHVybiAkJHR5cGVvZjtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiB1bmRlZmluZWQ7XHJcbn0gLy8gQXN5bmNNb2RlIGlzIGRlcHJlY2F0ZWQgYWxvbmcgd2l0aCBpc0FzeW5jTW9kZVxyXG5cclxudmFyIEFzeW5jTW9kZSA9IFJFQUNUX0FTWU5DX01PREVfVFlQRTtcclxudmFyIENvbmN1cnJlbnRNb2RlID0gUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEU7XHJcbnZhciBDb250ZXh0Q29uc3VtZXIgPSBSRUFDVF9DT05URVhUX1RZUEU7XHJcbnZhciBDb250ZXh0UHJvdmlkZXIgPSBSRUFDVF9QUk9WSURFUl9UWVBFO1xyXG52YXIgRWxlbWVudCA9IFJFQUNUX0VMRU1FTlRfVFlQRTtcclxudmFyIEZvcndhcmRSZWYgPSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFO1xyXG52YXIgRnJhZ21lbnQgPSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xyXG52YXIgTGF6eSA9IFJFQUNUX0xBWllfVFlQRTtcclxudmFyIE1lbW8gPSBSRUFDVF9NRU1PX1RZUEU7XHJcbnZhciBQb3J0YWwgPSBSRUFDVF9QT1JUQUxfVFlQRTtcclxudmFyIFByb2ZpbGVyID0gUkVBQ1RfUFJPRklMRVJfVFlQRTtcclxudmFyIFN0cmljdE1vZGUgPSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFO1xyXG52YXIgU3VzcGVuc2UgPSBSRUFDVF9TVVNQRU5TRV9UWVBFO1xyXG52YXIgaGFzV2FybmVkQWJvdXREZXByZWNhdGVkSXNBc3luY01vZGUgPSBmYWxzZTsgLy8gQXN5bmNNb2RlIHNob3VsZCBiZSBkZXByZWNhdGVkXHJcblxyXG5mdW5jdGlvbiBpc0FzeW5jTW9kZShvYmplY3QpIHtcclxuICB7XHJcbiAgICBpZiAoIWhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZElzQXN5bmNNb2RlKSB7XHJcbiAgICAgIGhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZElzQXN5bmNNb2RlID0gdHJ1ZTsgLy8gVXNpbmcgY29uc29sZVsnd2FybiddIHRvIGV2YWRlIEJhYmVsIGFuZCBFU0xpbnRcclxuXHJcbiAgICAgIGNvbnNvbGVbJ3dhcm4nXSgnVGhlIFJlYWN0SXMuaXNBc3luY01vZGUoKSBhbGlhcyBoYXMgYmVlbiBkZXByZWNhdGVkLCAnICsgJ2FuZCB3aWxsIGJlIHJlbW92ZWQgaW4gUmVhY3QgMTcrLiBVcGRhdGUgeW91ciBjb2RlIHRvIHVzZSAnICsgJ1JlYWN0SXMuaXNDb25jdXJyZW50TW9kZSgpIGluc3RlYWQuIEl0IGhhcyB0aGUgZXhhY3Qgc2FtZSBBUEkuJyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gaXNDb25jdXJyZW50TW9kZShvYmplY3QpIHx8IHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9BU1lOQ19NT0RFX1RZUEU7XHJcbn1cclxuZnVuY3Rpb24gaXNDb25jdXJyZW50TW9kZShvYmplY3QpIHtcclxuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFO1xyXG59XHJcbmZ1bmN0aW9uIGlzQ29udGV4dENvbnN1bWVyKG9iamVjdCkge1xyXG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFO1xyXG59XHJcbmZ1bmN0aW9uIGlzQ29udGV4dFByb3ZpZGVyKG9iamVjdCkge1xyXG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRTtcclxufVxyXG5mdW5jdGlvbiBpc0VsZW1lbnQob2JqZWN0KSB7XHJcbiAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcclxufVxyXG5mdW5jdGlvbiBpc0ZvcndhcmRSZWYob2JqZWN0KSB7XHJcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFO1xyXG59XHJcbmZ1bmN0aW9uIGlzRnJhZ21lbnQob2JqZWN0KSB7XHJcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xyXG59XHJcbmZ1bmN0aW9uIGlzTGF6eShvYmplY3QpIHtcclxuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0xBWllfVFlQRTtcclxufVxyXG5mdW5jdGlvbiBpc01lbW8ob2JqZWN0KSB7XHJcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9NRU1PX1RZUEU7XHJcbn1cclxuZnVuY3Rpb24gaXNQb3J0YWwob2JqZWN0KSB7XHJcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9QT1JUQUxfVFlQRTtcclxufVxyXG5mdW5jdGlvbiBpc1Byb2ZpbGVyKG9iamVjdCkge1xyXG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfUFJPRklMRVJfVFlQRTtcclxufVxyXG5mdW5jdGlvbiBpc1N0cmljdE1vZGUob2JqZWN0KSB7XHJcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFO1xyXG59XHJcbmZ1bmN0aW9uIGlzU3VzcGVuc2Uob2JqZWN0KSB7XHJcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFO1xyXG59XHJcblxyXG5leHBvcnRzLkFzeW5jTW9kZSA9IEFzeW5jTW9kZTtcclxuZXhwb3J0cy5Db25jdXJyZW50TW9kZSA9IENvbmN1cnJlbnRNb2RlO1xyXG5leHBvcnRzLkNvbnRleHRDb25zdW1lciA9IENvbnRleHRDb25zdW1lcjtcclxuZXhwb3J0cy5Db250ZXh0UHJvdmlkZXIgPSBDb250ZXh0UHJvdmlkZXI7XHJcbmV4cG9ydHMuRWxlbWVudCA9IEVsZW1lbnQ7XHJcbmV4cG9ydHMuRm9yd2FyZFJlZiA9IEZvcndhcmRSZWY7XHJcbmV4cG9ydHMuRnJhZ21lbnQgPSBGcmFnbWVudDtcclxuZXhwb3J0cy5MYXp5ID0gTGF6eTtcclxuZXhwb3J0cy5NZW1vID0gTWVtbztcclxuZXhwb3J0cy5Qb3J0YWwgPSBQb3J0YWw7XHJcbmV4cG9ydHMuUHJvZmlsZXIgPSBQcm9maWxlcjtcclxuZXhwb3J0cy5TdHJpY3RNb2RlID0gU3RyaWN0TW9kZTtcclxuZXhwb3J0cy5TdXNwZW5zZSA9IFN1c3BlbnNlO1xyXG5leHBvcnRzLmlzQXN5bmNNb2RlID0gaXNBc3luY01vZGU7XHJcbmV4cG9ydHMuaXNDb25jdXJyZW50TW9kZSA9IGlzQ29uY3VycmVudE1vZGU7XHJcbmV4cG9ydHMuaXNDb250ZXh0Q29uc3VtZXIgPSBpc0NvbnRleHRDb25zdW1lcjtcclxuZXhwb3J0cy5pc0NvbnRleHRQcm92aWRlciA9IGlzQ29udGV4dFByb3ZpZGVyO1xyXG5leHBvcnRzLmlzRWxlbWVudCA9IGlzRWxlbWVudDtcclxuZXhwb3J0cy5pc0ZvcndhcmRSZWYgPSBpc0ZvcndhcmRSZWY7XHJcbmV4cG9ydHMuaXNGcmFnbWVudCA9IGlzRnJhZ21lbnQ7XHJcbmV4cG9ydHMuaXNMYXp5ID0gaXNMYXp5O1xyXG5leHBvcnRzLmlzTWVtbyA9IGlzTWVtbztcclxuZXhwb3J0cy5pc1BvcnRhbCA9IGlzUG9ydGFsO1xyXG5leHBvcnRzLmlzUHJvZmlsZXIgPSBpc1Byb2ZpbGVyO1xyXG5leHBvcnRzLmlzU3RyaWN0TW9kZSA9IGlzU3RyaWN0TW9kZTtcclxuZXhwb3J0cy5pc1N1c3BlbnNlID0gaXNTdXNwZW5zZTtcclxuZXhwb3J0cy5pc1ZhbGlkRWxlbWVudFR5cGUgPSBpc1ZhbGlkRWxlbWVudFR5cGU7XHJcbmV4cG9ydHMudHlwZU9mID0gdHlwZU9mO1xyXG4gIH0pKCk7XHJcbn1cclxuIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcclxuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWlzLnByb2R1Y3Rpb24ubWluLmpzJyk7XHJcbn0gZWxzZSB7XHJcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1pcy5kZXZlbG9wbWVudC5qcycpO1xyXG59XHJcbiIsIm1vZHVsZS5leHBvcnRzID0gKF9fd2VicGFja19yZXF1aXJlX18oLyohIGRsbC1yZWZlcmVuY2UgZGxsX2EwZWE4MTk2ZTg2OWI5YjQ0MjVlICovIFwiZGxsLXJlZmVyZW5jZSBkbGxfYTBlYTgxOTZlODY5YjliNDQyNWVcIikpKFwiLi9ub2RlX21vZHVsZXMvcmVhY3QvaW5kZXguanNcIik7IiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxyXG4gKi9cclxuXHJcbnZhciBydW50aW1lID0gKGZ1bmN0aW9uIChleHBvcnRzKSB7XHJcbiAgXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4gIHZhciBPcCA9IE9iamVjdC5wcm90b3R5cGU7XHJcbiAgdmFyIGhhc093biA9IE9wLmhhc093blByb3BlcnR5O1xyXG4gIHZhciB1bmRlZmluZWQ7IC8vIE1vcmUgY29tcHJlc3NpYmxlIHRoYW4gdm9pZCAwLlxyXG4gIHZhciAkU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiID8gU3ltYm9sIDoge307XHJcbiAgdmFyIGl0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIjtcclxuICB2YXIgYXN5bmNJdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuYXN5bmNJdGVyYXRvciB8fCBcIkBAYXN5bmNJdGVyYXRvclwiO1xyXG4gIHZhciB0b1N0cmluZ1RhZ1N5bWJvbCA9ICRTeW1ib2wudG9TdHJpbmdUYWcgfHwgXCJAQHRvU3RyaW5nVGFnXCI7XHJcblxyXG4gIGZ1bmN0aW9uIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcclxuICAgIC8vIElmIG91dGVyRm4gcHJvdmlkZWQgYW5kIG91dGVyRm4ucHJvdG90eXBlIGlzIGEgR2VuZXJhdG9yLCB0aGVuIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yLlxyXG4gICAgdmFyIHByb3RvR2VuZXJhdG9yID0gb3V0ZXJGbiAmJiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvciA/IG91dGVyRm4gOiBHZW5lcmF0b3I7XHJcbiAgICB2YXIgZ2VuZXJhdG9yID0gT2JqZWN0LmNyZWF0ZShwcm90b0dlbmVyYXRvci5wcm90b3R5cGUpO1xyXG4gICAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSk7XHJcblxyXG4gICAgLy8gVGhlIC5faW52b2tlIG1ldGhvZCB1bmlmaWVzIHRoZSBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlIC5uZXh0LFxyXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzLlxyXG4gICAgZ2VuZXJhdG9yLl9pbnZva2UgPSBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xyXG5cclxuICAgIHJldHVybiBnZW5lcmF0b3I7XHJcbiAgfVxyXG4gIGV4cG9ydHMud3JhcCA9IHdyYXA7XHJcblxyXG4gIC8vIFRyeS9jYXRjaCBoZWxwZXIgdG8gbWluaW1pemUgZGVvcHRpbWl6YXRpb25zLiBSZXR1cm5zIGEgY29tcGxldGlvblxyXG4gIC8vIHJlY29yZCBsaWtlIGNvbnRleHQudHJ5RW50cmllc1tpXS5jb21wbGV0aW9uLiBUaGlzIGludGVyZmFjZSBjb3VsZFxyXG4gIC8vIGhhdmUgYmVlbiAoYW5kIHdhcyBwcmV2aW91c2x5KSBkZXNpZ25lZCB0byB0YWtlIGEgY2xvc3VyZSB0byBiZVxyXG4gIC8vIGludm9rZWQgd2l0aG91dCBhcmd1bWVudHMsIGJ1dCBpbiBhbGwgdGhlIGNhc2VzIHdlIGNhcmUgYWJvdXQgd2VcclxuICAvLyBhbHJlYWR5IGhhdmUgYW4gZXhpc3RpbmcgbWV0aG9kIHdlIHdhbnQgdG8gY2FsbCwgc28gdGhlcmUncyBubyBuZWVkXHJcbiAgLy8gdG8gY3JlYXRlIGEgbmV3IGZ1bmN0aW9uIG9iamVjdC4gV2UgY2FuIGV2ZW4gZ2V0IGF3YXkgd2l0aCBhc3N1bWluZ1xyXG4gIC8vIHRoZSBtZXRob2QgdGFrZXMgZXhhY3RseSBvbmUgYXJndW1lbnQsIHNpbmNlIHRoYXQgaGFwcGVucyB0byBiZSB0cnVlXHJcbiAgLy8gaW4gZXZlcnkgY2FzZSwgc28gd2UgZG9uJ3QgaGF2ZSB0byB0b3VjaCB0aGUgYXJndW1lbnRzIG9iamVjdC4gVGhlXHJcbiAgLy8gb25seSBhZGRpdGlvbmFsIGFsbG9jYXRpb24gcmVxdWlyZWQgaXMgdGhlIGNvbXBsZXRpb24gcmVjb3JkLCB3aGljaFxyXG4gIC8vIGhhcyBhIHN0YWJsZSBzaGFwZSBhbmQgc28gaG9wZWZ1bGx5IHNob3VsZCBiZSBjaGVhcCB0byBhbGxvY2F0ZS5cclxuICBmdW5jdGlvbiB0cnlDYXRjaChmbiwgb2JqLCBhcmcpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIHJldHVybiB7IHR5cGU6IFwibm9ybWFsXCIsIGFyZzogZm4uY2FsbChvYmosIGFyZykgfTtcclxuICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICByZXR1cm4geyB0eXBlOiBcInRocm93XCIsIGFyZzogZXJyIH07XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRTdGFydCA9IFwic3VzcGVuZGVkU3RhcnRcIjtcclxuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRZaWVsZCA9IFwic3VzcGVuZGVkWWllbGRcIjtcclxuICB2YXIgR2VuU3RhdGVFeGVjdXRpbmcgPSBcImV4ZWN1dGluZ1wiO1xyXG4gIHZhciBHZW5TdGF0ZUNvbXBsZXRlZCA9IFwiY29tcGxldGVkXCI7XHJcblxyXG4gIC8vIFJldHVybmluZyB0aGlzIG9iamVjdCBmcm9tIHRoZSBpbm5lckZuIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXNcclxuICAvLyBicmVha2luZyBvdXQgb2YgdGhlIGRpc3BhdGNoIHN3aXRjaCBzdGF0ZW1lbnQuXHJcbiAgdmFyIENvbnRpbnVlU2VudGluZWwgPSB7fTtcclxuXHJcbiAgLy8gRHVtbXkgY29uc3RydWN0b3IgZnVuY3Rpb25zIHRoYXQgd2UgdXNlIGFzIHRoZSAuY29uc3RydWN0b3IgYW5kXHJcbiAgLy8gLmNvbnN0cnVjdG9yLnByb3RvdHlwZSBwcm9wZXJ0aWVzIGZvciBmdW5jdGlvbnMgdGhhdCByZXR1cm4gR2VuZXJhdG9yXHJcbiAgLy8gb2JqZWN0cy4gRm9yIGZ1bGwgc3BlYyBjb21wbGlhbmNlLCB5b3UgbWF5IHdpc2ggdG8gY29uZmlndXJlIHlvdXJcclxuICAvLyBtaW5pZmllciBub3QgdG8gbWFuZ2xlIHRoZSBuYW1lcyBvZiB0aGVzZSB0d28gZnVuY3Rpb25zLlxyXG4gIGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9XHJcbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fVxyXG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge31cclxuXHJcbiAgLy8gVGhpcyBpcyBhIHBvbHlmaWxsIGZvciAlSXRlcmF0b3JQcm90b3R5cGUlIGZvciBlbnZpcm9ubWVudHMgdGhhdFxyXG4gIC8vIGRvbid0IG5hdGl2ZWx5IHN1cHBvcnQgaXQuXHJcbiAgdmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XHJcbiAgSXRlcmF0b3JQcm90b3R5cGVbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfTtcclxuXHJcbiAgdmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xyXG4gIHZhciBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvICYmIGdldFByb3RvKGdldFByb3RvKHZhbHVlcyhbXSkpKTtcclxuICBpZiAoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgJiZcclxuICAgICAgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgIT09IE9wICYmXHJcbiAgICAgIGhhc093bi5jYWxsKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlLCBpdGVyYXRvclN5bWJvbCkpIHtcclxuICAgIC8vIFRoaXMgZW52aXJvbm1lbnQgaGFzIGEgbmF0aXZlICVJdGVyYXRvclByb3RvdHlwZSU7IHVzZSBpdCBpbnN0ZWFkXHJcbiAgICAvLyBvZiB0aGUgcG9seWZpbGwuXHJcbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlO1xyXG4gIH1cclxuXHJcbiAgdmFyIEdwID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlID1cclxuICAgIEdlbmVyYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlKTtcclxuICBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHcC5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xyXG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb247XHJcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGVbdG9TdHJpbmdUYWdTeW1ib2xdID1cclxuICAgIEdlbmVyYXRvckZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xyXG5cclxuICAvLyBIZWxwZXIgZm9yIGRlZmluaW5nIHRoZSAubmV4dCwgLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzIG9mIHRoZVxyXG4gIC8vIEl0ZXJhdG9yIGludGVyZmFjZSBpbiB0ZXJtcyBvZiBhIHNpbmdsZSAuX2ludm9rZSBtZXRob2QuXHJcbiAgZnVuY3Rpb24gZGVmaW5lSXRlcmF0b3JNZXRob2RzKHByb3RvdHlwZSkge1xyXG4gICAgW1wibmV4dFwiLCBcInRocm93XCIsIFwicmV0dXJuXCJdLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XHJcbiAgICAgIHByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24oYXJnKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7XHJcbiAgICAgIH07XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uKGdlbkZ1bikge1xyXG4gICAgdmFyIGN0b3IgPSB0eXBlb2YgZ2VuRnVuID09PSBcImZ1bmN0aW9uXCIgJiYgZ2VuRnVuLmNvbnN0cnVjdG9yO1xyXG4gICAgcmV0dXJuIGN0b3JcclxuICAgICAgPyBjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fFxyXG4gICAgICAgIC8vIEZvciB0aGUgbmF0aXZlIEdlbmVyYXRvckZ1bmN0aW9uIGNvbnN0cnVjdG9yLCB0aGUgYmVzdCB3ZSBjYW5cclxuICAgICAgICAvLyBkbyBpcyB0byBjaGVjayBpdHMgLm5hbWUgcHJvcGVydHkuXHJcbiAgICAgICAgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSA9PT0gXCJHZW5lcmF0b3JGdW5jdGlvblwiXHJcbiAgICAgIDogZmFsc2U7XHJcbiAgfTtcclxuXHJcbiAgZXhwb3J0cy5tYXJrID0gZnVuY3Rpb24oZ2VuRnVuKSB7XHJcbiAgICBpZiAoT2JqZWN0LnNldFByb3RvdHlwZU9mKSB7XHJcbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGdlbkZ1bi5fX3Byb3RvX18gPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcclxuICAgICAgaWYgKCEodG9TdHJpbmdUYWdTeW1ib2wgaW4gZ2VuRnVuKSkge1xyXG4gICAgICAgIGdlbkZ1blt0b1N0cmluZ1RhZ1N5bWJvbF0gPSBcIkdlbmVyYXRvckZ1bmN0aW9uXCI7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGdlbkZ1bi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdwKTtcclxuICAgIHJldHVybiBnZW5GdW47XHJcbiAgfTtcclxuXHJcbiAgLy8gV2l0aGluIHRoZSBib2R5IG9mIGFueSBhc3luYyBmdW5jdGlvbiwgYGF3YWl0IHhgIGlzIHRyYW5zZm9ybWVkIHRvXHJcbiAgLy8gYHlpZWxkIHJlZ2VuZXJhdG9yUnVudGltZS5hd3JhcCh4KWAsIHNvIHRoYXQgdGhlIHJ1bnRpbWUgY2FuIHRlc3RcclxuICAvLyBgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKWAgdG8gZGV0ZXJtaW5lIGlmIHRoZSB5aWVsZGVkIHZhbHVlIGlzXHJcbiAgLy8gbWVhbnQgdG8gYmUgYXdhaXRlZC5cclxuICBleHBvcnRzLmF3cmFwID0gZnVuY3Rpb24oYXJnKSB7XHJcbiAgICByZXR1cm4geyBfX2F3YWl0OiBhcmcgfTtcclxuICB9O1xyXG5cclxuICBmdW5jdGlvbiBBc3luY0l0ZXJhdG9yKGdlbmVyYXRvciwgUHJvbWlzZUltcGwpIHtcclxuICAgIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChnZW5lcmF0b3JbbWV0aG9kXSwgZ2VuZXJhdG9yLCBhcmcpO1xyXG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xyXG4gICAgICAgIHJlamVjdChyZWNvcmQuYXJnKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gcmVjb3JkLmFyZztcclxuICAgICAgICB2YXIgdmFsdWUgPSByZXN1bHQudmFsdWU7XHJcbiAgICAgICAgaWYgKHZhbHVlICYmXHJcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJlxyXG4gICAgICAgICAgICBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpKSB7XHJcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZUltcGwucmVzb2x2ZSh2YWx1ZS5fX2F3YWl0KS50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIGludm9rZShcIm5leHRcIiwgdmFsdWUsIHJlc29sdmUsIHJlamVjdCk7XHJcbiAgICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcclxuICAgICAgICAgICAgaW52b2tlKFwidGhyb3dcIiwgZXJyLCByZXNvbHZlLCByZWplY3QpO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gUHJvbWlzZUltcGwucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbih1bndyYXBwZWQpIHtcclxuICAgICAgICAgIC8vIFdoZW4gYSB5aWVsZGVkIFByb21pc2UgaXMgcmVzb2x2ZWQsIGl0cyBmaW5hbCB2YWx1ZSBiZWNvbWVzXHJcbiAgICAgICAgICAvLyB0aGUgLnZhbHVlIG9mIHRoZSBQcm9taXNlPHt2YWx1ZSxkb25lfT4gcmVzdWx0IGZvciB0aGVcclxuICAgICAgICAgIC8vIGN1cnJlbnQgaXRlcmF0aW9uLlxyXG4gICAgICAgICAgcmVzdWx0LnZhbHVlID0gdW53cmFwcGVkO1xyXG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xyXG4gICAgICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XHJcbiAgICAgICAgICAvLyBJZiBhIHJlamVjdGVkIFByb21pc2Ugd2FzIHlpZWxkZWQsIHRocm93IHRoZSByZWplY3Rpb24gYmFja1xyXG4gICAgICAgICAgLy8gaW50byB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIHNvIGl0IGNhbiBiZSBoYW5kbGVkIHRoZXJlLlxyXG4gICAgICAgICAgcmV0dXJuIGludm9rZShcInRocm93XCIsIGVycm9yLCByZXNvbHZlLCByZWplY3QpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHByZXZpb3VzUHJvbWlzZTtcclxuXHJcbiAgICBmdW5jdGlvbiBlbnF1ZXVlKG1ldGhvZCwgYXJnKSB7XHJcbiAgICAgIGZ1bmN0aW9uIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZUltcGwoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBwcmV2aW91c1Byb21pc2UgPVxyXG4gICAgICAgIC8vIElmIGVucXVldWUgaGFzIGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIHdhaXQgdW50aWxcclxuICAgICAgICAvLyBhbGwgcHJldmlvdXMgUHJvbWlzZXMgaGF2ZSBiZWVuIHJlc29sdmVkIGJlZm9yZSBjYWxsaW5nIGludm9rZSxcclxuICAgICAgICAvLyBzbyB0aGF0IHJlc3VsdHMgYXJlIGFsd2F5cyBkZWxpdmVyZWQgaW4gdGhlIGNvcnJlY3Qgb3JkZXIuIElmXHJcbiAgICAgICAgLy8gZW5xdWV1ZSBoYXMgbm90IGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiBpdCBpcyBpbXBvcnRhbnQgdG9cclxuICAgICAgICAvLyBjYWxsIGludm9rZSBpbW1lZGlhdGVseSwgd2l0aG91dCB3YWl0aW5nIG9uIGEgY2FsbGJhY2sgdG8gZmlyZSxcclxuICAgICAgICAvLyBzbyB0aGF0IHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gaGFzIHRoZSBvcHBvcnR1bml0eSB0byBkb1xyXG4gICAgICAgIC8vIGFueSBuZWNlc3Nhcnkgc2V0dXAgaW4gYSBwcmVkaWN0YWJsZSB3YXkuIFRoaXMgcHJlZGljdGFiaWxpdHlcclxuICAgICAgICAvLyBpcyB3aHkgdGhlIFByb21pc2UgY29uc3RydWN0b3Igc3luY2hyb25vdXNseSBpbnZva2VzIGl0c1xyXG4gICAgICAgIC8vIGV4ZWN1dG9yIGNhbGxiYWNrLCBhbmQgd2h5IGFzeW5jIGZ1bmN0aW9ucyBzeW5jaHJvbm91c2x5XHJcbiAgICAgICAgLy8gZXhlY3V0ZSBjb2RlIGJlZm9yZSB0aGUgZmlyc3QgYXdhaXQuIFNpbmNlIHdlIGltcGxlbWVudCBzaW1wbGVcclxuICAgICAgICAvLyBhc3luYyBmdW5jdGlvbnMgaW4gdGVybXMgb2YgYXN5bmMgZ2VuZXJhdG9ycywgaXQgaXMgZXNwZWNpYWxseVxyXG4gICAgICAgIC8vIGltcG9ydGFudCB0byBnZXQgdGhpcyByaWdodCwgZXZlbiB0aG91Z2ggaXQgcmVxdWlyZXMgY2FyZS5cclxuICAgICAgICBwcmV2aW91c1Byb21pc2UgPyBwcmV2aW91c1Byb21pc2UudGhlbihcclxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnLFxyXG4gICAgICAgICAgLy8gQXZvaWQgcHJvcGFnYXRpbmcgZmFpbHVyZXMgdG8gUHJvbWlzZXMgcmV0dXJuZWQgYnkgbGF0ZXJcclxuICAgICAgICAgIC8vIGludm9jYXRpb25zIG9mIHRoZSBpdGVyYXRvci5cclxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnXHJcbiAgICAgICAgKSA6IGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRGVmaW5lIHRoZSB1bmlmaWVkIGhlbHBlciBtZXRob2QgdGhhdCBpcyB1c2VkIHRvIGltcGxlbWVudCAubmV4dCxcclxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gKHNlZSBkZWZpbmVJdGVyYXRvck1ldGhvZHMpLlxyXG4gICAgdGhpcy5faW52b2tlID0gZW5xdWV1ZTtcclxuICB9XHJcblxyXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSk7XHJcbiAgQXN5bmNJdGVyYXRvci5wcm90b3R5cGVbYXN5bmNJdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9O1xyXG4gIGV4cG9ydHMuQXN5bmNJdGVyYXRvciA9IEFzeW5jSXRlcmF0b3I7XHJcblxyXG4gIC8vIE5vdGUgdGhhdCBzaW1wbGUgYXN5bmMgZnVuY3Rpb25zIGFyZSBpbXBsZW1lbnRlZCBvbiB0b3Agb2ZcclxuICAvLyBBc3luY0l0ZXJhdG9yIG9iamVjdHM7IHRoZXkganVzdCByZXR1cm4gYSBQcm9taXNlIGZvciB0aGUgdmFsdWUgb2ZcclxuICAvLyB0aGUgZmluYWwgcmVzdWx0IHByb2R1Y2VkIGJ5IHRoZSBpdGVyYXRvci5cclxuICBleHBvcnRzLmFzeW5jID0gZnVuY3Rpb24oaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QsIFByb21pc2VJbXBsKSB7XHJcbiAgICBpZiAoUHJvbWlzZUltcGwgPT09IHZvaWQgMCkgUHJvbWlzZUltcGwgPSBQcm9taXNlO1xyXG5cclxuICAgIHZhciBpdGVyID0gbmV3IEFzeW5jSXRlcmF0b3IoXHJcbiAgICAgIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpLFxyXG4gICAgICBQcm9taXNlSW1wbFxyXG4gICAgKTtcclxuXHJcbiAgICByZXR1cm4gZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uKG91dGVyRm4pXHJcbiAgICAgID8gaXRlciAvLyBJZiBvdXRlckZuIGlzIGEgZ2VuZXJhdG9yLCByZXR1cm4gdGhlIGZ1bGwgaXRlcmF0b3IuXHJcbiAgICAgIDogaXRlci5uZXh0KCkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcclxuICAgICAgICAgIHJldHVybiByZXN1bHQuZG9uZSA/IHJlc3VsdC52YWx1ZSA6IGl0ZXIubmV4dCgpO1xyXG4gICAgICAgIH0pO1xyXG4gIH07XHJcblxyXG4gIGZ1bmN0aW9uIG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkge1xyXG4gICAgdmFyIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydDtcclxuXHJcbiAgICByZXR1cm4gZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnKSB7XHJcbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVFeGVjdXRpbmcpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXCIpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlQ29tcGxldGVkKSB7XHJcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XHJcbiAgICAgICAgICB0aHJvdyBhcmc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBCZSBmb3JnaXZpbmcsIHBlciAyNS4zLjMuMy4zIG9mIHRoZSBzcGVjOlxyXG4gICAgICAgIC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1nZW5lcmF0b3JyZXN1bWVcclxuICAgICAgICByZXR1cm4gZG9uZVJlc3VsdCgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IG1ldGhvZDtcclxuICAgICAgY29udGV4dC5hcmcgPSBhcmc7XHJcblxyXG4gICAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgIHZhciBkZWxlZ2F0ZSA9IGNvbnRleHQuZGVsZWdhdGU7XHJcbiAgICAgICAgaWYgKGRlbGVnYXRlKSB7XHJcbiAgICAgICAgICB2YXIgZGVsZWdhdGVSZXN1bHQgPSBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcclxuICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCkge1xyXG4gICAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQgPT09IENvbnRpbnVlU2VudGluZWwpIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICByZXR1cm4gZGVsZWdhdGVSZXN1bHQ7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwibmV4dFwiKSB7XHJcbiAgICAgICAgICAvLyBTZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcclxuICAgICAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXHJcbiAgICAgICAgICBjb250ZXh0LnNlbnQgPSBjb250ZXh0Ll9zZW50ID0gY29udGV4dC5hcmc7XHJcblxyXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xyXG4gICAgICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0KSB7XHJcbiAgICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XHJcbiAgICAgICAgICAgIHRocm93IGNvbnRleHQuYXJnO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpO1xyXG5cclxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInJldHVyblwiKSB7XHJcbiAgICAgICAgICBjb250ZXh0LmFicnVwdChcInJldHVyblwiLCBjb250ZXh0LmFyZyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzdGF0ZSA9IEdlblN0YXRlRXhlY3V0aW5nO1xyXG5cclxuICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XHJcbiAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiKSB7XHJcbiAgICAgICAgICAvLyBJZiBhbiBleGNlcHRpb24gaXMgdGhyb3duIGZyb20gaW5uZXJGbiwgd2UgbGVhdmUgc3RhdGUgPT09XHJcbiAgICAgICAgICAvLyBHZW5TdGF0ZUV4ZWN1dGluZyBhbmQgbG9vcCBiYWNrIGZvciBhbm90aGVyIGludm9jYXRpb24uXHJcbiAgICAgICAgICBzdGF0ZSA9IGNvbnRleHQuZG9uZVxyXG4gICAgICAgICAgICA/IEdlblN0YXRlQ29tcGxldGVkXHJcbiAgICAgICAgICAgIDogR2VuU3RhdGVTdXNwZW5kZWRZaWVsZDtcclxuXHJcbiAgICAgICAgICBpZiAocmVjb3JkLmFyZyA9PT0gQ29udGludWVTZW50aW5lbCkge1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB2YWx1ZTogcmVjb3JkLmFyZyxcclxuICAgICAgICAgICAgZG9uZTogY29udGV4dC5kb25lXHJcbiAgICAgICAgICB9O1xyXG5cclxuICAgICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcclxuICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XHJcbiAgICAgICAgICAvLyBEaXNwYXRjaCB0aGUgZXhjZXB0aW9uIGJ5IGxvb3BpbmcgYmFjayBhcm91bmQgdG8gdGhlXHJcbiAgICAgICAgICAvLyBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKSBjYWxsIGFib3ZlLlxyXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XHJcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLy8gQ2FsbCBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF0oY29udGV4dC5hcmcpIGFuZCBoYW5kbGUgdGhlXHJcbiAgLy8gcmVzdWx0LCBlaXRoZXIgYnkgcmV0dXJuaW5nIGEgeyB2YWx1ZSwgZG9uZSB9IHJlc3VsdCBmcm9tIHRoZVxyXG4gIC8vIGRlbGVnYXRlIGl0ZXJhdG9yLCBvciBieSBtb2RpZnlpbmcgY29udGV4dC5tZXRob2QgYW5kIGNvbnRleHQuYXJnLFxyXG4gIC8vIHNldHRpbmcgY29udGV4dC5kZWxlZ2F0ZSB0byBudWxsLCBhbmQgcmV0dXJuaW5nIHRoZSBDb250aW51ZVNlbnRpbmVsLlxyXG4gIGZ1bmN0aW9uIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpIHtcclxuICAgIHZhciBtZXRob2QgPSBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF07XHJcbiAgICBpZiAobWV0aG9kID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgLy8gQSAudGhyb3cgb3IgLnJldHVybiB3aGVuIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgbm8gLnRocm93XHJcbiAgICAgIC8vIG1ldGhvZCBhbHdheXMgdGVybWluYXRlcyB0aGUgeWllbGQqIGxvb3AuXHJcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xyXG5cclxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcclxuICAgICAgICAvLyBOb3RlOiBbXCJyZXR1cm5cIl0gbXVzdCBiZSB1c2VkIGZvciBFUzMgcGFyc2luZyBjb21wYXRpYmlsaXR5LlxyXG4gICAgICAgIGlmIChkZWxlZ2F0ZS5pdGVyYXRvcltcInJldHVyblwiXSkge1xyXG4gICAgICAgICAgLy8gSWYgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBhIHJldHVybiBtZXRob2QsIGdpdmUgaXQgYVxyXG4gICAgICAgICAgLy8gY2hhbmNlIHRvIGNsZWFuIHVwLlxyXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInJldHVyblwiO1xyXG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcclxuXHJcbiAgICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xyXG4gICAgICAgICAgICAvLyBJZiBtYXliZUludm9rZURlbGVnYXRlKGNvbnRleHQpIGNoYW5nZWQgY29udGV4dC5tZXRob2QgZnJvbVxyXG4gICAgICAgICAgICAvLyBcInJldHVyblwiIHRvIFwidGhyb3dcIiwgbGV0IHRoYXQgb3ZlcnJpZGUgdGhlIFR5cGVFcnJvciBiZWxvdy5cclxuICAgICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcclxuICAgICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXHJcbiAgICAgICAgICBcIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ3Rocm93JyBtZXRob2RcIik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChtZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBjb250ZXh0LmFyZyk7XHJcblxyXG4gICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcclxuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XHJcbiAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcclxuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XHJcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZztcclxuXHJcbiAgICBpZiAoISBpbmZvKSB7XHJcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xyXG4gICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJpdGVyYXRvciByZXN1bHQgaXMgbm90IGFuIG9iamVjdFwiKTtcclxuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XHJcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChpbmZvLmRvbmUpIHtcclxuICAgICAgLy8gQXNzaWduIHRoZSByZXN1bHQgb2YgdGhlIGZpbmlzaGVkIGRlbGVnYXRlIHRvIHRoZSB0ZW1wb3JhcnlcclxuICAgICAgLy8gdmFyaWFibGUgc3BlY2lmaWVkIGJ5IGRlbGVnYXRlLnJlc3VsdE5hbWUgKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cclxuICAgICAgY29udGV4dFtkZWxlZ2F0ZS5yZXN1bHROYW1lXSA9IGluZm8udmFsdWU7XHJcblxyXG4gICAgICAvLyBSZXN1bWUgZXhlY3V0aW9uIGF0IHRoZSBkZXNpcmVkIGxvY2F0aW9uIChzZWUgZGVsZWdhdGVZaWVsZCkuXHJcbiAgICAgIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2M7XHJcblxyXG4gICAgICAvLyBJZiBjb250ZXh0Lm1ldGhvZCB3YXMgXCJ0aHJvd1wiIGJ1dCB0aGUgZGVsZWdhdGUgaGFuZGxlZCB0aGVcclxuICAgICAgLy8gZXhjZXB0aW9uLCBsZXQgdGhlIG91dGVyIGdlbmVyYXRvciBwcm9jZWVkIG5vcm1hbGx5LiBJZlxyXG4gICAgICAvLyBjb250ZXh0Lm1ldGhvZCB3YXMgXCJuZXh0XCIsIGZvcmdldCBjb250ZXh0LmFyZyBzaW5jZSBpdCBoYXMgYmVlblxyXG4gICAgICAvLyBcImNvbnN1bWVkXCIgYnkgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yLiBJZiBjb250ZXh0Lm1ldGhvZCB3YXNcclxuICAgICAgLy8gXCJyZXR1cm5cIiwgYWxsb3cgdGhlIG9yaWdpbmFsIC5yZXR1cm4gY2FsbCB0byBjb250aW51ZSBpbiB0aGVcclxuICAgICAgLy8gb3V0ZXIgZ2VuZXJhdG9yLlxyXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgIT09IFwicmV0dXJuXCIpIHtcclxuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xyXG4gICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xyXG4gICAgICB9XHJcblxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gUmUteWllbGQgdGhlIHJlc3VsdCByZXR1cm5lZCBieSB0aGUgZGVsZWdhdGUgbWV0aG9kLlxyXG4gICAgICByZXR1cm4gaW5mbztcclxuICAgIH1cclxuXHJcbiAgICAvLyBUaGUgZGVsZWdhdGUgaXRlcmF0b3IgaXMgZmluaXNoZWQsIHNvIGZvcmdldCBpdCBhbmQgY29udGludWUgd2l0aFxyXG4gICAgLy8gdGhlIG91dGVyIGdlbmVyYXRvci5cclxuICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xyXG4gICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XHJcbiAgfVxyXG5cclxuICAvLyBEZWZpbmUgR2VuZXJhdG9yLnByb3RvdHlwZS57bmV4dCx0aHJvdyxyZXR1cm59IGluIHRlcm1zIG9mIHRoZVxyXG4gIC8vIHVuaWZpZWQgLl9pbnZva2UgaGVscGVyIG1ldGhvZC5cclxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoR3ApO1xyXG5cclxuICBHcFt0b1N0cmluZ1RhZ1N5bWJvbF0gPSBcIkdlbmVyYXRvclwiO1xyXG5cclxuICAvLyBBIEdlbmVyYXRvciBzaG91bGQgYWx3YXlzIHJldHVybiBpdHNlbGYgYXMgdGhlIGl0ZXJhdG9yIG9iamVjdCB3aGVuIHRoZVxyXG4gIC8vIEBAaXRlcmF0b3IgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGl0LiBTb21lIGJyb3dzZXJzJyBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlXHJcbiAgLy8gaXRlcmF0b3IgcHJvdG90eXBlIGNoYWluIGluY29ycmVjdGx5IGltcGxlbWVudCB0aGlzLCBjYXVzaW5nIHRoZSBHZW5lcmF0b3JcclxuICAvLyBvYmplY3QgdG8gbm90IGJlIHJldHVybmVkIGZyb20gdGhpcyBjYWxsLiBUaGlzIGVuc3VyZXMgdGhhdCBkb2Vzbid0IGhhcHBlbi5cclxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL2lzc3Vlcy8yNzQgZm9yIG1vcmUgZGV0YWlscy5cclxuICBHcFtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH07XHJcblxyXG4gIEdwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gXCJbb2JqZWN0IEdlbmVyYXRvcl1cIjtcclxuICB9O1xyXG5cclxuICBmdW5jdGlvbiBwdXNoVHJ5RW50cnkobG9jcykge1xyXG4gICAgdmFyIGVudHJ5ID0geyB0cnlMb2M6IGxvY3NbMF0gfTtcclxuXHJcbiAgICBpZiAoMSBpbiBsb2NzKSB7XHJcbiAgICAgIGVudHJ5LmNhdGNoTG9jID0gbG9jc1sxXTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoMiBpbiBsb2NzKSB7XHJcbiAgICAgIGVudHJ5LmZpbmFsbHlMb2MgPSBsb2NzWzJdO1xyXG4gICAgICBlbnRyeS5hZnRlckxvYyA9IGxvY3NbM107XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy50cnlFbnRyaWVzLnB1c2goZW50cnkpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcmVzZXRUcnlFbnRyeShlbnRyeSkge1xyXG4gICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb24gfHwge307XHJcbiAgICByZWNvcmQudHlwZSA9IFwibm9ybWFsXCI7XHJcbiAgICBkZWxldGUgcmVjb3JkLmFyZztcclxuICAgIGVudHJ5LmNvbXBsZXRpb24gPSByZWNvcmQ7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBDb250ZXh0KHRyeUxvY3NMaXN0KSB7XHJcbiAgICAvLyBUaGUgcm9vdCBlbnRyeSBvYmplY3QgKGVmZmVjdGl2ZWx5IGEgdHJ5IHN0YXRlbWVudCB3aXRob3V0IGEgY2F0Y2hcclxuICAgIC8vIG9yIGEgZmluYWxseSBibG9jaykgZ2l2ZXMgdXMgYSBwbGFjZSB0byBzdG9yZSB2YWx1ZXMgdGhyb3duIGZyb21cclxuICAgIC8vIGxvY2F0aW9ucyB3aGVyZSB0aGVyZSBpcyBubyBlbmNsb3NpbmcgdHJ5IHN0YXRlbWVudC5cclxuICAgIHRoaXMudHJ5RW50cmllcyA9IFt7IHRyeUxvYzogXCJyb290XCIgfV07XHJcbiAgICB0cnlMb2NzTGlzdC5mb3JFYWNoKHB1c2hUcnlFbnRyeSwgdGhpcyk7XHJcbiAgICB0aGlzLnJlc2V0KHRydWUpO1xyXG4gIH1cclxuXHJcbiAgZXhwb3J0cy5rZXlzID0gZnVuY3Rpb24ob2JqZWN0KSB7XHJcbiAgICB2YXIga2V5cyA9IFtdO1xyXG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xyXG4gICAgICBrZXlzLnB1c2goa2V5KTtcclxuICAgIH1cclxuICAgIGtleXMucmV2ZXJzZSgpO1xyXG5cclxuICAgIC8vIFJhdGhlciB0aGFuIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCBhIG5leHQgbWV0aG9kLCB3ZSBrZWVwXHJcbiAgICAvLyB0aGluZ3Mgc2ltcGxlIGFuZCByZXR1cm4gdGhlIG5leHQgZnVuY3Rpb24gaXRzZWxmLlxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoKSB7XHJcbiAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCkge1xyXG4gICAgICAgIHZhciBrZXkgPSBrZXlzLnBvcCgpO1xyXG4gICAgICAgIGlmIChrZXkgaW4gb2JqZWN0KSB7XHJcbiAgICAgICAgICBuZXh0LnZhbHVlID0ga2V5O1xyXG4gICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XHJcbiAgICAgICAgICByZXR1cm4gbmV4dDtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFRvIGF2b2lkIGNyZWF0aW5nIGFuIGFkZGl0aW9uYWwgb2JqZWN0LCB3ZSBqdXN0IGhhbmcgdGhlIC52YWx1ZVxyXG4gICAgICAvLyBhbmQgLmRvbmUgcHJvcGVydGllcyBvZmYgdGhlIG5leHQgZnVuY3Rpb24gb2JqZWN0IGl0c2VsZi4gVGhpc1xyXG4gICAgICAvLyBhbHNvIGVuc3VyZXMgdGhhdCB0aGUgbWluaWZpZXIgd2lsbCBub3QgYW5vbnltaXplIHRoZSBmdW5jdGlvbi5cclxuICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcclxuICAgICAgcmV0dXJuIG5leHQ7XHJcbiAgICB9O1xyXG4gIH07XHJcblxyXG4gIGZ1bmN0aW9uIHZhbHVlcyhpdGVyYWJsZSkge1xyXG4gICAgaWYgKGl0ZXJhYmxlKSB7XHJcbiAgICAgIHZhciBpdGVyYXRvck1ldGhvZCA9IGl0ZXJhYmxlW2l0ZXJhdG9yU3ltYm9sXTtcclxuICAgICAgaWYgKGl0ZXJhdG9yTWV0aG9kKSB7XHJcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhYmxlLm5leHQgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgIHJldHVybiBpdGVyYWJsZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCFpc05hTihpdGVyYWJsZS5sZW5ndGgpKSB7XHJcbiAgICAgICAgdmFyIGkgPSAtMSwgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XHJcbiAgICAgICAgICB3aGlsZSAoKytpIDwgaXRlcmFibGUubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGlmIChoYXNPd24uY2FsbChpdGVyYWJsZSwgaSkpIHtcclxuICAgICAgICAgICAgICBuZXh0LnZhbHVlID0gaXRlcmFibGVbaV07XHJcbiAgICAgICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBuZXh0LnZhbHVlID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICByZXR1cm4gbmV4dDtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICByZXR1cm4gbmV4dC5uZXh0ID0gbmV4dDtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFJldHVybiBhbiBpdGVyYXRvciB3aXRoIG5vIHZhbHVlcy5cclxuICAgIHJldHVybiB7IG5leHQ6IGRvbmVSZXN1bHQgfTtcclxuICB9XHJcbiAgZXhwb3J0cy52YWx1ZXMgPSB2YWx1ZXM7XHJcblxyXG4gIGZ1bmN0aW9uIGRvbmVSZXN1bHQoKSB7XHJcbiAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XHJcbiAgfVxyXG5cclxuICBDb250ZXh0LnByb3RvdHlwZSA9IHtcclxuICAgIGNvbnN0cnVjdG9yOiBDb250ZXh0LFxyXG5cclxuICAgIHJlc2V0OiBmdW5jdGlvbihza2lwVGVtcFJlc2V0KSB7XHJcbiAgICAgIHRoaXMucHJldiA9IDA7XHJcbiAgICAgIHRoaXMubmV4dCA9IDA7XHJcbiAgICAgIC8vIFJlc2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXHJcbiAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXHJcbiAgICAgIHRoaXMuc2VudCA9IHRoaXMuX3NlbnQgPSB1bmRlZmluZWQ7XHJcbiAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xyXG4gICAgICB0aGlzLmRlbGVnYXRlID0gbnVsbDtcclxuXHJcbiAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XHJcbiAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xyXG5cclxuICAgICAgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSk7XHJcblxyXG4gICAgICBpZiAoIXNraXBUZW1wUmVzZXQpIHtcclxuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMpIHtcclxuICAgICAgICAgIC8vIE5vdCBzdXJlIGFib3V0IHRoZSBvcHRpbWFsIG9yZGVyIG9mIHRoZXNlIGNvbmRpdGlvbnM6XHJcbiAgICAgICAgICBpZiAobmFtZS5jaGFyQXQoMCkgPT09IFwidFwiICYmXHJcbiAgICAgICAgICAgICAgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiZcclxuICAgICAgICAgICAgICAhaXNOYU4oK25hbWUuc2xpY2UoMSkpKSB7XHJcbiAgICAgICAgICAgIHRoaXNbbmFtZV0gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xyXG4gICAgICB0aGlzLmRvbmUgPSB0cnVlO1xyXG5cclxuICAgICAgdmFyIHJvb3RFbnRyeSA9IHRoaXMudHJ5RW50cmllc1swXTtcclxuICAgICAgdmFyIHJvb3RSZWNvcmQgPSByb290RW50cnkuY29tcGxldGlvbjtcclxuICAgICAgaWYgKHJvb3RSZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XHJcbiAgICAgICAgdGhyb3cgcm9vdFJlY29yZC5hcmc7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB0aGlzLnJ2YWw7XHJcbiAgICB9LFxyXG5cclxuICAgIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbihleGNlcHRpb24pIHtcclxuICAgICAgaWYgKHRoaXMuZG9uZSkge1xyXG4gICAgICAgIHRocm93IGV4Y2VwdGlvbjtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzO1xyXG4gICAgICBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHtcclxuICAgICAgICByZWNvcmQudHlwZSA9IFwidGhyb3dcIjtcclxuICAgICAgICByZWNvcmQuYXJnID0gZXhjZXB0aW9uO1xyXG4gICAgICAgIGNvbnRleHQubmV4dCA9IGxvYztcclxuXHJcbiAgICAgICAgaWYgKGNhdWdodCkge1xyXG4gICAgICAgICAgLy8gSWYgdGhlIGRpc3BhdGNoZWQgZXhjZXB0aW9uIHdhcyBjYXVnaHQgYnkgYSBjYXRjaCBibG9jayxcclxuICAgICAgICAgIC8vIHRoZW4gbGV0IHRoYXQgY2F0Y2ggYmxvY2sgaGFuZGxlIHRoZSBleGNlcHRpb24gbm9ybWFsbHkuXHJcbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xyXG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gISEgY2F1Z2h0O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XHJcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xyXG4gICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xyXG5cclxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSBcInJvb3RcIikge1xyXG4gICAgICAgICAgLy8gRXhjZXB0aW9uIHRocm93biBvdXRzaWRlIG9mIGFueSB0cnkgYmxvY2sgdGhhdCBjb3VsZCBoYW5kbGVcclxuICAgICAgICAgIC8vIGl0LCBzbyBzZXQgdGhlIGNvbXBsZXRpb24gdmFsdWUgb2YgdGhlIGVudGlyZSBmdW5jdGlvbiB0b1xyXG4gICAgICAgICAgLy8gdGhyb3cgdGhlIGV4Y2VwdGlvbi5cclxuICAgICAgICAgIHJldHVybiBoYW5kbGUoXCJlbmRcIik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldikge1xyXG4gICAgICAgICAgdmFyIGhhc0NhdGNoID0gaGFzT3duLmNhbGwoZW50cnksIFwiY2F0Y2hMb2NcIik7XHJcbiAgICAgICAgICB2YXIgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIik7XHJcblxyXG4gICAgICAgICAgaWYgKGhhc0NhdGNoICYmIGhhc0ZpbmFsbHkpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xyXG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xyXG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNGaW5hbGx5KSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XCIpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBhYnJ1cHQ6IGZ1bmN0aW9uKHR5cGUsIGFyZykge1xyXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XHJcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xyXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2ICYmXHJcbiAgICAgICAgICAgIGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIikgJiZcclxuICAgICAgICAgICAgdGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xyXG4gICAgICAgICAgdmFyIGZpbmFsbHlFbnRyeSA9IGVudHJ5O1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoZmluYWxseUVudHJ5ICYmXHJcbiAgICAgICAgICAodHlwZSA9PT0gXCJicmVha1wiIHx8XHJcbiAgICAgICAgICAgdHlwZSA9PT0gXCJjb250aW51ZVwiKSAmJlxyXG4gICAgICAgICAgZmluYWxseUVudHJ5LnRyeUxvYyA8PSBhcmcgJiZcclxuICAgICAgICAgIGFyZyA8PSBmaW5hbGx5RW50cnkuZmluYWxseUxvYykge1xyXG4gICAgICAgIC8vIElnbm9yZSB0aGUgZmluYWxseSBlbnRyeSBpZiBjb250cm9sIGlzIG5vdCBqdW1waW5nIHRvIGFcclxuICAgICAgICAvLyBsb2NhdGlvbiBvdXRzaWRlIHRoZSB0cnkvY2F0Y2ggYmxvY2suXHJcbiAgICAgICAgZmluYWxseUVudHJ5ID0gbnVsbDtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIHJlY29yZCA9IGZpbmFsbHlFbnRyeSA/IGZpbmFsbHlFbnRyeS5jb21wbGV0aW9uIDoge307XHJcbiAgICAgIHJlY29yZC50eXBlID0gdHlwZTtcclxuICAgICAgcmVjb3JkLmFyZyA9IGFyZztcclxuXHJcbiAgICAgIGlmIChmaW5hbGx5RW50cnkpIHtcclxuICAgICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xyXG4gICAgICAgIHRoaXMubmV4dCA9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jO1xyXG4gICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZShyZWNvcmQpO1xyXG4gICAgfSxcclxuXHJcbiAgICBjb21wbGV0ZTogZnVuY3Rpb24ocmVjb3JkLCBhZnRlckxvYykge1xyXG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xyXG4gICAgICAgIHRocm93IHJlY29yZC5hcmc7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJicmVha1wiIHx8XHJcbiAgICAgICAgICByZWNvcmQudHlwZSA9PT0gXCJjb250aW51ZVwiKSB7XHJcbiAgICAgICAgdGhpcy5uZXh0ID0gcmVjb3JkLmFyZztcclxuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJyZXR1cm5cIikge1xyXG4gICAgICAgIHRoaXMucnZhbCA9IHRoaXMuYXJnID0gcmVjb3JkLmFyZztcclxuICAgICAgICB0aGlzLm1ldGhvZCA9IFwicmV0dXJuXCI7XHJcbiAgICAgICAgdGhpcy5uZXh0ID0gXCJlbmRcIjtcclxuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIiAmJiBhZnRlckxvYykge1xyXG4gICAgICAgIHRoaXMubmV4dCA9IGFmdGVyTG9jO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcclxuICAgIH0sXHJcblxyXG4gICAgZmluaXNoOiBmdW5jdGlvbihmaW5hbGx5TG9jKSB7XHJcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcclxuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XHJcbiAgICAgICAgaWYgKGVudHJ5LmZpbmFsbHlMb2MgPT09IGZpbmFsbHlMb2MpIHtcclxuICAgICAgICAgIHRoaXMuY29tcGxldGUoZW50cnkuY29tcGxldGlvbiwgZW50cnkuYWZ0ZXJMb2MpO1xyXG4gICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XHJcbiAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgXCJjYXRjaFwiOiBmdW5jdGlvbih0cnlMb2MpIHtcclxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xyXG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcclxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHtcclxuICAgICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xyXG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcclxuICAgICAgICAgICAgdmFyIHRocm93biA9IHJlY29yZC5hcmc7XHJcbiAgICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmV0dXJuIHRocm93bjtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFRoZSBjb250ZXh0LmNhdGNoIG1ldGhvZCBtdXN0IG9ubHkgYmUgY2FsbGVkIHdpdGggYSBsb2NhdGlvblxyXG4gICAgICAvLyBhcmd1bWVudCB0aGF0IGNvcnJlc3BvbmRzIHRvIGEga25vd24gY2F0Y2ggYmxvY2suXHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTtcclxuICAgIH0sXHJcblxyXG4gICAgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24oaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHtcclxuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IHtcclxuICAgICAgICBpdGVyYXRvcjogdmFsdWVzKGl0ZXJhYmxlKSxcclxuICAgICAgICByZXN1bHROYW1lOiByZXN1bHROYW1lLFxyXG4gICAgICAgIG5leHRMb2M6IG5leHRMb2NcclxuICAgICAgfTtcclxuXHJcbiAgICAgIGlmICh0aGlzLm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcclxuICAgICAgICAvLyBEZWxpYmVyYXRlbHkgZm9yZ2V0IHRoZSBsYXN0IHNlbnQgdmFsdWUgc28gdGhhdCB3ZSBkb24ndFxyXG4gICAgICAgIC8vIGFjY2lkZW50YWxseSBwYXNzIGl0IG9uIHRvIHRoZSBkZWxlZ2F0ZS5cclxuICAgICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLy8gUmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoaXMgc2NyaXB0IGlzIGV4ZWN1dGluZyBhcyBhIENvbW1vbkpTIG1vZHVsZVxyXG4gIC8vIG9yIG5vdCwgcmV0dXJuIHRoZSBydW50aW1lIG9iamVjdCBzbyB0aGF0IHdlIGNhbiBkZWNsYXJlIHRoZSB2YXJpYWJsZVxyXG4gIC8vIHJlZ2VuZXJhdG9yUnVudGltZSBpbiB0aGUgb3V0ZXIgc2NvcGUsIHdoaWNoIGFsbG93cyB0aGlzIG1vZHVsZSB0byBiZVxyXG4gIC8vIGluamVjdGVkIGVhc2lseSBieSBgYmluL3JlZ2VuZXJhdG9yIC0taW5jbHVkZS1ydW50aW1lIHNjcmlwdC5qc2AuXHJcbiAgcmV0dXJuIGV4cG9ydHM7XHJcblxyXG59KFxyXG4gIC8vIElmIHRoaXMgc2NyaXB0IGlzIGV4ZWN1dGluZyBhcyBhIENvbW1vbkpTIG1vZHVsZSwgdXNlIG1vZHVsZS5leHBvcnRzXHJcbiAgLy8gYXMgdGhlIHJlZ2VuZXJhdG9yUnVudGltZSBuYW1lc3BhY2UuIE90aGVyd2lzZSBjcmVhdGUgYSBuZXcgZW1wdHlcclxuICAvLyBvYmplY3QuIEVpdGhlciB3YXksIHRoZSByZXN1bHRpbmcgb2JqZWN0IHdpbGwgYmUgdXNlZCB0byBpbml0aWFsaXplXHJcbiAgLy8gdGhlIHJlZ2VuZXJhdG9yUnVudGltZSB2YXJpYWJsZSBhdCB0aGUgdG9wIG9mIHRoaXMgZmlsZS5cclxuICB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiID8gbW9kdWxlLmV4cG9ydHMgOiB7fVxyXG4pKTtcclxuXHJcbnRyeSB7XHJcbiAgcmVnZW5lcmF0b3JSdW50aW1lID0gcnVudGltZTtcclxufSBjYXRjaCAoYWNjaWRlbnRhbFN0cmljdE1vZGUpIHtcclxuICAvLyBUaGlzIG1vZHVsZSBzaG91bGQgbm90IGJlIHJ1bm5pbmcgaW4gc3RyaWN0IG1vZGUsIHNvIHRoZSBhYm92ZVxyXG4gIC8vIGFzc2lnbm1lbnQgc2hvdWxkIGFsd2F5cyB3b3JrIHVubGVzcyBzb21ldGhpbmcgaXMgbWlzY29uZmlndXJlZC4gSnVzdFxyXG4gIC8vIGluIGNhc2UgcnVudGltZS5qcyBhY2NpZGVudGFsbHkgcnVucyBpbiBzdHJpY3QgbW9kZSwgd2UgY2FuIGVzY2FwZVxyXG4gIC8vIHN0cmljdCBtb2RlIHVzaW5nIGEgZ2xvYmFsIEZ1bmN0aW9uIGNhbGwuIFRoaXMgY291bGQgY29uY2VpdmFibHkgZmFpbFxyXG4gIC8vIGlmIGEgQ29udGVudCBTZWN1cml0eSBQb2xpY3kgZm9yYmlkcyB1c2luZyBGdW5jdGlvbiwgYnV0IGluIHRoYXQgY2FzZVxyXG4gIC8vIHRoZSBwcm9wZXIgc29sdXRpb24gaXMgdG8gZml4IHRoZSBhY2NpZGVudGFsIHN0cmljdCBtb2RlIHByb2JsZW0uIElmXHJcbiAgLy8geW91J3ZlIG1pc2NvbmZpZ3VyZWQgeW91ciBidW5kbGVyIHRvIGZvcmNlIHN0cmljdCBtb2RlIGFuZCBhcHBsaWVkIGFcclxuICAvLyBDU1AgdG8gZm9yYmlkIEZ1bmN0aW9uLCBhbmQgeW91J3JlIG5vdCB3aWxsaW5nIHRvIGZpeCBlaXRoZXIgb2YgdGhvc2VcclxuICAvLyBwcm9ibGVtcywgcGxlYXNlIGRldGFpbCB5b3VyIHVuaXF1ZSBwcmVkaWNhbWVudCBpbiBhIEdpdEh1YiBpc3N1ZS5cclxuICBGdW5jdGlvbihcInJcIiwgXCJyZWdlbmVyYXRvclJ1bnRpbWUgPSByXCIpKHJ1bnRpbWUpO1xyXG59XHJcbiIsInZhciBVTktOT1dOX0ZVTkNUSU9OID0gJzx1bmtub3duPic7XHJcbi8qKlxyXG4gKiBUaGlzIHBhcnNlcyB0aGUgZGlmZmVyZW50IHN0YWNrIHRyYWNlcyBhbmQgcHV0cyB0aGVtIGludG8gb25lIGZvcm1hdFxyXG4gKiBUaGlzIGJvcnJvd3MgaGVhdmlseSBmcm9tIFRyYWNlS2l0IChodHRwczovL2dpdGh1Yi5jb20vY3Nub3Zlci9UcmFjZUtpdClcclxuICovXHJcblxyXG5mdW5jdGlvbiBwYXJzZShzdGFja1N0cmluZykge1xyXG4gIHZhciBsaW5lcyA9IHN0YWNrU3RyaW5nLnNwbGl0KCdcXG4nKTtcclxuICByZXR1cm4gbGluZXMucmVkdWNlKGZ1bmN0aW9uIChzdGFjaywgbGluZSkge1xyXG4gICAgdmFyIHBhcnNlUmVzdWx0ID0gcGFyc2VDaHJvbWUobGluZSkgfHwgcGFyc2VXaW5qcyhsaW5lKSB8fCBwYXJzZUdlY2tvKGxpbmUpIHx8IHBhcnNlTm9kZShsaW5lKSB8fCBwYXJzZUpTQyhsaW5lKTtcclxuXHJcbiAgICBpZiAocGFyc2VSZXN1bHQpIHtcclxuICAgICAgc3RhY2sucHVzaChwYXJzZVJlc3VsdCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHN0YWNrO1xyXG4gIH0sIFtdKTtcclxufVxyXG52YXIgY2hyb21lUmUgPSAvXlxccyphdCAoLio/KSA/XFwoKCg/OmZpbGV8aHR0cHM/fGJsb2J8Y2hyb21lLWV4dGVuc2lvbnxuYXRpdmV8ZXZhbHx3ZWJwYWNrfDxhbm9ueW1vdXM+fFxcL3xbYS16XTpcXFxcfFxcXFxcXFxcKS4qPykoPzo6KFxcZCspKT8oPzo6KFxcZCspKT9cXCk/XFxzKiQvaTtcclxudmFyIGNocm9tZUV2YWxSZSA9IC9cXCgoXFxTKikoPzo6KFxcZCspKSg/OjooXFxkKykpXFwpLztcclxuXHJcbmZ1bmN0aW9uIHBhcnNlQ2hyb21lKGxpbmUpIHtcclxuICB2YXIgcGFydHMgPSBjaHJvbWVSZS5leGVjKGxpbmUpO1xyXG5cclxuICBpZiAoIXBhcnRzKSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIHZhciBpc05hdGl2ZSA9IHBhcnRzWzJdICYmIHBhcnRzWzJdLmluZGV4T2YoJ25hdGl2ZScpID09PSAwOyAvLyBzdGFydCBvZiBsaW5lXHJcblxyXG4gIHZhciBpc0V2YWwgPSBwYXJ0c1syXSAmJiBwYXJ0c1syXS5pbmRleE9mKCdldmFsJykgPT09IDA7IC8vIHN0YXJ0IG9mIGxpbmVcclxuXHJcbiAgdmFyIHN1Ym1hdGNoID0gY2hyb21lRXZhbFJlLmV4ZWMocGFydHNbMl0pO1xyXG5cclxuICBpZiAoaXNFdmFsICYmIHN1Ym1hdGNoICE9IG51bGwpIHtcclxuICAgIC8vIHRocm93IG91dCBldmFsIGxpbmUvY29sdW1uIGFuZCB1c2UgdG9wLW1vc3QgbGluZS9jb2x1bW4gbnVtYmVyXHJcbiAgICBwYXJ0c1syXSA9IHN1Ym1hdGNoWzFdOyAvLyB1cmxcclxuXHJcbiAgICBwYXJ0c1szXSA9IHN1Ym1hdGNoWzJdOyAvLyBsaW5lXHJcblxyXG4gICAgcGFydHNbNF0gPSBzdWJtYXRjaFszXTsgLy8gY29sdW1uXHJcbiAgfVxyXG5cclxuICByZXR1cm4ge1xyXG4gICAgZmlsZTogIWlzTmF0aXZlID8gcGFydHNbMl0gOiBudWxsLFxyXG4gICAgbWV0aG9kTmFtZTogcGFydHNbMV0gfHwgVU5LTk9XTl9GVU5DVElPTixcclxuICAgIGFyZ3VtZW50czogaXNOYXRpdmUgPyBbcGFydHNbMl1dIDogW10sXHJcbiAgICBsaW5lTnVtYmVyOiBwYXJ0c1szXSA/ICtwYXJ0c1szXSA6IG51bGwsXHJcbiAgICBjb2x1bW46IHBhcnRzWzRdID8gK3BhcnRzWzRdIDogbnVsbFxyXG4gIH07XHJcbn1cclxuXHJcbnZhciB3aW5qc1JlID0gL15cXHMqYXQgKD86KCg/OlxcW29iamVjdCBvYmplY3RcXF0pPy4rKSApP1xcKD8oKD86ZmlsZXxtcy1hcHB4fGh0dHBzP3x3ZWJwYWNrfGJsb2IpOi4qPyk6KFxcZCspKD86OihcXGQrKSk/XFwpP1xccyokL2k7XHJcblxyXG5mdW5jdGlvbiBwYXJzZVdpbmpzKGxpbmUpIHtcclxuICB2YXIgcGFydHMgPSB3aW5qc1JlLmV4ZWMobGluZSk7XHJcblxyXG4gIGlmICghcGFydHMpIHtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIGZpbGU6IHBhcnRzWzJdLFxyXG4gICAgbWV0aG9kTmFtZTogcGFydHNbMV0gfHwgVU5LTk9XTl9GVU5DVElPTixcclxuICAgIGFyZ3VtZW50czogW10sXHJcbiAgICBsaW5lTnVtYmVyOiArcGFydHNbM10sXHJcbiAgICBjb2x1bW46IHBhcnRzWzRdID8gK3BhcnRzWzRdIDogbnVsbFxyXG4gIH07XHJcbn1cclxuXHJcbnZhciBnZWNrb1JlID0gL15cXHMqKC4qPykoPzpcXCgoLio/KVxcKSk/KD86XnxAKSgoPzpmaWxlfGh0dHBzP3xibG9ifGNocm9tZXx3ZWJwYWNrfHJlc291cmNlfFxcW25hdGl2ZSkuKj98W15AXSpidW5kbGUpKD86OihcXGQrKSk/KD86OihcXGQrKSk/XFxzKiQvaTtcclxudmFyIGdlY2tvRXZhbFJlID0gLyhcXFMrKSBsaW5lIChcXGQrKSg/OiA+IGV2YWwgbGluZSBcXGQrKSogPiBldmFsL2k7XHJcblxyXG5mdW5jdGlvbiBwYXJzZUdlY2tvKGxpbmUpIHtcclxuICB2YXIgcGFydHMgPSBnZWNrb1JlLmV4ZWMobGluZSk7XHJcblxyXG4gIGlmICghcGFydHMpIHtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuXHJcbiAgdmFyIGlzRXZhbCA9IHBhcnRzWzNdICYmIHBhcnRzWzNdLmluZGV4T2YoJyA+IGV2YWwnKSA+IC0xO1xyXG4gIHZhciBzdWJtYXRjaCA9IGdlY2tvRXZhbFJlLmV4ZWMocGFydHNbM10pO1xyXG5cclxuICBpZiAoaXNFdmFsICYmIHN1Ym1hdGNoICE9IG51bGwpIHtcclxuICAgIC8vIHRocm93IG91dCBldmFsIGxpbmUvY29sdW1uIGFuZCB1c2UgdG9wLW1vc3QgbGluZSBudW1iZXJcclxuICAgIHBhcnRzWzNdID0gc3VibWF0Y2hbMV07XHJcbiAgICBwYXJ0c1s0XSA9IHN1Ym1hdGNoWzJdO1xyXG4gICAgcGFydHNbNV0gPSBudWxsOyAvLyBubyBjb2x1bW4gd2hlbiBldmFsXHJcbiAgfVxyXG5cclxuICByZXR1cm4ge1xyXG4gICAgZmlsZTogcGFydHNbM10sXHJcbiAgICBtZXRob2ROYW1lOiBwYXJ0c1sxXSB8fCBVTktOT1dOX0ZVTkNUSU9OLFxyXG4gICAgYXJndW1lbnRzOiBwYXJ0c1syXSA/IHBhcnRzWzJdLnNwbGl0KCcsJykgOiBbXSxcclxuICAgIGxpbmVOdW1iZXI6IHBhcnRzWzRdID8gK3BhcnRzWzRdIDogbnVsbCxcclxuICAgIGNvbHVtbjogcGFydHNbNV0gPyArcGFydHNbNV0gOiBudWxsXHJcbiAgfTtcclxufVxyXG5cclxudmFyIGphdmFTY3JpcHRDb3JlUmUgPSAvXlxccyooPzooW15AXSopKD86XFwoKC4qPylcXCkpP0ApPyhcXFMuKj8pOihcXGQrKSg/OjooXFxkKykpP1xccyokL2k7XHJcblxyXG5mdW5jdGlvbiBwYXJzZUpTQyhsaW5lKSB7XHJcbiAgdmFyIHBhcnRzID0gamF2YVNjcmlwdENvcmVSZS5leGVjKGxpbmUpO1xyXG5cclxuICBpZiAoIXBhcnRzKSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBmaWxlOiBwYXJ0c1szXSxcclxuICAgIG1ldGhvZE5hbWU6IHBhcnRzWzFdIHx8IFVOS05PV05fRlVOQ1RJT04sXHJcbiAgICBhcmd1bWVudHM6IFtdLFxyXG4gICAgbGluZU51bWJlcjogK3BhcnRzWzRdLFxyXG4gICAgY29sdW1uOiBwYXJ0c1s1XSA/ICtwYXJ0c1s1XSA6IG51bGxcclxuICB9O1xyXG59XHJcblxyXG52YXIgbm9kZVJlID0gL15cXHMqYXQgKD86KCg/OlxcW29iamVjdCBvYmplY3RcXF0pP1teXFxcXC9dKyg/OiBcXFthcyBcXFMrXFxdKT8pICk/XFwoPyguKj8pOihcXGQrKSg/OjooXFxkKykpP1xcKT9cXHMqJC9pO1xyXG5cclxuZnVuY3Rpb24gcGFyc2VOb2RlKGxpbmUpIHtcclxuICB2YXIgcGFydHMgPSBub2RlUmUuZXhlYyhsaW5lKTtcclxuXHJcbiAgaWYgKCFwYXJ0cykge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICByZXR1cm4ge1xyXG4gICAgZmlsZTogcGFydHNbMl0sXHJcbiAgICBtZXRob2ROYW1lOiBwYXJ0c1sxXSB8fCBVTktOT1dOX0ZVTkNUSU9OLFxyXG4gICAgYXJndW1lbnRzOiBbXSxcclxuICAgIGxpbmVOdW1iZXI6ICtwYXJ0c1szXSxcclxuICAgIGNvbHVtbjogcGFydHNbNF0gPyArcGFydHNbNF0gOiBudWxsXHJcbiAgfTtcclxufVxyXG5cclxuZXhwb3J0IHsgcGFyc2UgfTtcclxuIiwiJ3VzZSBzdHJpY3QnO1xyXG5jb25zdCBhbnNpUmVnZXggPSByZXF1aXJlKCdhbnNpLXJlZ2V4Jyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHN0cmluZyA9PiB0eXBlb2Ygc3RyaW5nID09PSAnc3RyaW5nJyA/IHN0cmluZy5yZXBsYWNlKGFuc2lSZWdleCgpLCAnJykgOiBzdHJpbmc7XHJcbiIsInZhciB0LG4sZT1mdW5jdGlvbigpe3JldHVyblwiXCIuY29uY2F0KERhdGUubm93KCksXCItXCIpLmNvbmNhdChNYXRoLmZsb29yKDg5OTk5OTk5OTk5OTkqTWF0aC5yYW5kb20oKSkrMWUxMil9LGk9ZnVuY3Rpb24odCl7dmFyIG49YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOi0xO3JldHVybntuYW1lOnQsdmFsdWU6bixkZWx0YTowLGVudHJpZXM6W10saWQ6ZSgpLGlzRmluYWw6ITF9fSxhPWZ1bmN0aW9uKHQsbil7dHJ5e2lmKFBlcmZvcm1hbmNlT2JzZXJ2ZXIuc3VwcG9ydGVkRW50cnlUeXBlcy5pbmNsdWRlcyh0KSl7dmFyIGU9bmV3IFBlcmZvcm1hbmNlT2JzZXJ2ZXIoKGZ1bmN0aW9uKHQpe3JldHVybiB0LmdldEVudHJpZXMoKS5tYXAobil9KSk7cmV0dXJuIGUub2JzZXJ2ZSh7dHlwZTp0LGJ1ZmZlcmVkOiEwfSksZX19Y2F0Y2godCl7fX0scj0hMSxvPSExLHM9ZnVuY3Rpb24odCl7cj0hdC5wZXJzaXN0ZWR9LHU9ZnVuY3Rpb24oKXthZGRFdmVudExpc3RlbmVyKFwicGFnZWhpZGVcIixzKSxhZGRFdmVudExpc3RlbmVyKFwidW5sb2FkXCIsKGZ1bmN0aW9uKCl7fSkpfSxjPWZ1bmN0aW9uKHQpe3ZhciBuPWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdJiZhcmd1bWVudHNbMV07b3x8KHUoKSxvPSEwKSxhZGRFdmVudExpc3RlbmVyKFwidmlzaWJpbGl0eWNoYW5nZVwiLChmdW5jdGlvbihuKXt2YXIgZT1uLnRpbWVTdGFtcDtcImhpZGRlblwiPT09ZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlJiZ0KHt0aW1lU3RhbXA6ZSxpc1VubG9hZGluZzpyfSl9KSx7Y2FwdHVyZTohMCxvbmNlOm59KX0sbD1mdW5jdGlvbih0LG4sZSxpKXt2YXIgYTtyZXR1cm4gZnVuY3Rpb24oKXtlJiZuLmlzRmluYWwmJmUuZGlzY29ubmVjdCgpLG4udmFsdWU+PTAmJihpfHxuLmlzRmluYWx8fFwiaGlkZGVuXCI9PT1kb2N1bWVudC52aXNpYmlsaXR5U3RhdGUpJiYobi5kZWx0YT1uLnZhbHVlLShhfHwwKSwobi5kZWx0YXx8bi5pc0ZpbmFsfHx2b2lkIDA9PT1hKSYmKHQobiksYT1uLnZhbHVlKSl9fSxwPWZ1bmN0aW9uKHQpe3ZhciBuPWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdJiZhcmd1bWVudHNbMV0sZT1pKFwiQ0xTXCIsMCkscj1mdW5jdGlvbih0KXt0LmhhZFJlY2VudElucHV0fHwoZS52YWx1ZSs9dC52YWx1ZSxlLmVudHJpZXMucHVzaCh0KSxzKCkpfSxvPWEoXCJsYXlvdXQtc2hpZnRcIixyKSxzPWwodCxlLG8sbik7YygoZnVuY3Rpb24odCl7dmFyIG49dC5pc1VubG9hZGluZztvJiZvLnRha2VSZWNvcmRzKCkubWFwKHIpLG4mJihlLmlzRmluYWw9ITApLHMoKX0pKX0sZD1mdW5jdGlvbigpe3JldHVybiB2b2lkIDA9PT10JiYodD1cImhpZGRlblwiPT09ZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlPzA6MS8wLGMoKGZ1bmN0aW9uKG4pe3ZhciBlPW4udGltZVN0YW1wO3JldHVybiB0PWV9KSwhMCkpLHtnZXQgdGltZVN0YW1wKCl7cmV0dXJuIHR9fX0sbT1mdW5jdGlvbih0KXt2YXIgbj1pKFwiRkNQXCIpLGU9ZCgpLHI9YShcInBhaW50XCIsKGZ1bmN0aW9uKHQpe1wiZmlyc3QtY29udGVudGZ1bC1wYWludFwiPT09dC5uYW1lJiZ0LnN0YXJ0VGltZTxlLnRpbWVTdGFtcCYmKG4udmFsdWU9dC5zdGFydFRpbWUsbi5pc0ZpbmFsPSEwLG4uZW50cmllcy5wdXNoKHQpLG8oKSl9KSksbz1sKHQsbixyKX0sdj1mdW5jdGlvbih0KXt2YXIgbj1pKFwiRklEXCIpLGU9ZCgpLHI9ZnVuY3Rpb24odCl7dC5zdGFydFRpbWU8ZS50aW1lU3RhbXAmJihuLnZhbHVlPXQucHJvY2Vzc2luZ1N0YXJ0LXQuc3RhcnRUaW1lLG4uZW50cmllcy5wdXNoKHQpLG4uaXNGaW5hbD0hMCxzKCkpfSxvPWEoXCJmaXJzdC1pbnB1dFwiLHIpLHM9bCh0LG4sbyk7YygoZnVuY3Rpb24oKXtvJiYoby50YWtlUmVjb3JkcygpLm1hcChyKSxvLmRpc2Nvbm5lY3QoKSl9KSwhMCksb3x8d2luZG93LnBlcmZNZXRyaWNzJiZ3aW5kb3cucGVyZk1ldHJpY3Mub25GaXJzdElucHV0RGVsYXkmJndpbmRvdy5wZXJmTWV0cmljcy5vbkZpcnN0SW5wdXREZWxheSgoZnVuY3Rpb24odCxpKXtpLnRpbWVTdGFtcDxlLnRpbWVTdGFtcCYmKG4udmFsdWU9dCxuLmlzRmluYWw9ITAsbi5lbnRyaWVzPVt7ZW50cnlUeXBlOlwiZmlyc3QtaW5wdXRcIixuYW1lOmkudHlwZSx0YXJnZXQ6aS50YXJnZXQsY2FuY2VsYWJsZTppLmNhbmNlbGFibGUsc3RhcnRUaW1lOmkudGltZVN0YW1wLHByb2Nlc3NpbmdTdGFydDppLnRpbWVTdGFtcCt0fV0scygpKX0pKX0sZj1mdW5jdGlvbigpe3JldHVybiBufHwobj1uZXcgUHJvbWlzZSgoZnVuY3Rpb24odCl7cmV0dXJuW1wic2Nyb2xsXCIsXCJrZXlkb3duXCIsXCJwb2ludGVyZG93blwiXS5tYXAoKGZ1bmN0aW9uKG4pe2FkZEV2ZW50TGlzdGVuZXIobix0LHtvbmNlOiEwLHBhc3NpdmU6ITAsY2FwdHVyZTohMH0pfSkpfSkpKSxufSxnPWZ1bmN0aW9uKHQpe3ZhciBuPWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdJiZhcmd1bWVudHNbMV0sZT1pKFwiTENQXCIpLHI9ZCgpLG89ZnVuY3Rpb24odCl7dmFyIG49dC5zdGFydFRpbWU7bjxyLnRpbWVTdGFtcD8oZS52YWx1ZT1uLGUuZW50cmllcy5wdXNoKHQpKTplLmlzRmluYWw9ITAsdSgpfSxzPWEoXCJsYXJnZXN0LWNvbnRlbnRmdWwtcGFpbnRcIixvKSx1PWwodCxlLHMsbikscD1mdW5jdGlvbigpe2UuaXNGaW5hbHx8KHMmJnMudGFrZVJlY29yZHMoKS5tYXAobyksZS5pc0ZpbmFsPSEwLHUoKSl9O2YoKS50aGVuKHApLGMocCwhMCl9LGg9ZnVuY3Rpb24odCl7dmFyIG4sZT1pKFwiVFRGQlwiKTtuPWZ1bmN0aW9uKCl7dHJ5e3ZhciBuPXBlcmZvcm1hbmNlLmdldEVudHJpZXNCeVR5cGUoXCJuYXZpZ2F0aW9uXCIpWzBdfHxmdW5jdGlvbigpe3ZhciB0PXBlcmZvcm1hbmNlLnRpbWluZyxuPXtlbnRyeVR5cGU6XCJuYXZpZ2F0aW9uXCIsc3RhcnRUaW1lOjB9O2Zvcih2YXIgZSBpbiB0KVwibmF2aWdhdGlvblN0YXJ0XCIhPT1lJiZcInRvSlNPTlwiIT09ZSYmKG5bZV09TWF0aC5tYXgodFtlXS10Lm5hdmlnYXRpb25TdGFydCwwKSk7cmV0dXJuIG59KCk7ZS52YWx1ZT1lLmRlbHRhPW4ucmVzcG9uc2VTdGFydCxlLmVudHJpZXM9W25dLGUuaXNGaW5hbD0hMCx0KGUpfWNhdGNoKHQpe319LFwiY29tcGxldGVcIj09PWRvY3VtZW50LnJlYWR5U3RhdGU/c2V0VGltZW91dChuLDApOmFkZEV2ZW50TGlzdGVuZXIoXCJwYWdlc2hvd1wiLG4pfTtleHBvcnR7cCBhcyBnZXRDTFMsbSBhcyBnZXRGQ1AsdiBhcyBnZXRGSUQsZyBhcyBnZXRMQ1AsaCBhcyBnZXRUVEZCfTtcclxuIiwidmFyIGc7XHJcblxyXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxyXG5nID0gKGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzO1xyXG59KSgpO1xyXG5cclxudHJ5IHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcclxuXHRnID0gZyB8fCBuZXcgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpO1xyXG59IGNhdGNoIChlKSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcclxuXHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIikgZyA9IHdpbmRvdztcclxufVxyXG5cclxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxyXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xyXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGc7XHJcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obW9kdWxlKSB7XHJcblx0aWYgKCFtb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XHJcblx0XHRtb2R1bGUuZGVwcmVjYXRlID0gZnVuY3Rpb24oKSB7fTtcclxuXHRcdG1vZHVsZS5wYXRocyA9IFtdO1xyXG5cdFx0Ly8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XHJcblx0XHRpZiAoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImxvYWRlZFwiLCB7XHJcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXHJcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5sO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwiaWRcIiwge1xyXG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxyXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiBtb2R1bGUuaTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0XHRtb2R1bGUud2VicGFja1BvbHlmaWxsID0gMTtcclxuXHR9XHJcblx0cmV0dXJuIG1vZHVsZTtcclxufTtcclxuIiwibW9kdWxlLmV4cG9ydHMgPSBkbGxfYTBlYTgxOTZlODY5YjliNDQyNWU7Il0sInNvdXJjZVJvb3QiOiIifQ==